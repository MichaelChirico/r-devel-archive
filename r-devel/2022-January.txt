From c@g|||e@p|e @end|ng |rom gm@||@com  Sat Jan  1 20:24:01 2022
From: c@g|||e@p|e @end|ng |rom gm@||@com (Colin Gillespie)
Date: Sat, 1 Jan 2022 19:24:01 +0000
Subject: [Rd] Documentation for floor, ceiling & trunc
Message-ID: <CADbDLZkcaK+2E_KA6+NwBhXDYhKjF-KbR9YXtzt6DjDDjH7Hyg@mail.gmail.com>

Hi,

The documentation for floor, ceiling and trunc is slightly ambiguous.

"floor takes ... and returns a numeric vector containing the largest
integers ..."

My initial thought was that floor() would return a vector of integers.
Instead, it returns a vector of doubles, i.e c(1L, 2L) vs c(1, 2)

 * Could the docs be changed
 * Would it be worth returning integers instead?

Thanks

Colin


From murdoch@dunc@n @end|ng |rom gm@||@com  Sat Jan  1 21:03:49 2022
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Sat, 1 Jan 2022 15:03:49 -0500
Subject: [Rd] Documentation for floor, ceiling & trunc
In-Reply-To: <CADbDLZkcaK+2E_KA6+NwBhXDYhKjF-KbR9YXtzt6DjDDjH7Hyg@mail.gmail.com>
References: <CADbDLZkcaK+2E_KA6+NwBhXDYhKjF-KbR9YXtzt6DjDDjH7Hyg@mail.gmail.com>
Message-ID: <5d3c433a-9711-e1a2-64cc-dadc2a4cc347@gmail.com>

On 01/01/2022 2:24 p.m., Colin Gillespie wrote:
> Hi,
> 
> The documentation for floor, ceiling and trunc is slightly ambiguous.
> 
> "floor takes ... and returns a numeric vector containing the largest
> integers ..."
> 
> My initial thought was that floor() would return a vector of integers.

That would be described as "an integer vector".  I think the docs are 
pretty consistent about this:  if an output is described as "a numeric 
vector", that's the type you get.  ("numeric" and "double" refer to the 
same type in R.  This naming inconsistency is discussed in the ?double 
help page.)

> Instead, it returns a vector of doubles, i.e c(1L, 2L) vs c(1, 2)
> 
>   * Could the docs be changed
>   * Would it be worth returning integers instead?

The range of inputs is much larger than the range of 32 bit integers, so 
this would just make things more complicated, and would mean that code 
that cares about the difference between numeric and integer would need 
extra tests.

For example 3e9 + 0.1 is not an integer, and if you take the floor you 
get 3e9. That number can't be represented in the integer type, but can 
be exactly represented as a mathematical integer in the numeric/double type.

Duncan Murdoch


From @v|gro@@ @end|ng |rom ver|zon@net  Sat Jan  1 21:31:18 2022
From: @v|gro@@ @end|ng |rom ver|zon@net (Avi Gross)
Date: Sat, 1 Jan 2022 15:31:18 -0500
Subject: [Rd] Documentation for floor, ceiling & trunc
In-Reply-To: <5d3c433a-9711-e1a2-64cc-dadc2a4cc347@gmail.com>
References: <CADbDLZkcaK+2E_KA6+NwBhXDYhKjF-KbR9YXtzt6DjDDjH7Hyg@mail.gmail.com>
 <5d3c433a-9711-e1a2-64cc-dadc2a4cc347@gmail.com>
Message-ID: <015201d7ff4e$88696720$993c3560$@verizon.net>

Excellent reason, Duncan. R does not have an unlimited integer type as in
Python so truncating or rounding activities can well produce a result that
would be out of bounds.

If someone really wants an array of integers, other than efficiency reasons,
they could process the output from something like floor carefully to see if
all number returned were less than .Machine$integer.max (and similarly for
negatives in the other direction) and then have the option to make a vector
of as.integer(whatever) for later uses. If any numbers where out of the
range, they could presumably do other things like make then NA or Inf or
switch to some larger integer format they can find or create. Of course, any
such alterations may well not work well if fed to anything not expecting
them.

Now consider the purpose of the R functions round(), floor(), ceiling() and
trunc() and perhaps even signif() taken as a group. Clearly some of them can
be used only in a floating point context as rounding something to three
significant digits beyond the decimal point will not usually result in an
integer. Sure, some of them are normally used in real life to mean round it
to the nearest integer and in those cases it could be reasonable to have a
function with a restricted domain that maps into the restricted integer
range.  You can make your own such function easily enough.

-----Original Message-----
From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Duncan Murdoch
Sent: Saturday, January 1, 2022 3:04 PM
To: Colin Gillespie <csgillespie at gmail.com>; r-devel at r-project.org
Subject: Re: [Rd] Documentation for floor, ceiling & trunc

On 01/01/2022 2:24 p.m., Colin Gillespie wrote:
> Hi,
> 
> The documentation for floor, ceiling and trunc is slightly ambiguous.
> 
> "floor takes ... and returns a numeric vector containing the largest 
> integers ..."
> 
> My initial thought was that floor() would return a vector of integers.

That would be described as "an integer vector".  I think the docs are pretty
consistent about this:  if an output is described as "a numeric vector",
that's the type you get.  ("numeric" and "double" refer to the same type in
R.  This naming inconsistency is discussed in the ?double help page.)

> Instead, it returns a vector of doubles, i.e c(1L, 2L) vs c(1, 2)
> 
>   * Could the docs be changed
>   * Would it be worth returning integers instead?

The range of inputs is much larger than the range of 32 bit integers, so
this would just make things more complicated, and would mean that code that
cares about the difference between numeric and integer would need extra
tests.

For example 3e9 + 0.1 is not an integer, and if you take the floor you get
3e9. That number can't be represented in the integer type, but can be
exactly represented as a mathematical integer in the numeric/double type.

Duncan Murdoch

______________________________________________
R-devel at r-project.org mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Mon Jan  3 16:54:26 2022
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Mon, 3 Jan 2022 16:54:26 +0100
Subject: [Rd] 
 Why does lm() with the subset argument give a different answer
 than subsetting in advance?
In-Reply-To: <82962536-60a4-8a71-eaa0-ce79f5025d2e@gmail.com>
References: <B29E2C41-2EB5-465D-8EA2-6E9E3B9906A3@miami.edu>
 <82962536-60a4-8a71-eaa0-ce79f5025d2e@gmail.com>
Message-ID: <25043.7218.319752.651473@stat.math.ethz.ch>

>>>>> Ben Bolker 
>>>>>     on Mon, 27 Dec 2021 09:43:42 -0500 writes:

    >    I agree that it seems non-intuitive (I can't think of a
    > design reason for it to look this way), but I'd like to
    > stress that it's *not* an information leak; the
    > predictions of the model are independent of the
    > parameterization, which is all this issue affects. In a
    > worst case there might be some unfortunate effects on
    > numerical stability if the data-dependent bases are
    > computed on a very different set of data than the model
    > fitting actually uses.

    >    I've attached a suggested documentation patch (I hope
    > it makes it through to the list, if not I can add it to
    > the body of a message.)

It did make it through;  thank you, Ben!
( After adding two forgotten '}' ) I've committed the help file
additions to the R sources (R-devel) in svn r81434 .

Thanks again and

       "Happy New Year"

to all readers,

Martin




    > On 12/26/21 8:35 PM, Balise, Raymond R wrote:
    >> Hello R folks, Today I noticed that using the subset
    >> argument in lm() with a polynomial gives a different
    >> result than using the polynomial when the data has
    >> already been subsetted. This was not at all intuitive for
    >> me.  You can see an example here:
    >> https://stackoverflow.com/questions/70490599/why-does-lm-with-the-subset-argument-give-a-different-answer-than-subsetting-i
    >> 
    >> If this is a design feature that you don?t think should
    >> be fixed, can you please include it in the documentation
    >> and explain why it makes sense to figure out the
    >> orthogonal polynomials on the entire dataset?  This feels
    >> like a serous leak of information when evaluating train
    >> and test datasets in a statistical learning framework.
    >> 
    >> Ray
    >> 
    >> Raymond R. Balise, PhD Assistant Professor Department of
    >> Public Health Sciences, Biostatistics
    >> 
    >> University of Miami, Miller School of Medicine 1120
    >> N.W. 14th Street Don Soffer Clinical Research Center -
    >> Room 1061 Miami, Florida 33136
    >> 
    >> 
    >> 
    >> [[alternative HTML version deleted]]
    >> 
    >> ______________________________________________
    >> R-devel at r-project.org mailing list
    >> https://stat.ethz.ch/mailman/listinfo/r-devel
    >> 

    > -- 
    > Dr. Benjamin Bolker Professor, Mathematics & Statistics
    > and Biology, McMaster University Director, School of
    > Computational Science and Engineering Graduate chair,
    > Mathematics & Statistics x[DELETED ATTACHMENT external:
    > BenB_lm-subset.patch, plain text]
    > ______________________________________________
    > R-devel at r-project.org mailing list
    > https://stat.ethz.ch/mailman/listinfo/r-devel


From bbo|ker @end|ng |rom gm@||@com  Mon Jan  3 17:04:48 2022
From: bbo|ker @end|ng |rom gm@||@com (Ben Bolker)
Date: Mon, 3 Jan 2022 11:04:48 -0500
Subject: [Rd] trivial typo in NEWS file
Message-ID: <77a401c8-722b-95d7-7d54-c442c478f5ef@gmail.com>


   Index: doc/NEWS.Rd
===================================================================
--- doc/NEWS.Rd	(revision 81435)
+++ doc/NEWS.Rd	(working copy)
@@ -425,7 +425,7 @@
        data frames with default row names (Thanks to Charlie Gao's
        \PR{18179}).

-      \item \code{txtProgresBar()} now enforces a non-zero width for
+      \item \code{txtProgressBar()} now enforces a non-zero width for
        \code{char}, without which no progress can be visible.

        \item \code{dimnames(table(d))} is more consistent in the case where


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Mon Jan  3 17:23:45 2022
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Mon, 3 Jan 2022 17:23:45 +0100
Subject: [Rd] trivial typo in NEWS file
In-Reply-To: <77a401c8-722b-95d7-7d54-c442c478f5ef@gmail.com>
References: <77a401c8-722b-95d7-7d54-c442c478f5ef@gmail.com>
Message-ID: <25043.8977.289648.963947@stat.math.ethz.ch>

>>>>> Ben Bolker 
>>>>>     on Mon, 3 Jan 2022 11:04:48 -0500 writes:

    > Index: doc/NEWS.Rd
    > ===================================================================
    > --- doc/NEWS.Rd	(revision 81435)
    > +++ doc/NEWS.Rd	(working copy)
    > @@ -425,7 +425,7 @@
    > data frames with default row names (Thanks to Charlie Gao's
    > \PR{18179}).

    > -      \item \code{txtProgresBar()} now enforces a non-zero width for
    > +      \item \code{txtProgressBar()} now enforces a non-zero width for
    > \code{char}, without which no progress can be visible.

    > \item \code{dimnames(table(d))} is more consistent in the case where


Thank you, Ben!

I will take care of this with my next commit (dealing with R's
bugzilla PR#18272).

Martin


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Mon Jan  3 18:15:20 2022
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Mon, 3 Jan 2022 18:15:20 +0100
Subject: [Rd] "getOption(max.print) omitted %d entries" may be negative
In-Reply-To: <CAJmOi+MFUrn+hx9PVj1ALWwMFPq518dTYGPDToqF92TB4w9xgw@mail.gmail.com>
References: <CAJmOi+MFUrn+hx9PVj1ALWwMFPq518dTYGPDToqF92TB4w9xgw@mail.gmail.com>
Message-ID: <25043.12072.659723.752755@stat.math.ethz.ch>

>>>>> Hugh Parsonage 
>>>>>     on Wed, 29 Dec 2021 00:36:51 +1100 writes:

    > In src/main/printvector.c in the definition of printVector and
    > printNamedVector  (and elsewhere):

    > Rprintf(" [ reached getOption(\"max.print\") -- omitted %d entries ]\n",
    >         n - n_pr);

    > Though n - n_pr is of type R_xlen_t so may not be representable as
    > int. In practice negative values may be observed for long vectors.

    > Rprintf(" [ reached getOption(\"max.print\") -- omitted %lld entries ]\n",
    >         n - n_pr);


Thank you Hugh, for finding and reporting this,
including a proposed remedy. 

At some point in time, I think the   %lld   format specifier was
not portable enough to all versions of C compiler / libraries
that were considered valid for compiling R.

See e.g.,

   https://stackoverflow.com/questions/462345/format-specifier-for-long-long

which says that "it" does not work on Windows.

Maybe this has changed now that we require C99 and also that
since R version 4.0.0 (or 4.0.1) we also use a somewhat more
recent version of gcc also on Windows?

... ah, searching the R sources reveals uses of %lld
*plus*

#ifdef Win32
#include <trioremap.h> /* for %lld */
#endif

so it seems we can and should probably change this ...

[Please, C  compiler / library standard experts, chime in !]

Martin Maechler
ETH Zurich  and  R core team


From tom@@@k@||ber@ @end|ng |rom gm@||@com  Mon Jan  3 20:59:30 2022
From: tom@@@k@||ber@ @end|ng |rom gm@||@com (Tomas Kalibera)
Date: Mon, 3 Jan 2022 20:59:30 +0100
Subject: [Rd] "getOption(max.print) omitted %d entries" may be negative
In-Reply-To: <25043.12072.659723.752755@stat.math.ethz.ch>
References: <CAJmOi+MFUrn+hx9PVj1ALWwMFPq518dTYGPDToqF92TB4w9xgw@mail.gmail.com>
 <25043.12072.659723.752755@stat.math.ethz.ch>
Message-ID: <fe5e0663-1827-8045-7aee-6b87e9c140ac@gmail.com>


On 1/3/22 6:15 PM, Martin Maechler wrote:
>>>>>> Hugh Parsonage
>>>>>>      on Wed, 29 Dec 2021 00:36:51 +1100 writes:
>      > In src/main/printvector.c in the definition of printVector and
>      > printNamedVector  (and elsewhere):
>
>      > Rprintf(" [ reached getOption(\"max.print\") -- omitted %d entries ]\n",
>      >         n - n_pr);
>
>      > Though n - n_pr is of type R_xlen_t so may not be representable as
>      > int. In practice negative values may be observed for long vectors.
>
>      > Rprintf(" [ reached getOption(\"max.print\") -- omitted %lld entries ]\n",
>      >         n - n_pr);
>
>
> Thank you Hugh, for finding and reporting this,
> including a proposed remedy.
>
> At some point in time, I think the   %lld   format specifier was
> not portable enough to all versions of C compiler / libraries
> that were considered valid for compiling R.
>
> See e.g.,
>
>     https://stackoverflow.com/questions/462345/format-specifier-for-long-long
>
> which says that "it" does not work on Windows.
>
> Maybe this has changed now that we require C99 and also that
> since R version 4.0.0 (or 4.0.1) we also use a somewhat more
> recent version of gcc also on Windows?
>
> ... ah, searching the R sources reveals uses of %lld
> *plus*
>
> #ifdef Win32
> #include <trioremap.h> /* for %lld */
> #endif
>
> so it seems we can and should probably change this ...

UCRT on Windows supports the C99 format, so %lld works, but there is a 
bug in GCC which causes a compilation warning to appear for %lld.

There is an open GCC bug report with a patch. It has not been adopted, 
yet, but I got reviews from two people and patched the build of GCC in 
Rtools42. So, %lld etc now works without a warning for us on Windows and 
certainly can be used in package code.
https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95130

For base R, as we have been using the trio remap to get rid of the 
warning with %lld, it would make sense to keep doing this for 
consistency. Eventually we might be able to remove the dependency on 
trio, after checking that the other problems due to which we use it have 
been resolved in UCRT.

Tomas

>
> [Please, C  compiler / library standard experts, chime in !]
>
> Martin Maechler
> ETH Zurich  and  R core team
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From @v|gro@@ @end|ng |rom ver|zon@net  Mon Jan  3 21:42:16 2022
From: @v|gro@@ @end|ng |rom ver|zon@net (Avi Gross)
Date: Mon, 3 Jan 2022 15:42:16 -0500
Subject: [Rd] A patchwork indeed
References: <018301d800e2$65064bf0$2f12e3d0$.ref@verizon.net>
Message-ID: <018301d800e2$65064bf0$2f12e3d0$@verizon.net>

Let me be clear up front that I do not want to start any major discussions,
merely to share some observations.

 

We discussed at length what it would mean if R was extended to allow a plus
sign to concatenate text when the operands were both of the right types that
made sense for the purpose so that, as in a language like Python:

 

                "Hello " + "World!"

 

would result in the obvious concatenation and not as an error. It might be a
way to call perhaps a limited functionality of paste0() as an example. 

 

So, I was studying an R package called patchwork and looking at it from a
perspective in that it slightly extends the way ggplot uses the plus sign
when applied to objects of certain classes. Patchwork does allow something
like some form of (many types) of graphic objects to be displayed left to
right (or in a grid) by just typing 

p1 + p2 + p3

 

BUT it goes a bit nuts and overlays lots of operators so that:

 

                (p1 | p2) / p3

 

results in the first two taking up half each of a top row and the third in
the next row and wide. You can of course make all kinds of adjustments but
the point is that those symbols are in a sense overlaid from their default
meanings. there is also a meaning (a tad obscure) for a unary negative sign
as in

- p1 

 

And, without explanation here, the symbols * and & also are used in new
ways. 

 

I note the obvious that the normal precedence rules in R for these
symbols/operators are NOT changed so you often need to use extra levels of
parentheses to guarantee the order of evaluation.

 

Clearly anyone reading your code that has not thoroughly read the manual for
the package will be even more mystified than people are about ggplot and the
plus sign, or the pipe symbols used in the tidyverse and even the new one
now in base R. 

 

But my point is that it looks like doing it is quite possible and small
isolated worlds can benefit from the notational simplicity. Having said
that, this package also allows you to bypass all of this and use more
standard functions that generally get you the same results. Since
manipulating graphs and subgraphs generally does not require combining the
above symbols alongside their other normal usage, this may look harmless and
if you come from languages that routinely allow operators to be overloaded
or polymorphic, looks fine.

 

I am providing this info, not to make a case for doing anything but to ask
if it makes sense to document acceptable methods for others, perhaps using
their own created objects, to do such effects.

 

In case anyone is curious, start here for a sort of tutorial:

 

https://patchwork.data-imaginist.com/

 

Again, not advocating, just providing an example, no doubt among many
others, where R is used in an extended way that can be useful. But of course
moving R to be fully object-oriented in the same way as some other specific
language is not a valid goal.

 


	[[alternative HTML version deleted]]


From mtmorg@n@b|oc @end|ng |rom gm@||@com  Tue Jan  4 20:35:30 2022
From: mtmorg@n@b|oc @end|ng |rom gm@||@com (Martin Morgan)
Date: Tue, 4 Jan 2022 19:35:30 +0000
Subject: [Rd] gsub() hex character range problems in R-devel?
Message-ID: <BN8PR04MB6241FCAA6D228F3CB00991B5F94A9@BN8PR04MB6241.namprd04.prod.outlook.com>

I'm not very good at character encoding / etc so this might be user error. The following code is meant to replace extended ASCII characters, in particular a non-breaking space, with "", and it works in R-4-1-branch

> R.version.string
[1] "R version 4.1.2 Patched (2022-01-04 r81445)"
> gsub("[\x7f-\xff]", "", "fo\xa0o")
[1] "foo"

but fails in R-devel

> R.version.string
[1] "R Under development (unstable) (2022-01-04 r81445)"
> gsub("[\x7f-\xff]", "", "fo\xa0o")
Error in gsub("[\177-\xff]", "", "fo\xa0o") : invalid regular expression '[-?]', reason 'Invalid character range'
In addition: Warning message:
In gsub("[\177-\xff]", "", "fo\xa0o") :
  TRE pattern compilation error 'Invalid character range'

There are other oddities, too, like

> gsub("[[:alnum:]]", "", "fo\xa0o")  # R-4-1-branch
[1] "\xfc\xbe\x8c\x86\x84\xbc"

> gsub("[[:alnum:]]", "", "fo\xa0o")  # R-devel
[1] "<>"

The R-devel sessionInfo is

> sessionInfo()
R Under development (unstable) (2022-01-04 r81445)
Platform: x86_64-apple-darwin19.6.0 (64-bit)
Running under: macOS Catalina 10.15.7

Matrix products: default
BLAS:   /Users/ma38727/bin/R-devel/lib/libRblas.dylib
LAPACK: /Users/ma38727/bin/R-devel/lib/libRlapack.dylib

locale:
[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base

loaded via a namespace (and not attached):
[1] compiler_4.2.0

(I have built my own R on macOS; similar behavior is observed on a Linux machine)

Any hints welcome,

Martin Morgan

From brod|e@g@@|@m @end|ng |rom y@hoo@com  Wed Jan  5 02:54:21 2022
From: brod|e@g@@|@m @end|ng |rom y@hoo@com (Brodie Gaslam)
Date: Wed, 5 Jan 2022 01:54:21 +0000 (UTC)
Subject: [Rd] gsub() hex character range problems in R-devel?
In-Reply-To: <BN8PR04MB6241FCAA6D228F3CB00991B5F94A9@BN8PR04MB6241.namprd04.prod.outlook.com>
References: <BN8PR04MB6241FCAA6D228F3CB00991B5F94A9@BN8PR04MB6241.namprd04.prod.outlook.com>
Message-ID: <1523321191.1706512.1641347661397@mail.yahoo.com>

> On Tuesday, January 4, 2022, 02:35:50 PM EST, Martin Morgan <mtmorgan.bioc at gmail.com> wrote:
>
> I'm not very good at character encoding / etc so this might be user
> error. The following code is meant to replace extended ASCII characters,
> in particular a non-breaking space, with "", and it works in
> R-4-1-branch

Martin,

I'm (obviously) not R-Core, so you should take whatever I say with a grain
of salt.? Nonetheless I have run into a similar issue as you, and my
assessment is that the behavior in R-4-1-2 is due to a bug that was fixed
with -r81103 for R-devel only.? It only appears more correct due to
happenstance and "surprising" (at least to me) behavior from the
"corrected" code.

But before I get into the details, I'd be remiss not to add some warnings
about using arbitrary bytes in strings as you do here.? The strings in
your examples are not marked:

??? Encoding("fo\xa0o")
??? [1] "unknown"

This means internals may interpret them as being in native encoding (UTF-8
in your case, in which your string is invalid).? If you want to use byte
operations you should mark your strings as "bytes" / use the "useBytes"
parameter to the functions in question (and assume all the consequences of
generating invalid encodings), or even better translate the string from its
actual encoding to your encoding.? For your case assuming you have
ISO-8859-1 encoding (I'm just guessing) I would do:

??? x <- "fo\xa0o"
??? y <- iconv(x, "ISO-8859-1", "UTF-8")
??? gsub("\ua0", "", y)
??? [1] "foo"

You could also just have marked your string as "latin1" as for 0xA0 it is
the same as ISO-8859-1 and gotten the same result without `iconv`, but the
`iconv` solution is more general.

I'll address the two examples in reverse order as the first one
is more obvious.

> > gsub("[[:alnum:]]", "", "fo\xa0o")? # R-4-1-branch
> [1] "\xfc\xbe\x8c\x86\x84\xbc"
>
> > gsub("[[:alnum:]]", "", "fo\xa0o")? # R-devel
> [1] "<>"

The result in the 4-1 contains bytes not present in the input.? Clearly
this cannot be correct.? R-devel is "correct" if you account for the
surprising (to me) behavior that invalid bytes in UTF-8 interpreted
strings may be escaped in pre-processing.? This is roughly what's
happening:

??? "fo\xa0o" -> "fo<a0>o" -> gsub("[[:alnum:]]", "", "fo<a0>o") -> "<>"

Where "<a0>" is the escaped version of the "\xa0".? It's clearer if you do
(R-devel):

??? gsub("f", "", "fo\xa0o")
??? [1] "o<a0>o"

I do think this "correct" behavior would be better as an error or at a
minimum a warning, and hopefully this is something that will change in the
future.

> > R.version.string
> [1] "R version 4.1.2 Patched (2022-01-04 r81445)"
> > gsub("[\x7f-\xff]", "", "fo\xa0o")
> [1] "foo"
>
> but fails in R-devel
> > R.version.string
> [1] "R Under development (unstable) (2022-01-04 r81445)"
> > gsub("[\x7f-\xff]", "", "fo\xa0o")
> Error in gsub("[\177-\xff]", "", "fo\xa0o") : invalid regular expression '[-?]', reason 'Invalid character range'
> In addition: Warning message:
> In gsub("[\177-\xff]", "", "fo\xa0o") :
>?? TRE pattern compilation error 'Invalid character range'

This one is pretty interesting.? The same bug persists, but because it
affects both the pattern and the string to manipulate the bugs cancel out.
If you look at what's happening internally in R-4-1, the range "\x7f-\xff"
is translated to "\u7f-\U{3e66663c}", but "fo\xa0o" is also translated to
"fo\U{3e30613c}o", so it happens to work.

Why "\U{3e66663c}"?? Well, it's really 3e 66 66 3c, which the code
intended to have interpreted as < f f >.? In ASCII encoding, we have 3e =
<, 66 = f, 3c = >.? So the intent was to write out "<ff>", the 4 character
escape for the single byte "\xff".? Instead, the 4 bytes are written into
a single wchar_t (on systems with 32bit wchar_t) and interpreted as that
code point.

In little-endian machines like ours, the double cancellation does not
always work as seen in R-4-1-2:

??? gsub("[\x7f-\xab]", "",? "\xab")
??? ## [1] ""
??? gsub("[\x7f-\xba]", "",? "\xab")? # changed end to be \xba
??? ## [1] "\xab"

One would expect the second range to still capture the character, but
because wchar_t is interpreted little endian the order of the "a" and "b"
written into the wchar_t is opposite of what is desired.? So it would not
be possible to leave the bug in (even if it didn't cause other issues) on
the grounds it cancels itself out.

With the patch applied in R-devel, the range "[\x7f-\xff]" becomes
"[\x7f-<ff>]", which is invalid because "<" has a lower code point that
"\x7f".? Here the fix exposes the "surprisingness" of the current
behavior.

Although again, you can currently side-step all this simply by
converting everything into valid encodings and avoiding bytes
manipulation, or doing everything very carefully explicitly with "bytes"
marked strings and "useBytes=TRUE".

Best,

B.

> The R-devel sessionInfo is
>
> > sessionInfo()
> R Under development (unstable) (2022-01-04 r81445)
> Platform: x86_64-apple-darwin19.6.0 (64-bit)
> Running under: macOS Catalina 10.15.7
>
> Matrix products: default
> BLAS:? /Users/ma38727/bin/R-devel/lib/libRblas.dylib
> LAPACK: /Users/ma38727/bin/R-devel/lib/libRlapack.dylib
>
> locale:
> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
>
> attached base packages:
> [1] stats??? graphics? grDevices utils??? datasets? methods? base
>
> loaded via a namespace (and not attached):
> [1] compiler_4.2.0
>
> (I have built my own R on macOS; similar behavior is observed on a Linux machine)
>
> Any hints welcome,
>
> Martin Morgan
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>
>


From tom@@@k@||ber@ @end|ng |rom gm@||@com  Wed Jan  5 10:17:01 2022
From: tom@@@k@||ber@ @end|ng |rom gm@||@com (Tomas Kalibera)
Date: Wed, 5 Jan 2022 10:17:01 +0100
Subject: [Rd] gsub() hex character range problems in R-devel?
In-Reply-To: <BN8PR04MB6241FCAA6D228F3CB00991B5F94A9@BN8PR04MB6241.namprd04.prod.outlook.com>
References: <BN8PR04MB6241FCAA6D228F3CB00991B5F94A9@BN8PR04MB6241.namprd04.prod.outlook.com>
Message-ID: <04c065e3-8f53-0233-55c5-a8ce510bd47f@gmail.com>

Hi Martin,

I'd add few comments to the excellent analysis of Brodie.

- \xhh is allowed and defined in Perl regular expressions, see ?regex 
(would need perl=TRUE), but to enter that in an R string, you need to 
escape the backslash.

- \xhh is not defined by POSIX for extended regular expressions, neither 
it is documented in ?regex for those; TRE supports it, but still 
portable programs should not rely on that

- literal \xhh in an R string is turned to the byte by R, but I would 
say this should not be used at all by users, because the result is 
encoding specific

- use of \u and \U in an R string is fine, it has well defined semantics 
and the corresponding string will then be flagged UTF-8 in R (so e.g. 
\ua0 is fine to represent the Unicode no-break space)

- see caveats of using character ranges with POSIX extended regular 
expressions in ?regex re encodings, using Perl regular expressions in 
UTF-8 mode is more reliable for those

So, a variant of your example might be:

 > gsub("[\\x7f-\\xff]", "", "fo\ua0o", perl=TRUE)
[1] "foo"

(note that the \ua0 ensures that the text is UTF-8, and hence the UTF-8 
mode for regular expressions is used, ?regex has more)

However, I think it is better to formulate regular expressions to cover 
all of Unicode, so do something like e.g. "only keep ASCII digits, ASCII 
space, ASCII underscore, but remove all other characters".

Best
Tomas

On 1/4/22 8:35 PM, Martin Morgan wrote:

> I'm not very good at character encoding / etc so this might be user error. The following code is meant to replace extended ASCII characters, in particular a non-breaking space, with "", and it works in R-4-1-branch
>
>> R.version.string
> [1] "R version 4.1.2 Patched (2022-01-04 r81445)"
>> gsub("[\x7f-\xff]", "", "fo\xa0o")
> [1] "foo"
>
> but fails in R-devel
>
>> R.version.string
> [1] "R Under development (unstable) (2022-01-04 r81445)"
>> gsub("[\x7f-\xff]", "", "fo\xa0o")
> Error in gsub("[\177-\xff]", "", "fo\xa0o") : invalid regular expression '[-?]', reason 'Invalid character range'
> In addition: Warning message:
> In gsub("[\177-\xff]", "", "fo\xa0o") :
>    TRE pattern compilation error 'Invalid character range'
>
> There are other oddities, too, like
>
>> gsub("[[:alnum:]]", "", "fo\xa0o")  # R-4-1-branch
> [1] "\xfc\xbe\x8c\x86\x84\xbc"
>
>> gsub("[[:alnum:]]", "", "fo\xa0o")  # R-devel
> [1] "<>"
>
> The R-devel sessionInfo is
>
>> sessionInfo()
> R Under development (unstable) (2022-01-04 r81445)
> Platform: x86_64-apple-darwin19.6.0 (64-bit)
> Running under: macOS Catalina 10.15.7
>
> Matrix products: default
> BLAS:   /Users/ma38727/bin/R-devel/lib/libRblas.dylib
> LAPACK: /Users/ma38727/bin/R-devel/lib/libRlapack.dylib
>
> locale:
> [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
>
> attached base packages:
> [1] stats     graphics  grDevices utils     datasets  methods   base
>
> loaded via a namespace (and not attached):
> [1] compiler_4.2.0
>
> (I have built my own R on macOS; similar behavior is observed on a Linux machine)
>
> Any hints welcome,
>
> Martin Morgan
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From mtmorg@n@b|oc @end|ng |rom gm@||@com  Thu Jan  6 17:47:31 2022
From: mtmorg@n@b|oc @end|ng |rom gm@||@com (Martin Morgan)
Date: Thu, 6 Jan 2022 16:47:31 +0000
Subject: [Rd] gsub() hex character range problems in R-devel?
In-Reply-To: <04c065e3-8f53-0233-55c5-a8ce510bd47f@gmail.com>
References: <BN8PR04MB6241FCAA6D228F3CB00991B5F94A9@BN8PR04MB6241.namprd04.prod.outlook.com>
 <04c065e3-8f53-0233-55c5-a8ce510bd47f@gmail.com>
Message-ID: <BN8PR04MB6241C3B0400F5E25DA88C629F94C9@BN8PR04MB6241.namprd04.prod.outlook.com>

Thanks Tomas and 'Brodie' for your expert explanation; it provides great help in understanding and solving my immediate problem.

Thomas' observation to 'do something like e.g. "only keep ASCII digits, ASCII space, ASCII underscore, but remove all other characters"' points to a basic weakness in the code I'm looking at. E.g., removing non-breaking space is probably not appropriate ('foo\ua0bar' is probably cleaned to 'foo bar' and not 'foobar'). And more generally other non-ASCII characters ('fancy' quotes, em-dashes, ...) would require special treatment. It seems like the right thing to do is to handle the raw data in its original encoding, rather than to try to clean it to ASCII.

Martin

?On 1/5/22, 4:17 AM, "Tomas Kalibera" <tomas.kalibera at gmail.com> wrote:

    Hi Martin,

    I'd add few comments to the excellent analysis of Brodie.

    - \xhh is allowed and defined in Perl regular expressions, see ?regex 
    (would need perl=TRUE), but to enter that in an R string, you need to 
    escape the backslash.

    - \xhh is not defined by POSIX for extended regular expressions, neither 
    it is documented in ?regex for those; TRE supports it, but still 
    portable programs should not rely on that

    - literal \xhh in an R string is turned to the byte by R, but I would 
    say this should not be used at all by users, because the result is 
    encoding specific

    - use of \u and \U in an R string is fine, it has well defined semantics 
    and the corresponding string will then be flagged UTF-8 in R (so e.g. 
    \ua0 is fine to represent the Unicode no-break space)

    - see caveats of using character ranges with POSIX extended regular 
    expressions in ?regex re encodings, using Perl regular expressions in 
    UTF-8 mode is more reliable for those

    So, a variant of your example might be:

     > gsub("[\\x7f-\\xff]", "", "fo\ua0o", perl=TRUE)
    [1] "foo"

    (note that the \ua0 ensures that the text is UTF-8, and hence the UTF-8 
    mode for regular expressions is used, ?regex has more)

    However, I think it is better to formulate regular expressions to cover 
    all of Unicode, so do something like e.g. "only keep ASCII digits, ASCII 
    space, ASCII underscore, but remove all other characters".

    Best
    Tomas

    On 1/4/22 8:35 PM, Martin Morgan wrote:

    > I'm not very good at character encoding / etc so this might be user error. The following code is meant to replace extended ASCII characters, in particular a non-breaking space, with "", and it works in R-4-1-branch
    >
    >> R.version.string
    > [1] "R version 4.1.2 Patched (2022-01-04 r81445)"
    >> gsub("[\x7f-\xff]", "", "fo\xa0o")
    > [1] "foo"
    >
    > but fails in R-devel
    >
    >> R.version.string
    > [1] "R Under development (unstable) (2022-01-04 r81445)"
    >> gsub("[\x7f-\xff]", "", "fo\xa0o")
    > Error in gsub("[\177-\xff]", "", "fo\xa0o") : invalid regular expression '[-?]', reason 'Invalid character range'
    > In addition: Warning message:
    > In gsub("[\177-\xff]", "", "fo\xa0o") :
    >    TRE pattern compilation error 'Invalid character range'
    >
    > There are other oddities, too, like
    >
    >> gsub("[[:alnum:]]", "", "fo\xa0o")  # R-4-1-branch
    > [1] "\xfc\xbe\x8c\x86\x84\xbc"
    >
    >> gsub("[[:alnum:]]", "", "fo\xa0o")  # R-devel
    > [1] "<>"
    >
    > The R-devel sessionInfo is
    >
    >> sessionInfo()
    > R Under development (unstable) (2022-01-04 r81445)
    > Platform: x86_64-apple-darwin19.6.0 (64-bit)
    > Running under: macOS Catalina 10.15.7
    >
    > Matrix products: default
    > BLAS:   /Users/ma38727/bin/R-devel/lib/libRblas.dylib
    > LAPACK: /Users/ma38727/bin/R-devel/lib/libRlapack.dylib
    >
    > locale:
    > [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
    >
    > attached base packages:
    > [1] stats     graphics  grDevices utils     datasets  methods   base
    >
    > loaded via a namespace (and not attached):
    > [1] compiler_4.2.0
    >
    > (I have built my own R on macOS; similar behavior is observed on a Linux machine)
    >
    > Any hints welcome,
    >
    > Martin Morgan
    > ______________________________________________
    > R-devel at r-project.org mailing list
    > https://stat.ethz.ch/mailman/listinfo/r-devel

From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Sat Jan  8 16:36:26 2022
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Sat, 8 Jan 2022 16:36:26 +0100
Subject: [Rd] "getOption(max.print) omitted %d entries" may be negative
In-Reply-To: <fe5e0663-1827-8045-7aee-6b87e9c140ac@gmail.com>
References: <CAJmOi+MFUrn+hx9PVj1ALWwMFPq518dTYGPDToqF92TB4w9xgw@mail.gmail.com>
 <25043.12072.659723.752755@stat.math.ethz.ch>
 <fe5e0663-1827-8045-7aee-6b87e9c140ac@gmail.com>
Message-ID: <25049.44922.461214.439279@stat.math.ethz.ch>

>>>>> Tomas Kalibera 
>>>>>     on Mon, 3 Jan 2022 20:59:30 +0100 writes:

    > On 1/3/22 6:15 PM, Martin Maechler wrote:
    >>>>>>> Hugh Parsonage on Wed, 29 Dec 2021 00:36:51 +1100
    >>>>>>> writes:
    >> > In src/main/printvector.c in the definition of
    >> printVector and > printNamedVector (and elsewhere):
    >> 
    >> > Rprintf(" [ reached getOption(\"max.print\") -- omitted
    >> %d entries ]\n", > n - n_pr);
    >> 
    >> > Though n - n_pr is of type R_xlen_t so may not be
    >> representable as > int. In practice negative values may
    >> be observed for long vectors.
    >> 
    >> > Rprintf(" [ reached getOption(\"max.print\") -- omitted
    >> %lld entries ]\n", > n - n_pr);
    >> 
    >> 
    >> Thank you Hugh, for finding and reporting this, including
    >> a proposed remedy.
    >> 
    >> At some point in time, I think the %lld format specifier
    >> was not portable enough to all versions of C compiler /
    >> libraries that were considered valid for compiling R.
    >> 
    >> See e.g.,
    >> 
    >> https://stackoverflow.com/questions/462345/format-specifier-for-long-long
    >> 
    >> which says that "it" does not work on Windows.
    >> 
    >> Maybe this has changed now that we require C99 and also
    >> that since R version 4.0.0 (or 4.0.1) we also use a
    >> somewhat more recent version of gcc also on Windows?
    >> 
    >> ... ah, searching the R sources reveals uses of %lld
    >> *plus*
    >> 
    >> #ifdef Win32 #include <trioremap.h> /* for %lld */ #endif
    >> 
    >> so it seems we can and should probably change this ...

    > UCRT on Windows supports the C99 format, so %lld works,
    > but there is a bug in GCC which causes a compilation
    > warning to appear for %lld.

    > There is an open GCC bug report with a patch. It has not
    > been adopted, yet, but I got reviews from two people and
    > patched the build of GCC in Rtools42. So, %lld etc now
    > works without a warning for us on Windows and certainly
    > can be used in package code.
    > https://gcc.gnu.org/bugzilla/show_bug.cgi?id=95130

    > For base R, as we have been using the trio remap to get
    > rid of the warning with %lld, it would make sense to keep
    > doing this for consistency. Eventually we might be able to
    > remove the dependency on trio, after checking that the
    > other problems due to which we use it have been resolved
    > in UCRT.

    > Tomas

I have committed changes now (svn r81459), using %lld as mentioned above,
also including  trioremap.h  for Windows,
not just for printing long unnamed atomic vectors, but also in
the code for printing named vectors and "generic vectors" aka
lists.... which previously did not allow long vectors at all,
using `length() and `int` before.

I've set it as to be ported to  "R 4.1.2 patched" eventually.
Martin




    >> 
    >> [Please, C compiler / library standard experts, chime in
    >> !]
    >> 
    >> Martin Maechler ETH Zurich and R core team


From bbo|ker @end|ng |rom gm@||@com  Sun Jan  9 22:39:43 2022
From: bbo|ker @end|ng |rom gm@||@com (Ben Bolker)
Date: Sun, 9 Jan 2022 16:39:43 -0500
Subject: [Rd] =?utf-8?q?documentation_patch_for_as=2Eformula_=E2=86=92_re?=
 =?utf-8?q?formulate?=
Message-ID: <7150b64c-c139-1421-9ba2-1a297dc32ac9@gmail.com>

   There was some discussion on twitter about the fact that the manual 
page for as.formula() doesn't mention reformulate(), and indeed the last 
example is

## Create a formula for a model with a large number of variables:
      xnam <- paste0("x", 1:25)
      (fmla <- as.formula(paste("y ~ ", paste(xnam, collapse= "+"))))


which could arguably be better done as

   reformulate(xname, response = "y")

   I've attached a documentation patch that adds the alternative version 
and a \seealso{} link.

   Happy to submit to r-bugzilla if requested.

   cheers
    Ben Bolker

-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: reformulate_patch.txt
URL: <https://stat.ethz.ch/pipermail/r-devel/attachments/20220109/f3266495/attachment.txt>

From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Mon Jan 10 10:04:11 2022
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Mon, 10 Jan 2022 10:04:11 +0100
Subject: [Rd] 
 =?utf-8?q?documentation_patch_for_as=2Eformula_=E2=86=92_re?=
 =?utf-8?q?formulate?=
In-Reply-To: <7150b64c-c139-1421-9ba2-1a297dc32ac9@gmail.com>
References: <7150b64c-c139-1421-9ba2-1a297dc32ac9@gmail.com>
Message-ID: <25051.63115.679473.229695@stat.math.ethz.ch>

>>>>> Ben Bolker   on Sun, 9 Jan 2022 16:39:43 -0500 writes:

>    There was some discussion on twitter about the fact
> that the manual page for as.formula() doesn't mention
> reformulate(), and indeed the last example is

> ## Create a formula for a model with a large number of
> variables: xnam <- paste0("x", 1:25) (fmla <-
> as.formula(paste("y ~ ", paste(xnam, collapse= "+"))))


> which could arguably be better done as

>    reformulate(xname, response = "y")

>    I've attached a documentation patch that adds the
> alternative version and a \seealso{} link.

>    Happy to submit to r-bugzilla if requested.

>    cheers Ben Bolker

x[DELETED ATTACHMENT external:  reformulate_patch.txt, plain text]

Thanks a lot, Ben!

I've committed (+-) it to R-devel as svn rev 81464
Martin


