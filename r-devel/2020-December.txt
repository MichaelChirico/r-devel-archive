From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Tue Dec  1 10:31:36 2020
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Tue, 1 Dec 2020 10:31:36 +0100
Subject: [Rd] all.equal applied to function closures
In-Reply-To: <CAHqSRuR0CzvyB_CkC2mkxXrJ8XGvGugJDtct6VVOOhCdvU0C5Q@mail.gmail.com>
References: <B43EED2F-F34F-436E-9822-AFB2A1C954DF@adobe.com>
 <8142836e-d8d5-1faa-fbfe-265a9c6f22e9@gmail.com>
 <CAHqSRuR0CzvyB_CkC2mkxXrJ8XGvGugJDtct6VVOOhCdvU0C5Q@mail.gmail.com>
Message-ID: <24518.3448.1707.699927@stat.math.ethz.ch>

>>>>> Bill Dunlap 
>>>>>     on Mon, 30 Nov 2020 13:41:54 -0800 writes:

    > To make the comparison more complete, all.equal.environment could compare
    > the parents of the target and current environments.  That would have to be
    > recursive but could stop at the first 'top level environment' (the global,
    > empty, or a package-related environment generally) and use identical
    > there.  E.g.,

    > > f1 <- function(x) (function(){ expx <- exp(x) ; function(y) y + expx})()
    > > all.equal(f1(2), f1(3))
    > [1] "Environments: Component ?expx?: Mean relative difference: 1.718282"
    > 
    > [2] "Environments: <parent.env> Component ?x?: Mean relative difference:
    > 0.5"

    > This is from the following, where I avoided putting the existing
    > non-recursive all.equal.environment into the body of this one.

    > all.equal.environment <-
    > function(target, current, ...)
    > {
    >     .all.equal.environment <- base::all.equal.environment # temporary hack
    >     stopifnot(is.environment(target), is.environment(current))
    >     if (identical(target, current)) {
    >         TRUE
    >     } else {
    >         msg <- NULL # TODO: check attributes
    >         # deal with emptyenv now since parent.env(emptyenv()) gives error
    >         # and topenv(emptyenv()) gives GlobalEnv
    >         eTarget <- identical(target, emptyenv()) ||
    > identical(target,topenv(target))
    >         eCurrent <- identical(current, emptyenv()) ||
    > identical(current,topenv(current))
    >         if (eTarget || eCurrent) {
    >             msg <- c(msg, paste("target is", format(target), "and current
    > is", format(current)))
    >         } else {
    >             thisComparison <- .all.equal.environment(target, current, ...)
    >             if (!isTRUE(thisComparison)) {
    >                 msg <- c(msg, thisComparison)
    >             }
    >             parentComparison <- Recall(parent.env(target),
    > parent.env(current), ...)
    >             if (!isTRUE(parentComparison)) {
    >                 msg <- c(msg, paste("<parent.env>", parentComparison))
    >             }
    >         }
    >         if (is.null(msg) || isTRUE(msg)) TRUE else msg
    >     }
    > }

Thank you, Duncan and Bill (and Kevin for bringing up the
topic).

I agree  all.equal() should work better with functions,

and I think probably it would make sense to define  all.equal.function()
rather than put this into all.equal.default()

However, it's not quite clear if it is always desirable to check the
environments as well notably as that *is* done recursively.

Bill, I'm sure you've noticed that we did write  all.equal.environment()
to work recursively... Actually, I had worked quite a bit at
that, too long ago to remember details, but the relevant svn log
entry is
------------------------------------------------------------------------
r66640 | maechler | 2014-09-18 22:10:20 +0200 (Thu, 18 Sep 2014) | 1 line

more sophisticated all.equal.environment(): no longer "simple" infinite recursions
------------------------------------------------------------------------

Are you sure that code with the internal recursive do1()
function should/could not be amended where needed?

Martin

    > On Mon, Nov 30, 2020 at 10:42 AM Duncan Murdoch <murdoch.duncan at gmail.com>
    > wrote:
    > 
    > > On 30/11/2020 1:05 p.m., Kevin Van Horn via R-devel wrote:
    > > > Consider the following code:
    > > >
    > > >      f <- function(x)function(y){x+y}
    > > >      all.equal(f(5), f(0))
    > > >
    > > > This returns TRUE, when it should return FALSE; I think it?s hard to
    > > make the case that f(5) and f(0) are ?approximately equal? in any
    > > meaningful sense. Digging into the code for all.equal(), I see that
    > > all.equal(f(5), f(0)) results in a call to all.equal.language(f(5), f(0)),
    > > which only compares the function texts for equality.
    > > >
    > > > If it is decided to leave this behavior as-is, then at least it should
    > > be documented. Currently I cannot find any documentation for all.equal
    > > applied to functions.
    > >
    > > Clearly it should also compare the environments of the two functions,
    > > then it would see a difference:
    > >
    > >  > all.equal(environment(f(5)), environment(f(0)))
    > > [1] "Component ?x?: Mean relative difference: 1"
    > >
    > > Changing the first few lines from
    > >
    > >      if (is.language(target) || is.function(target))
    > >          return(all.equal.language(target, current, ...))
    > >
    > > to
    > >
    > >      if (is.function(target)) {
    > >          msg <- all.equal.language(target, current, ...)
    > >          if (isTRUE(msg)) {
    > >              msg <- all.equal.environment(environment(target),
    > > environment(current), ...)
    > >              if (is.character(msg))
    > >                msg <- paste("Environments:", msg)
    > >          }
    > >          return(msg)
    > >      }
    > >      if (is.language(target))
    > >          return(all.equal.language(target, current, ...))
    > >
    > > would fix it.
    > >
    > > Duncan Murdoch
    > >
    > > ______________________________________________
    > > R-devel at r-project.org mailing list
    > > https://stat.ethz.ch/mailman/listinfo/r-devel


From w||||@mwdun|@p @end|ng |rom gm@||@com  Tue Dec  1 16:37:02 2020
From: w||||@mwdun|@p @end|ng |rom gm@||@com (Bill Dunlap)
Date: Tue, 1 Dec 2020 07:37:02 -0800
Subject: [Rd] all.equal applied to function closures
In-Reply-To: <24518.3448.1707.699927@stat.math.ethz.ch>
References: <B43EED2F-F34F-436E-9822-AFB2A1C954DF@adobe.com>
 <8142836e-d8d5-1faa-fbfe-265a9c6f22e9@gmail.com>
 <CAHqSRuR0CzvyB_CkC2mkxXrJ8XGvGugJDtct6VVOOhCdvU0C5Q@mail.gmail.com>
 <24518.3448.1707.699927@stat.math.ethz.ch>
Message-ID: <CAHqSRuQ0mrNnExHvpMhMow99ZqoAFkYLE3Pg-SZBxipokJS=2g@mail.gmail.com>

Probably all.equal.environment's do1() could be enhanced to do the
recursion (and look at the environments' attributes).  I wrote a separate
function because it was easier to experiment that way (e.g., when to stop
recursing - it stops when one environment is a top-level environment or the
empty environment).  I've been thinking about similar recursion options for
ls.str() - it would make it easier to debug refClass and R6 code where the
data is somewhere in a stack of environments.

> E1 <- list2env(list(X=1.1, Y=1.2), parent=list2env(list(p=1.3),
parent=baseenv()))
> E2 <- list2env(list(X=1.1, Y=1.2), parent=list2env(list(p=1.4),
parent=baseenv()))
> base::all.equal.environment(E1,E2)
[1] TRUE
> globalenv()$all.equal.environment(E1,E2)
[1] "<parent.env> Component ?p?: Mean relative difference: 0.07692308"
>
> E3 <- list2env(list(X=1.1, Y=1.2), parent=list2env(list(p=1.5),
parent=new.env(parent=baseenv())))
> base::all.equal.environment(E1,E3)
[1] TRUE
> globalenv()$all.equal.environment(E1,E3)
[1] "<parent.env> Component ?p?: Mean relative difference: 0.1538462"
[2] "<parent.env> <parent.env> target is <environment: base> and current is
<environment: 0x564e806705c8>"

On Tue, Dec 1, 2020 at 1:31 AM Martin Maechler <maechler at stat.math.ethz.ch>
wrote:

> >>>>> Bill Dunlap
> >>>>>     on Mon, 30 Nov 2020 13:41:54 -0800 writes:
>
>     > To make the comparison more complete, all.equal.environment could
> compare
>     > the parents of the target and current environments.  That would have
> to be
>     > recursive but could stop at the first 'top level environment' (the
> global,
>     > empty, or a package-related environment generally) and use identical
>     > there.  E.g.,
>
>     > > f1 <- function(x) (function(){ expx <- exp(x) ; function(y) y +
> expx})()
>     > > all.equal(f1(2), f1(3))
>     > [1] "Environments: Component ?expx?: Mean relative difference:
> 1.718282"
>     >
>     > [2] "Environments: <parent.env> Component ?x?: Mean relative
> difference:
>     > 0.5"
>
>     > This is from the following, where I avoided putting the existing
>     > non-recursive all.equal.environment into the body of this one.
>
>     > all.equal.environment <-
>     > function(target, current, ...)
>     > {
>     >     .all.equal.environment <- base::all.equal.environment #
> temporary hack
>     >     stopifnot(is.environment(target), is.environment(current))
>     >     if (identical(target, current)) {
>     >         TRUE
>     >     } else {
>     >         msg <- NULL # TODO: check attributes
>     >         # deal with emptyenv now since parent.env(emptyenv()) gives
> error
>     >         # and topenv(emptyenv()) gives GlobalEnv
>     >         eTarget <- identical(target, emptyenv()) ||
>     > identical(target,topenv(target))
>     >         eCurrent <- identical(current, emptyenv()) ||
>     > identical(current,topenv(current))
>     >         if (eTarget || eCurrent) {
>     >             msg <- c(msg, paste("target is", format(target), "and
> current
>     > is", format(current)))
>     >         } else {
>     >             thisComparison <- .all.equal.environment(target,
> current, ...)
>     >             if (!isTRUE(thisComparison)) {
>     >                 msg <- c(msg, thisComparison)
>     >             }
>     >             parentComparison <- Recall(parent.env(target),
>     > parent.env(current), ...)
>     >             if (!isTRUE(parentComparison)) {
>     >                 msg <- c(msg, paste("<parent.env>",
> parentComparison))
>     >             }
>     >         }
>     >         if (is.null(msg) || isTRUE(msg)) TRUE else msg
>     >     }
>     > }
>
> Thank you, Duncan and Bill (and Kevin for bringing up the
> topic).
>
> I agree  all.equal() should work better with functions,
>
> and I think probably it would make sense to define  all.equal.function()
> rather than put this into all.equal.default()
>
> However, it's not quite clear if it is always desirable to check the
> environments as well notably as that *is* done recursively.
>
> Bill, I'm sure you've noticed that we did write  all.equal.environment()
> to work recursively... Actually, I had worked quite a bit at
> that, too long ago to remember details, but the relevant svn log
> entry is
> ------------------------------------------------------------------------
> r66640 | maechler | 2014-09-18 22:10:20 +0200 (Thu, 18 Sep 2014) | 1 line
>
> more sophisticated all.equal.environment(): no longer "simple" infinite
> recursions
> ------------------------------------------------------------------------
>
> Are you sure that code with the internal recursive do1()
> function should/could not be amended where needed?
>
> Martin
>
>     > On Mon, Nov 30, 2020 at 10:42 AM Duncan Murdoch <
> murdoch.duncan at gmail.com>
>     > wrote:
>     >
>     > > On 30/11/2020 1:05 p.m., Kevin Van Horn via R-devel wrote:
>     > > > Consider the following code:
>     > > >
>     > > >      f <- function(x)function(y){x+y}
>     > > >      all.equal(f(5), f(0))
>     > > >
>     > > > This returns TRUE, when it should return FALSE; I think it?s
> hard to
>     > > make the case that f(5) and f(0) are ?approximately equal? in any
>     > > meaningful sense. Digging into the code for all.equal(), I see that
>     > > all.equal(f(5), f(0)) results in a call to
> all.equal.language(f(5), f(0)),
>     > > which only compares the function texts for equality.
>     > > >
>     > > > If it is decided to leave this behavior as-is, then at least it
> should
>     > > be documented. Currently I cannot find any documentation for
> all.equal
>     > > applied to functions.
>     > >
>     > > Clearly it should also compare the environments of the two
> functions,
>     > > then it would see a difference:
>     > >
>     > >  > all.equal(environment(f(5)), environment(f(0)))
>     > > [1] "Component ?x?: Mean relative difference: 1"
>     > >
>     > > Changing the first few lines from
>     > >
>     > >      if (is.language(target) || is.function(target))
>     > >          return(all.equal.language(target, current, ...))
>     > >
>     > > to
>     > >
>     > >      if (is.function(target)) {
>     > >          msg <- all.equal.language(target, current, ...)
>     > >          if (isTRUE(msg)) {
>     > >              msg <- all.equal.environment(environment(target),
>     > > environment(current), ...)
>     > >              if (is.character(msg))
>     > >                msg <- paste("Environments:", msg)
>     > >          }
>     > >          return(msg)
>     > >      }
>     > >      if (is.language(target))
>     > >          return(all.equal.language(target, current, ...))
>     > >
>     > > would fix it.
>     > >
>     > > Duncan Murdoch
>     > >
>     > > ______________________________________________
>     > > R-devel at r-project.org mailing list
>     > > https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From murdoch@dunc@n @end|ng |rom gm@||@com  Tue Dec  1 17:08:25 2020
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Tue, 1 Dec 2020 11:08:25 -0500
Subject: [Rd] all.equal applied to function closures
In-Reply-To: <CAHqSRuQ0mrNnExHvpMhMow99ZqoAFkYLE3Pg-SZBxipokJS=2g@mail.gmail.com>
References: <B43EED2F-F34F-436E-9822-AFB2A1C954DF@adobe.com>
 <8142836e-d8d5-1faa-fbfe-265a9c6f22e9@gmail.com>
 <CAHqSRuR0CzvyB_CkC2mkxXrJ8XGvGugJDtct6VVOOhCdvU0C5Q@mail.gmail.com>
 <24518.3448.1707.699927@stat.math.ethz.ch>
 <CAHqSRuQ0mrNnExHvpMhMow99ZqoAFkYLE3Pg-SZBxipokJS=2g@mail.gmail.com>
Message-ID: <96f3f5b1-71a1-f7d2-c291-df890a2fb493@gmail.com>

One more comment:  it might be worthwhile reporting on a case where 
identical(e1, e2) fails when those are the environments associated with 
two functions (though I think not by default in all.equal.environment).

Functions can modify variables in their environment, so examples like 
the open.account example in the R-intro manual would distinguish between 
ross and robert even if the balances matched.

Duncan Murdoch

On 01/12/2020 10:37 a.m., Bill Dunlap wrote:
> Probably all.equal.environment's do1() could be enhanced to do the 
> recursion (and look at the environments' attributes).? I wrote a 
> separate function because it was easier to experiment that way (e.g., 
> when to stop recursing?- it stops when one environment is a top-level 
> environment or the empty environment).? I've been thinking about similar 
> recursion options for ls.str() - it would make it easier to debug 
> refClass and R6 code where the data is somewhere in a stack of environments.
> 
>  > E1 <- list2env(list(X=1.1, Y=1.2), parent=list2env(list(p=1.3), 
> parent=baseenv()))
>  > E2 <- list2env(list(X=1.1, Y=1.2), parent=list2env(list(p=1.4), 
> parent=baseenv()))
>  > base::all.equal.environment(E1,E2)
> [1] TRUE
>  > globalenv()$all.equal.environment(E1,E2)
> [1] "<parent.env> Component ?p?: Mean relative difference: 0.07692308"
>  >
>  > E3 <- list2env(list(X=1.1, Y=1.2), parent=list2env(list(p=1.5), 
> parent=new.env(parent=baseenv())))
>  > base::all.equal.environment(E1,E3)
> [1] TRUE
>  > globalenv()$all.equal.environment(E1,E3)
> [1] "<parent.env> Component ?p?: Mean relative difference: 0.1538462"
> [2] "<parent.env> <parent.env> target is <environment: base> and current 
> is <environment: 0x564e806705c8>"
> 
> On Tue, Dec 1, 2020 at 1:31 AM Martin Maechler 
> <maechler at stat.math.ethz.ch <mailto:maechler at stat.math.ethz.ch>> wrote:
> 
>      >>>>> Bill Dunlap
>      >>>>>? ? ?on Mon, 30 Nov 2020 13:41:54 -0800 writes:
> 
>      ? ? > To make the comparison more complete, all.equal.environment
>     could compare
>      ? ? > the parents of the target and current environments.? That
>     would have to be
>      ? ? > recursive but could stop at the first 'top level environment'
>     (the global,
>      ? ? > empty, or a package-related environment generally) and use
>     identical
>      ? ? > there.? E.g.,
> 
>      ? ? > > f1 <- function(x) (function(){ expx <- exp(x) ; function(y)
>     y + expx})()
>      ? ? > > all.equal(f1(2), f1(3))
>      ? ? > [1] "Environments: Component ?expx?: Mean relative
>     difference: 1.718282"
>      ? ? >
>      ? ? > [2] "Environments: <parent.env> Component ?x?: Mean relative
>     difference:
>      ? ? > 0.5"
> 
>      ? ? > This is from the following, where I avoided putting the existing
>      ? ? > non-recursive all.equal.environment into the body of this one.
> 
>      ? ? > all.equal.environment <-
>      ? ? > function(target, current, ...)
>      ? ? > {
>      ? ? >? ? ?.all.equal.environment <- base::all.equal.environment #
>     temporary hack
>      ? ? >? ? ?stopifnot(is.environment(target), is.environment(current))
>      ? ? >? ? ?if (identical(target, current)) {
>      ? ? >? ? ? ? ?TRUE
>      ? ? >? ? ?} else {
>      ? ? >? ? ? ? ?msg <- NULL # TODO: check attributes
>      ? ? >? ? ? ? ?# deal with emptyenv now since parent.env(emptyenv())
>     gives error
>      ? ? >? ? ? ? ?# and topenv(emptyenv()) gives GlobalEnv
>      ? ? >? ? ? ? ?eTarget <- identical(target, emptyenv()) ||
>      ? ? > identical(target,topenv(target))
>      ? ? >? ? ? ? ?eCurrent <- identical(current, emptyenv()) ||
>      ? ? > identical(current,topenv(current))
>      ? ? >? ? ? ? ?if (eTarget || eCurrent) {
>      ? ? >? ? ? ? ? ? ?msg <- c(msg, paste("target is", format(target),
>     "and current
>      ? ? > is", format(current)))
>      ? ? >? ? ? ? ?} else {
>      ? ? >? ? ? ? ? ? ?thisComparison <- .all.equal.environment(target,
>     current, ...)
>      ? ? >? ? ? ? ? ? ?if (!isTRUE(thisComparison)) {
>      ? ? >? ? ? ? ? ? ? ? ?msg <- c(msg, thisComparison)
>      ? ? >? ? ? ? ? ? ?}
>      ? ? >? ? ? ? ? ? ?parentComparison <- Recall(parent.env(target),
>      ? ? > parent.env(current), ...)
>      ? ? >? ? ? ? ? ? ?if (!isTRUE(parentComparison)) {
>      ? ? >? ? ? ? ? ? ? ? ?msg <- c(msg, paste("<parent.env>",
>     parentComparison))
>      ? ? >? ? ? ? ? ? ?}
>      ? ? >? ? ? ? ?}
>      ? ? >? ? ? ? ?if (is.null(msg) || isTRUE(msg)) TRUE else msg
>      ? ? >? ? ?}
>      ? ? > }
> 
>     Thank you, Duncan and Bill (and Kevin for bringing up the
>     topic).
> 
>     I agree? all.equal() should work better with functions,
> 
>     and I think probably it would make sense to define? all.equal.function()
>     rather than put this into all.equal.default()
> 
>     However, it's not quite clear if it is always desirable to check the
>     environments as well notably as that *is* done recursively.
> 
>     Bill, I'm sure you've noticed that we did write? all.equal.environment()
>     to work recursively... Actually, I had worked quite a bit at
>     that, too long ago to remember details, but the relevant svn log
>     entry is
>     ------------------------------------------------------------------------
>     r66640 | maechler | 2014-09-18 22:10:20 +0200 (Thu, 18 Sep 2014) | 1
>     line
> 
>     more sophisticated all.equal.environment(): no longer "simple"
>     infinite recursions
>     ------------------------------------------------------------------------
> 
>     Are you sure that code with the internal recursive do1()
>     function should/could not be amended where needed?
> 
>     Martin
> 
>      ? ? > On Mon, Nov 30, 2020 at 10:42 AM Duncan Murdoch
>     <murdoch.duncan at gmail.com <mailto:murdoch.duncan at gmail.com>>
>      ? ? > wrote:
>      ? ? >
>      ? ? > > On 30/11/2020 1:05 p.m., Kevin Van Horn via R-devel wrote:
>      ? ? > > > Consider the following code:
>      ? ? > > >
>      ? ? > > >? ? ? f <- function(x)function(y){x+y}
>      ? ? > > >? ? ? all.equal(f(5), f(0))
>      ? ? > > >
>      ? ? > > > This returns TRUE, when it should return FALSE; I think
>     it?s hard to
>      ? ? > > make the case that f(5) and f(0) are ?approximately equal?
>     in any
>      ? ? > > meaningful sense. Digging into the code for all.equal(), I
>     see that
>      ? ? > > all.equal(f(5), f(0)) results in a call to
>     all.equal.language(f(5), f(0)),
>      ? ? > > which only compares the function texts for equality.
>      ? ? > > >
>      ? ? > > > If it is decided to leave this behavior as-is, then at
>     least it should
>      ? ? > > be documented. Currently I cannot find any documentation
>     for all.equal
>      ? ? > > applied to functions.
>      ? ? > >
>      ? ? > > Clearly it should also compare the environments of the two
>     functions,
>      ? ? > > then it would see a difference:
>      ? ? > >
>      ? ? > >? > all.equal(environment(f(5)), environment(f(0)))
>      ? ? > > [1] "Component ?x?: Mean relative difference: 1"
>      ? ? > >
>      ? ? > > Changing the first few lines from
>      ? ? > >
>      ? ? > >? ? ? if (is.language(target) || is.function(target))
>      ? ? > >? ? ? ? ? return(all.equal.language(target, current, ...))
>      ? ? > >
>      ? ? > > to
>      ? ? > >
>      ? ? > >? ? ? if (is.function(target)) {
>      ? ? > >? ? ? ? ? msg <- all.equal.language(target, current, ...)
>      ? ? > >? ? ? ? ? if (isTRUE(msg)) {
>      ? ? > >? ? ? ? ? ? ? msg <- all.equal.environment(environment(target),
>      ? ? > > environment(current), ...)
>      ? ? > >? ? ? ? ? ? ? if (is.character(msg))
>      ? ? > >? ? ? ? ? ? ? ? msg <- paste("Environments:", msg)
>      ? ? > >? ? ? ? ? }
>      ? ? > >? ? ? ? ? return(msg)
>      ? ? > >? ? ? }
>      ? ? > >? ? ? if (is.language(target))
>      ? ? > >? ? ? ? ? return(all.equal.language(target, current, ...))
>      ? ? > >
>      ? ? > > would fix it.
>      ? ? > >
>      ? ? > > Duncan Murdoch
>      ? ? > >
>      ? ? > > ______________________________________________
>      ? ? > > R-devel at r-project.org <mailto:R-devel at r-project.org>
>     mailing list
>      ? ? > > https://stat.ethz.ch/mailman/listinfo/r-devel
>     <https://stat.ethz.ch/mailman/listinfo/r-devel>
>


From j@goreck| @end|ng |rom w|t@edu@p|  Tue Dec  1 17:16:51 2020
From: j@goreck| @end|ng |rom w|t@edu@p| (Jan Gorecki)
Date: Tue, 1 Dec 2020 18:16:51 +0200
Subject: [Rd] [External] Re: .Internal(quit(...)): system call failed:
 Cannot allocate memory
In-Reply-To: <alpine.DEB.2.21.2011271410260.3003@luke-Latitude-7480>
References: <CAOO9MKUhAxhv_UAtBKBebN+zCQW+JVTuRHhzohdaUZ=tZYkWAg@mail.gmail.com>
 <2b09f5dd-0217-bd98-d427-38c6fa374d41@gmail.com>
 <CAHqSRuRPbuyq0T_Oh7XfbH6Ls_gOA6ifinAhG9D-vXn3DU2sHw@mail.gmail.com>
 <CAOO9MKWTUTXZeg2GG0v6OedG4zRPC0ospNvgb10h-9FeOJ0HYw@mail.gmail.com>
 <cf311324-cc24-4ccc-c4df-b0fcc152cd86@gmail.com>
 <CAOO9MKWXVEv+LX_CdpA+WOP52zhPH30U23ZaZb8LLNncT1aYeg@mail.gmail.com>
 <alpine.DEB.2.21.2011251432380.3003@luke-Latitude-7480>
 <CAOO9MKWk3qdghJ0KJx0KemXdFEGr7QzzjHZHguWFzfSKYwFYPA@mail.gmail.com>
 <alpine.DEB.2.21.2011271410260.3003@luke-Latitude-7480>
Message-ID: <CAOO9MKXujYPcJb2GBpnHqHZN6qwQPPgunoE2qh9GqQzRxCxSgw@mail.gmail.com>

Thank you Luke,

I tried your suggestion about R_MAX_VSIZE but I am not able to get the
error you are getting.
I tried recent R devel as I have seen you made a change to GC there.
My machine is 128GB, free -h reports 125GB available. I tried to set
128, 125 and 100. In all cases the result is "Command terminated by
signal 9". Each took around 6-6.5h.
Details below, if it tells you anything how could I optimize it (or
raise an exception early) please do let me know.

R 4.0.3

unset R_MAX_VSIZE
        User time (seconds): 40447.92
        System time (seconds): 4034.37
        Percent of CPU this job got: 201%
        Elapsed (wall clock) time (h:mm:ss or m:ss): 6:07:59
        Maximum resident set size (kbytes): 127261184
        Major (requiring I/O) page faults: 72441
        Minor (reclaiming a frame) page faults: 3315491751
        Voluntary context switches: 381446
        Involuntary context switches: 529554
        File system inputs: 108339200
        File system outputs: 120

R-devel 2020-11-27 r79522

unset R_MAX_VSIZE
        User time (seconds): 40713.52
        System time (seconds): 4039.52
        Percent of CPU this job got: 198%
        Elapsed (wall clock) time (h:mm:ss or m:ss): 6:15:52
        Maximum resident set size (kbytes): 127254796
        Major (requiring I/O) page faults: 72810
        Minor (reclaiming a frame) page faults: 3433589848
        Voluntary context switches: 384363
        Involuntary context switches: 609024
        File system inputs: 108467064
        File system outputs: 112

R_MAX_VSIZE=128Gb
        User time (seconds): 40411.13
        System time (seconds): 4227.99
        Percent of CPU this job got: 198%
        Elapsed (wall clock) time (h:mm:ss or m:ss): 6:14:01
        Maximum resident set size (kbytes): 127249316
        Major (requiring I/O) page faults: 88500
        Minor (reclaiming a frame) page faults: 3544520527
        Voluntary context switches: 384117
        Involuntary context switches: 545397
        File system inputs: 111675896
        File system outputs: 120

R_MAX_VSIZE=125Gb
        User time (seconds): 40246.83
        System time (seconds): 4042.76
        Percent of CPU this job got: 201%
        Elapsed (wall clock) time (h:mm:ss or m:ss): 6:06:56
        Maximum resident set size (kbytes): 127254200
        Major (requiring I/O) page faults: 63867
        Minor (reclaiming a frame) page faults: 3449493803
        Voluntary context switches: 370753
        Involuntary context switches: 614607
        File system inputs: 106322880
        File system outputs: 112

R_MAX_VSIZE=100Gb
        User time (seconds): 41837.10
        System time (seconds): 3979.57
        Percent of CPU this job got: 192%
        Elapsed (wall clock) time (h:mm:ss or m:ss): 6:36:34
        Maximum resident set size (kbytes): 127256940
        Major (requiring I/O) page faults: 66829
        Minor (reclaiming a frame) page faults: 3357778594
        Voluntary context switches: 391149
        Involuntary context switches: 646410
        File system inputs: 106605648
        File system outputs: 120

On Fri, Nov 27, 2020 at 10:18 PM <luke-tierney at uiowa.edu> wrote:
>
> On Thu, 26 Nov 2020, Jan Gorecki wrote:
>
> > Thank you Luke for looking into it. Your knowledge of gc is definitely
> > helpful here. I put comments inline below.
> >
> > Best,
> > Jan
> >
> > On Wed, Nov 25, 2020 at 10:38 PM <luke-tierney at uiowa.edu> wrote:
> >>
> >> On Tue, 24 Nov 2020, Jan Gorecki wrote:
> >>
> >>> As for other calls to system. I avoid calling system. In the past I
> >>> had some (to get memory stats from OS), but they were failing with
> >>> exactly the same issue. So yes, if I would add call to system before
> >>> calling quit, I believe it would fail with the same error.
> >>> At the same time I think (although I am not sure) that new allocations
> >>> made in R are working fine. So R seems to reserve some memory and can
> >>> continue to operate, while external call like system will fail. Maybe
> >>> it is like this by design, don't know.
> >>
> >> Thanks for the report on quit(). We're exploring how to make the
> >> cleanup on exit more robust to low memory situations like these.
> >>
> >>>
> >>> Aside from this problem that is easy to report due to the warning
> >>> message, I think that gc() is choking at the same time. I tried to
> >>> make reproducible example for that, multiple times but couldn't, let
> >>> me try one more time.
> >>> It happens to manifest when there is 4e8+ unique characters/factors in
> >>> an R session. I am able to reproduce it using data.table and dplyr
> >>> (0.8.4 because 1.0.0+ fails even sooner), but using base R is not easy
> >>> because of the size. I described briefly problem in:
> >>> https://github.com/h2oai/db-benchmark/issues/110
> >>
> >> Because of the design of R's character vectors, with each element
> >> allocated separately, R is never going to be great at handling huge
> >> numbers of distinct strings. But it can do an adequate job given
> >> enough memory to work with.
> >>
> >> When I run your GitHub issue example on a machine with around 500 Gb
> >> of RAM it seems to run OK; /usr/bin/time reports
> >>
> >> 2706.89user 161.89system 37:10.65elapsed 128%CPU (0avgtext+0avgdata 92180796maxresident)k
> >> 0inputs+103450552outputs (0major+38716351minor)pagefaults 0swaps
> >>
> >> So the memory footprint is quite large. Using gc.time() it looks like
> >> about 1/3 of the time is in GC. Not ideal, and maybe could be improved
> >> on a bit, but probably not by much. The GC is basically doing an
> >> adequate job, given enough RAM.
> >
> > Agree, 1/3 is a lot but still acceptable. So this strictly is not
> > something that requires intervention.
> > PS. I wasn't aware of gc.time(), it may be worth linking it from
> > SeeAlso in gc() manual.
> >
> >>
> >> If you run this example on a system without enough RAM, or with other
> >> programs competing for RAM, you are likely to end up fighting with
> >> your OS/hardware's virtual memory system. When I try to run it on a
> >> 16Gb system it churns for an hour or so before getting killed, and
> >> /usr/bin/time reports a huge number of page faults:
> >>
> >> 312523816inputs+0outputs (24761285major+25762068minor)pagefaults 0swaps
> >>
> >> You are probably experiencing something similar.
> >
> > Yes, this is exactly what I am experiencing.
> > The machine is a bare metal machine of 128GB mem, csv size 50GB,
> > data.frame size 74GB.
> > In my case it churns for ~3h before it gets killed with SIGINT from
> > the parent R process which uses 3h as a timeout for this script.
> > This is something I would like to be addressed because gc time is far
> > bigger than actual computation time. This is not really acceptable, I
> > would prefer to raise an exception instead.
> >
> >>
> >> There may be opportunities for more tuning of the GC to better handle
> >> running this close to memory limits, but I doubt the payoff would be
> >> worth the effort.
> >
> > If you don't have plans/time to work on that anytime soon, then I can
> > fill bugzilla for this problem so it won't get lost in the mailing
> > list.
>
> I'm not convinced anything useful can be done that would work well for
> your application without working badly for others.
>
> If you want to drive this close to your memory limits you are probably
> going to have to take responsibility for some tuning at your end. One
> option in ?Memory you might try is the R_MAX_VSIZE environment
> variable. On my 16Gb machine with R_MAX_VSIZE=16Gb your example fails
> very quickly with
>
> Error: vector memory exhausted (limit reached?)
>
> rather than churning for an hour trying to make things work. Setting
> memory and/or virtual memory limits in your shell is another option.
>
> Best,
>
> luke
>
> >
> >
> >>
> >> Best,
> >>
> >> luke
> >>
> >>> It would help if gcinfo() could take FALSE/TRUE/2L where 2L will print
> >>> even more information about gc, like how much time the each gc()
> >>> process took, how many objects it has to check on each level.
> >>>
> >>> Best regards,
> >>> Jan
> >>>
> >>>
> >>>
> >>> On Tue, Nov 24, 2020 at 1:05 PM Tomas Kalibera <tomas.kalibera at gmail.com> wrote:
> >>>>
> >>>> On 11/24/20 11:27 AM, Jan Gorecki wrote:
> >>>>> Thanks Bill for checking that.
> >>>>> It was my impression that warnings are raised from some internal
> >>>>> system calls made when quitting R. At that point I don't have much
> >>>>> control over checking the return status of those.
> >>>>> Your suggestion looks good to me.
> >>>>>
> >>>>> Tomas, do you think this could help? could this be implemented?
> >>>>
> >>>> I think this is a good suggestion. Deleting files on Unix was changed
> >>>> from system("rm") to doing that in C, and deleting the session directory
> >>>> should follow.
> >>>>
> >>>> It might also help diagnosing your problem, but I don't think it would
> >>>> solve it. If the diagnostics in R works fine and the OS was so
> >>>> hopelessly out of memory that it couldn't run any more external
> >>>> processes, then really this is not a problem of R, but of having
> >>>> exhausted the resources. And it would be a coincidence that just this
> >>>> particular call to "system" at the end of the session did not work.
> >>>> Anything else could break as well close to the end of the script. This
> >>>> seems the most likely explanation to me.
> >>>>
> >>>> Do you get this warning repeatedly, reproducibly at least in slightly
> >>>> different scripts at the very end, with this warning always from quit()?
> >>>> So that the "call" part of the warning message has .Internal(quit) like
> >>>> in the case you posted? Would adding another call to "system" before the
> >>>> call to "q()" work - with checking the return value? If it is always
> >>>> only the last call to "system" in "q()", then it is suspicious, perhaps
> >>>> an indication that some diagnostics in R is not correct. In that case, a
> >>>> reproducible example would be the key - so either if you could diagnose
> >>>> on your end what is the problem, or create a reproducible example that
> >>>> someone else can use to reproduce and debug.
> >>>>
> >>>> Best
> >>>> Tomas
> >>>>
> >>>>>
> >>>>> On Mon, Nov 23, 2020 at 7:10 PM Bill Dunlap <williamwdunlap at gmail.com> wrote:
> >>>>>> The call to system() probably is an internal call used to delete the session's tempdir().  This sort of failure means that a potentially large amount of disk space is not being recovered when R is done.  Perhaps R_CleanTempDir() could call R_unlink() instead of having a subprocess call 'rm -rf ...'.  Then it could also issue a specific warning if it was impossible to delete all of tempdir().  (That should be very rare.)
> >>>>>>
> >>>>>>> q("no")
> >>>>>> Breakpoint 1, R_system (command=command at entry=0x7fffffffa1e0 "rm -Rf /tmp/RtmppoKPXb") at sysutils.c:311
> >>>>>> 311     {
> >>>>>> (gdb) where
> >>>>>> #0  R_system (command=command at entry=0x7fffffffa1e0 "rm -Rf /tmp/RtmppoKPXb") at sysutils.c:311
> >>>>>> #1  0x00005555557c30ec in R_CleanTempDir () at sys-std.c:1178
> >>>>>> #2  0x00005555557c31d7 in Rstd_CleanUp (saveact=<optimized out>, status=0, runLast=<optimized out>) at sys-std.c:1243
> >>>>>> #3  0x00005555557c593d in R_CleanUp (saveact=saveact at entry=SA_NOSAVE, status=status at entry=0, runLast=<optimized out>) at system.c:87
> >>>>>> #4  0x00005555556cc85e in do_quit (call=<optimized out>, op=<optimized out>, args=0x555557813f90, rho=<optimized out>) at main.c:1393
> >>>>>>
> >>>>>> -Bill
> >>>>>>
> >>>>>> On Mon, Nov 23, 2020 at 3:15 AM Tomas Kalibera <tomas.kalibera at gmail.com> wrote:
> >>>>>>> On 11/21/20 6:51 PM, Jan Gorecki wrote:
> >>>>>>>> Dear R-developers,
> >>>>>>>>
> >>>>>>>> Some of the more fat scripts (50+ GB mem used by R) that I am running,
> >>>>>>>> when they finish they do quit with q("no", status=0)
> >>>>>>>> Quite often it happens that there is an extra stderr output produced
> >>>>>>>> at the very end which looks like this:
> >>>>>>>>
> >>>>>>>> Warning message:
> >>>>>>>> In .Internal(quit(save, status, runLast)) :
> >>>>>>>>     system call failed: Cannot allocate memory
> >>>>>>>>
> >>>>>>>> Is there any way to avoid this kind of warnings? I am using stderr
> >>>>>>>> output for detecting failures in scripts and this warning is a false
> >>>>>>>> positive of a failure.
> >>>>>>>>
> >>>>>>>> Maybe quit function could wait little bit longer trying to allocate
> >>>>>>>> before it raises this warning?
> >>>>>>> If you see this warning, some call to system() or system2() or similar,
> >>>>>>> which executes an external program, failed to even run a shell to run
> >>>>>>> that external program, because there was not enough memory. You should
> >>>>>>> be able to find out where it happens by checking the exit status of
> >>>>>>> system().
> >>>>>>>
> >>>>>>> Tomas
> >>>>>>>
> >>>>>>>
> >>>>>>>> Best regards,
> >>>>>>>> Jan Gorecki
> >>>>>>>>
> >>>>>>>> ______________________________________________
> >>>>>>>> R-devel at r-project.org mailing list
> >>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>>>>>> ______________________________________________
> >>>>>>> R-devel at r-project.org mailing list
> >>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>>>
> >>>>
> >>>
> >>> ______________________________________________
> >>> R-devel at r-project.org mailing list
> >>> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>>
> >>
> >> --
> >> Luke Tierney
> >> Ralph E. Wareham Professor of Mathematical Sciences
> >> University of Iowa                  Phone:             319-335-3386
> >> Department of Statistics and        Fax:               319-335-3017
> >>     Actuarial Science
> >> 241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
> >> Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu
> >
>
> --
> Luke Tierney
> Ralph E. Wareham Professor of Mathematical Sciences
> University of Iowa                  Phone:             319-335-3386
> Department of Statistics and        Fax:               319-335-3017
>     Actuarial Science
> 241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
> Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu


From iuke-tier@ey m@iii@g oii uiow@@edu  Tue Dec  1 17:54:32 2020
From: iuke-tier@ey m@iii@g oii uiow@@edu (iuke-tier@ey m@iii@g oii uiow@@edu)
Date: Tue, 1 Dec 2020 10:54:32 -0600 (CST)
Subject: [Rd] [External] Re: .Internal(quit(...)): system call failed:
 Cannot allocate memory
In-Reply-To: <CAOO9MKXujYPcJb2GBpnHqHZN6qwQPPgunoE2qh9GqQzRxCxSgw@mail.gmail.com>
References: <CAOO9MKUhAxhv_UAtBKBebN+zCQW+JVTuRHhzohdaUZ=tZYkWAg@mail.gmail.com>
 <2b09f5dd-0217-bd98-d427-38c6fa374d41@gmail.com>
 <CAHqSRuRPbuyq0T_Oh7XfbH6Ls_gOA6ifinAhG9D-vXn3DU2sHw@mail.gmail.com>
 <CAOO9MKWTUTXZeg2GG0v6OedG4zRPC0ospNvgb10h-9FeOJ0HYw@mail.gmail.com>
 <cf311324-cc24-4ccc-c4df-b0fcc152cd86@gmail.com>
 <CAOO9MKWXVEv+LX_CdpA+WOP52zhPH30U23ZaZb8LLNncT1aYeg@mail.gmail.com>
 <alpine.DEB.2.21.2011251432380.3003@luke-Latitude-7480>
 <CAOO9MKWk3qdghJ0KJx0KemXdFEGr7QzzjHZHguWFzfSKYwFYPA@mail.gmail.com>
 <alpine.DEB.2.21.2011271410260.3003@luke-Latitude-7480>
 <CAOO9MKXujYPcJb2GBpnHqHZN6qwQPPgunoE2qh9GqQzRxCxSgw@mail.gmail.com>
Message-ID: <alpine.DEB.2.21.2012011049490.3003@luke-Latitude-7480>

The fact that your max resident size isn't affected looks odd.  Are
you setting the environment variable outside R? When I run

     env R_MAX_VSIZE=16Gb /usr/bin/time bin/Rscript jg.R 1e9 2e0 0 0

(your code in jg.R). I get a quick failure with 11785524maxresident)k

Best,

luke

On Tue, 1 Dec 2020, Jan Gorecki wrote:

> Thank you Luke,
>
> I tried your suggestion about R_MAX_VSIZE but I am not able to get the
> error you are getting.
> I tried recent R devel as I have seen you made a change to GC there.
> My machine is 128GB, free -h reports 125GB available. I tried to set
> 128, 125 and 100. In all cases the result is "Command terminated by
> signal 9". Each took around 6-6.5h.
> Details below, if it tells you anything how could I optimize it (or
> raise an exception early) please do let me know.
>
> R 4.0.3
>
> unset R_MAX_VSIZE
>        User time (seconds): 40447.92
>        System time (seconds): 4034.37
>        Percent of CPU this job got: 201%
>        Elapsed (wall clock) time (h:mm:ss or m:ss): 6:07:59
>        Maximum resident set size (kbytes): 127261184
>        Major (requiring I/O) page faults: 72441
>        Minor (reclaiming a frame) page faults: 3315491751
>        Voluntary context switches: 381446
>        Involuntary context switches: 529554
>        File system inputs: 108339200
>        File system outputs: 120
>
> R-devel 2020-11-27 r79522
>
> unset R_MAX_VSIZE
>        User time (seconds): 40713.52
>        System time (seconds): 4039.52
>        Percent of CPU this job got: 198%
>        Elapsed (wall clock) time (h:mm:ss or m:ss): 6:15:52
>        Maximum resident set size (kbytes): 127254796
>        Major (requiring I/O) page faults: 72810
>        Minor (reclaiming a frame) page faults: 3433589848
>        Voluntary context switches: 384363
>        Involuntary context switches: 609024
>        File system inputs: 108467064
>        File system outputs: 112
>
> R_MAX_VSIZE=128Gb
>        User time (seconds): 40411.13
>        System time (seconds): 4227.99
>        Percent of CPU this job got: 198%
>        Elapsed (wall clock) time (h:mm:ss or m:ss): 6:14:01
>        Maximum resident set size (kbytes): 127249316
>        Major (requiring I/O) page faults: 88500
>        Minor (reclaiming a frame) page faults: 3544520527
>        Voluntary context switches: 384117
>        Involuntary context switches: 545397
>        File system inputs: 111675896
>        File system outputs: 120
>
> R_MAX_VSIZE=125Gb
>        User time (seconds): 40246.83
>        System time (seconds): 4042.76
>        Percent of CPU this job got: 201%
>        Elapsed (wall clock) time (h:mm:ss or m:ss): 6:06:56
>        Maximum resident set size (kbytes): 127254200
>        Major (requiring I/O) page faults: 63867
>        Minor (reclaiming a frame) page faults: 3449493803
>        Voluntary context switches: 370753
>        Involuntary context switches: 614607
>        File system inputs: 106322880
>        File system outputs: 112
>
> R_MAX_VSIZE=100Gb
>        User time (seconds): 41837.10
>        System time (seconds): 3979.57
>        Percent of CPU this job got: 192%
>        Elapsed (wall clock) time (h:mm:ss or m:ss): 6:36:34
>        Maximum resident set size (kbytes): 127256940
>        Major (requiring I/O) page faults: 66829
>        Minor (reclaiming a frame) page faults: 3357778594
>        Voluntary context switches: 391149
>        Involuntary context switches: 646410
>        File system inputs: 106605648
>        File system outputs: 120
>
> On Fri, Nov 27, 2020 at 10:18 PM <luke-tierney at uiowa.edu> wrote:
>>
>> On Thu, 26 Nov 2020, Jan Gorecki wrote:
>>
>>> Thank you Luke for looking into it. Your knowledge of gc is definitely
>>> helpful here. I put comments inline below.
>>>
>>> Best,
>>> Jan
>>>
>>> On Wed, Nov 25, 2020 at 10:38 PM <luke-tierney at uiowa.edu> wrote:
>>>>
>>>> On Tue, 24 Nov 2020, Jan Gorecki wrote:
>>>>
>>>>> As for other calls to system. I avoid calling system. In the past I
>>>>> had some (to get memory stats from OS), but they were failing with
>>>>> exactly the same issue. So yes, if I would add call to system before
>>>>> calling quit, I believe it would fail with the same error.
>>>>> At the same time I think (although I am not sure) that new allocations
>>>>> made in R are working fine. So R seems to reserve some memory and can
>>>>> continue to operate, while external call like system will fail. Maybe
>>>>> it is like this by design, don't know.
>>>>
>>>> Thanks for the report on quit(). We're exploring how to make the
>>>> cleanup on exit more robust to low memory situations like these.
>>>>
>>>>>
>>>>> Aside from this problem that is easy to report due to the warning
>>>>> message, I think that gc() is choking at the same time. I tried to
>>>>> make reproducible example for that, multiple times but couldn't, let
>>>>> me try one more time.
>>>>> It happens to manifest when there is 4e8+ unique characters/factors in
>>>>> an R session. I am able to reproduce it using data.table and dplyr
>>>>> (0.8.4 because 1.0.0+ fails even sooner), but using base R is not easy
>>>>> because of the size. I described briefly problem in:
>>>>> https://github.com/h2oai/db-benchmark/issues/110
>>>>
>>>> Because of the design of R's character vectors, with each element
>>>> allocated separately, R is never going to be great at handling huge
>>>> numbers of distinct strings. But it can do an adequate job given
>>>> enough memory to work with.
>>>>
>>>> When I run your GitHub issue example on a machine with around 500 Gb
>>>> of RAM it seems to run OK; /usr/bin/time reports
>>>>
>>>> 2706.89user 161.89system 37:10.65elapsed 128%CPU (0avgtext+0avgdata 92180796maxresident)k
>>>> 0inputs+103450552outputs (0major+38716351minor)pagefaults 0swaps
>>>>
>>>> So the memory footprint is quite large. Using gc.time() it looks like
>>>> about 1/3 of the time is in GC. Not ideal, and maybe could be improved
>>>> on a bit, but probably not by much. The GC is basically doing an
>>>> adequate job, given enough RAM.
>>>
>>> Agree, 1/3 is a lot but still acceptable. So this strictly is not
>>> something that requires intervention.
>>> PS. I wasn't aware of gc.time(), it may be worth linking it from
>>> SeeAlso in gc() manual.
>>>
>>>>
>>>> If you run this example on a system without enough RAM, or with other
>>>> programs competing for RAM, you are likely to end up fighting with
>>>> your OS/hardware's virtual memory system. When I try to run it on a
>>>> 16Gb system it churns for an hour or so before getting killed, and
>>>> /usr/bin/time reports a huge number of page faults:
>>>>
>>>> 312523816inputs+0outputs (24761285major+25762068minor)pagefaults 0swaps
>>>>
>>>> You are probably experiencing something similar.
>>>
>>> Yes, this is exactly what I am experiencing.
>>> The machine is a bare metal machine of 128GB mem, csv size 50GB,
>>> data.frame size 74GB.
>>> In my case it churns for ~3h before it gets killed with SIGINT from
>>> the parent R process which uses 3h as a timeout for this script.
>>> This is something I would like to be addressed because gc time is far
>>> bigger than actual computation time. This is not really acceptable, I
>>> would prefer to raise an exception instead.
>>>
>>>>
>>>> There may be opportunities for more tuning of the GC to better handle
>>>> running this close to memory limits, but I doubt the payoff would be
>>>> worth the effort.
>>>
>>> If you don't have plans/time to work on that anytime soon, then I can
>>> fill bugzilla for this problem so it won't get lost in the mailing
>>> list.
>>
>> I'm not convinced anything useful can be done that would work well for
>> your application without working badly for others.
>>
>> If you want to drive this close to your memory limits you are probably
>> going to have to take responsibility for some tuning at your end. One
>> option in ?Memory you might try is the R_MAX_VSIZE environment
>> variable. On my 16Gb machine with R_MAX_VSIZE=16Gb your example fails
>> very quickly with
>>
>> Error: vector memory exhausted (limit reached?)
>>
>> rather than churning for an hour trying to make things work. Setting
>> memory and/or virtual memory limits in your shell is another option.
>>
>> Best,
>>
>> luke
>>
>>>
>>>
>>>>
>>>> Best,
>>>>
>>>> luke
>>>>
>>>>> It would help if gcinfo() could take FALSE/TRUE/2L where 2L will print
>>>>> even more information about gc, like how much time the each gc()
>>>>> process took, how many objects it has to check on each level.
>>>>>
>>>>> Best regards,
>>>>> Jan
>>>>>
>>>>>
>>>>>
>>>>> On Tue, Nov 24, 2020 at 1:05 PM Tomas Kalibera <tomas.kalibera at gmail.com> wrote:
>>>>>>
>>>>>> On 11/24/20 11:27 AM, Jan Gorecki wrote:
>>>>>>> Thanks Bill for checking that.
>>>>>>> It was my impression that warnings are raised from some internal
>>>>>>> system calls made when quitting R. At that point I don't have much
>>>>>>> control over checking the return status of those.
>>>>>>> Your suggestion looks good to me.
>>>>>>>
>>>>>>> Tomas, do you think this could help? could this be implemented?
>>>>>>
>>>>>> I think this is a good suggestion. Deleting files on Unix was changed
>>>>>> from system("rm") to doing that in C, and deleting the session directory
>>>>>> should follow.
>>>>>>
>>>>>> It might also help diagnosing your problem, but I don't think it would
>>>>>> solve it. If the diagnostics in R works fine and the OS was so
>>>>>> hopelessly out of memory that it couldn't run any more external
>>>>>> processes, then really this is not a problem of R, but of having
>>>>>> exhausted the resources. And it would be a coincidence that just this
>>>>>> particular call to "system" at the end of the session did not work.
>>>>>> Anything else could break as well close to the end of the script. This
>>>>>> seems the most likely explanation to me.
>>>>>>
>>>>>> Do you get this warning repeatedly, reproducibly at least in slightly
>>>>>> different scripts at the very end, with this warning always from quit()?
>>>>>> So that the "call" part of the warning message has .Internal(quit) like
>>>>>> in the case you posted? Would adding another call to "system" before the
>>>>>> call to "q()" work - with checking the return value? If it is always
>>>>>> only the last call to "system" in "q()", then it is suspicious, perhaps
>>>>>> an indication that some diagnostics in R is not correct. In that case, a
>>>>>> reproducible example would be the key - so either if you could diagnose
>>>>>> on your end what is the problem, or create a reproducible example that
>>>>>> someone else can use to reproduce and debug.
>>>>>>
>>>>>> Best
>>>>>> Tomas
>>>>>>
>>>>>>>
>>>>>>> On Mon, Nov 23, 2020 at 7:10 PM Bill Dunlap <williamwdunlap at gmail.com> wrote:
>>>>>>>> The call to system() probably is an internal call used to delete the session's tempdir().  This sort of failure means that a potentially large amount of disk space is not being recovered when R is done.  Perhaps R_CleanTempDir() could call R_unlink() instead of having a subprocess call 'rm -rf ...'.  Then it could also issue a specific warning if it was impossible to delete all of tempdir().  (That should be very rare.)
>>>>>>>>
>>>>>>>>> q("no")
>>>>>>>> Breakpoint 1, R_system (command=command at entry=0x7fffffffa1e0 "rm -Rf /tmp/RtmppoKPXb") at sysutils.c:311
>>>>>>>> 311     {
>>>>>>>> (gdb) where
>>>>>>>> #0  R_system (command=command at entry=0x7fffffffa1e0 "rm -Rf /tmp/RtmppoKPXb") at sysutils.c:311
>>>>>>>> #1  0x00005555557c30ec in R_CleanTempDir () at sys-std.c:1178
>>>>>>>> #2  0x00005555557c31d7 in Rstd_CleanUp (saveact=<optimized out>, status=0, runLast=<optimized out>) at sys-std.c:1243
>>>>>>>> #3  0x00005555557c593d in R_CleanUp (saveact=saveact at entry=SA_NOSAVE, status=status at entry=0, runLast=<optimized out>) at system.c:87
>>>>>>>> #4  0x00005555556cc85e in do_quit (call=<optimized out>, op=<optimized out>, args=0x555557813f90, rho=<optimized out>) at main.c:1393
>>>>>>>>
>>>>>>>> -Bill
>>>>>>>>
>>>>>>>> On Mon, Nov 23, 2020 at 3:15 AM Tomas Kalibera <tomas.kalibera at gmail.com> wrote:
>>>>>>>>> On 11/21/20 6:51 PM, Jan Gorecki wrote:
>>>>>>>>>> Dear R-developers,
>>>>>>>>>>
>>>>>>>>>> Some of the more fat scripts (50+ GB mem used by R) that I am running,
>>>>>>>>>> when they finish they do quit with q("no", status=0)
>>>>>>>>>> Quite often it happens that there is an extra stderr output produced
>>>>>>>>>> at the very end which looks like this:
>>>>>>>>>>
>>>>>>>>>> Warning message:
>>>>>>>>>> In .Internal(quit(save, status, runLast)) :
>>>>>>>>>>     system call failed: Cannot allocate memory
>>>>>>>>>>
>>>>>>>>>> Is there any way to avoid this kind of warnings? I am using stderr
>>>>>>>>>> output for detecting failures in scripts and this warning is a false
>>>>>>>>>> positive of a failure.
>>>>>>>>>>
>>>>>>>>>> Maybe quit function could wait little bit longer trying to allocate
>>>>>>>>>> before it raises this warning?
>>>>>>>>> If you see this warning, some call to system() or system2() or similar,
>>>>>>>>> which executes an external program, failed to even run a shell to run
>>>>>>>>> that external program, because there was not enough memory. You should
>>>>>>>>> be able to find out where it happens by checking the exit status of
>>>>>>>>> system().
>>>>>>>>>
>>>>>>>>> Tomas
>>>>>>>>>
>>>>>>>>>
>>>>>>>>>> Best regards,
>>>>>>>>>> Jan Gorecki
>>>>>>>>>>
>>>>>>>>>> ______________________________________________
>>>>>>>>>> R-devel at r-project.org mailing list
>>>>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>>>> ______________________________________________
>>>>>>>>> R-devel at r-project.org mailing list
>>>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>
>>>>>>
>>>>>
>>>>> ______________________________________________
>>>>> R-devel at r-project.org mailing list
>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>
>>>>
>>>> --
>>>> Luke Tierney
>>>> Ralph E. Wareham Professor of Mathematical Sciences
>>>> University of Iowa                  Phone:             319-335-3386
>>>> Department of Statistics and        Fax:               319-335-3017
>>>>     Actuarial Science
>>>> 241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
>>>> Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu
>>>
>>
>> --
>> Luke Tierney
>> Ralph E. Wareham Professor of Mathematical Sciences
>> University of Iowa                  Phone:             319-335-3386
>> Department of Statistics and        Fax:               319-335-3017
>>     Actuarial Science
>> 241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
>> Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu
>

-- 
Luke Tierney
Ralph E. Wareham Professor of Mathematical Sciences
University of Iowa                  Phone:             319-335-3386
Department of Statistics and        Fax:               319-335-3017
    Actuarial Science
241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu


From j@goreck| @end|ng |rom w|t@edu@p|  Tue Dec  1 18:22:54 2020
From: j@goreck| @end|ng |rom w|t@edu@p| (Jan Gorecki)
Date: Tue, 1 Dec 2020 19:22:54 +0200
Subject: [Rd] [External] Re: .Internal(quit(...)): system call failed:
 Cannot allocate memory
In-Reply-To: <alpine.DEB.2.21.2012011049490.3003@luke-Latitude-7480>
References: <CAOO9MKUhAxhv_UAtBKBebN+zCQW+JVTuRHhzohdaUZ=tZYkWAg@mail.gmail.com>
 <2b09f5dd-0217-bd98-d427-38c6fa374d41@gmail.com>
 <CAHqSRuRPbuyq0T_Oh7XfbH6Ls_gOA6ifinAhG9D-vXn3DU2sHw@mail.gmail.com>
 <CAOO9MKWTUTXZeg2GG0v6OedG4zRPC0ospNvgb10h-9FeOJ0HYw@mail.gmail.com>
 <cf311324-cc24-4ccc-c4df-b0fcc152cd86@gmail.com>
 <CAOO9MKWXVEv+LX_CdpA+WOP52zhPH30U23ZaZb8LLNncT1aYeg@mail.gmail.com>
 <alpine.DEB.2.21.2011251432380.3003@luke-Latitude-7480>
 <CAOO9MKWk3qdghJ0KJx0KemXdFEGr7QzzjHZHguWFzfSKYwFYPA@mail.gmail.com>
 <alpine.DEB.2.21.2011271410260.3003@luke-Latitude-7480>
 <CAOO9MKXujYPcJb2GBpnHqHZN6qwQPPgunoE2qh9GqQzRxCxSgw@mail.gmail.com>
 <alpine.DEB.2.21.2012011049490.3003@luke-Latitude-7480>
Message-ID: <CAOO9MKVOdO=KWhH87QPoEvNQvUhtUi2syXPZJbWMpQTzLnRwiQ@mail.gmail.com>

Yes, I do set outside of R, in shell:
R_MAX_VSIZE=100Gb SRC_DATANAME=G1_1e9_2e0_0_0 /usr/bin/time -v Rscript
datatable/groupby-datatable.R

I think it might be related to allocations made with malloc rather than R_alloc.
Probably malloc allocation is not capped by setting this env var.
If so, then I have to limit memory on OS/shell level. As you mentioned before.

Best

On Tue, Dec 1, 2020 at 6:54 PM <luke-tierney at uiowa.edu> wrote:
>
> The fact that your max resident size isn't affected looks odd.  Are
> you setting the environment variable outside R? When I run
>
>      env R_MAX_VSIZE=16Gb /usr/bin/time bin/Rscript jg.R 1e9 2e0 0 0
>
> (your code in jg.R). I get a quick failure with 11785524maxresident)k
>
> Best,
>
> luke
>
> On Tue, 1 Dec 2020, Jan Gorecki wrote:
>
> > Thank you Luke,
> >
> > I tried your suggestion about R_MAX_VSIZE but I am not able to get the
> > error you are getting.
> > I tried recent R devel as I have seen you made a change to GC there.
> > My machine is 128GB, free -h reports 125GB available. I tried to set
> > 128, 125 and 100. In all cases the result is "Command terminated by
> > signal 9". Each took around 6-6.5h.
> > Details below, if it tells you anything how could I optimize it (or
> > raise an exception early) please do let me know.
> >
> > R 4.0.3
> >
> > unset R_MAX_VSIZE
> >        User time (seconds): 40447.92
> >        System time (seconds): 4034.37
> >        Percent of CPU this job got: 201%
> >        Elapsed (wall clock) time (h:mm:ss or m:ss): 6:07:59
> >        Maximum resident set size (kbytes): 127261184
> >        Major (requiring I/O) page faults: 72441
> >        Minor (reclaiming a frame) page faults: 3315491751
> >        Voluntary context switches: 381446
> >        Involuntary context switches: 529554
> >        File system inputs: 108339200
> >        File system outputs: 120
> >
> > R-devel 2020-11-27 r79522
> >
> > unset R_MAX_VSIZE
> >        User time (seconds): 40713.52
> >        System time (seconds): 4039.52
> >        Percent of CPU this job got: 198%
> >        Elapsed (wall clock) time (h:mm:ss or m:ss): 6:15:52
> >        Maximum resident set size (kbytes): 127254796
> >        Major (requiring I/O) page faults: 72810
> >        Minor (reclaiming a frame) page faults: 3433589848
> >        Voluntary context switches: 384363
> >        Involuntary context switches: 609024
> >        File system inputs: 108467064
> >        File system outputs: 112
> >
> > R_MAX_VSIZE=128Gb
> >        User time (seconds): 40411.13
> >        System time (seconds): 4227.99
> >        Percent of CPU this job got: 198%
> >        Elapsed (wall clock) time (h:mm:ss or m:ss): 6:14:01
> >        Maximum resident set size (kbytes): 127249316
> >        Major (requiring I/O) page faults: 88500
> >        Minor (reclaiming a frame) page faults: 3544520527
> >        Voluntary context switches: 384117
> >        Involuntary context switches: 545397
> >        File system inputs: 111675896
> >        File system outputs: 120
> >
> > R_MAX_VSIZE=125Gb
> >        User time (seconds): 40246.83
> >        System time (seconds): 4042.76
> >        Percent of CPU this job got: 201%
> >        Elapsed (wall clock) time (h:mm:ss or m:ss): 6:06:56
> >        Maximum resident set size (kbytes): 127254200
> >        Major (requiring I/O) page faults: 63867
> >        Minor (reclaiming a frame) page faults: 3449493803
> >        Voluntary context switches: 370753
> >        Involuntary context switches: 614607
> >        File system inputs: 106322880
> >        File system outputs: 112
> >
> > R_MAX_VSIZE=100Gb
> >        User time (seconds): 41837.10
> >        System time (seconds): 3979.57
> >        Percent of CPU this job got: 192%
> >        Elapsed (wall clock) time (h:mm:ss or m:ss): 6:36:34
> >        Maximum resident set size (kbytes): 127256940
> >        Major (requiring I/O) page faults: 66829
> >        Minor (reclaiming a frame) page faults: 3357778594
> >        Voluntary context switches: 391149
> >        Involuntary context switches: 646410
> >        File system inputs: 106605648
> >        File system outputs: 120
> >
> > On Fri, Nov 27, 2020 at 10:18 PM <luke-tierney at uiowa.edu> wrote:
> >>
> >> On Thu, 26 Nov 2020, Jan Gorecki wrote:
> >>
> >>> Thank you Luke for looking into it. Your knowledge of gc is definitely
> >>> helpful here. I put comments inline below.
> >>>
> >>> Best,
> >>> Jan
> >>>
> >>> On Wed, Nov 25, 2020 at 10:38 PM <luke-tierney at uiowa.edu> wrote:
> >>>>
> >>>> On Tue, 24 Nov 2020, Jan Gorecki wrote:
> >>>>
> >>>>> As for other calls to system. I avoid calling system. In the past I
> >>>>> had some (to get memory stats from OS), but they were failing with
> >>>>> exactly the same issue. So yes, if I would add call to system before
> >>>>> calling quit, I believe it would fail with the same error.
> >>>>> At the same time I think (although I am not sure) that new allocations
> >>>>> made in R are working fine. So R seems to reserve some memory and can
> >>>>> continue to operate, while external call like system will fail. Maybe
> >>>>> it is like this by design, don't know.
> >>>>
> >>>> Thanks for the report on quit(). We're exploring how to make the
> >>>> cleanup on exit more robust to low memory situations like these.
> >>>>
> >>>>>
> >>>>> Aside from this problem that is easy to report due to the warning
> >>>>> message, I think that gc() is choking at the same time. I tried to
> >>>>> make reproducible example for that, multiple times but couldn't, let
> >>>>> me try one more time.
> >>>>> It happens to manifest when there is 4e8+ unique characters/factors in
> >>>>> an R session. I am able to reproduce it using data.table and dplyr
> >>>>> (0.8.4 because 1.0.0+ fails even sooner), but using base R is not easy
> >>>>> because of the size. I described briefly problem in:
> >>>>> https://github.com/h2oai/db-benchmark/issues/110
> >>>>
> >>>> Because of the design of R's character vectors, with each element
> >>>> allocated separately, R is never going to be great at handling huge
> >>>> numbers of distinct strings. But it can do an adequate job given
> >>>> enough memory to work with.
> >>>>
> >>>> When I run your GitHub issue example on a machine with around 500 Gb
> >>>> of RAM it seems to run OK; /usr/bin/time reports
> >>>>
> >>>> 2706.89user 161.89system 37:10.65elapsed 128%CPU (0avgtext+0avgdata 92180796maxresident)k
> >>>> 0inputs+103450552outputs (0major+38716351minor)pagefaults 0swaps
> >>>>
> >>>> So the memory footprint is quite large. Using gc.time() it looks like
> >>>> about 1/3 of the time is in GC. Not ideal, and maybe could be improved
> >>>> on a bit, but probably not by much. The GC is basically doing an
> >>>> adequate job, given enough RAM.
> >>>
> >>> Agree, 1/3 is a lot but still acceptable. So this strictly is not
> >>> something that requires intervention.
> >>> PS. I wasn't aware of gc.time(), it may be worth linking it from
> >>> SeeAlso in gc() manual.
> >>>
> >>>>
> >>>> If you run this example on a system without enough RAM, or with other
> >>>> programs competing for RAM, you are likely to end up fighting with
> >>>> your OS/hardware's virtual memory system. When I try to run it on a
> >>>> 16Gb system it churns for an hour or so before getting killed, and
> >>>> /usr/bin/time reports a huge number of page faults:
> >>>>
> >>>> 312523816inputs+0outputs (24761285major+25762068minor)pagefaults 0swaps
> >>>>
> >>>> You are probably experiencing something similar.
> >>>
> >>> Yes, this is exactly what I am experiencing.
> >>> The machine is a bare metal machine of 128GB mem, csv size 50GB,
> >>> data.frame size 74GB.
> >>> In my case it churns for ~3h before it gets killed with SIGINT from
> >>> the parent R process which uses 3h as a timeout for this script.
> >>> This is something I would like to be addressed because gc time is far
> >>> bigger than actual computation time. This is not really acceptable, I
> >>> would prefer to raise an exception instead.
> >>>
> >>>>
> >>>> There may be opportunities for more tuning of the GC to better handle
> >>>> running this close to memory limits, but I doubt the payoff would be
> >>>> worth the effort.
> >>>
> >>> If you don't have plans/time to work on that anytime soon, then I can
> >>> fill bugzilla for this problem so it won't get lost in the mailing
> >>> list.
> >>
> >> I'm not convinced anything useful can be done that would work well for
> >> your application without working badly for others.
> >>
> >> If you want to drive this close to your memory limits you are probably
> >> going to have to take responsibility for some tuning at your end. One
> >> option in ?Memory you might try is the R_MAX_VSIZE environment
> >> variable. On my 16Gb machine with R_MAX_VSIZE=16Gb your example fails
> >> very quickly with
> >>
> >> Error: vector memory exhausted (limit reached?)
> >>
> >> rather than churning for an hour trying to make things work. Setting
> >> memory and/or virtual memory limits in your shell is another option.
> >>
> >> Best,
> >>
> >> luke
> >>
> >>>
> >>>
> >>>>
> >>>> Best,
> >>>>
> >>>> luke
> >>>>
> >>>>> It would help if gcinfo() could take FALSE/TRUE/2L where 2L will print
> >>>>> even more information about gc, like how much time the each gc()
> >>>>> process took, how many objects it has to check on each level.
> >>>>>
> >>>>> Best regards,
> >>>>> Jan
> >>>>>
> >>>>>
> >>>>>
> >>>>> On Tue, Nov 24, 2020 at 1:05 PM Tomas Kalibera <tomas.kalibera at gmail.com> wrote:
> >>>>>>
> >>>>>> On 11/24/20 11:27 AM, Jan Gorecki wrote:
> >>>>>>> Thanks Bill for checking that.
> >>>>>>> It was my impression that warnings are raised from some internal
> >>>>>>> system calls made when quitting R. At that point I don't have much
> >>>>>>> control over checking the return status of those.
> >>>>>>> Your suggestion looks good to me.
> >>>>>>>
> >>>>>>> Tomas, do you think this could help? could this be implemented?
> >>>>>>
> >>>>>> I think this is a good suggestion. Deleting files on Unix was changed
> >>>>>> from system("rm") to doing that in C, and deleting the session directory
> >>>>>> should follow.
> >>>>>>
> >>>>>> It might also help diagnosing your problem, but I don't think it would
> >>>>>> solve it. If the diagnostics in R works fine and the OS was so
> >>>>>> hopelessly out of memory that it couldn't run any more external
> >>>>>> processes, then really this is not a problem of R, but of having
> >>>>>> exhausted the resources. And it would be a coincidence that just this
> >>>>>> particular call to "system" at the end of the session did not work.
> >>>>>> Anything else could break as well close to the end of the script. This
> >>>>>> seems the most likely explanation to me.
> >>>>>>
> >>>>>> Do you get this warning repeatedly, reproducibly at least in slightly
> >>>>>> different scripts at the very end, with this warning always from quit()?
> >>>>>> So that the "call" part of the warning message has .Internal(quit) like
> >>>>>> in the case you posted? Would adding another call to "system" before the
> >>>>>> call to "q()" work - with checking the return value? If it is always
> >>>>>> only the last call to "system" in "q()", then it is suspicious, perhaps
> >>>>>> an indication that some diagnostics in R is not correct. In that case, a
> >>>>>> reproducible example would be the key - so either if you could diagnose
> >>>>>> on your end what is the problem, or create a reproducible example that
> >>>>>> someone else can use to reproduce and debug.
> >>>>>>
> >>>>>> Best
> >>>>>> Tomas
> >>>>>>
> >>>>>>>
> >>>>>>> On Mon, Nov 23, 2020 at 7:10 PM Bill Dunlap <williamwdunlap at gmail.com> wrote:
> >>>>>>>> The call to system() probably is an internal call used to delete the session's tempdir().  This sort of failure means that a potentially large amount of disk space is not being recovered when R is done.  Perhaps R_CleanTempDir() could call R_unlink() instead of having a subprocess call 'rm -rf ...'.  Then it could also issue a specific warning if it was impossible to delete all of tempdir().  (That should be very rare.)
> >>>>>>>>
> >>>>>>>>> q("no")
> >>>>>>>> Breakpoint 1, R_system (command=command at entry=0x7fffffffa1e0 "rm -Rf /tmp/RtmppoKPXb") at sysutils.c:311
> >>>>>>>> 311     {
> >>>>>>>> (gdb) where
> >>>>>>>> #0  R_system (command=command at entry=0x7fffffffa1e0 "rm -Rf /tmp/RtmppoKPXb") at sysutils.c:311
> >>>>>>>> #1  0x00005555557c30ec in R_CleanTempDir () at sys-std.c:1178
> >>>>>>>> #2  0x00005555557c31d7 in Rstd_CleanUp (saveact=<optimized out>, status=0, runLast=<optimized out>) at sys-std.c:1243
> >>>>>>>> #3  0x00005555557c593d in R_CleanUp (saveact=saveact at entry=SA_NOSAVE, status=status at entry=0, runLast=<optimized out>) at system.c:87
> >>>>>>>> #4  0x00005555556cc85e in do_quit (call=<optimized out>, op=<optimized out>, args=0x555557813f90, rho=<optimized out>) at main.c:1393
> >>>>>>>>
> >>>>>>>> -Bill
> >>>>>>>>
> >>>>>>>> On Mon, Nov 23, 2020 at 3:15 AM Tomas Kalibera <tomas.kalibera at gmail.com> wrote:
> >>>>>>>>> On 11/21/20 6:51 PM, Jan Gorecki wrote:
> >>>>>>>>>> Dear R-developers,
> >>>>>>>>>>
> >>>>>>>>>> Some of the more fat scripts (50+ GB mem used by R) that I am running,
> >>>>>>>>>> when they finish they do quit with q("no", status=0)
> >>>>>>>>>> Quite often it happens that there is an extra stderr output produced
> >>>>>>>>>> at the very end which looks like this:
> >>>>>>>>>>
> >>>>>>>>>> Warning message:
> >>>>>>>>>> In .Internal(quit(save, status, runLast)) :
> >>>>>>>>>>     system call failed: Cannot allocate memory
> >>>>>>>>>>
> >>>>>>>>>> Is there any way to avoid this kind of warnings? I am using stderr
> >>>>>>>>>> output for detecting failures in scripts and this warning is a false
> >>>>>>>>>> positive of a failure.
> >>>>>>>>>>
> >>>>>>>>>> Maybe quit function could wait little bit longer trying to allocate
> >>>>>>>>>> before it raises this warning?
> >>>>>>>>> If you see this warning, some call to system() or system2() or similar,
> >>>>>>>>> which executes an external program, failed to even run a shell to run
> >>>>>>>>> that external program, because there was not enough memory. You should
> >>>>>>>>> be able to find out where it happens by checking the exit status of
> >>>>>>>>> system().
> >>>>>>>>>
> >>>>>>>>> Tomas
> >>>>>>>>>
> >>>>>>>>>
> >>>>>>>>>> Best regards,
> >>>>>>>>>> Jan Gorecki
> >>>>>>>>>>
> >>>>>>>>>> ______________________________________________
> >>>>>>>>>> R-devel at r-project.org mailing list
> >>>>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>>>>>>>> ______________________________________________
> >>>>>>>>> R-devel at r-project.org mailing list
> >>>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>>>>>
> >>>>>>
> >>>>>
> >>>>> ______________________________________________
> >>>>> R-devel at r-project.org mailing list
> >>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>>>>
> >>>>
> >>>> --
> >>>> Luke Tierney
> >>>> Ralph E. Wareham Professor of Mathematical Sciences
> >>>> University of Iowa                  Phone:             319-335-3386
> >>>> Department of Statistics and        Fax:               319-335-3017
> >>>>     Actuarial Science
> >>>> 241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
> >>>> Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu
> >>>
> >>
> >> --
> >> Luke Tierney
> >> Ralph E. Wareham Professor of Mathematical Sciences
> >> University of Iowa                  Phone:             319-335-3386
> >> Department of Statistics and        Fax:               319-335-3017
> >>     Actuarial Science
> >> 241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
> >> Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu
> >
>
> --
> Luke Tierney
> Ralph E. Wareham Professor of Mathematical Sciences
> University of Iowa                  Phone:             319-335-3386
> Department of Statistics and        Fax:               319-335-3017
>     Actuarial Science
> 241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
> Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu


From b@becker @end|ng |rom |qb@hu-ber||n@de  Tue Dec  1 18:42:46 2020
From: b@becker @end|ng |rom |qb@hu-ber||n@de (Benjamin Becker)
Date: Tue, 1 Dec 2020 18:42:46 +0100
Subject: [Rd] order() and sort() on single row data.frames
Message-ID: <036bf6f5-477c-84e2-db0e-9e3349255229@iqb.hu-berlin.de>

Hi,

not sure whether this belongs here or has been reported/asked before.

In the current R devel the behavior of order() and sort() on data.frames 
with a single row has changed.

Before (release):

 > sort(data.frame("b", "a"))
 ? X.a. X.b.
1??? a??? b

Now (devel):

 > sort(data.frame("b", "a"))
 ? X.b.
1??? b

I did not find any specific documentation in the daily news log on this.

Thanks,
Benjamin


From Kurt@Horn|k @end|ng |rom wu@@c@@t  Tue Dec  1 19:16:34 2020
From: Kurt@Horn|k @end|ng |rom wu@@c@@t (Kurt Hornik)
Date: Tue, 1 Dec 2020 19:16:34 +0100
Subject: [Rd] order() and sort() on single row data.frames
In-Reply-To: <036bf6f5-477c-84e2-db0e-9e3349255229@iqb.hu-berlin.de>
References: <036bf6f5-477c-84e2-db0e-9e3349255229@iqb.hu-berlin.de>
Message-ID: <24518.34946.577900.599828@hornik.net>

>>>>> Benjamin Becker writes:

> Hi,
> not sure whether this belongs here or has been reported/asked before.

> In the current R devel the behavior of order() and sort() on data.frames 
> with a single row has changed.

> Before (release):

>> sort(data.frame("b", "a"))
>  ? X.a. X.b.
> 1??? a??? b

> Now (devel):

>> sort(data.frame("b", "a"))
>  ? X.b.
> 1??? b

> I did not find any specific documentation in the daily news log on
> this.

Work in progress.  Likely this will become an error: ? sort clearly says
it does not work on data frames.

Best
-k

> Thanks,
> Benjamin

> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From c@@rd|@g@bor @end|ng |rom gm@||@com  Wed Dec  2 00:48:37 2020
From: c@@rd|@g@bor @end|ng |rom gm@||@com (=?UTF-8?B?R8OhYm9yIENzw6FyZGk=?=)
Date: Tue, 1 Dec 2020 23:48:37 +0000
Subject: [Rd] translation domain is wrong in stopifnot()?
Message-ID: <CABtg=KmgYOiapjccOVrF-qHSsUYzOtu5RAfiaMrbBidmMmhbwg@mail.gmail.com>

I don't know if this would be considered a bug in either stopifnot()
or (n)gettext(), or not a bug at all, but sometimes the translation
domain is not set properly for stopifnot() messages, so they won't be
translated. E.g.

Sys.setenv(LANGUAGE = "de")

# This is good
stopifnot(FALSE)
#> Fehler: FALSE ist nicht TRUE

f <- function() stopifnot(FALSE)
# This is not
f()
#> Fehler in f() : FALSE is not TRUE

Gabor


From @purd|e@@ @end|ng |rom gm@||@com  Wed Dec  2 02:33:38 2020
From: @purd|e@@ @end|ng |rom gm@||@com (Abby Spurdle)
Date: Wed, 2 Dec 2020 14:33:38 +1300
Subject: [Rd] all.equal applied to function closures
In-Reply-To: <24518.3448.1707.699927@stat.math.ethz.ch>
References: <B43EED2F-F34F-436E-9822-AFB2A1C954DF@adobe.com>
 <8142836e-d8d5-1faa-fbfe-265a9c6f22e9@gmail.com>
 <CAHqSRuR0CzvyB_CkC2mkxXrJ8XGvGugJDtct6VVOOhCdvU0C5Q@mail.gmail.com>
 <24518.3448.1707.699927@stat.math.ethz.ch>
Message-ID: <CAB8pepydy=MTv7tsYcUs67Zm0rLyYYORYBM9P5GJuuHL-BTFBw@mail.gmail.com>

> Bill, I'm sure you've noticed that we did write  all.equal.environment()
> to work recursively... Actually, I had worked quite a bit at
> that, too long ago to remember details, but the relevant svn log
> entry is
> ------------------------------------------------------------------------
> r66640 | maechler | 2014-09-18 22:10:20 +0200 (Thu, 18 Sep 2014) | 1 line
>
> more sophisticated all.equal.environment(): no longer "simple" infinite recursions
> ------------------------------------------------------------------------

I haven't checked the above reference.
But I would like to note the following behaviour:

    #e group
    e = new.env ()
    e1 = new.env ()
    e$e = e1
    e1$e = e

    #f group
    f = new.env ()
    f1 = new.env ()
    f2 = new.env ()
    f$e = f1
    f1$e = f2
    f2$e = f

    all.equal (e, f)

I tried a number of examples with circular references.
All worked correctly, except for "identical" environments nested an
unequal number of times.

I suspect there may be other special cases.


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Wed Dec  2 09:45:27 2020
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Wed, 2 Dec 2020 09:45:27 +0100
Subject: [Rd] undocumented 'offset' argument in
 src/library/grDevices/man/adjustcolor.Rd
In-Reply-To: <70078b99-0c2e-d456-a2e5-088c3a2cd49f@gmail.com>
References: <70078b99-0c2e-d456-a2e5-088c3a2cd49f@gmail.com>
Message-ID: <24519.21543.662505.904535@stat.math.ethz.ch>

>>>>> Ben Bolker 
>>>>>     on Mon, 30 Nov 2020 16:33:23 -0500 writes:

    > The 'offset' argument description is blank ...
    > maybe 'additive adjustment to each of the (red, green, blue, alpha) 
    > values defining the colors, after adjustment by the corresponding 
    > \code{.f} factor' ...?

Thank you, Ben.   I'm using adjustcolor() very often, and I had
also wondered about the documentation "FIXME" there.

As I've not been a real expert in color space transformations, I
hadn't dared to describe it myself,  but your description above
is clearly better than the emptyness ...

Maybe someone can add something, or contribute some example(s)
on how using offset != 0  makes sense ?

    > This is the relevant code:

>      x <- col2rgb(col, alpha = TRUE)/255
>      x[] <- pmax(0, pmin(1,
>                          transform %*% x +
>                          matrix(offset, nrow = 4L, ncol = ncol(x))))
>      rgb(x[1L,], x[2L,], x[3L,], x[4L,])


From wo||@ch|@eger @end|ng |rom un|-m@|nz@de  Wed Dec  2 11:56:36 2020
From: wo||@ch|@eger @end|ng |rom un|-m@|nz@de (Wollschlaeger, Daniel)
Date: Wed, 2 Dec 2020 10:56:36 +0000
Subject: [Rd] undocumented 'offset' argument in
 src/library/grDevices/man/adjustcolor.Rd
In-Reply-To: <24519.21543.662505.904535@stat.math.ethz.ch>
References: <70078b99-0c2e-d456-a2e5-088c3a2cd49f@gmail.com>,
 <24519.21543.662505.904535@stat.math.ethz.ch>
Message-ID: <a1c8d04b3c1e47f7971eefae5ca271e2@uni-mainz.de>

One might say that adjustcolor() performs affine color transformation. Argument 'offset' defines the shift in color space after the linear transformation defined by argument 'transform'. In other words, 'offset' represents additive color mixing (in the sense of adding lights, not paints) after linear transformation.

> red <- rgb(1, 0, 0)
> green <- c(0, 0.9, 0, 1)
> adjustcolor(red, 1, 0.9, 0.9, 0.9, offset=green)
[1] "#E6E600FF"

("red + green = yellow")

However, the implementation of adjustcolor() is a bit inconsistent with this description as it does not force 'offset' to be a color by using col2rgb(offset, alpha=TRUE)/255. The help page already gives an example for using 'offset' for the purpose of adding white light.
________________________________________
Von: R-devel <r-devel-bounces at r-project.org> im Auftrag von Martin Maechler <maechler at stat.math.ethz.ch>
Gesendet: Mittwoch, 2. Dezember 2020 09:45:27
An: Ben Bolker
Cc: r-devel at r-project.org
Betreff: Re: [Rd] undocumented 'offset' argument in src/library/grDevices/man/adjustcolor.Rd

>>>>> Ben Bolker
>>>>>     on Mon, 30 Nov 2020 16:33:23 -0500 writes:

    > The 'offset' argument description is blank ...
    > maybe 'additive adjustment to each of the (red, green, blue, alpha)
    > values defining the colors, after adjustment by the corresponding
    > \code{.f} factor' ...?

Thank you, Ben.   I'm using adjustcolor() very often, and I had
also wondered about the documentation "FIXME" there.

As I've not been a real expert in color space transformations, I
hadn't dared to describe it myself,  but your description above
is clearly better than the emptyness ...

Maybe someone can add something, or contribute some example(s)
on how using offset != 0  makes sense ?

    > This is the relevant code:

>      x <- col2rgb(col, alpha = TRUE)/255
>      x[] <- pmax(0, pmin(1,
>                          transform %*% x +
>                          matrix(offset, nrow = 4L, ncol = ncol(x))))
>      rgb(x[1L,], x[2L,], x[3L,], x[4L,])

______________________________________________
R-devel at r-project.org mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Wed Dec  2 13:09:20 2020
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Wed, 2 Dec 2020 13:09:20 +0100
Subject: [Rd] translation domain is wrong in stopifnot()?
In-Reply-To: <CABtg=KmgYOiapjccOVrF-qHSsUYzOtu5RAfiaMrbBidmMmhbwg@mail.gmail.com>
References: <CABtg=KmgYOiapjccOVrF-qHSsUYzOtu5RAfiaMrbBidmMmhbwg@mail.gmail.com>
Message-ID: <24519.33776.873538.855659@stat.math.ethz.ch>

>>>>> G?bor Cs?rdi 
>>>>>     on Tue, 1 Dec 2020 23:48:37 +0000 writes:

    > I don't know if this would be considered a bug in either stopifnot()
    > or (n)gettext(), or not a bug at all, but sometimes the translation
    > domain is not set properly for stopifnot() messages, so they won't be
    > translated. E.g.

    > Sys.setenv(LANGUAGE = "de")

    > # This is good
    > stopifnot(FALSE)
    > #> Fehler: FALSE ist nicht TRUE

    > f <- function() stopifnot(FALSE)
    > # This is not
    > f()
    > #> Fehler in f() : FALSE is not TRUE

    > Gabor

or even just directly :

  > (function() stopifnot(1))()
  Fehler in (function() stopifnot(1))() : 1 is not TRUE


I agree there is a bug.

The problem is that the default for the optional 'domain'
argument does not "work" correctly in the 2nd case.

I've checked that this can be worked around if I explicitly add

  , domain = "R-base"

to the ngettext() call   [ and also the gettext() call above ] .
Then I do get

  > (function() stopifnot(1))()
  Fehler in (function() stopifnot(1))() : 1 ist nicht TRUE
  > 

For now I'd claim the bug is in the underlying C code of
gettext() , ngettext() ...

It would we good to report this in R's bugzilla, please,
see https://www.r-project.org/bugs.html

Martin


From c@@rd|@g@bor @end|ng |rom gm@||@com  Wed Dec  2 19:53:56 2020
From: c@@rd|@g@bor @end|ng |rom gm@||@com (=?UTF-8?B?R8OhYm9yIENzw6FyZGk=?=)
Date: Wed, 2 Dec 2020 18:53:56 +0000
Subject: [Rd] translation domain is wrong in stopifnot()?
In-Reply-To: <24519.33776.873538.855659@stat.math.ethz.ch>
References: <CABtg=KmgYOiapjccOVrF-qHSsUYzOtu5RAfiaMrbBidmMmhbwg@mail.gmail.com>
 <24519.33776.873538.855659@stat.math.ethz.ch>
Message-ID: <CABtg=KnszU3hWtAzFNENcgDexzm8sAu_4ArryPk+YqJwdghncw@mail.gmail.com>

Bug report: https://bugs.r-project.org/bugzilla/show_bug.cgi?id=17998

Gabor

On Wed, Dec 2, 2020 at 12:09 PM Martin Maechler
<maechler at stat.math.ethz.ch> wrote:
>
> >>>>> G?bor Cs?rdi
> >>>>>     on Tue, 1 Dec 2020 23:48:37 +0000 writes:
>
>     > I don't know if this would be considered a bug in either stopifnot()
>     > or (n)gettext(), or not a bug at all, but sometimes the translation
>     > domain is not set properly for stopifnot() messages, so they won't be
>     > translated. E.g.
>
>     > Sys.setenv(LANGUAGE = "de")
>
>     > # This is good
>     > stopifnot(FALSE)
>     > #> Fehler: FALSE ist nicht TRUE
>
>     > f <- function() stopifnot(FALSE)
>     > # This is not
>     > f()
>     > #> Fehler in f() : FALSE is not TRUE
>
>     > Gabor
>
> or even just directly :
>
>   > (function() stopifnot(1))()
>   Fehler in (function() stopifnot(1))() : 1 is not TRUE
>
>
> I agree there is a bug.
>
> The problem is that the default for the optional 'domain'
> argument does not "work" correctly in the 2nd case.
>
> I've checked that this can be worked around if I explicitly add
>
>   , domain = "R-base"
>
> to the ngettext() call   [ and also the gettext() call above ] .
> Then I do get
>
>   > (function() stopifnot(1))()
>   Fehler in (function() stopifnot(1))() : 1 ist nicht TRUE
>   >
>
> For now I'd claim the bug is in the underlying C code of
> gettext() , ngettext() ...
>
> It would we good to report this in R's bugzilla, please,
> see https://www.r-project.org/bugs.html
>
> Martin
>
>


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Thu Dec  3 18:29:58 2020
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Thu, 3 Dec 2020 18:29:58 +0100
Subject: [Rd] all.equal applied to function closures
In-Reply-To: <24518.3448.1707.699927@stat.math.ethz.ch>
References: <B43EED2F-F34F-436E-9822-AFB2A1C954DF@adobe.com>
 <8142836e-d8d5-1faa-fbfe-265a9c6f22e9@gmail.com>
 <CAHqSRuR0CzvyB_CkC2mkxXrJ8XGvGugJDtct6VVOOhCdvU0C5Q@mail.gmail.com>
 <24518.3448.1707.699927@stat.math.ethz.ch>
Message-ID: <24521.8342.495206.768977@stat.math.ethz.ch>

>>>>> Martin Maechler 
>>>>>     on Tue, 1 Dec 2020 10:31:36 +0100 writes:

>>>>> Bill Dunlap 
>>>>>     on Mon, 30 Nov 2020 13:41:54 -0800 writes:

    >> To make the comparison more complete,
    >> all.equal.environment could compare the parents of the
    >> target and current environments.  That would have to be
    >> recursive but could stop at the first 'top level
    >> environment' (the global, empty, or a package-related
    >> environment generally) and use identical there.  E.g.,

    >> > f1 <- function(x) (function(){ expx <- exp(x) ; function(y) y + expx})()
    >> > all.equal(f1(2), f1(3))
    >> [1] "Environments: Component ?expx?: Mean relative difference: 1.718282"
    >> 
    >> [2] "Environments: <parent.env> Component ?x?: Mean relative difference:
    >> 0.5"

    >> This is from the following, where I avoided putting the existing
    >> non-recursive all.equal.environment into the body of this one.

    [[.........]]

    > Thank you, Duncan and Bill (and Kevin for bringing up the
    > topic).

    > I agree  all.equal() should work better with functions,

    > and I think probably it would make sense to define  all.equal.function()
    > rather than put this into all.equal.default()

    > However, it's not quite clear if it is always desirable to check the
    > environments as well notably as that *is* done recursively.

A small  "work in progress" update (because I've been advancing slowly only):

I'm currently testing 'make check-all' after

1) adding all.equal.function() method,
2) not changing  all.equal.environment() yet
3) but adapting all.equal.default() to give a deprecating warning
   when called with a function

all.equal.function <- function(target, current, check.environments = TRUE, ...)
{
    msg <- all.equal.language(target, current, ...)
    if(check.environments) {
        ## pre-check identical(), for speed *and* against infinite recursion:
        ee <- identical(environment(target), environment(current), ignore.environment=FALSE)
        if(!ee)
            ee <- all.equal.environment(environment(target), environment(current), ...)
        if(isTRUE(msg))
            ee
        else
            c(msg, if(!isTRUE(ee)) ee)
    } else
        msg
}

It's amazing that this breaks our own checks in several places,
which I'm chasing slowly (being busy with teaching related
duties, etc).
I did have the correct gut feeling to have 'check.environments'
being an optional argument, because indeed there are cases (in
our own regression tests) where we now needed to change the
checks to use   check.environments=FALSE .

My plan is to finish the   all.equal.function()  functionality /
modify "base R" coded (or, for now, rather the testing code)
where needed, and then *commit* that to R-devel.

After that we should come back to improve or even re-write
all.equal.environment()  when needed.

Martin

    > Bill, I'm sure you've noticed that we did write  all.equal.environment()
    > to work recursively... Actually, I had worked quite a bit at
    > that, too long ago to remember details, but the relevant svn log
    > entry is
    > ------------------------------------------------------------------------
    > r66640 | maechler | 2014-09-18 22:10:20 +0200 (Thu, 18 Sep 2014) | 1 line

    > more sophisticated all.equal.environment(): no longer "simple" infinite recursions
    > ------------------------------------------------------------------------

    > Are you sure that code with the internal recursive do1()
    > function should/could not be amended where needed?

    > Martin

    >> On Mon, Nov 30, 2020 at 10:42 AM Duncan Murdoch <murdoch.duncan at gmail.com>
    >> wrote:
    >> 
    >> > On 30/11/2020 1:05 p.m., Kevin Van Horn via R-devel wrote:
    >> > > Consider the following code:
    >> > >
    >> > >      f <- function(x)function(y){x+y}
    >> > >      all.equal(f(5), f(0))
    >> > >
    >> > > This returns TRUE, when it should return FALSE; I think it?s hard to
    >> > make the case that f(5) and f(0) are ?approximately equal? in any
    >> > meaningful sense. Digging into the code for all.equal(), I see that
    >> > all.equal(f(5), f(0)) results in a call to all.equal.language(f(5), f(0)),
    >> > which only compares the function texts for equality.
    >> > >
    >> > > If it is decided to leave this behavior as-is, then at least it should
    >> > be documented. Currently I cannot find any documentation for all.equal
    >> > applied to functions.
    >> >
    >> > Clearly it should also compare the environments of the two functions,
    >> > then it would see a difference:
    >> >
    >> >  > all.equal(environment(f(5)), environment(f(0)))
    >> > [1] "Component ?x?: Mean relative difference: 1"
    >> >
    >> > Changing the first few lines from
    >> >
    >> >      if (is.language(target) || is.function(target))
    >> >          return(all.equal.language(target, current, ...))
    >> >
    >> > to
    >> >
    >> >      if (is.function(target)) {
    >> >          msg <- all.equal.language(target, current, ...)
    >> >          if (isTRUE(msg)) {
    >> >              msg <- all.equal.environment(environment(target),
    >> > environment(current), ...)
    >> >              if (is.character(msg))
    >> >                msg <- paste("Environments:", msg)
    >> >          }
    >> >          return(msg)
    >> >      }
    >> >      if (is.language(target))
    >> >          return(all.equal.language(target, current, ...))
    >> >
    >> > would fix it.
    >> >
    >> > Duncan Murdoch
    >> >
    >> > ______________________________________________
    >> > R-devel at r-project.org mailing list
    >> > https://stat.ethz.ch/mailman/listinfo/r-devel

    > ______________________________________________
    > R-devel at r-project.org mailing list
    > https://stat.ethz.ch/mailman/listinfo/r-devel


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Fri Dec  4 12:40:33 2020
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Fri, 4 Dec 2020 12:40:33 +0100
Subject: [Rd] all.equal() applied to function closures -- now committed
In-Reply-To: <24521.8342.495206.768977@stat.math.ethz.ch>
References: <B43EED2F-F34F-436E-9822-AFB2A1C954DF@adobe.com>
 <8142836e-d8d5-1faa-fbfe-265a9c6f22e9@gmail.com>
 <CAHqSRuR0CzvyB_CkC2mkxXrJ8XGvGugJDtct6VVOOhCdvU0C5Q@mail.gmail.com>
 <24518.3448.1707.699927@stat.math.ethz.ch>
 <24521.8342.495206.768977@stat.math.ethz.ch>
Message-ID: <24522.8241.97906.360207@stat.math.ethz.ch>

>>>>> Martin Maechler 
>>>>>     on Thu, 3 Dec 2020 18:29:58 +0100 writes:

>>>>> Martin Maechler 
>>>>>     on Tue, 1 Dec 2020 10:31:36 +0100 writes:

>>>>> Bill Dunlap 
>>>>>     on Mon, 30 Nov 2020 13:41:54 -0800 writes:

    >>> To make the comparison more complete,
    >>> all.equal.environment could compare the parents of the
    >>> target and current environments.  That would have to be
    >>> recursive but could stop at the first 'top level
    >>> environment' (the global, empty, or a package-related
    >>> environment generally) and use identical there.  E.g.,

    >>> > f1 <- function(x) (function(){ expx <- exp(x) ; function(y) y + expx})()
    >>> > all.equal(f1(2), f1(3))
    >>> [1] "Environments: Component ?expx?: Mean relative difference: 1.718282"
    >>> 
    >>> [2] "Environments: <parent.env> Component ?x?: Mean relative difference:
    >>> 0.5"

    >>> This is from the following, where I avoided putting the existing
    >>> non-recursive all.equal.environment into the body of this one.

    > [[.........]]

    >> Thank you, Duncan and Bill (and Kevin for bringing up the
    >> topic).

    >> I agree  all.equal() should work better with functions,

    >> and I think probably it would make sense to define  all.equal.function()
    >> rather than put this into all.equal.default()

    >> However, it's not quite clear if it is always desirable to check the
    >> environments as well notably as that *is* done recursively.

    > A small  "work in progress" update (because I've been advancing slowly only):

    > I'm currently testing 'make check-all' after

    > 1) adding all.equal.function() method,
    > 2) not changing  all.equal.environment() yet
    > 3) but adapting all.equal.default() to give a deprecating warning
    > when called with a function

    > all.equal.function <- function(target, current, check.environments = TRUE, ...)
    > {
    [........]
    > }

    > It's amazing that this breaks our own checks in several places,
    > which I'm chasing slowly (being busy with teaching related
    > duties, etc).
    > I did have the correct gut feeling to have 'check.environments'
    > being an optional argument, because indeed there are cases (in
    > our own regression tests) where we now needed to change the
    > checks to use   check.environments=FALSE .

    > My plan is to finish the   all.equal.function()  functionality /
    > modify "base R" coded (or, for now, rather the testing code)
    > where needed, and then *commit* that to R-devel.

I've done that now:
------------------------------------------------------------------------
r79555 | maechler | 2020-12-04 12:13:06 +0100 (Fri, 04 Dec 2020) | 1 line
Changed paths:
   M doc/NEWS.Rd
   M src/library/base/R/all.equal.R
   M src/library/base/R/zzz.R
   M src/library/base/man/all.equal.Rd
   M src/library/base/man/dput.Rd
   M src/library/stats/tests/nls.R
   M src/library/stats/tests/nls.Rout.save
   M tests/eval-etc-2.Rout.save
   M tests/eval-etc.Rout.save
   M tests/eval-fns.R
   M tests/reg-tests-1d.R

new all.equal.function() checks environment(.)
------------------------------------------------------------------------

Note the seven extra files needed to be changed

  src/library/base/man/dput.Rd
  src/library/stats/tests/nls.{R,Rout.save}
  tests/eval-{etc.Rout.save,fns.Rtests/eval-etc{,-2}.Rout.save}

where in all cases I needed to add an explicit
', check.environments = FALSE' to an existing  stopifnot(all.equal(..))
check.

Consequently, I expect some  "carnage" in checks of existing  CRAN / BioC 
(and github, etc but that does not count) packages.

The NEWS entry (in 'NEW FEATURES') mentions an important case :

    ? all.equal(f, g) for functions now by default also compares their
      environment(.)s, notably via new all.equal method for class
      function.  Comparison of nls() fits, e.g., may now need
      all.equal(m1, m2, check.environments=FALSE).

So if you are a package maintainer observing that all.equal() --
or its corresponding 'testthat' obfuscation -- signals errors
"suddenly" (and only in R-devel), it's that you need to add
'check.environments=FALSE' there.

The good news is that this works also in existing (and previous)
versions of R :

  > all.equal(lm,lm, check.environments=FALSE)
  [1] TRUE
  > 

thanks to the "..."  _feature_ of typically just silently swallowing
everything that's not understood.  (yes: _feature_ is tongue in cheek).

Martin


    > After that we should come back to improve or even re-write
    > all.equal.environment()  when needed.


From murdoch@dunc@n @end|ng |rom gm@||@com  Fri Dec  4 12:50:39 2020
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Fri, 4 Dec 2020 06:50:39 -0500
Subject: [Rd] New pipe operator
Message-ID: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>

Just saw this on the R-devel news:


R now provides a simple native pipe syntax ?|>? as well as a shorthand 
notation for creating functions, e.g. ?\(x) x + 1? is parsed as 
?function(x) x + 1?. The pipe implementation as a syntax transformation 
was motivated by suggestions from Jim Hester and Lionel Henry. These 
features are experimental and may change prior to release.


This is a good addition; by using "|>" instead of "%>%" there should be 
a chance to get operator precedence right.  That said, the ?Syntax help 
topic hasn't been updated, so I'm not sure where it fits in.

There are some choices that take a little getting used to:

 > mtcars |> head
Error: The pipe operator requires a function call or an anonymous 
function expression as RHS

(I need to say mtcars |> head() instead.)  This sometimes leads to error 
messages that are somewhat confusing:

 > mtcars |> magrittr::debug_pipe |> head
Error: function '::' not supported in RHS call of a pipe

but

mtcars |> magrittr::debug_pipe() |> head()

works.

Overall, I think this is a great addition, though it's going to be 
disruptive for a while.

Duncan Murdoch


From yut@n|@|n| @end|ng |rom gm@||@com  Fri Dec  4 14:13:46 2020
From: yut@n|@|n| @end|ng |rom gm@||@com (Hiroaki Yutani)
Date: Fri, 4 Dec 2020 22:13:46 +0900
Subject: [Rd] New pipe operator
In-Reply-To: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
Message-ID: <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>

>  Error: function '::' not supported in RHS call of a pipe

To me, this error looks much more friendly than magrittr's error.
Some of them got too used to specify functions without (). This
is OK until they use `::`, but when they need to use it, it takes
hours to figure out why

mtcars %>% base::head
#> Error in .::base : unused argument (head)

won't work but

mtcars %>% head

works. I think this is a too harsh lesson for ordinary R users to
learn `::` is a function. I've been wanting for magrittr to drop the
support for a function name without () to avoid this confusion,
so I would very much welcome the new pipe operator's behavior.
Thank you all the developers who implemented this!

Best,
Hiroaki Yutani

2020?12?4?(?) 20:51 Duncan Murdoch <murdoch.duncan at gmail.com>:
>
> Just saw this on the R-devel news:
>
>
> R now provides a simple native pipe syntax ?|>? as well as a shorthand
> notation for creating functions, e.g. ?\(x) x + 1? is parsed as
> ?function(x) x + 1?. The pipe implementation as a syntax transformation
> was motivated by suggestions from Jim Hester and Lionel Henry. These
> features are experimental and may change prior to release.
>
>
> This is a good addition; by using "|>" instead of "%>%" there should be
> a chance to get operator precedence right.  That said, the ?Syntax help
> topic hasn't been updated, so I'm not sure where it fits in.
>
> There are some choices that take a little getting used to:
>
>  > mtcars |> head
> Error: The pipe operator requires a function call or an anonymous
> function expression as RHS
>
> (I need to say mtcars |> head() instead.)  This sometimes leads to error
> messages that are somewhat confusing:
>
>  > mtcars |> magrittr::debug_pipe |> head
> Error: function '::' not supported in RHS call of a pipe
>
> but
>
> mtcars |> magrittr::debug_pipe() |> head()
>
> works.
>
> Overall, I think this is a great addition, though it's going to be
> disruptive for a while.
>
> Duncan Murdoch
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From murdoch@dunc@n @end|ng |rom gm@||@com  Fri Dec  4 15:05:06 2020
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Fri, 4 Dec 2020 09:05:06 -0500
Subject: [Rd] New pipe operator
In-Reply-To: <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
Message-ID: <7586e034-e287-0970-6480-f82d747b5445@gmail.com>

On 04/12/2020 8:13 a.m., Hiroaki Yutani wrote:
>>   Error: function '::' not supported in RHS call of a pipe
> 
> To me, this error looks much more friendly than magrittr's error.
> Some of them got too used to specify functions without (). This
> is OK until they use `::`, but when they need to use it, it takes
> hours to figure out why
> 
> mtcars %>% base::head
> #> Error in .::base : unused argument (head)
> 
> won't work but
> 
> mtcars %>% head
> 
> works. I think this is a too harsh lesson for ordinary R users to
> learn `::` is a function. I've been wanting for magrittr to drop the
> support for a function name without () to avoid this confusion,
> so I would very much welcome the new pipe operator's behavior.
> Thank you all the developers who implemented this!

I agree, it's an improvement on the corresponding magrittr error.

I think the semantics of not evaluating the RHS, but treating the pipe 
as purely syntactical is a good decision.

I'm not sure I like the recommended way to pipe into a particular argument:

   mtcars |> subset(cyl == 4) |> \(d) lm(mpg ~ disp, data = d)

or

   mtcars |> subset(cyl == 4) |> function(d) lm(mpg ~ disp, data = d)

both of which are equivalent to

   mtcars |> subset(cyl == 4) |> (function(d) lm(mpg ~ disp, data = d))()

It's tempting to suggest it should allow something like

   mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)

which would be expanded to something equivalent to the other versions: 
but that makes it quite a bit more complicated.  (Maybe _ or \. should 
be used instead of ., since those are not legal variable names.)

I don't think there should be an attempt to copy magrittr's special 
casing of how . is used in determining whether to also include the 
previous value as first argument.

Duncan Murdoch


> 
> Best,
> Hiroaki Yutani
> 
> 2020?12?4?(?) 20:51 Duncan Murdoch <murdoch.duncan at gmail.com>:
>>
>> Just saw this on the R-devel news:
>>
>>
>> R now provides a simple native pipe syntax ?|>? as well as a shorthand
>> notation for creating functions, e.g. ?\(x) x + 1? is parsed as
>> ?function(x) x + 1?. The pipe implementation as a syntax transformation
>> was motivated by suggestions from Jim Hester and Lionel Henry. These
>> features are experimental and may change prior to release.
>>
>>
>> This is a good addition; by using "|>" instead of "%>%" there should be
>> a chance to get operator precedence right.  That said, the ?Syntax help
>> topic hasn't been updated, so I'm not sure where it fits in.
>>
>> There are some choices that take a little getting used to:
>>
>>   > mtcars |> head
>> Error: The pipe operator requires a function call or an anonymous
>> function expression as RHS
>>
>> (I need to say mtcars |> head() instead.)  This sometimes leads to error
>> messages that are somewhat confusing:
>>
>>   > mtcars |> magrittr::debug_pipe |> head
>> Error: function '::' not supported in RHS call of a pipe
>>
>> but
>>
>> mtcars |> magrittr::debug_pipe() |> head()
>>
>> works.
>>
>> Overall, I think this is a great addition, though it's going to be
>> disruptive for a while.
>>
>> Duncan Murdoch
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


From toth@dene@ @end|ng |rom kogentum@hu  Fri Dec  4 16:05:45 2020
From: toth@dene@ @end|ng |rom kogentum@hu (=?UTF-8?B?RMOpbmVzIFTDs3Ro?=)
Date: Fri, 4 Dec 2020 16:05:45 +0100
Subject: [Rd] New pipe operator
In-Reply-To: <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
Message-ID: <b98cf6d4-b856-2963-1882-9341384d141d@kogentum.hu>


On 12/4/20 3:05 PM, Duncan Murdoch wrote:
> ...
> 
> It's tempting to suggest it should allow something like
> 
>  ? mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
> 
> which would be expanded to something equivalent to the other versions: 
> but that makes it quite a bit more complicated.? (Maybe _ or \. should 
> be used instead of ., since those are not legal variable names.)

I support the idea of using an underscore (_) as the placeholder symbol. 
  Syntactic sugars work the the best if 1) they require less keystrokes 
and/or 2) are easier to read compared to the "normal" syntax, and 3) can 
not lead to unexpected bugs (which is a major problem with the magrittr 
pipe). Using '_' fulfills all of these criteria since '_' can not clash 
with any variable in the environment.

Denes


From @eb@meyer @end|ng |rom |@u@de  Fri Dec  4 17:22:35 2020
From: @eb@meyer @end|ng |rom |@u@de (Sebastian Meyer)
Date: Fri, 4 Dec 2020 17:22:35 +0100
Subject: [Rd] New pipe operator
In-Reply-To: <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
Message-ID: <a94e9286-9655-fa86-4be2-8e5f5b68002b@fau.de>

Am 04.12.20 um 15:05 schrieb Duncan Murdoch:
> On 04/12/2020 8:13 a.m., Hiroaki Yutani wrote:
>>> ? Error: function '::' not supported in RHS call of a pipe
>>
>> To me, this error looks much more friendly than magrittr's error.
>> Some of them got too used to specify functions without (). This
>> is OK until they use `::`, but when they need to use it, it takes
>> hours to figure out why
>>
>> mtcars %>% base::head
>> #> Error in .::base : unused argument (head)
>>
>> won't work but
>>
>> mtcars %>% head
>>
>> works. I think this is a too harsh lesson for ordinary R users to
>> learn `::` is a function. I've been wanting for magrittr to drop the
>> support for a function name without () to avoid this confusion,
>> so I would very much welcome the new pipe operator's behavior.
>> Thank you all the developers who implemented this!
> 
> I agree, it's an improvement on the corresponding magrittr error.


Thank you for this example. I agree but think that the new base R pipe
might trigger some initial confusion as well:

    mtcars |> function(x) dim(x)[1L]
    #> [1] 32

    mtcars |> nrow
    #> Error: The pipe operator requires a function call or an anonymous
function expression as RHS

The RHS evaluates to the same thing in both cases (bar attributes and
environments), but only the anonymous variant is supported. I admit that
I haven't used %>% before; maybe the above discrepancy is less
irritating for those who have. The error message is clear though!

That said, I think the code is very readable when piping explicitly into
an anonymous function and I also prefer

    mtcars |> nrow()

over mtcars |> nrow, because we are visibly calling something.

IMO, readability is lost when using the cryptic short-hand notation

    mtcars |> \(x) dim(x)[1L]

which really only saves 7 letters.


> I think the semantics of not evaluating the RHS, but treating the pipe
> as purely syntactical is a good decision.
> 
> I'm not sure I like the recommended way to pipe into a particular argument:
> 
> ? mtcars |> subset(cyl == 4) |> \(d) lm(mpg ~ disp, data = d)
> 
> or
> 
> ? mtcars |> subset(cyl == 4) |> function(d) lm(mpg ~ disp, data = d)
> 
> both of which are equivalent to
> 
> ? mtcars |> subset(cyl == 4) |> (function(d) lm(mpg ~ disp, data = d))()
> 
> It's tempting to suggest it should allow something like
> 
> ? mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
> 
> which would be expanded to something equivalent to the other versions:
> but that makes it quite a bit more complicated.? (Maybe _ or \. should
> be used instead of ., since those are not legal variable names.)


I guess "_" as a placeholder would be difficult to implement precisely
because it currently is a syntax error.

Best regards,

	Sebastian Meyer


> I don't think there should be an attempt to copy magrittr's special
> casing of how . is used in determining whether to also include the
> previous value as first argument.
> 
> Duncan Murdoch
> 
> 
>>
>> Best,
>> Hiroaki Yutani
>>
>> 2020?12?4?(?) 20:51 Duncan Murdoch <murdoch.duncan at gmail.com>:
>>>
>>> Just saw this on the R-devel news:
>>>
>>>
>>> R now provides a simple native pipe syntax ?|>? as well as a shorthand
>>> notation for creating functions, e.g. ?\(x) x + 1? is parsed as
>>> ?function(x) x + 1?. The pipe implementation as a syntax transformation
>>> was motivated by suggestions from Jim Hester and Lionel Henry. These
>>> features are experimental and may change prior to release.
>>>
>>>
>>> This is a good addition; by using "|>" instead of "%>%" there should be
>>> a chance to get operator precedence right.? That said, the ?Syntax help
>>> topic hasn't been updated, so I'm not sure where it fits in.
>>>
>>> There are some choices that take a little getting used to:
>>>
>>> ? > mtcars |> head
>>> Error: The pipe operator requires a function call or an anonymous
>>> function expression as RHS
>>>
>>> (I need to say mtcars |> head() instead.)? This sometimes leads to error
>>> messages that are somewhat confusing:
>>>
>>> ? > mtcars |> magrittr::debug_pipe |> head
>>> Error: function '::' not supported in RHS call of a pipe
>>>
>>> but
>>>
>>> mtcars |> magrittr::debug_pipe() |> head()
>>>
>>> works.
>>>
>>> Overall, I think this is a great addition, though it's going to be
>>> disruptive for a while.
>>>
>>> Duncan Murdoch
>>>
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From deep@y@n@@@rk@r @end|ng |rom gm@||@com  Fri Dec  4 18:06:16 2020
From: deep@y@n@@@rk@r @end|ng |rom gm@||@com (Deepayan Sarkar)
Date: Fri, 4 Dec 2020 22:36:16 +0530
Subject: [Rd] New pipe operator
In-Reply-To: <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
Message-ID: <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>

On Fri, Dec 4, 2020 at 7:35 PM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>
> On 04/12/2020 8:13 a.m., Hiroaki Yutani wrote:
> >>   Error: function '::' not supported in RHS call of a pipe
> >
> > To me, this error looks much more friendly than magrittr's error.
> > Some of them got too used to specify functions without (). This
> > is OK until they use `::`, but when they need to use it, it takes
> > hours to figure out why
> >
> > mtcars %>% base::head
> > #> Error in .::base : unused argument (head)
> >
> > won't work but
> >
> > mtcars %>% head
> >
> > works. I think this is a too harsh lesson for ordinary R users to
> > learn `::` is a function. I've been wanting for magrittr to drop the
> > support for a function name without () to avoid this confusion,
> > so I would very much welcome the new pipe operator's behavior.
> > Thank you all the developers who implemented this!
>
> I agree, it's an improvement on the corresponding magrittr error.
>
> I think the semantics of not evaluating the RHS, but treating the pipe
> as purely syntactical is a good decision.
>
> I'm not sure I like the recommended way to pipe into a particular argument:
>
>    mtcars |> subset(cyl == 4) |> \(d) lm(mpg ~ disp, data = d)
>
> or
>
>    mtcars |> subset(cyl == 4) |> function(d) lm(mpg ~ disp, data = d)
>
> both of which are equivalent to
>
>    mtcars |> subset(cyl == 4) |> (function(d) lm(mpg ~ disp, data = d))()
>
> It's tempting to suggest it should allow something like
>
>    mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)

Which is really not that far off from

mtcars |> subset(cyl == 4) |> \(.) lm(mpg ~ disp, data = .)

once you get used to it.

One consequence of the implementation is that it's not clear how
multiple occurrences of the placeholder would be interpreted. With
magrittr,

sort(runif(10)) %>% ecdf(.)(.)
## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0

This is probably what you would expect, if you expect it to work at all, and not

ecdf(sort(runif(10)))(sort(runif(10)))

There would be no such ambiguity with anonymous functions

sort(runif(10)) |> \(.) ecdf(.)(.)

-Deepayan

> which would be expanded to something equivalent to the other versions:
> but that makes it quite a bit more complicated.  (Maybe _ or \. should
> be used instead of ., since those are not legal variable names.)
>
> I don't think there should be an attempt to copy magrittr's special
> casing of how . is used in determining whether to also include the
> previous value as first argument.
>
> Duncan Murdoch
>
>
> >
> > Best,
> > Hiroaki Yutani
> >
> > 2020?12?4?(?) 20:51 Duncan Murdoch <murdoch.duncan at gmail.com>:
> >>
> >> Just saw this on the R-devel news:
> >>
> >>
> >> R now provides a simple native pipe syntax ?|>? as well as a shorthand
> >> notation for creating functions, e.g. ?\(x) x + 1? is parsed as
> >> ?function(x) x + 1?. The pipe implementation as a syntax transformation
> >> was motivated by suggestions from Jim Hester and Lionel Henry. These
> >> features are experimental and may change prior to release.
> >>
> >>
> >> This is a good addition; by using "|>" instead of "%>%" there should be
> >> a chance to get operator precedence right.  That said, the ?Syntax help
> >> topic hasn't been updated, so I'm not sure where it fits in.
> >>
> >> There are some choices that take a little getting used to:
> >>
> >>   > mtcars |> head
> >> Error: The pipe operator requires a function call or an anonymous
> >> function expression as RHS
> >>
> >> (I need to say mtcars |> head() instead.)  This sometimes leads to error
> >> messages that are somewhat confusing:
> >>
> >>   > mtcars |> magrittr::debug_pipe |> head
> >> Error: function '::' not supported in RHS call of a pipe
> >>
> >> but
> >>
> >> mtcars |> magrittr::debug_pipe() |> head()
> >>
> >> works.
> >>
> >> Overall, I think this is a great addition, though it's going to be
> >> disruptive for a while.
> >>
> >> Duncan Murdoch
> >>
> >> ______________________________________________
> >> R-devel at r-project.org mailing list
> >> https://stat.ethz.ch/mailman/listinfo/r-devel
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
> >
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From iuke-tier@ey m@iii@g oii uiow@@edu  Fri Dec  4 20:26:29 2020
From: iuke-tier@ey m@iii@g oii uiow@@edu (iuke-tier@ey m@iii@g oii uiow@@edu)
Date: Fri, 4 Dec 2020 13:26:29 -0600 (CST)
Subject: [Rd] [External] Re:  New pipe operator
In-Reply-To: <b98cf6d4-b856-2963-1882-9341384d141d@kogentum.hu>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <b98cf6d4-b856-2963-1882-9341384d141d@kogentum.hu>
Message-ID: <alpine.DEB.2.21.2012041310130.3003@luke-Latitude-7480>

On Fri, 4 Dec 2020, D?nes T?th wrote:

>
> On 12/4/20 3:05 PM, Duncan Murdoch wrote:
>> ...
>> 
>> It's tempting to suggest it should allow something like
>>
>>  ? mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
>> 
>> which would be expanded to something equivalent to the other versions: but 
>> that makes it quite a bit more complicated.? (Maybe _ or \. should be used 
>> instead of ., since those are not legal variable names.)
>
> I support the idea of using an underscore (_) as the placeholder symbol.

I strongly oppose adding a placeholder. Allowing for an optional
placeholder significantly complicates both implementing and explaining
the semantics. For a simple syntax transformation to be viable it
would also require some restrictions, such as only allowing a
placeholder as a top level argument and only once. Checking that these
restrictions are met, and accurately signaling when they are not with
reasonable error messages, is essentially an unsolvable problem given
R's semantics.

The case where the LHS is to be passed as something other than the
first argument is unusual. For me, having that case stand out by using
a function expression makes it much easier to see and so makes the
code easier to understand. As a wearer of progressive bifocals
and someone whose screen is not always free of small dust particles,
having to spot the non-standard pipe stages by seeing a placeholder,
especially a . placeholder, is be a bug, not a feature.

Best,

luke

> Syntactic sugars work the the best if 1) they require less keystrokes and/or 
> 2) are easier to read compared to the "normal" syntax, and 3) can not lead to 
> unexpected bugs (which is a major problem with the magrittr pipe). Using '_' 
> fulfills all of these criteria since '_' can not clash with any variable in 
> the environment.
>
> Denes
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

-- 
Luke Tierney
Ralph E. Wareham Professor of Mathematical Sciences
University of Iowa                  Phone:             319-335-3386
Department of Statistics and        Fax:               319-335-3017
    Actuarial Science
241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu

From murdoch@dunc@n @end|ng |rom gm@||@com  Sat Dec  5 02:01:53 2020
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Fri, 4 Dec 2020 20:01:53 -0500
Subject: [Rd] New pipe operator
In-Reply-To: <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
Message-ID: <8c623961-f502-6916-bc8f-eb0c164e1b42@gmail.com>

On 04/12/2020 12:06 p.m., Deepayan Sarkar wrote:
> On Fri, Dec 4, 2020 at 7:35 PM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>>
>> On 04/12/2020 8:13 a.m., Hiroaki Yutani wrote:
>>>>    Error: function '::' not supported in RHS call of a pipe
>>>
>>> To me, this error looks much more friendly than magrittr's error.
>>> Some of them got too used to specify functions without (). This
>>> is OK until they use `::`, but when they need to use it, it takes
>>> hours to figure out why
>>>
>>> mtcars %>% base::head
>>> #> Error in .::base : unused argument (head)
>>>
>>> won't work but
>>>
>>> mtcars %>% head
>>>
>>> works. I think this is a too harsh lesson for ordinary R users to
>>> learn `::` is a function. I've been wanting for magrittr to drop the
>>> support for a function name without () to avoid this confusion,
>>> so I would very much welcome the new pipe operator's behavior.
>>> Thank you all the developers who implemented this!
>>
>> I agree, it's an improvement on the corresponding magrittr error.
>>
>> I think the semantics of not evaluating the RHS, but treating the pipe
>> as purely syntactical is a good decision.
>>
>> I'm not sure I like the recommended way to pipe into a particular argument:
>>
>>     mtcars |> subset(cyl == 4) |> \(d) lm(mpg ~ disp, data = d)
>>
>> or
>>
>>     mtcars |> subset(cyl == 4) |> function(d) lm(mpg ~ disp, data = d)
>>
>> both of which are equivalent to
>>
>>     mtcars |> subset(cyl == 4) |> (function(d) lm(mpg ~ disp, data = d))()
>>
>> It's tempting to suggest it should allow something like
>>
>>     mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
> 
> Which is really not that far off from
> 
> mtcars |> subset(cyl == 4) |> \(.) lm(mpg ~ disp, data = .)
> 
> once you get used to it.
> 
> One consequence of the implementation is that it's not clear how
> multiple occurrences of the placeholder would be interpreted. With
> magrittr,
> 
> sort(runif(10)) %>% ecdf(.)(.)
> ## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
> 
> This is probably what you would expect, if you expect it to work at all, and not
> 
> ecdf(sort(runif(10)))(sort(runif(10)))

I didn't suggest that.  That would be a bad.  All I suggested was 
different sugar to write (function(d) ecdf(d)(d))().

Duncan Murdoch

> 
> There would be no such ambiguity with anonymous functions
> 
> sort(runif(10)) |> \(.) ecdf(.)(.)
> 
> -Deepayan
> 
>> which would be expanded to something equivalent to the other versions:
>> but that makes it quite a bit more complicated.  (Maybe _ or \. should
>> be used instead of ., since those are not legal variable names.)
>>
>> I don't think there should be an attempt to copy magrittr's special
>> casing of how . is used in determining whether to also include the
>> previous value as first argument.
>>
>> Duncan Murdoch
>>
>>
>>>
>>> Best,
>>> Hiroaki Yutani
>>>
>>> 2020?12?4?(?) 20:51 Duncan Murdoch <murdoch.duncan at gmail.com>:
>>>>
>>>> Just saw this on the R-devel news:
>>>>
>>>>
>>>> R now provides a simple native pipe syntax ?|>? as well as a shorthand
>>>> notation for creating functions, e.g. ?\(x) x + 1? is parsed as
>>>> ?function(x) x + 1?. The pipe implementation as a syntax transformation
>>>> was motivated by suggestions from Jim Hester and Lionel Henry. These
>>>> features are experimental and may change prior to release.
>>>>
>>>>
>>>> This is a good addition; by using "|>" instead of "%>%" there should be
>>>> a chance to get operator precedence right.  That said, the ?Syntax help
>>>> topic hasn't been updated, so I'm not sure where it fits in.
>>>>
>>>> There are some choices that take a little getting used to:
>>>>
>>>>    > mtcars |> head
>>>> Error: The pipe operator requires a function call or an anonymous
>>>> function expression as RHS
>>>>
>>>> (I need to say mtcars |> head() instead.)  This sometimes leads to error
>>>> messages that are somewhat confusing:
>>>>
>>>>    > mtcars |> magrittr::debug_pipe |> head
>>>> Error: function '::' not supported in RHS call of a pipe
>>>>
>>>> but
>>>>
>>>> mtcars |> magrittr::debug_pipe() |> head()
>>>>
>>>> works.
>>>>
>>>> Overall, I think this is a great addition, though it's going to be
>>>> disruptive for a while.
>>>>
>>>> Duncan Murdoch
>>>>
>>>> ______________________________________________
>>>> R-devel at r-project.org mailing list
>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel


From murdoch@dunc@n @end|ng |rom gm@||@com  Sat Dec  5 02:03:23 2020
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Fri, 4 Dec 2020 20:03:23 -0500
Subject: [Rd] [External] Re:  New pipe operator
In-Reply-To: <alpine.DEB.2.21.2012041310130.3003@luke-Latitude-7480>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <b98cf6d4-b856-2963-1882-9341384d141d@kogentum.hu>
 <alpine.DEB.2.21.2012041310130.3003@luke-Latitude-7480>
Message-ID: <d03c6867-4aa8-fa82-fe98-e706994dad3a@gmail.com>

On 04/12/2020 2:26 p.m., luke-tierney at uiowa.edu wrote:
> On Fri, 4 Dec 2020, D?nes T?th wrote:
> 
>>
>> On 12/4/20 3:05 PM, Duncan Murdoch wrote:
>>> ...
>>>
>>> It's tempting to suggest it should allow something like
>>>
>>>   ? mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
>>>
>>> which would be expanded to something equivalent to the other versions: but
>>> that makes it quite a bit more complicated.? (Maybe _ or \. should be used
>>> instead of ., since those are not legal variable names.)
>>
>> I support the idea of using an underscore (_) as the placeholder symbol.
> 
> I strongly oppose adding a placeholder. Allowing for an optional
> placeholder significantly complicates both implementing and explaining
> the semantics. For a simple syntax transformation to be viable it
> would also require some restrictions, such as only allowing a
> placeholder as a top level argument and only once. Checking that these
> restrictions are met, and accurately signaling when they are not with
> reasonable error messages, is essentially an unsolvable problem given
> R's semantics.

I don't think you read my suggestion, but that's okay:  you're 
maintaining it, not me.

Duncan Murdoch

> 
> The case where the LHS is to be passed as something other than the
> first argument is unusual. For me, having that case stand out by using
> a function expression makes it much easier to see and so makes the
> code easier to understand. As a wearer of progressive bifocals
> and someone whose screen is not always free of small dust particles,
> having to spot the non-standard pipe stages by seeing a placeholder,
> especially a . placeholder, is be a bug, not a feature.
> 
> Best,
> 
> luke
> 
>> Syntactic sugars work the the best if 1) they require less keystrokes and/or
>> 2) are easier to read compared to the "normal" syntax, and 3) can not lead to
>> unexpected bugs (which is a major problem with the magrittr pipe). Using '_'
>> fulfills all of these criteria since '_' can not clash with any variable in
>> the environment.
>>
>> Denes
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>


From iuke-tier@ey m@iii@g oii uiow@@edu  Sat Dec  5 03:11:17 2020
From: iuke-tier@ey m@iii@g oii uiow@@edu (iuke-tier@ey m@iii@g oii uiow@@edu)
Date: Fri, 4 Dec 2020 20:11:17 -0600 (CST)
Subject: [Rd] [External] Re:  New pipe operator
In-Reply-To: <d03c6867-4aa8-fa82-fe98-e706994dad3a@gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <b98cf6d4-b856-2963-1882-9341384d141d@kogentum.hu>
 <alpine.DEB.2.21.2012041310130.3003@luke-Latitude-7480>
 <d03c6867-4aa8-fa82-fe98-e706994dad3a@gmail.com>
Message-ID: <alpine.DEB.2.21.2012042001540.3003@luke-Latitude-7480>

On Sat, 5 Dec 2020, Duncan Murdoch wrote:

> On 04/12/2020 2:26 p.m., luke-tierney at uiowa.edu wrote:
>> On Fri, 4 Dec 2020, D?nes T?th wrote:
>> 
>>> 
>>> On 12/4/20 3:05 PM, Duncan Murdoch wrote:
>>>> ...
>>>> 
>>>> It's tempting to suggest it should allow something like
>>>>
>>>>   ? mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
>>>> 
>>>> which would be expanded to something equivalent to the other versions: 
>>>> but
>>>> that makes it quite a bit more complicated.? (Maybe _ or \. should be 
>>>> used
>>>> instead of ., since those are not legal variable names.)
>>> 
>>> I support the idea of using an underscore (_) as the placeholder symbol.
>> 
>> I strongly oppose adding a placeholder. Allowing for an optional
>> placeholder significantly complicates both implementing and explaining
>> the semantics. For a simple syntax transformation to be viable it
>> would also require some restrictions, such as only allowing a
>> placeholder as a top level argument and only once. Checking that these
>> restrictions are met, and accurately signaling when they are not with
>> reasonable error messages, is essentially an unsolvable problem given
>> R's semantics.
>
> I don't think you read my suggestion, but that's okay:  you're maintaining 
> it, not me.

I thought I did but maybe I missed something. You are right that
supporting a placeholder makes things a lot more complicated. For
being able to easily recognize the non-standard cases _ is better than
. but for me at least not by much.

We did try a number of variations; the code is in the R-syntax branch.
At the root of that branch are two .md files with some notes as of
around useR20. Once things settle down I may update those and look
into turning them into a blog post.

Best,

luke

>
> Duncan Murdoch
>
>> 
>> The case where the LHS is to be passed as something other than the
>> first argument is unusual. For me, having that case stand out by using
>> a function expression makes it much easier to see and so makes the
>> code easier to understand. As a wearer of progressive bifocals
>> and someone whose screen is not always free of small dust particles,
>> having to spot the non-standard pipe stages by seeing a placeholder,
>> especially a . placeholder, is be a bug, not a feature.
>> 
>> Best,
>> 
>> luke
>> 
>>> Syntactic sugars work the the best if 1) they require less keystrokes 
>>> and/or
>>> 2) are easier to read compared to the "normal" syntax, and 3) can not lead 
>>> to
>>> unexpected bugs (which is a major problem with the magrittr pipe). Using 
>>> '_'
>>> fulfills all of these criteria since '_' can not clash with any variable 
>>> in
>>> the environment.
>>> 
>>> Denes
>>> 
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>> 
>> 
>
>

-- 
Luke Tierney
Ralph E. Wareham Professor of Mathematical Sciences
University of Iowa                  Phone:             319-335-3386
Department of Statistics and        Fax:               319-335-3017
    Actuarial Science
241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu

From kry|ov@r00t @end|ng |rom gm@||@com  Sat Dec  5 08:27:55 2020
From: kry|ov@r00t @end|ng |rom gm@||@com (Ivan Krylov)
Date: Sat, 5 Dec 2020 10:27:55 +0300
Subject: [Rd] [External] Re:  New pipe operator
In-Reply-To: <alpine.DEB.2.21.2012042001540.3003@luke-Latitude-7480>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <b98cf6d4-b856-2963-1882-9341384d141d@kogentum.hu>
 <alpine.DEB.2.21.2012041310130.3003@luke-Latitude-7480>
 <d03c6867-4aa8-fa82-fe98-e706994dad3a@gmail.com>
 <alpine.DEB.2.21.2012042001540.3003@luke-Latitude-7480>
Message-ID: <20201205102755.0bd0a627@Tarkus>

On Fri, 4 Dec 2020 20:11:17 -0600 (CST)
luke-tierney at uiowa.edu wrote:

> We did try a number of variations; the code is in the R-syntax branch.
> At the root of that branch are two .md files with some notes as of
> around useR20.

Thanks for the information!

Can I make a suggestion? If the variation of the pipe that allows
a symbol on the RHS to be interpreted as the name of a function to call
does get chosen, may it also allow fully-qualified symbols?

Index: src/main/gram.y
===================================================================
--- src/main/gram.y     (revision 79567)
+++ src/main/gram.y     (working copy)
@@ -1242,7 +1242,11 @@
     if (GenerateCode) {
        /* allow for symbols or lambda expressions */
        if (TYPEOF(rhs) == SYMSXP ||
-           TYPEOF(rhs) == LANGSXP && CAR(rhs) == R_FunctionSymbol)
+           TYPEOF(rhs) == LANGSXP && (
+               CAR(rhs) == R_FunctionSymbol ||
+               CAR(rhs) == R_DoubleColonSymbol ||
+               CAR(rhs) == R_TripleColonSymbol
+           ))
            return lang2(rhs, lhs);
                    
        if (TYPEOF(rhs) != LANGSXP)

Or is this feature creep?

-- 
Best regards,
Ivan

P.S. This lambda function is waving at us: \ (O,o) `/`


From ggrothend|eck @end|ng |rom gm@||@com  Sat Dec  5 14:59:25 2020
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Sat, 5 Dec 2020 08:59:25 -0500
Subject: [Rd] installling R-devel on Windows
Message-ID: <CAP01uRmSCkwj-yJ0+KXSGn_rWV9NBKmbVWxuoA4t2fp5daVY8A@mail.gmail.com>

When I try to install r-devel on Windows all I get is this.  No other
files.  This also occurred yesterday as well.

 Directory of C:\Program Files\R\R-test

12/05/2020  08:56 AM    <DIR>          .
12/05/2020  08:56 AM    <DIR>          ..
12/05/2020  08:56 AM            11,503 unins000.dat
12/05/2020  08:56 AM         2,594,145 unins000.exe
               2 File(s)      2,605,648 bytes

-- 
Statistics & Software Consulting
GKX Group, GKX Associates Inc.
tel: 1-877-GKX-GROUP
email: ggrothendieck at gmail.com


From jeroenoom@ @end|ng |rom gm@||@com  Sat Dec  5 15:12:59 2020
From: jeroenoom@ @end|ng |rom gm@||@com (Jeroen Ooms)
Date: Sat, 5 Dec 2020 15:12:59 +0100
Subject: [Rd] installling R-devel on Windows
In-Reply-To: <CAP01uRmSCkwj-yJ0+KXSGn_rWV9NBKmbVWxuoA4t2fp5daVY8A@mail.gmail.com>
References: <CAP01uRmSCkwj-yJ0+KXSGn_rWV9NBKmbVWxuoA4t2fp5daVY8A@mail.gmail.com>
Message-ID: <CABFfbXtJKwBQtUQst33_RdNPeiE9dMSX2YCGS+5y+zEjD1KWMA@mail.gmail.com>

On Sat, Dec 5, 2020 at 3:00 PM Gabor Grothendieck
<ggrothendieck at gmail.com> wrote:
>
> When I try to install r-devel on Windows all I get is this.  No other
> files.  This also occurred yesterday as well.

It just tested it to be sure, but it works fine for me. Are you using
the official installer from
https://cran.r-project.org/bin/windows/base/rdevel.html ?

The default install path is not R-test C:\Program Files\R\R-devel.
Perhaps you have old files lingering from previous installations that
cause permission problems during the installation process?


From ggrothend|eck @end|ng |rom gm@||@com  Sat Dec  5 15:52:24 2020
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Sat, 5 Dec 2020 09:52:24 -0500
Subject: [Rd] installling R-devel on Windows
In-Reply-To: <CABFfbXtJKwBQtUQst33_RdNPeiE9dMSX2YCGS+5y+zEjD1KWMA@mail.gmail.com>
References: <CAP01uRmSCkwj-yJ0+KXSGn_rWV9NBKmbVWxuoA4t2fp5daVY8A@mail.gmail.com>
 <CABFfbXtJKwBQtUQst33_RdNPeiE9dMSX2YCGS+5y+zEjD1KWMA@mail.gmail.com>
Message-ID: <CAP01uR=bZCaH8TQP5Yhf4pc62vmbfNOMvJNdXJYZ1Pjvp9Qgbw@mail.gmail.com>

I clicked on the download link at
https://cran.r-project.org/bin/windows/base/rdevel.html
and then opened the downloaded file which starts the installation process.
I specified a new directory that does not exist, R-test, to be sure that
it would not get confused with an old directory.

I repeated this using different directories and on different days.

I tried it from a user and an Admin account.

If I use the exact same procedure to install R-4.0.3patched it works.

I have successfully downloaded and installed R maybe hundreds
of times over the last 10 to 20 years and have never before
encountered this.





On Sat, Dec 5, 2020 at 9:13 AM Jeroen Ooms <jeroenooms at gmail.com> wrote:
>
> On Sat, Dec 5, 2020 at 3:00 PM Gabor Grothendieck
> <ggrothendieck at gmail.com> wrote:
> >
> > When I try to install r-devel on Windows all I get is this.  No other
> > files.  This also occurred yesterday as well.
>
> It just tested it to be sure, but it works fine for me. Are you using
> the official installer from
> https://cran.r-project.org/bin/windows/base/rdevel.html ?
>
> The default install path is not R-test C:\Program Files\R\R-devel.
> Perhaps you have old files lingering from previous installations that
> cause permission problems during the installation process?



-- 
Statistics & Software Consulting
GKX Group, GKX Associates Inc.
tel: 1-877-GKX-GROUP
email: ggrothendieck at gmail.com


From @v|gro@@ @end|ng |rom ver|zon@net  Sat Dec  5 03:56:29 2020
From: @v|gro@@ @end|ng |rom ver|zon@net (Avi Gross)
Date: Fri, 4 Dec 2020 21:56:29 -0500
Subject: [Rd] [External] Re:  New pipe operator
In-Reply-To: <alpine.DEB.2.21.2012042001540.3003@luke-Latitude-7480>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <b98cf6d4-b856-2963-1882-9341384d141d@kogentum.hu>
 <alpine.DEB.2.21.2012041310130.3003@luke-Latitude-7480>
 <d03c6867-4aa8-fa82-fe98-e706994dad3a@gmail.com>
 <alpine.DEB.2.21.2012042001540.3003@luke-Latitude-7480>
Message-ID: <03ec01d6cab2$3b270250$b17506f0$@verizon.net>

Luke and others,

Can anyone comment on how this new pipe operator will interoperate with existing pipe methods or packages like the tidyverse that currently do things using them?

What differences might it make for efficiency? For example, making an anonymous function just so you can call another function and pass along the results to somewhere other than the first argument sounds like extra overhead. But the anonymous function does provide some interesting scenarios that allow things like a sort of tee functionality that may print/graph  a mid-stream result as well as pass it along the pipeline or do amusing things like apply multiple steps to the data and perhaps concatenate some of the results in the output. Of course, that can be done now with a non-anonymous function.

Perhaps we should name one version (or the other) a pipette or a pipe dream ?

The name "pipe" feels better in the new version as "|>" has the UNIX pipe symbol "|" in it. 


-----Original Message-----
From: R-devel <r-devel-bounces at r-project.org> On Behalf Of luke-tierney at uiowa.edu
Sent: Friday, December 4, 2020 9:11 PM
To: Duncan Murdoch <murdoch.duncan at gmail.com>
Cc: r-devel at r-project.org
Subject: Re: [Rd] [External] Re: New pipe operator

On Sat, 5 Dec 2020, Duncan Murdoch wrote:

> On 04/12/2020 2:26 p.m., luke-tierney at uiowa.edu wrote:
>> On Fri, 4 Dec 2020, D?nes T?th wrote:
>> 
>>> 
>>> On 12/4/20 3:05 PM, Duncan Murdoch wrote:
>>>> ...
>>>> 
>>>> It's tempting to suggest it should allow something like
>>>>
>>>>     mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
>>>> 
>>>> which would be expanded to something equivalent to the other versions: 
>>>> but
>>>> that makes it quite a bit more complicated.  (Maybe _ or \. should 
>>>> be used instead of ., since those are not legal variable names.)
>>> 
>>> I support the idea of using an underscore (_) as the placeholder symbol.
>> 
>> I strongly oppose adding a placeholder. Allowing for an optional 
>> placeholder significantly complicates both implementing and 
>> explaining the semantics. For a simple syntax transformation to be 
>> viable it would also require some restrictions, such as only allowing 
>> a placeholder as a top level argument and only once. Checking that 
>> these restrictions are met, and accurately signaling when they are 
>> not with reasonable error messages, is essentially an unsolvable 
>> problem given R's semantics.
>
> I don't think you read my suggestion, but that's okay:  you're 
> maintaining it, not me.

I thought I did but maybe I missed something. You are right that supporting a placeholder makes things a lot more complicated. For being able to easily recognize the non-standard cases _ is better than . but for me at least not by much.

We did try a number of variations; the code is in the R-syntax branch.
At the root of that branch are two .md files with some notes as of around useR20. Once things settle down I may update those and look into turning them into a blog post.

Best,

luke

>
> Duncan Murdoch
>
>> 
>> The case where the LHS is to be passed as something other than the 
>> first argument is unusual. For me, having that case stand out by 
>> using a function expression makes it much easier to see and so makes 
>> the code easier to understand. As a wearer of progressive bifocals 
>> and someone whose screen is not always free of small dust particles, 
>> having to spot the non-standard pipe stages by seeing a placeholder, 
>> especially a . placeholder, is be a bug, not a feature.
>> 
>> Best,
>> 
>> luke
>> 
>>> Syntactic sugars work the the best if 1) they require less 
>>> keystrokes and/or
>>> 2) are easier to read compared to the "normal" syntax, and 3) can 
>>> not lead to unexpected bugs (which is a major problem with the 
>>> magrittr pipe). Using '_'
>>> fulfills all of these criteria since '_' can not clash with any 
>>> variable in the environment.
>>> 
>>> Denes
>>> 
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>> 
>> 
>
>

--
Luke Tierney
Ralph E. Wareham Professor of Mathematical Sciences
University of Iowa                  Phone:             319-335-3386
Department of Statistics and        Fax:               319-335-3017
    Actuarial Science
241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu
______________________________________________
R-devel at r-project.org mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


Scanned by McAfee and confirmed virus-free.	
Find out more here: https://bit.ly/2zCJMrO


From murdoch@dunc@n @end|ng |rom gm@||@com  Sat Dec  5 16:57:15 2020
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Sat, 5 Dec 2020 10:57:15 -0500
Subject: [Rd] [External] Re:  New pipe operator
In-Reply-To: <alpine.DEB.2.21.2012042001540.3003@luke-Latitude-7480>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <b98cf6d4-b856-2963-1882-9341384d141d@kogentum.hu>
 <alpine.DEB.2.21.2012041310130.3003@luke-Latitude-7480>
 <d03c6867-4aa8-fa82-fe98-e706994dad3a@gmail.com>
 <alpine.DEB.2.21.2012042001540.3003@luke-Latitude-7480>
Message-ID: <ef0f31c7-f054-3c4c-5a56-e4195e0c1123@gmail.com>

On 04/12/2020 9:11 p.m., luke-tierney at uiowa.edu wrote:
> On Sat, 5 Dec 2020, Duncan Murdoch wrote:
> 
>> On 04/12/2020 2:26 p.m., luke-tierney at uiowa.edu wrote:
>>> On Fri, 4 Dec 2020, D?nes T?th wrote:
>>>
>>>>
>>>> On 12/4/20 3:05 PM, Duncan Murdoch wrote:
>>>>> ...
>>>>>
>>>>> It's tempting to suggest it should allow something like
>>>>>
>>>>>    ? mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
>>>>>
>>>>> which would be expanded to something equivalent to the other versions:
>>>>> but
>>>>> that makes it quite a bit more complicated.? (Maybe _ or \. should be
>>>>> used
>>>>> instead of ., since those are not legal variable names.)
>>>>
>>>> I support the idea of using an underscore (_) as the placeholder symbol.
>>>
>>> I strongly oppose adding a placeholder. Allowing for an optional
>>> placeholder significantly complicates both implementing and explaining
>>> the semantics. For a simple syntax transformation to be viable it
>>> would also require some restrictions, such as only allowing a
>>> placeholder as a top level argument and only once. Checking that these
>>> restrictions are met, and accurately signaling when they are not with
>>> reasonable error messages, is essentially an unsolvable problem given
>>> R's semantics.
>>
>> I don't think you read my suggestion, but that's okay:  you're maintaining
>> it, not me.
> 
> I thought I did but maybe I missed something. You are right that
> supporting a placeholder makes things a lot more complicated. For
> being able to easily recognize the non-standard cases _ is better than
> . but for me at least not by much.
> 
> We did try a number of variations; the code is in the R-syntax branch.
> At the root of that branch are two .md files with some notes as of
> around useR20. Once things settle down I may update those and look
> into turning them into a blog post.

Thanks for pointing out those documents.

Duncan Murdoch


From hugh@p@r@on@ge @end|ng |rom gm@||@com  Sat Dec  5 17:58:09 2020
From: hugh@p@r@on@ge @end|ng |rom gm@||@com (Hugh Parsonage)
Date: Sun, 6 Dec 2020 03:58:09 +1100
Subject: [Rd] New pipe operator
In-Reply-To: <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
Message-ID: <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>

I'm surprised by the aversion to

mtcars |> nrow

over

mtcars |> nrow()

and I think the decision to disallow the former should be
reconsidered.  The pipe operator is only going to be used when the rhs
is a function, so there is no ambiguity with omitting the parentheses.
If it's disallowed, it becomes inconsistent with other treatments like
sapply(mtcars, typeof) where sapply(mtcars, typeof()) would just be
noise.  I'm not sure why this decision was taken

If the only issue is with the double (and triple) colon operator, then
ideally `mtcars |> base::head` should resolve to `base::head(mtcars)`
-- in other words, demote the precedence of |>

Obviously (looking at the R-Syntax branch) this decision was
considered, put into place, then dropped, but I can't see why
precisely.

Best,


Hugh.







On Sat, 5 Dec 2020 at 04:07, Deepayan Sarkar <deepayan.sarkar at gmail.com> wrote:
>
> On Fri, Dec 4, 2020 at 7:35 PM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
> >
> > On 04/12/2020 8:13 a.m., Hiroaki Yutani wrote:
> > >>   Error: function '::' not supported in RHS call of a pipe
> > >
> > > To me, this error looks much more friendly than magrittr's error.
> > > Some of them got too used to specify functions without (). This
> > > is OK until they use `::`, but when they need to use it, it takes
> > > hours to figure out why
> > >
> > > mtcars %>% base::head
> > > #> Error in .::base : unused argument (head)
> > >
> > > won't work but
> > >
> > > mtcars %>% head
> > >
> > > works. I think this is a too harsh lesson for ordinary R users to
> > > learn `::` is a function. I've been wanting for magrittr to drop the
> > > support for a function name without () to avoid this confusion,
> > > so I would very much welcome the new pipe operator's behavior.
> > > Thank you all the developers who implemented this!
> >
> > I agree, it's an improvement on the corresponding magrittr error.
> >
> > I think the semantics of not evaluating the RHS, but treating the pipe
> > as purely syntactical is a good decision.
> >
> > I'm not sure I like the recommended way to pipe into a particular argument:
> >
> >    mtcars |> subset(cyl == 4) |> \(d) lm(mpg ~ disp, data = d)
> >
> > or
> >
> >    mtcars |> subset(cyl == 4) |> function(d) lm(mpg ~ disp, data = d)
> >
> > both of which are equivalent to
> >
> >    mtcars |> subset(cyl == 4) |> (function(d) lm(mpg ~ disp, data = d))()
> >
> > It's tempting to suggest it should allow something like
> >
> >    mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
>
> Which is really not that far off from
>
> mtcars |> subset(cyl == 4) |> \(.) lm(mpg ~ disp, data = .)
>
> once you get used to it.
>
> One consequence of the implementation is that it's not clear how
> multiple occurrences of the placeholder would be interpreted. With
> magrittr,
>
> sort(runif(10)) %>% ecdf(.)(.)
> ## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
>
> This is probably what you would expect, if you expect it to work at all, and not
>
> ecdf(sort(runif(10)))(sort(runif(10)))
>
> There would be no such ambiguity with anonymous functions
>
> sort(runif(10)) |> \(.) ecdf(.)(.)
>
> -Deepayan
>
> > which would be expanded to something equivalent to the other versions:
> > but that makes it quite a bit more complicated.  (Maybe _ or \. should
> > be used instead of ., since those are not legal variable names.)
> >
> > I don't think there should be an attempt to copy magrittr's special
> > casing of how . is used in determining whether to also include the
> > previous value as first argument.
> >
> > Duncan Murdoch
> >
> >
> > >
> > > Best,
> > > Hiroaki Yutani
> > >
> > > 2020?12?4?(?) 20:51 Duncan Murdoch <murdoch.duncan at gmail.com>:
> > >>
> > >> Just saw this on the R-devel news:
> > >>
> > >>
> > >> R now provides a simple native pipe syntax ?|>? as well as a shorthand
> > >> notation for creating functions, e.g. ?\(x) x + 1? is parsed as
> > >> ?function(x) x + 1?. The pipe implementation as a syntax transformation
> > >> was motivated by suggestions from Jim Hester and Lionel Henry. These
> > >> features are experimental and may change prior to release.
> > >>
> > >>
> > >> This is a good addition; by using "|>" instead of "%>%" there should be
> > >> a chance to get operator precedence right.  That said, the ?Syntax help
> > >> topic hasn't been updated, so I'm not sure where it fits in.
> > >>
> > >> There are some choices that take a little getting used to:
> > >>
> > >>   > mtcars |> head
> > >> Error: The pipe operator requires a function call or an anonymous
> > >> function expression as RHS
> > >>
> > >> (I need to say mtcars |> head() instead.)  This sometimes leads to error
> > >> messages that are somewhat confusing:
> > >>
> > >>   > mtcars |> magrittr::debug_pipe |> head
> > >> Error: function '::' not supported in RHS call of a pipe
> > >>
> > >> but
> > >>
> > >> mtcars |> magrittr::debug_pipe() |> head()
> > >>
> > >> works.
> > >>
> > >> Overall, I think this is a great addition, though it's going to be
> > >> disruptive for a while.
> > >>
> > >> Duncan Murdoch
> > >>
> > >> ______________________________________________
> > >> R-devel at r-project.org mailing list
> > >> https://stat.ethz.ch/mailman/listinfo/r-devel
> > >
> > > ______________________________________________
> > > R-devel at r-project.org mailing list
> > > https://stat.ethz.ch/mailman/listinfo/r-devel
> > >
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From ggrothend|eck @end|ng |rom gm@||@com  Sat Dec  5 19:08:28 2020
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Sat, 5 Dec 2020 13:08:28 -0500
Subject: [Rd] New pipe operator
In-Reply-To: <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
Message-ID: <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>

The construct utils::head  is not that common but bare functions are
very common and to make it harder to use the common case so that
the uncommon case is slightly easier is not desirable.

Also it is trivial to write this which does work:

mtcars %>% (utils::head)

On Sat, Dec 5, 2020 at 11:59 AM Hugh Parsonage <hugh.parsonage at gmail.com> wrote:
>
> I'm surprised by the aversion to
>
> mtcars |> nrow
>
> over
>
> mtcars |> nrow()
>
> and I think the decision to disallow the former should be
> reconsidered.  The pipe operator is only going to be used when the rhs
> is a function, so there is no ambiguity with omitting the parentheses.
> If it's disallowed, it becomes inconsistent with other treatments like
> sapply(mtcars, typeof) where sapply(mtcars, typeof()) would just be
> noise.  I'm not sure why this decision was taken
>
> If the only issue is with the double (and triple) colon operator, then
> ideally `mtcars |> base::head` should resolve to `base::head(mtcars)`
> -- in other words, demote the precedence of |>
>
> Obviously (looking at the R-Syntax branch) this decision was
> considered, put into place, then dropped, but I can't see why
> precisely.
>
> Best,
>
>
> Hugh.
>
>
>
>
>
>
>
> On Sat, 5 Dec 2020 at 04:07, Deepayan Sarkar <deepayan.sarkar at gmail.com> wrote:
> >
> > On Fri, Dec 4, 2020 at 7:35 PM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
> > >
> > > On 04/12/2020 8:13 a.m., Hiroaki Yutani wrote:
> > > >>   Error: function '::' not supported in RHS call of a pipe
> > > >
> > > > To me, this error looks much more friendly than magrittr's error.
> > > > Some of them got too used to specify functions without (). This
> > > > is OK until they use `::`, but when they need to use it, it takes
> > > > hours to figure out why
> > > >
> > > > mtcars %>% base::head
> > > > #> Error in .::base : unused argument (head)
> > > >
> > > > won't work but
> > > >
> > > > mtcars %>% head
> > > >
> > > > works. I think this is a too harsh lesson for ordinary R users to
> > > > learn `::` is a function. I've been wanting for magrittr to drop the
> > > > support for a function name without () to avoid this confusion,
> > > > so I would very much welcome the new pipe operator's behavior.
> > > > Thank you all the developers who implemented this!
> > >
> > > I agree, it's an improvement on the corresponding magrittr error.
> > >
> > > I think the semantics of not evaluating the RHS, but treating the pipe
> > > as purely syntactical is a good decision.
> > >
> > > I'm not sure I like the recommended way to pipe into a particular argument:
> > >
> > >    mtcars |> subset(cyl == 4) |> \(d) lm(mpg ~ disp, data = d)
> > >
> > > or
> > >
> > >    mtcars |> subset(cyl == 4) |> function(d) lm(mpg ~ disp, data = d)
> > >
> > > both of which are equivalent to
> > >
> > >    mtcars |> subset(cyl == 4) |> (function(d) lm(mpg ~ disp, data = d))()
> > >
> > > It's tempting to suggest it should allow something like
> > >
> > >    mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
> >
> > Which is really not that far off from
> >
> > mtcars |> subset(cyl == 4) |> \(.) lm(mpg ~ disp, data = .)
> >
> > once you get used to it.
> >
> > One consequence of the implementation is that it's not clear how
> > multiple occurrences of the placeholder would be interpreted. With
> > magrittr,
> >
> > sort(runif(10)) %>% ecdf(.)(.)
> > ## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
> >
> > This is probably what you would expect, if you expect it to work at all, and not
> >
> > ecdf(sort(runif(10)))(sort(runif(10)))
> >
> > There would be no such ambiguity with anonymous functions
> >
> > sort(runif(10)) |> \(.) ecdf(.)(.)
> >
> > -Deepayan
> >
> > > which would be expanded to something equivalent to the other versions:
> > > but that makes it quite a bit more complicated.  (Maybe _ or \. should
> > > be used instead of ., since those are not legal variable names.)
> > >
> > > I don't think there should be an attempt to copy magrittr's special
> > > casing of how . is used in determining whether to also include the
> > > previous value as first argument.
> > >
> > > Duncan Murdoch
> > >
> > >
> > > >
> > > > Best,
> > > > Hiroaki Yutani
> > > >
> > > > 2020?12?4?(?) 20:51 Duncan Murdoch <murdoch.duncan at gmail.com>:
> > > >>
> > > >> Just saw this on the R-devel news:
> > > >>
> > > >>
> > > >> R now provides a simple native pipe syntax ?|>? as well as a shorthand
> > > >> notation for creating functions, e.g. ?\(x) x + 1? is parsed as
> > > >> ?function(x) x + 1?. The pipe implementation as a syntax transformation
> > > >> was motivated by suggestions from Jim Hester and Lionel Henry. These
> > > >> features are experimental and may change prior to release.
> > > >>
> > > >>
> > > >> This is a good addition; by using "|>" instead of "%>%" there should be
> > > >> a chance to get operator precedence right.  That said, the ?Syntax help
> > > >> topic hasn't been updated, so I'm not sure where it fits in.
> > > >>
> > > >> There are some choices that take a little getting used to:
> > > >>
> > > >>   > mtcars |> head
> > > >> Error: The pipe operator requires a function call or an anonymous
> > > >> function expression as RHS
> > > >>
> > > >> (I need to say mtcars |> head() instead.)  This sometimes leads to error
> > > >> messages that are somewhat confusing:
> > > >>
> > > >>   > mtcars |> magrittr::debug_pipe |> head
> > > >> Error: function '::' not supported in RHS call of a pipe
> > > >>
> > > >> but
> > > >>
> > > >> mtcars |> magrittr::debug_pipe() |> head()
> > > >>
> > > >> works.
> > > >>
> > > >> Overall, I think this is a great addition, though it's going to be
> > > >> disruptive for a while.
> > > >>
> > > >> Duncan Murdoch
> > > >>
> > > >> ______________________________________________
> > > >> R-devel at r-project.org mailing list
> > > >> https://stat.ethz.ch/mailman/listinfo/r-devel
> > > >
> > > > ______________________________________________
> > > > R-devel at r-project.org mailing list
> > > > https://stat.ethz.ch/mailman/listinfo/r-devel
> > > >
> > >
> > > ______________________________________________
> > > R-devel at r-project.org mailing list
> > > https://stat.ethz.ch/mailman/listinfo/r-devel
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel



-- 
Statistics & Software Consulting
GKX Group, GKX Associates Inc.
tel: 1-877-GKX-GROUP
email: ggrothendieck at gmail.com


From iuke-tier@ey m@iii@g oii uiow@@edu  Sat Dec  5 19:10:04 2020
From: iuke-tier@ey m@iii@g oii uiow@@edu (iuke-tier@ey m@iii@g oii uiow@@edu)
Date: Sat, 5 Dec 2020 12:10:04 -0600 (CST)
Subject: [Rd] [External] Re:  New pipe operator
In-Reply-To: <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
Message-ID: <alpine.DEB.2.21.2012051203250.3003@luke-Latitude-7480>

We went back and forth on this several times. The key advantage of
requiring parentheses is to keep things simple and consistent.  Let's
get some experience with that. If experience shows requiring
parentheses creates too many issues then we can add the option of
dropping them later (with special handling of :: and :::). It's easier
to add flexibility and complexity than to restrict it after the fact.

Best,

luke

On Sat, 5 Dec 2020, Hugh Parsonage wrote:

> I'm surprised by the aversion to
>
> mtcars |> nrow
>
> over
>
> mtcars |> nrow()
>
> and I think the decision to disallow the former should be
> reconsidered.  The pipe operator is only going to be used when the rhs
> is a function, so there is no ambiguity with omitting the parentheses.
> If it's disallowed, it becomes inconsistent with other treatments like
> sapply(mtcars, typeof) where sapply(mtcars, typeof()) would just be
> noise.  I'm not sure why this decision was taken
>
> If the only issue is with the double (and triple) colon operator, then
> ideally `mtcars |> base::head` should resolve to `base::head(mtcars)`
> -- in other words, demote the precedence of |>
>
> Obviously (looking at the R-Syntax branch) this decision was
> considered, put into place, then dropped, but I can't see why
> precisely.
>
> Best,
>
>
> Hugh.
>
>
>
>
>
>
>
> On Sat, 5 Dec 2020 at 04:07, Deepayan Sarkar <deepayan.sarkar at gmail.com> wrote:
>>
>> On Fri, Dec 4, 2020 at 7:35 PM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>>>
>>> On 04/12/2020 8:13 a.m., Hiroaki Yutani wrote:
>>>>>   Error: function '::' not supported in RHS call of a pipe
>>>>
>>>> To me, this error looks much more friendly than magrittr's error.
>>>> Some of them got too used to specify functions without (). This
>>>> is OK until they use `::`, but when they need to use it, it takes
>>>> hours to figure out why
>>>>
>>>> mtcars %>% base::head
>>>> #> Error in .::base : unused argument (head)
>>>>
>>>> won't work but
>>>>
>>>> mtcars %>% head
>>>>
>>>> works. I think this is a too harsh lesson for ordinary R users to
>>>> learn `::` is a function. I've been wanting for magrittr to drop the
>>>> support for a function name without () to avoid this confusion,
>>>> so I would very much welcome the new pipe operator's behavior.
>>>> Thank you all the developers who implemented this!
>>>
>>> I agree, it's an improvement on the corresponding magrittr error.
>>>
>>> I think the semantics of not evaluating the RHS, but treating the pipe
>>> as purely syntactical is a good decision.
>>>
>>> I'm not sure I like the recommended way to pipe into a particular argument:
>>>
>>>    mtcars |> subset(cyl == 4) |> \(d) lm(mpg ~ disp, data = d)
>>>
>>> or
>>>
>>>    mtcars |> subset(cyl == 4) |> function(d) lm(mpg ~ disp, data = d)
>>>
>>> both of which are equivalent to
>>>
>>>    mtcars |> subset(cyl == 4) |> (function(d) lm(mpg ~ disp, data = d))()
>>>
>>> It's tempting to suggest it should allow something like
>>>
>>>    mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
>>
>> Which is really not that far off from
>>
>> mtcars |> subset(cyl == 4) |> \(.) lm(mpg ~ disp, data = .)
>>
>> once you get used to it.
>>
>> One consequence of the implementation is that it's not clear how
>> multiple occurrences of the placeholder would be interpreted. With
>> magrittr,
>>
>> sort(runif(10)) %>% ecdf(.)(.)
>> ## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
>>
>> This is probably what you would expect, if you expect it to work at all, and not
>>
>> ecdf(sort(runif(10)))(sort(runif(10)))
>>
>> There would be no such ambiguity with anonymous functions
>>
>> sort(runif(10)) |> \(.) ecdf(.)(.)
>>
>> -Deepayan
>>
>>> which would be expanded to something equivalent to the other versions:
>>> but that makes it quite a bit more complicated.  (Maybe _ or \. should
>>> be used instead of ., since those are not legal variable names.)
>>>
>>> I don't think there should be an attempt to copy magrittr's special
>>> casing of how . is used in determining whether to also include the
>>> previous value as first argument.
>>>
>>> Duncan Murdoch
>>>
>>>
>>>>
>>>> Best,
>>>> Hiroaki Yutani
>>>>
>>>> 2020?12?4?(?) 20:51 Duncan Murdoch <murdoch.duncan at gmail.com>:
>>>>>
>>>>> Just saw this on the R-devel news:
>>>>>
>>>>>
>>>>> R now provides a simple native pipe syntax ?|>? as well as a shorthand
>>>>> notation for creating functions, e.g. ?\(x) x + 1? is parsed as
>>>>> ?function(x) x + 1?. The pipe implementation as a syntax transformation
>>>>> was motivated by suggestions from Jim Hester and Lionel Henry. These
>>>>> features are experimental and may change prior to release.
>>>>>
>>>>>
>>>>> This is a good addition; by using "|>" instead of "%>%" there should be
>>>>> a chance to get operator precedence right.  That said, the ?Syntax help
>>>>> topic hasn't been updated, so I'm not sure where it fits in.
>>>>>
>>>>> There are some choices that take a little getting used to:
>>>>>
>>>>>  > mtcars |> head
>>>>> Error: The pipe operator requires a function call or an anonymous
>>>>> function expression as RHS
>>>>>
>>>>> (I need to say mtcars |> head() instead.)  This sometimes leads to error
>>>>> messages that are somewhat confusing:
>>>>>
>>>>>  > mtcars |> magrittr::debug_pipe |> head
>>>>> Error: function '::' not supported in RHS call of a pipe
>>>>>
>>>>> but
>>>>>
>>>>> mtcars |> magrittr::debug_pipe() |> head()
>>>>>
>>>>> works.
>>>>>
>>>>> Overall, I think this is a great addition, though it's going to be
>>>>> disruptive for a while.
>>>>>
>>>>> Duncan Murdoch
>>>>>
>>>>> ______________________________________________
>>>>> R-devel at r-project.org mailing list
>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>
>>>> ______________________________________________
>>>> R-devel at r-project.org mailing list
>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>
>>>
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

-- 
Luke Tierney
Ralph E. Wareham Professor of Mathematical Sciences
University of Iowa                  Phone:             319-335-3386
Department of Statistics and        Fax:               319-335-3017
    Actuarial Science
241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu

From jmount @end|ng |rom w|n-vector@com  Sat Dec  5 19:51:06 2020
From: jmount @end|ng |rom w|n-vector@com (John Mount)
Date: Sat, 5 Dec 2020 18:51:06 +0000
Subject: [Rd] New pipe operator
In-Reply-To: <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
Message-ID: <B1889688-C01E-41F0-93C7-A0FFD939CB67@win-vector.com>

The :: is a case that we worked to get right with wrapr dot-pipe. I shared notes on this S3/S4 pipe in the R journal https://journal.r-project.org/archive/2018/RJ-2018-042/index.html

library(magrittr)
packageVersion("magrittr")
# [1] ?2.0.1?
5 %>% base::sin
# Error in .::base : unused argument (sin)

library(wrapr)
5 %.>% base::sin
# [1] -0.9589243


On Dec 5, 2020, at 10:08 AM, Gabor Grothendieck <ggrothendieck at gmail.com<mailto:ggrothendieck at gmail.com>> wrote:

The construct utils::head  is not that common but bare functions are
very common and to make it harder to use the common case so that
the uncommon case is slightly easier is not desirable.

Also it is trivial to write this which does work:

mtcars %>% (utils::head)

On Sat, Dec 5, 2020 at 11:59 AM Hugh Parsonage <hugh.parsonage at gmail.com<mailto:hugh.parsonage at gmail.com>> wrote:

I'm surprised by the aversion to

mtcars |> nrow

over

mtcars |> nrow()

and I think the decision to disallow the former should be
reconsidered.  The pipe operator is only going to be used when the rhs
is a function, so there is no ambiguity with omitting the parentheses.
If it's disallowed, it becomes inconsistent with other treatments like
sapply(mtcars, typeof) where sapply(mtcars, typeof()) would just be
noise.  I'm not sure why this decision was taken

If the only issue is with the double (and triple) colon operator, then
ideally `mtcars |> base::head` should resolve to `base::head(mtcars)`
-- in other words, demote the precedence of |>

Obviously (looking at the R-Syntax branch) this decision was
considered, put into place, then dropped, but I can't see why
precisely.

Best,


Hugh.







On Sat, 5 Dec 2020 at 04:07, Deepayan Sarkar <deepayan.sarkar at gmail.com<mailto:deepayan.sarkar at gmail.com>> wrote:

On Fri, Dec 4, 2020 at 7:35 PM Duncan Murdoch <murdoch.duncan at gmail.com<mailto:murdoch.duncan at gmail.com>> wrote:

On 04/12/2020 8:13 a.m., Hiroaki Yutani wrote:
 Error: function '::' not supported in RHS call of a pipe

To me, this error looks much more friendly than magrittr's error.
Some of them got too used to specify functions without (). This
is OK until they use `::`, but when they need to use it, it takes
hours to figure out why

mtcars %>% base::head
#> Error in .::base : unused argument (head)

won't work but

mtcars %>% head

works. I think this is a too harsh lesson for ordinary R users to
learn `::` is a function. I've been wanting for magrittr to drop the
support for a function name without () to avoid this confusion,
so I would very much welcome the new pipe operator's behavior.
Thank you all the developers who implemented this!

I agree, it's an improvement on the corresponding magrittr error.

I think the semantics of not evaluating the RHS, but treating the pipe
as purely syntactical is a good decision.

I'm not sure I like the recommended way to pipe into a particular argument:

  mtcars |> subset(cyl == 4) |> \(d) lm(mpg ~ disp, data = d)

or

  mtcars |> subset(cyl == 4) |> function(d) lm(mpg ~ disp, data = d)

both of which are equivalent to

  mtcars |> subset(cyl == 4) |> (function(d) lm(mpg ~ disp, data = d))()

It's tempting to suggest it should allow something like

  mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)

Which is really not that far off from

mtcars |> subset(cyl == 4) |> \(.) lm(mpg ~ disp, data = .)

once you get used to it.

One consequence of the implementation is that it's not clear how
multiple occurrences of the placeholder would be interpreted. With
magrittr,

sort(runif(10)) %>% ecdf(.)(.)
## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0

This is probably what you would expect, if you expect it to work at all, and not

ecdf(sort(runif(10)))(sort(runif(10)))

There would be no such ambiguity with anonymous functions

sort(runif(10)) |> \(.) ecdf(.)(.)

-Deepayan

which would be expanded to something equivalent to the other versions:
but that makes it quite a bit more complicated.  (Maybe _ or \. should
be used instead of ., since those are not legal variable names.)

I don't think there should be an attempt to copy magrittr's special
casing of how . is used in determining whether to also include the
previous value as first argument.

Duncan Murdoch



Best,
Hiroaki Yutani

2020?12?4?(?) 20:51 Duncan Murdoch <murdoch.duncan at gmail.com<mailto:murdoch.duncan at gmail.com>>:

Just saw this on the R-devel news:


R now provides a simple native pipe syntax ?|>? as well as a shorthand
notation for creating functions, e.g. ?\(x) x + 1? is parsed as
?function(x) x + 1?. The pipe implementation as a syntax transformation
was motivated by suggestions from Jim Hester and Lionel Henry. These
features are experimental and may change prior to release.


This is a good addition; by using "|>" instead of "%>%" there should be
a chance to get operator precedence right.  That said, the ?Syntax help
topic hasn't been updated, so I'm not sure where it fits in.

There are some choices that take a little getting used to:

mtcars |> head
Error: The pipe operator requires a function call or an anonymous
function expression as RHS

(I need to say mtcars |> head() instead.)  This sometimes leads to error
messages that are somewhat confusing:

mtcars |> magrittr::debug_pipe |> head
Error: function '::' not supported in RHS call of a pipe

but

mtcars |> magrittr::debug_pipe() |> head()

works.

Overall, I think this is a great addition, though it's going to be
disruptive for a while.

Duncan Murdoch

______________________________________________
R-devel at r-project.org<mailto:R-devel at r-project.org> mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel

______________________________________________
R-devel at r-project.org<mailto:R-devel at r-project.org> mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


______________________________________________
R-devel at r-project.org<mailto:R-devel at r-project.org> mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel

______________________________________________
R-devel at r-project.org<mailto:R-devel at r-project.org> mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel

______________________________________________
R-devel at r-project.org<mailto:R-devel at r-project.org> mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel



--
Statistics & Software Consulting
GKX Group, GKX Associates Inc.
tel: 1-877-GKX-GROUP
email: ggrothendieck at gmail.com<http://gmail.com>

______________________________________________
R-devel at r-project.org<mailto:R-devel at r-project.org> mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


	[[alternative HTML version deleted]]


From @purd|e@@ @end|ng |rom gm@||@com  Sun Dec  6 03:43:17 2020
From: @purd|e@@ @end|ng |rom gm@||@com (Abby Spurdle)
Date: Sun, 6 Dec 2020 15:43:17 +1300
Subject: [Rd] New pipe operator
In-Reply-To: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
Message-ID: <CAB8pepzDHvM+JJtOcSOudyJ0Fe6-Yk2sG7Ep7qDkOK52bcuwZw@mail.gmail.com>

> This is a good addition

I can't understand why so many people are calling this a "pipe".
Pipes connect processes, via their I/O streams.
Arguably, a more general interpretation would include sockets and files.

https://en.wikipedia.org/wiki/Pipeline_(Unix)
https://en.wikipedia.org/wiki/Named_pipe
https://en.wikipedia.org/wiki/Anonymous_pipe

As far as I can tell, the magrittr-like operators are functions (not
pipes), with nonstandard syntax.
This is not consistent with R's original design philosophy, building
on C, Lisp and S, along with lots of *important* math and stats.

It's possible that some parties are interested in creating a kind of
"data pipeline".
I'm interested in this myself, and I think we could discuss this more.
But I'm not convinced the magrittr-like operators help to achieve this goal.
Which, in my opinion, would require one to model programs as directed
graphs, along with some degree of asynchronous input.

Presumably, these operators will be added to R anyway, and (almost) no
one will listen to me.

So, I would like to make one suggestion:
Is it possible for these operators to *not* be named:
    The R Pipe
    The S Pipe
    Or anything with a similar meaning.

Maybe tidy pipe, or something else that links it to its proponents?


From greg @end|ng |rom w@rne@@net  Sun Dec  6 04:22:12 2020
From: greg @end|ng |rom w@rne@@net (Gregory Warnes)
Date: Sat, 5 Dec 2020 22:22:12 -0500
Subject: [Rd] New pipe operator
In-Reply-To: <CAB8pepzDHvM+JJtOcSOudyJ0Fe6-Yk2sG7Ep7qDkOK52bcuwZw@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CAB8pepzDHvM+JJtOcSOudyJ0Fe6-Yk2sG7Ep7qDkOK52bcuwZw@mail.gmail.com>
Message-ID: <CAKorm_usbqOAxS8Xk6BeeFbPK0rg1KwMNTavrDzRgm4We+mN4g@mail.gmail.com>

If we?re being mathematically pedantic, the ?pipe? operator is actually
function composition.

That being said, pipes are a simple and well-known idiom. While being less
than mathematically exact, it seems a reasonable   label for the (very
useful) behavior.

On Sat, Dec 5, 2020 at 9:43 PM Abby Spurdle <spurdle.a at gmail.com> wrote:

> > This is a good addition
>
> I can't understand why so many people are calling this a "pipe".
> Pipes connect processes, via their I/O streams.
> Arguably, a more general interpretation would include sockets and files.
>
> https://en.wikipedia.org/wiki/Pipeline_(Unix)
> https://en.wikipedia.org/wiki/Named_pipe
> https://en.wikipedia.org/wiki/Anonymous_pipe
>
> As far as I can tell, the magrittr-like operators are functions (not
> pipes), with nonstandard syntax.
> This is not consistent with R's original design philosophy, building
> on C, Lisp and S, along with lots of *important* math and stats.
>
> It's possible that some parties are interested in creating a kind of
> "data pipeline".
> I'm interested in this myself, and I think we could discuss this more.
> But I'm not convinced the magrittr-like operators help to achieve this
> goal.
> Which, in my opinion, would require one to model programs as directed
> graphs, along with some degree of asynchronous input.
>
> Presumably, these operators will be added to R anyway, and (almost) no
> one will listen to me.
>
> So, I would like to make one suggestion:
> Is it possible for these operators to *not* be named:
>     The R Pipe
>     The S Pipe
>     Or anything with a similar meaning.
>
> Maybe tidy pipe, or something else that links it to its proponents?
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>
-- 
"Whereas true religion and good morals are the only solid foundations of
public liberty and happiness . . . it is hereby earnestly recommended to
the several States to take the most effectual measures for the
encouragement thereof." Continental Congress, 1778

	[[alternative HTML version deleted]]


From yut@n|@|n| @end|ng |rom gm@||@com  Sun Dec  6 04:29:23 2020
From: yut@n|@|n| @end|ng |rom gm@||@com (Hiroaki Yutani)
Date: Sun, 6 Dec 2020 12:29:23 +0900
Subject: [Rd] New pipe operator
In-Reply-To: <CAKorm_usbqOAxS8Xk6BeeFbPK0rg1KwMNTavrDzRgm4We+mN4g@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CAB8pepzDHvM+JJtOcSOudyJ0Fe6-Yk2sG7Ep7qDkOK52bcuwZw@mail.gmail.com>
 <CAKorm_usbqOAxS8Xk6BeeFbPK0rg1KwMNTavrDzRgm4We+mN4g@mail.gmail.com>
Message-ID: <CALyqOb-GUZXp5L3M8veguz4gNfYkpxtJGhdg7FbYAHFB6VAJLA@mail.gmail.com>

It is common practice to call |> as pipe (or pipeline operator) among
many languages
including ones that recently introduced it as an experimental feature.
Pipeline is a
common feature for functional programming, not just for "data pipeline."

    F#: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/symbol-and-operator-reference/
    Elixir: https://hexdocs.pm/elixir/operators.html#general-operators
    Typescript:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Pipeline_operator
    Ruby: https://bugs.ruby-lang.org/issues/15799

(This blog post about the history of pipe operator might be
interesting: https://mamememo.blogspot.com/2019/06/a-brief-history-of-pipeline-operator.html
)

I agree this is a bit confusing for those who are familiar with other
"pipe" concepts,
but there's no other appropriate term to call |>.

2020?12?6?(?) 12:22 Gregory Warnes <greg at warnes.net>:
>
> If we?re being mathematically pedantic, the ?pipe? operator is actually
> function composition.
>
> That being said, pipes are a simple and well-known idiom. While being less
> than mathematically exact, it seems a reasonable   label for the (very
> useful) behavior.
>
> On Sat, Dec 5, 2020 at 9:43 PM Abby Spurdle <spurdle.a at gmail.com> wrote:
>
> > > This is a good addition
> >
> > I can't understand why so many people are calling this a "pipe".
> > Pipes connect processes, via their I/O streams.
> > Arguably, a more general interpretation would include sockets and files.
> >
> > https://en.wikipedia.org/wiki/Pipeline_(Unix)
> > https://en.wikipedia.org/wiki/Named_pipe
> > https://en.wikipedia.org/wiki/Anonymous_pipe
> >
> > As far as I can tell, the magrittr-like operators are functions (not
> > pipes), with nonstandard syntax.
> > This is not consistent with R's original design philosophy, building
> > on C, Lisp and S, along with lots of *important* math and stats.
> >
> > It's possible that some parties are interested in creating a kind of
> > "data pipeline".
> > I'm interested in this myself, and I think we could discuss this more.
> > But I'm not convinced the magrittr-like operators help to achieve this
> > goal.
> > Which, in my opinion, would require one to model programs as directed
> > graphs, along with some degree of asynchronous input.
> >
> > Presumably, these operators will be added to R anyway, and (almost) no
> > one will listen to me.
> >
> > So, I would like to make one suggestion:
> > Is it possible for these operators to *not* be named:
> >     The R Pipe
> >     The S Pipe
> >     Or anything with a similar meaning.
> >
> > Maybe tidy pipe, or something else that links it to its proponents?
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
> >
> --
> "Whereas true religion and good morals are the only solid foundations of
> public liberty and happiness . . . it is hereby earnestly recommended to
> the several States to take the most effectual measures for the
> encouragement thereof." Continental Congress, 1778
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From ru|pb@rr@d@@ @end|ng |rom @@po@pt  Sun Dec  6 08:51:10 2020
From: ru|pb@rr@d@@ @end|ng |rom @@po@pt (Rui Barradas)
Date: Sun, 6 Dec 2020 07:51:10 +0000
Subject: [Rd] New pipe operator
In-Reply-To: <CAKorm_usbqOAxS8Xk6BeeFbPK0rg1KwMNTavrDzRgm4We+mN4g@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CAB8pepzDHvM+JJtOcSOudyJ0Fe6-Yk2sG7Ep7qDkOK52bcuwZw@mail.gmail.com>
 <CAKorm_usbqOAxS8Xk6BeeFbPK0rg1KwMNTavrDzRgm4We+mN4g@mail.gmail.com>
Message-ID: <89237cb3-dcda-6957-f86f-8d359fb66fff@sapo.pt>

Hello,

If Hilbert liked beer, I like "pipe".

More seriously, a new addition like this one is going to cause problems 
yet unknown. But it's a good idea to have a pipe operator available. As 
someone used to magrittr's data pipelines, I will play with this base 
one before making up my mind. I don't expect its behavior to be exactly 
like magrittr "%>%" (and it's not). For the moment all I can say is that 
it is something R users are used to and that it now avoids loading a 
package.
As for the new way to define anonymous functions, I am less sure. Too 
much syntatic sugar? Or am I finding the syntax ugly?

Hope this helps,

Rui Barradas


?s 03:22 de 06/12/20, Gregory Warnes escreveu:
> If we?re being mathematically pedantic, the ?pipe? operator is actually
> function composition >
> That being said, pipes are a simple and well-known idiom. While being less
> than mathematically exact, it seems a reasonable   label for the (very
> useful) behavior.
> 
> On Sat, Dec 5, 2020 at 9:43 PM Abby Spurdle <spurdle.a at gmail.com> wrote:
> 
>>> This is a good addition
>>
>> I can't understand why so many people are calling this a "pipe".
>> Pipes connect processes, via their I/O streams.
>> Arguably, a more general interpretation would include sockets and files.
>>
>> https://en.wikipedia.org/wiki/Pipeline_(Unix)
>> https://en.wikipedia.org/wiki/Named_pipe
>> https://en.wikipedia.org/wiki/Anonymous_pipe
>>
>> As far as I can tell, the magrittr-like operators are functions (not
>> pipes), with nonstandard syntax.
>> This is not consistent with R's original design philosophy, building
>> on C, Lisp and S, along with lots of *important* math and stats.
>>
>> It's possible that some parties are interested in creating a kind of
>> "data pipeline".
>> I'm interested in this myself, and I think we could discuss this more.
>> But I'm not convinced the magrittr-like operators help to achieve this
>> goal.
>> Which, in my opinion, would require one to model programs as directed
>> graphs, along with some degree of asynchronous input.
>>
>> Presumably, these operators will be added to R anyway, and (almost) no
>> one will listen to me.
>>
>> So, I would like to make one suggestion:
>> Is it possible for these operators to *not* be named:
>>      The R Pipe
>>      The S Pipe
>>      Or anything with a similar meaning.
>>
>> Maybe tidy pipe, or something else that links it to its proponents?
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>


From j@goreck| @end|ng |rom w|t@edu@p|  Sun Dec  6 10:42:53 2020
From: j@goreck| @end|ng |rom w|t@edu@p| (Jan Gorecki)
Date: Sun, 6 Dec 2020 11:42:53 +0200
Subject: [Rd] [External] Re: New pipe operator
In-Reply-To: <alpine.DEB.2.21.2012051203250.3003@luke-Latitude-7480>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <alpine.DEB.2.21.2012051203250.3003@luke-Latitude-7480>
Message-ID: <CAOO9MKU7LD9JkX3XK3NpqzzpiTirvRxdqJBbX0D=W3ik+Fw0bw@mail.gmail.com>

Luke,
When writing a blog post on that, could you please describe
performance implications that this new feature will carry?
AFAIU, compared to a standard way of using temporary variables, pipes
will allow to not increment REFCNT of objects being piped into.
Therefore peak memory usage could be lower in some cases.

As for brackets required on RHS, I think it makes sense to be
consistent and either require brackets for anonymous functions the
same way we require for function name, or not require brackets for
both of them.

Best,
Jan

On Sat, Dec 5, 2020 at 8:10 PM <luke-tierney at uiowa.edu> wrote:
>
> We went back and forth on this several times. The key advantage of
> requiring parentheses is to keep things simple and consistent.  Let's
> get some experience with that. If experience shows requiring
> parentheses creates too many issues then we can add the option of
> dropping them later (with special handling of :: and :::). It's easier
> to add flexibility and complexity than to restrict it after the fact.
>
> Best,
>
> luke
>
> On Sat, 5 Dec 2020, Hugh Parsonage wrote:
>
> > I'm surprised by the aversion to
> >
> > mtcars |> nrow
> >
> > over
> >
> > mtcars |> nrow()
> >
> > and I think the decision to disallow the former should be
> > reconsidered.  The pipe operator is only going to be used when the rhs
> > is a function, so there is no ambiguity with omitting the parentheses.
> > If it's disallowed, it becomes inconsistent with other treatments like
> > sapply(mtcars, typeof) where sapply(mtcars, typeof()) would just be
> > noise.  I'm not sure why this decision was taken
> >
> > If the only issue is with the double (and triple) colon operator, then
> > ideally `mtcars |> base::head` should resolve to `base::head(mtcars)`
> > -- in other words, demote the precedence of |>
> >
> > Obviously (looking at the R-Syntax branch) this decision was
> > considered, put into place, then dropped, but I can't see why
> > precisely.
> >
> > Best,
> >
> >
> > Hugh.
> >
> >
> >
> >
> >
> >
> >
> > On Sat, 5 Dec 2020 at 04:07, Deepayan Sarkar <deepayan.sarkar at gmail.com> wrote:
> >>
> >> On Fri, Dec 4, 2020 at 7:35 PM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
> >>>
> >>> On 04/12/2020 8:13 a.m., Hiroaki Yutani wrote:
> >>>>>   Error: function '::' not supported in RHS call of a pipe
> >>>>
> >>>> To me, this error looks much more friendly than magrittr's error.
> >>>> Some of them got too used to specify functions without (). This
> >>>> is OK until they use `::`, but when they need to use it, it takes
> >>>> hours to figure out why
> >>>>
> >>>> mtcars %>% base::head
> >>>> #> Error in .::base : unused argument (head)
> >>>>
> >>>> won't work but
> >>>>
> >>>> mtcars %>% head
> >>>>
> >>>> works. I think this is a too harsh lesson for ordinary R users to
> >>>> learn `::` is a function. I've been wanting for magrittr to drop the
> >>>> support for a function name without () to avoid this confusion,
> >>>> so I would very much welcome the new pipe operator's behavior.
> >>>> Thank you all the developers who implemented this!
> >>>
> >>> I agree, it's an improvement on the corresponding magrittr error.
> >>>
> >>> I think the semantics of not evaluating the RHS, but treating the pipe
> >>> as purely syntactical is a good decision.
> >>>
> >>> I'm not sure I like the recommended way to pipe into a particular argument:
> >>>
> >>>    mtcars |> subset(cyl == 4) |> \(d) lm(mpg ~ disp, data = d)
> >>>
> >>> or
> >>>
> >>>    mtcars |> subset(cyl == 4) |> function(d) lm(mpg ~ disp, data = d)
> >>>
> >>> both of which are equivalent to
> >>>
> >>>    mtcars |> subset(cyl == 4) |> (function(d) lm(mpg ~ disp, data = d))()
> >>>
> >>> It's tempting to suggest it should allow something like
> >>>
> >>>    mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
> >>
> >> Which is really not that far off from
> >>
> >> mtcars |> subset(cyl == 4) |> \(.) lm(mpg ~ disp, data = .)
> >>
> >> once you get used to it.
> >>
> >> One consequence of the implementation is that it's not clear how
> >> multiple occurrences of the placeholder would be interpreted. With
> >> magrittr,
> >>
> >> sort(runif(10)) %>% ecdf(.)(.)
> >> ## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
> >>
> >> This is probably what you would expect, if you expect it to work at all, and not
> >>
> >> ecdf(sort(runif(10)))(sort(runif(10)))
> >>
> >> There would be no such ambiguity with anonymous functions
> >>
> >> sort(runif(10)) |> \(.) ecdf(.)(.)
> >>
> >> -Deepayan
> >>
> >>> which would be expanded to something equivalent to the other versions:
> >>> but that makes it quite a bit more complicated.  (Maybe _ or \. should
> >>> be used instead of ., since those are not legal variable names.)
> >>>
> >>> I don't think there should be an attempt to copy magrittr's special
> >>> casing of how . is used in determining whether to also include the
> >>> previous value as first argument.
> >>>
> >>> Duncan Murdoch
> >>>
> >>>
> >>>>
> >>>> Best,
> >>>> Hiroaki Yutani
> >>>>
> >>>> 2020?12?4?(?) 20:51 Duncan Murdoch <murdoch.duncan at gmail.com>:
> >>>>>
> >>>>> Just saw this on the R-devel news:
> >>>>>
> >>>>>
> >>>>> R now provides a simple native pipe syntax ?|>? as well as a shorthand
> >>>>> notation for creating functions, e.g. ?\(x) x + 1? is parsed as
> >>>>> ?function(x) x + 1?. The pipe implementation as a syntax transformation
> >>>>> was motivated by suggestions from Jim Hester and Lionel Henry. These
> >>>>> features are experimental and may change prior to release.
> >>>>>
> >>>>>
> >>>>> This is a good addition; by using "|>" instead of "%>%" there should be
> >>>>> a chance to get operator precedence right.  That said, the ?Syntax help
> >>>>> topic hasn't been updated, so I'm not sure where it fits in.
> >>>>>
> >>>>> There are some choices that take a little getting used to:
> >>>>>
> >>>>>  > mtcars |> head
> >>>>> Error: The pipe operator requires a function call or an anonymous
> >>>>> function expression as RHS
> >>>>>
> >>>>> (I need to say mtcars |> head() instead.)  This sometimes leads to error
> >>>>> messages that are somewhat confusing:
> >>>>>
> >>>>>  > mtcars |> magrittr::debug_pipe |> head
> >>>>> Error: function '::' not supported in RHS call of a pipe
> >>>>>
> >>>>> but
> >>>>>
> >>>>> mtcars |> magrittr::debug_pipe() |> head()
> >>>>>
> >>>>> works.
> >>>>>
> >>>>> Overall, I think this is a great addition, though it's going to be
> >>>>> disruptive for a while.
> >>>>>
> >>>>> Duncan Murdoch
> >>>>>
> >>>>> ______________________________________________
> >>>>> R-devel at r-project.org mailing list
> >>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>>>
> >>>> ______________________________________________
> >>>> R-devel at r-project.org mailing list
> >>>> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>>>
> >>>
> >>> ______________________________________________
> >>> R-devel at r-project.org mailing list
> >>> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>
> >> ______________________________________________
> >> R-devel at r-project.org mailing list
> >> https://stat.ethz.ch/mailman/listinfo/r-devel
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
> >
>
> --
> Luke Tierney
> Ralph E. Wareham Professor of Mathematical Sciences
> University of Iowa                  Phone:             319-335-3386
> Department of Statistics and        Fax:               319-335-3017
>     Actuarial Science
> 241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
> Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From j@goreck| @end|ng |rom w|t@edu@p|  Sun Dec  6 12:04:05 2020
From: j@goreck| @end|ng |rom w|t@edu@p| (Jan Gorecki)
Date: Sun, 6 Dec 2020 13:04:05 +0200
Subject: [Rd] as.POSIXct.numeric change default of origin argument
Message-ID: <CAOO9MKUcye7E00SBEGWMQpCR-Z9q6yAdM0nM=QqRqb8T8jfRbA@mail.gmail.com>

Hello all,

I would like to propose to change the default value for "origin"
argument in as.POSIXct.numeric method, from current missing to new
"1970-01-01".
My proposal is motivated by the fact that this is the most commonly
needed value for "origin" argument and having that as a default seems
reasonable.
Proposed change seems to be pretty safe because it is now an error.

Best Regards,
Jan Gorecki


From @pencer@gr@ve@ @end|ng |rom prod@y@e@com  Sun Dec  6 12:53:52 2020
From: @pencer@gr@ve@ @end|ng |rom prod@y@e@com (Spencer Graves)
Date: Sun, 6 Dec 2020 05:53:52 -0600
Subject: [Rd] as.POSIXct.numeric change default of origin argument
In-Reply-To: <CAOO9MKUcye7E00SBEGWMQpCR-Z9q6yAdM0nM=QqRqb8T8jfRbA@mail.gmail.com>
References: <CAOO9MKUcye7E00SBEGWMQpCR-Z9q6yAdM0nM=QqRqb8T8jfRbA@mail.gmail.com>
Message-ID: <bc16e8bd-e54f-ad35-8c28-272aa3c735a4@prodsyse.com>

	  The fda package already includes as.POSIXct1970, which also sets 
tz="GMT" by default.


	  I made the equivalent thing for as.Date available as 
"Ecfun::as.Date1970".


	  If the Core R team doesn't want to make the change for the existing 
functions, they might consider adding alternatives like this.  And, of 
course, Jan Gorecki and others can use these (if they aren't already 
using them or something equivalent).


	  sg


On 2020-12-06 05:04, Jan Gorecki wrote:
> Hello all,
> 
> I would like to propose to change the default value for "origin"
> argument in as.POSIXct.numeric method, from current missing to new
> "1970-01-01".
> My proposal is motivated by the fact that this is the most commonly
> needed value for "origin" argument and having that as a default seems
> reasonable.
> Proposed change seems to be pretty safe because it is now an error.
> 
> Best Regards,
> Jan Gorecki
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


From Ach|m@Ze||e|@ @end|ng |rom u|bk@@c@@t  Sun Dec  6 13:10:29 2020
From: Ach|m@Ze||e|@ @end|ng |rom u|bk@@c@@t (Achim Zeileis)
Date: Sun, 6 Dec 2020 13:10:29 +0100 (CET)
Subject: [Rd] as.POSIXct.numeric change default of origin argument
In-Reply-To: <CAOO9MKUcye7E00SBEGWMQpCR-Z9q6yAdM0nM=QqRqb8T8jfRbA@mail.gmail.com>
References: <CAOO9MKUcye7E00SBEGWMQpCR-Z9q6yAdM0nM=QqRqb8T8jfRbA@mail.gmail.com>
Message-ID: <e31ea570-3ca6-dcc7-4b95-e46f66b8a849@uibk.ac.at>

On Sun, 6 Dec 2020, Jan Gorecki wrote:

> Hello all,
>
> I would like to propose to change the default value for "origin"
> argument in as.POSIXct.numeric method, from current missing to new
> "1970-01-01".
> My proposal is motivated by the fact that this is the most commonly
> needed value for "origin" argument and having that as a default seems
> reasonable.
> Proposed change seems to be pretty safe because it is now an error.

I would also be in favor of this (and have been for years), mostly to make 
it consistent with the as.numeric() method. Same for "Date".

To support the latter, the "zoo" package provides a separate as.Date() 
generic that enables the as.Date.numeric() with different default.

The main argument of R Core against it is that it is too uncertain whether 
the origin is really 1970-01-01, e.g., when importing from Excel or SAS.

Best wishes,
Z

> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


From toth@dene@ @end|ng |rom kogentum@hu  Sun Dec  6 15:43:26 2020
From: toth@dene@ @end|ng |rom kogentum@hu (=?UTF-8?B?RMOpbmVzIFTDs3Ro?=)
Date: Sun, 6 Dec 2020 15:43:26 +0100
Subject: [Rd] [External] Re: New pipe operator
In-Reply-To: <alpine.DEB.2.21.2012051203250.3003@luke-Latitude-7480>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <alpine.DEB.2.21.2012051203250.3003@luke-Latitude-7480>
Message-ID: <b1540fd5-339b-1a4c-440e-b683c86b4315@kogentum.hu>

Dear Luke,

In the meantime I checked the R-syntax branch and the docs; they are 
very helpful. I would also like to thank you for putting effort into 
this feature. Keeping it at the syntax level is also a very smart 
decision. However, the current API might not exploit the full power of 
the basic idea.

1) Requiring either an anonymous function or a function call, but not 
allowing for symbols which point to functions is inconsistent and will 
be misleading for non-experts.

foo <- function(x) x
identical(foo, function(x) x)

mtcars |> foo               #bang!
mtcars |> function(x) x     #fine?

You stated in :
"
Another variation supported by the implementation is that a symbol on
the RHS is interpreted as the name of a function to call with the LHS
as argument:

```r
 > quote(x |> f)
f(x)
```
"

So clearly this is not an implementation issue but a design decision.

As a remedy, two different pipe operators could be introduced:

LHS |> RHS    -> RHS is treated as a function call
LHS |>> RHS   -> RHS is treated as a function

If |>> is used, it would not matter which notation is used for the RHS 
expression; the parser would assume it evaluates to a function.

2) Simplified lambda expression:
IMHO in the vast majority of use cases, this is used for single-argument 
functions, so parenthesis would not be required. Hence, both forms would 
be valid and equivalent:

\x x + 1
\(x) x + 1


3) Function composition:
Allowing for concise composition of functions would be a great feature. 
E.g., instead of

foo <- function(x) print(mean(sqrt(x), na.rm = TRUE), digits = 2)

or

foo <- \x {x |> sqrt() |> mean(na.rm = TRUE) |> print(digits = 2)}

one could write

foo <- \x |> sqrt() |> mean(na.rm = TRUE) |> print(digits = 2)

So basically if the lambda argument is followed by a pipe operator, the 
pipe chain is transformed to a function body where the first lambda 
argument is inserted into the first position of the pipeline.


Best,
Denes


On 12/5/20 7:10 PM, luke-tierney at uiowa.edu wrote:
> We went back and forth on this several times. The key advantage of
> requiring parentheses is to keep things simple and consistent.? Let's
> get some experience with that. If experience shows requiring
> parentheses creates too many issues then we can add the option of
> dropping them later (with special handling of :: and :::). It's easier
> to add flexibility and complexity than to restrict it after the fact.
> 
> Best,
> 
> luke
> 
> On Sat, 5 Dec 2020, Hugh Parsonage wrote:
> 
>> I'm surprised by the aversion to
>>
>> mtcars |> nrow
>>
>> over
>>
>> mtcars |> nrow()
>>
>> and I think the decision to disallow the former should be
>> reconsidered.? The pipe operator is only going to be used when the rhs
>> is a function, so there is no ambiguity with omitting the parentheses.
>> If it's disallowed, it becomes inconsistent with other treatments like
>> sapply(mtcars, typeof) where sapply(mtcars, typeof()) would just be
>> noise.? I'm not sure why this decision was taken
>>
>> If the only issue is with the double (and triple) colon operator, then
>> ideally `mtcars |> base::head` should resolve to `base::head(mtcars)`
>> -- in other words, demote the precedence of |>
>>
>> Obviously (looking at the R-Syntax branch) this decision was
>> considered, put into place, then dropped, but I can't see why
>> precisely.
>>
>> Best,
>>
>>
>> Hugh.
>>
>>
>>
>>
>>
>>
>>
>> On Sat, 5 Dec 2020 at 04:07, Deepayan Sarkar 
>> <deepayan.sarkar at gmail.com> wrote:
>>>
>>> On Fri, Dec 4, 2020 at 7:35 PM Duncan Murdoch 
>>> <murdoch.duncan at gmail.com> wrote:
>>>>
>>>> On 04/12/2020 8:13 a.m., Hiroaki Yutani wrote:
>>>>>> ? Error: function '::' not supported in RHS call of a pipe
>>>>>
>>>>> To me, this error looks much more friendly than magrittr's error.
>>>>> Some of them got too used to specify functions without (). This
>>>>> is OK until they use `::`, but when they need to use it, it takes
>>>>> hours to figure out why
>>>>>
>>>>> mtcars %>% base::head
>>>>> #> Error in .::base : unused argument (head)
>>>>>
>>>>> won't work but
>>>>>
>>>>> mtcars %>% head
>>>>>
>>>>> works. I think this is a too harsh lesson for ordinary R users to
>>>>> learn `::` is a function. I've been wanting for magrittr to drop the
>>>>> support for a function name without () to avoid this confusion,
>>>>> so I would very much welcome the new pipe operator's behavior.
>>>>> Thank you all the developers who implemented this!
>>>>
>>>> I agree, it's an improvement on the corresponding magrittr error.
>>>>
>>>> I think the semantics of not evaluating the RHS, but treating the pipe
>>>> as purely syntactical is a good decision.
>>>>
>>>> I'm not sure I like the recommended way to pipe into a particular 
>>>> argument:
>>>>
>>>> ?? mtcars |> subset(cyl == 4) |> \(d) lm(mpg ~ disp, data = d)
>>>>
>>>> or
>>>>
>>>> ?? mtcars |> subset(cyl == 4) |> function(d) lm(mpg ~ disp, data = d)
>>>>
>>>> both of which are equivalent to
>>>>
>>>> ?? mtcars |> subset(cyl == 4) |> (function(d) lm(mpg ~ disp, data = 
>>>> d))()
>>>>
>>>> It's tempting to suggest it should allow something like
>>>>
>>>> ?? mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
>>>
>>> Which is really not that far off from
>>>
>>> mtcars |> subset(cyl == 4) |> \(.) lm(mpg ~ disp, data = .)
>>>
>>> once you get used to it.
>>>
>>> One consequence of the implementation is that it's not clear how
>>> multiple occurrences of the placeholder would be interpreted. With
>>> magrittr,
>>>
>>> sort(runif(10)) %>% ecdf(.)(.)
>>> ## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
>>>
>>> This is probably what you would expect, if you expect it to work at 
>>> all, and not
>>>
>>> ecdf(sort(runif(10)))(sort(runif(10)))
>>>
>>> There would be no such ambiguity with anonymous functions
>>>
>>> sort(runif(10)) |> \(.) ecdf(.)(.)
>>>
>>> -Deepayan
>>>
>>>> which would be expanded to something equivalent to the other versions:
>>>> but that makes it quite a bit more complicated.? (Maybe _ or \. should
>>>> be used instead of ., since those are not legal variable names.)
>>>>
>>>> I don't think there should be an attempt to copy magrittr's special
>>>> casing of how . is used in determining whether to also include the
>>>> previous value as first argument.
>>>>
>>>> Duncan Murdoch
>>>>
>>>>
>>>>>
>>>>> Best,
>>>>> Hiroaki Yutani
>>>>>
>>>>> 2020?12?4?(?) 20:51 Duncan Murdoch <murdoch.duncan at gmail.com>:
>>>>>>
>>>>>> Just saw this on the R-devel news:
>>>>>>
>>>>>>
>>>>>> R now provides a simple native pipe syntax ?|>? as well as a 
>>>>>> shorthand
>>>>>> notation for creating functions, e.g. ?\(x) x + 1? is parsed as
>>>>>> ?function(x) x + 1?. The pipe implementation as a syntax 
>>>>>> transformation
>>>>>> was motivated by suggestions from Jim Hester and Lionel Henry. These
>>>>>> features are experimental and may change prior to release.
>>>>>>
>>>>>>
>>>>>> This is a good addition; by using "|>" instead of "%>%" there 
>>>>>> should be
>>>>>> a chance to get operator precedence right.? That said, the ?Syntax 
>>>>>> help
>>>>>> topic hasn't been updated, so I'm not sure where it fits in.
>>>>>>
>>>>>> There are some choices that take a little getting used to:
>>>>>>
>>>>>> ?> mtcars |> head
>>>>>> Error: The pipe operator requires a function call or an anonymous
>>>>>> function expression as RHS
>>>>>>
>>>>>> (I need to say mtcars |> head() instead.)? This sometimes leads to 
>>>>>> error
>>>>>> messages that are somewhat confusing:
>>>>>>
>>>>>> ?> mtcars |> magrittr::debug_pipe |> head
>>>>>> Error: function '::' not supported in RHS call of a pipe
>>>>>>
>>>>>> but
>>>>>>
>>>>>> mtcars |> magrittr::debug_pipe() |> head()
>>>>>>
>>>>>> works.
>>>>>>
>>>>>> Overall, I think this is a great addition, though it's going to be
>>>>>> disruptive for a while.
>>>>>>
>>>>>> Duncan Murdoch
>>>>>>
>>>>>> ______________________________________________
>>>>>> R-devel at r-project.org mailing list
>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>
>>>>> ______________________________________________
>>>>> R-devel at r-project.org mailing list
>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>
>>>>
>>>> ______________________________________________
>>>> R-devel at r-project.org mailing list
>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>


From ggrothend|eck @end|ng |rom gm@||@com  Sun Dec  6 15:47:29 2020
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Sun, 6 Dec 2020 09:47:29 -0500
Subject: [Rd] as.POSIXct.numeric change default of origin argument
In-Reply-To: <e31ea570-3ca6-dcc7-4b95-e46f66b8a849@uibk.ac.at>
References: <CAOO9MKUcye7E00SBEGWMQpCR-Z9q6yAdM0nM=QqRqb8T8jfRbA@mail.gmail.com>
 <e31ea570-3ca6-dcc7-4b95-e46f66b8a849@uibk.ac.at>
Message-ID: <CAP01uR=eEJ276wLubM4HFfqaH1YhY=tUcWZMdsqUUo1MRaXdwQ@mail.gmail.com>

For example, this works:

  library(zoo)
  as.Date(0)
  ## [1] "1970-01-01"

On Sun, Dec 6, 2020 at 7:10 AM Achim Zeileis <Achim.Zeileis at uibk.ac.at> wrote:
>
> On Sun, 6 Dec 2020, Jan Gorecki wrote:
>
> > Hello all,
> >
> > I would like to propose to change the default value for "origin"
> > argument in as.POSIXct.numeric method, from current missing to new
> > "1970-01-01".
> > My proposal is motivated by the fact that this is the most commonly
> > needed value for "origin" argument and having that as a default seems
> > reasonable.
> > Proposed change seems to be pretty safe because it is now an error.
>
> I would also be in favor of this (and have been for years), mostly to make
> it consistent with the as.numeric() method. Same for "Date".
>
> To support the latter, the "zoo" package provides a separate as.Date()
> generic that enables the as.Date.numeric() with different default.
>
> The main argument of R Core against it is that it is too uncertain whether
> the origin is really 1970-01-01, e.g., when importing from Excel or SAS.
>
> Best wishes,
> Z
>
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
> >
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel



-- 
Statistics & Software Consulting
GKX Group, GKX Associates Inc.
tel: 1-877-GKX-GROUP
email: ggrothendieck at gmail.com


From ggrothend|eck @end|ng |rom gm@||@com  Sun Dec  6 16:27:42 2020
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Sun, 6 Dec 2020 10:27:42 -0500
Subject: [Rd] installling R-devel on Windows
In-Reply-To: <CAP01uR=bZCaH8TQP5Yhf4pc62vmbfNOMvJNdXJYZ1Pjvp9Qgbw@mail.gmail.com>
References: <CAP01uRmSCkwj-yJ0+KXSGn_rWV9NBKmbVWxuoA4t2fp5daVY8A@mail.gmail.com>
 <CABFfbXtJKwBQtUQst33_RdNPeiE9dMSX2YCGS+5y+zEjD1KWMA@mail.gmail.com>
 <CAP01uR=bZCaH8TQP5Yhf4pc62vmbfNOMvJNdXJYZ1Pjvp9Qgbw@mail.gmail.com>
Message-ID: <CAP01uRmxcvvjdpNXAqE+_wpk7-arethm+jwEaCH+a9-RXK1few@mail.gmail.com>

I tried it from another computer and it did work.  Is there some way
of installing R devel using the analog of the R --vanilla flag so that I can
do it in a reproducible manner. It seems to remember prior settings
and maybe that is a problem although one would not expect a setting
that could lead to what occurs.  I don't see anything documenting flags
on the Rtools40 page.

On Sat, Dec 5, 2020 at 9:52 AM Gabor Grothendieck
<ggrothendieck at gmail.com> wrote:
>
> I clicked on the download link at
> https://cran.r-project.org/bin/windows/base/rdevel.html
> and then opened the downloaded file which starts the installation process.
> I specified a new directory that does not exist, R-test, to be sure that
> it would not get confused with an old directory.
>
> I repeated this using different directories and on different days.
>
> I tried it from a user and an Admin account.
>
> If I use the exact same procedure to install R-4.0.3patched it works.
>
> I have successfully downloaded and installed R maybe hundreds
> of times over the last 10 to 20 years and have never before
> encountered this.
>
>
>
>
>
> On Sat, Dec 5, 2020 at 9:13 AM Jeroen Ooms <jeroenooms at gmail.com> wrote:
> >
> > On Sat, Dec 5, 2020 at 3:00 PM Gabor Grothendieck
> > <ggrothendieck at gmail.com> wrote:
> > >
> > > When I try to install r-devel on Windows all I get is this.  No other
> > > files.  This also occurred yesterday as well.
> >
> > It just tested it to be sure, but it works fine for me. Are you using
> > the official installer from
> > https://cran.r-project.org/bin/windows/base/rdevel.html ?
> >
> > The default install path is not R-test C:\Program Files\R\R-devel.
> > Perhaps you have old files lingering from previous installations that
> > cause permission problems during the installation process?
>
>
>
> --
> Statistics & Software Consulting
> GKX Group, GKX Associates Inc.
> tel: 1-877-GKX-GROUP
> email: ggrothendieck at gmail.com



-- 
Statistics & Software Consulting
GKX Group, GKX Associates Inc.
tel: 1-877-GKX-GROUP
email: ggrothendieck at gmail.com


From ggrothend|eck @end|ng |rom gm@||@com  Sun Dec  6 16:28:44 2020
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Sun, 6 Dec 2020 10:28:44 -0500
Subject: [Rd] installling R-devel on Windows
In-Reply-To: <CAP01uRmxcvvjdpNXAqE+_wpk7-arethm+jwEaCH+a9-RXK1few@mail.gmail.com>
References: <CAP01uRmSCkwj-yJ0+KXSGn_rWV9NBKmbVWxuoA4t2fp5daVY8A@mail.gmail.com>
 <CABFfbXtJKwBQtUQst33_RdNPeiE9dMSX2YCGS+5y+zEjD1KWMA@mail.gmail.com>
 <CAP01uR=bZCaH8TQP5Yhf4pc62vmbfNOMvJNdXJYZ1Pjvp9Qgbw@mail.gmail.com>
 <CAP01uRmxcvvjdpNXAqE+_wpk7-arethm+jwEaCH+a9-RXK1few@mail.gmail.com>
Message-ID: <CAP01uRn_EhST6vHfK6j9VijYCvg9OtBJ8R5uOAF2YExeOOLxAw@mail.gmail.com>

I meant on the R devel download page. (I was just installing Rtools40
on another computer.)

On Sun, Dec 6, 2020 at 10:27 AM Gabor Grothendieck
<ggrothendieck at gmail.com> wrote:
>
> I tried it from another computer and it did work.  Is there some way
> of installing R devel using the analog of the R --vanilla flag so that I can
> do it in a reproducible manner. It seems to remember prior settings
> and maybe that is a problem although one would not expect a setting
> that could lead to what occurs.  I don't see anything documenting flags
> on the Rtools40 page.
>
> On Sat, Dec 5, 2020 at 9:52 AM Gabor Grothendieck
> <ggrothendieck at gmail.com> wrote:
> >
> > I clicked on the download link at
> > https://cran.r-project.org/bin/windows/base/rdevel.html
> > and then opened the downloaded file which starts the installation process.
> > I specified a new directory that does not exist, R-test, to be sure that
> > it would not get confused with an old directory.
> >
> > I repeated this using different directories and on different days.
> >
> > I tried it from a user and an Admin account.
> >
> > If I use the exact same procedure to install R-4.0.3patched it works.
> >
> > I have successfully downloaded and installed R maybe hundreds
> > of times over the last 10 to 20 years and have never before
> > encountered this.
> >
> >
> >
> >
> >
> > On Sat, Dec 5, 2020 at 9:13 AM Jeroen Ooms <jeroenooms at gmail.com> wrote:
> > >
> > > On Sat, Dec 5, 2020 at 3:00 PM Gabor Grothendieck
> > > <ggrothendieck at gmail.com> wrote:
> > > >
> > > > When I try to install r-devel on Windows all I get is this.  No other
> > > > files.  This also occurred yesterday as well.
> > >
> > > It just tested it to be sure, but it works fine for me. Are you using
> > > the official installer from
> > > https://cran.r-project.org/bin/windows/base/rdevel.html ?
> > >
> > > The default install path is not R-test C:\Program Files\R\R-devel.
> > > Perhaps you have old files lingering from previous installations that
> > > cause permission problems during the installation process?
> >
> >
> >
> > --
> > Statistics & Software Consulting
> > GKX Group, GKX Associates Inc.
> > tel: 1-877-GKX-GROUP
> > email: ggrothendieck at gmail.com
>
>
>
> --
> Statistics & Software Consulting
> GKX Group, GKX Associates Inc.
> tel: 1-877-GKX-GROUP
> email: ggrothendieck at gmail.com



-- 
Statistics & Software Consulting
GKX Group, GKX Associates Inc.
tel: 1-877-GKX-GROUP
email: ggrothendieck at gmail.com


From @v|gro@@ @end|ng |rom ver|zon@net  Sun Dec  6 16:29:49 2020
From: @v|gro@@ @end|ng |rom ver|zon@net (Avi Gross)
Date: Sun, 6 Dec 2020 10:29:49 -0500
Subject: [Rd] New pipe operator
In-Reply-To: <CALyqOb-GUZXp5L3M8veguz4gNfYkpxtJGhdg7FbYAHFB6VAJLA@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CAB8pepzDHvM+JJtOcSOudyJ0Fe6-Yk2sG7Ep7qDkOK52bcuwZw@mail.gmail.com>
 <CAKorm_usbqOAxS8Xk6BeeFbPK0rg1KwMNTavrDzRgm4We+mN4g@mail.gmail.com>
 <CALyqOb-GUZXp5L3M8veguz4gNfYkpxtJGhdg7FbYAHFB6VAJLA@mail.gmail.com>
Message-ID: <02f001d6cbe4$a3125d00$e9371700$@verizon.net>

Naming is another whole topic.

I have seen suggestions that the current pipeline symbol used be phrased as THEN so

data %>% f1 %>% f2()

would be said as something like:
take data then apply f1 then f2

or some variants.

There are words other than pipe or pipeline that might also work such as "assembly line" or "conveyor belt" that might fit some kinds of pipelining better than others. My original exposure to UNIX in the early 80's used a pipeline of multiple processes whose standard input and/or standard output (and sometimes also standard error) were redirected to an anonymous "pipe" device that buffered whatever (usually) text that was thrown at it and the processes reading and writing from it were paused and restarted as needed when data was ready. Problems often could be decomposed into multiple parts that had a solution using some program and it was not unusual to do something like:

	cat *.c | grep -v ... | grep ... | sed ... | cut ... >output

Of course something like the above was often rewritten to be done within a single awk script or perl or whatever. You could view the above though from the perspective of "data" in some form, often text, being passed from one function(ality) to another and changing a bit each step of the way. A very common use of this form of pipeline was used to deal with embedded text in a different language in typsetting:

	tbl filename | eqn | pic | troff | ...

The above would open a file, pass through all lines except those between markers that specified a table starting and ending. Those lines would be processed and transformed into the troff language equivalent. The old plus new lines now went to eqn which found and transformed equations similarly then to pic which transformed instructions it knew to image descriptions in troff and finally troff processed the whole mess and then off to the printer.

Clearly the above can be seen as a data pipeline using full processes as nodes.

The way R is using the pipeline may just use functions but you can imagine it as having similarities and differences. Current implementations may be linear with lazy evaluation and with every part running to completion before the next part starts. Every "object" is fully made, then used, then often removed as a temporary object. There is no buffering. But in principle, you can make UNIX-like pipelines using parallelism within a process too. 

Would there be scenarios where phrases like "assembly line" or "conveyor belt" make sense to describe the method properly? The word pipe suggests a linearity to some whereas conveyor belts these days also can be used to selectively shunt things one way or another as in assembling all parts of your order from different parts of a warehouse and arranging they all end up in the same delivery area. Making applications do that dynamically may have other names. Think flowchart!

Time to go do something useful.

-----Original Message-----
From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Hiroaki Yutani
Sent: Saturday, December 5, 2020 10:29 PM
To: Abby Spurdle <spurdle.a at gmail.com>
Cc: r-devel <r-devel at r-project.org>
Subject: Re: [Rd] New pipe operator

It is common practice to call |> as pipe (or pipeline operator) among many languages including ones that recently introduced it as an experimental feature.
Pipeline is a
common feature for functional programming, not just for "data pipeline."

    F#: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/symbol-and-operator-reference/
    Elixir: https://hexdocs.pm/elixir/operators.html#general-operators
    Typescript:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Pipeline_operator
    Ruby: https://bugs.ruby-lang.org/issues/15799

(This blog post about the history of pipe operator might be
interesting: https://mamememo.blogspot.com/2019/06/a-brief-history-of-pipeline-operator.html
)

I agree this is a bit confusing for those who are familiar with other "pipe" concepts, but there's no other appropriate term to call |>.

2020?12?6?(?) 12:22 Gregory Warnes <greg at warnes.net>:
>
> If we?re being mathematically pedantic, the ?pipe? operator is 
> actually function composition.
>
> That being said, pipes are a simple and well-known idiom. While being less
> than mathematically exact, it seems a reasonable   label for the (very
> useful) behavior.
>
> On Sat, Dec 5, 2020 at 9:43 PM Abby Spurdle <spurdle.a at gmail.com> wrote:
>
> > > This is a good addition
> >
> > I can't understand why so many people are calling this a "pipe".
> > Pipes connect processes, via their I/O streams.
> > Arguably, a more general interpretation would include sockets and files.
> >
> > https://en.wikipedia.org/wiki/Pipeline_(Unix)
> > https://en.wikipedia.org/wiki/Named_pipe
> > https://en.wikipedia.org/wiki/Anonymous_pipe
> >
> > As far as I can tell, the magrittr-like operators are functions (not 
> > pipes), with nonstandard syntax.
> > This is not consistent with R's original design philosophy, building 
> > on C, Lisp and S, along with lots of *important* math and stats.
> >
> > It's possible that some parties are interested in creating a kind of 
> > "data pipeline".
> > I'm interested in this myself, and I think we could discuss this more.
> > But I'm not convinced the magrittr-like operators help to achieve 
> > this goal.
> > Which, in my opinion, would require one to model programs as 
> > directed graphs, along with some degree of asynchronous input.
> >
> > Presumably, these operators will be added to R anyway, and (almost) 
> > no one will listen to me.
> >
> > So, I would like to make one suggestion:
> > Is it possible for these operators to *not* be named:
> >     The R Pipe
> >     The S Pipe
> >     Or anything with a similar meaning.
> >
> > Maybe tidy pipe, or something else that links it to its proponents?
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
> >
> --
> "Whereas true religion and good morals are the only solid foundations 
> of public liberty and happiness . . . it is hereby earnestly 
> recommended to the several States to take the most effectual measures 
> for the encouragement thereof." Continental Congress, 1778
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel

______________________________________________
R-devel at r-project.org mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


Scanned by McAfee and confirmed virus-free.	
Find out more here: https://bit.ly/2zCJMrO


From murdoch@dunc@n @end|ng |rom gm@||@com  Sun Dec  6 16:32:56 2020
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Sun, 6 Dec 2020 10:32:56 -0500
Subject: [Rd] [External] Re: New pipe operator
In-Reply-To: <b1540fd5-339b-1a4c-440e-b683c86b4315@kogentum.hu>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <alpine.DEB.2.21.2012051203250.3003@luke-Latitude-7480>
 <b1540fd5-339b-1a4c-440e-b683c86b4315@kogentum.hu>
Message-ID: <294fa60b-565c-52d8-0494-10cfb61ea281@gmail.com>

On 06/12/2020 9:43 a.m., D?nes T?th wrote:
> Dear Luke,
> 
> In the meantime I checked the R-syntax branch and the docs; they are
> very helpful. I would also like to thank you for putting effort into
> this feature. Keeping it at the syntax level is also a very smart
> decision. However, the current API might not exploit the full power of
> the basic idea.
> 
> 1) Requiring either an anonymous function or a function call, but not
> allowing for symbols which point to functions is inconsistent and will
> be misleading for non-experts.
> 
> foo <- function(x) x
> identical(foo, function(x) x)
> 
> mtcars |> foo               #bang!
> mtcars |> function(x) x     #fine?

You are missing the point.  The value of the RHS is irrelevant to the 
transformation.  All that matters is its form.  So "foo" and 
"function(x) x" are completely different things, even if identical() 
thinks their value is the same.

It's also true that "foo()" and "function(x) x" are completely 
different, but they are well-defined forms:  one is a call, the other is 
an anonymous function definition.

Accepting a plain "foo" would add a third form (a name), which might 
make sense, but hardly gains anything: whereas dropping the anonymous 
function definition costs quite a bit.  Without special-casing anonymous 
function definitions you'd need to enter

mtcars |> (function(x) x)()

or

mtcars |> (\(x) x)()

which are both quite difficult to read.

Duncan Murdoch

> 
> You stated in :
> "
> Another variation supported by the implementation is that a symbol on
> the RHS is interpreted as the name of a function to call with the LHS
> as argument:
> 
> ```r
>   > quote(x |> f)
> f(x)
> ```
> "
> 
> So clearly this is not an implementation issue but a design decision.
> 
> As a remedy, two different pipe operators could be introduced:
> 
> LHS |> RHS    -> RHS is treated as a function call
> LHS |>> RHS   -> RHS is treated as a function
> 
> If |>> is used, it would not matter which notation is used for the RHS
> expression; the parser would assume it evaluates to a function.
> 
> 2) Simplified lambda expression:
> IMHO in the vast majority of use cases, this is used for single-argument
> functions, so parenthesis would not be required. Hence, both forms would
> be valid and equivalent:
> 
> \x x + 1
> \(x) x + 1
> 
> 
> 3) Function composition:
> Allowing for concise composition of functions would be a great feature.
> E.g., instead of
> 
> foo <- function(x) print(mean(sqrt(x), na.rm = TRUE), digits = 2)
> 
> or
> 
> foo <- \x {x |> sqrt() |> mean(na.rm = TRUE) |> print(digits = 2)}
> 
> one could write
> 
> foo <- \x |> sqrt() |> mean(na.rm = TRUE) |> print(digits = 2)
> 
> So basically if the lambda argument is followed by a pipe operator, the
> pipe chain is transformed to a function body where the first lambda
> argument is inserted into the first position of the pipeline.
> 
> 
> Best,
> Denes
> 
> 
> On 12/5/20 7:10 PM, luke-tierney at uiowa.edu wrote:
>> We went back and forth on this several times. The key advantage of
>> requiring parentheses is to keep things simple and consistent.? Let's
>> get some experience with that. If experience shows requiring
>> parentheses creates too many issues then we can add the option of
>> dropping them later (with special handling of :: and :::). It's easier
>> to add flexibility and complexity than to restrict it after the fact.
>>
>> Best,
>>
>> luke
>>
>> On Sat, 5 Dec 2020, Hugh Parsonage wrote:
>>
>>> I'm surprised by the aversion to
>>>
>>> mtcars |> nrow
>>>
>>> over
>>>
>>> mtcars |> nrow()
>>>
>>> and I think the decision to disallow the former should be
>>> reconsidered.? The pipe operator is only going to be used when the rhs
>>> is a function, so there is no ambiguity with omitting the parentheses.
>>> If it's disallowed, it becomes inconsistent with other treatments like
>>> sapply(mtcars, typeof) where sapply(mtcars, typeof()) would just be
>>> noise.? I'm not sure why this decision was taken
>>>
>>> If the only issue is with the double (and triple) colon operator, then
>>> ideally `mtcars |> base::head` should resolve to `base::head(mtcars)`
>>> -- in other words, demote the precedence of |>
>>>
>>> Obviously (looking at the R-Syntax branch) this decision was
>>> considered, put into place, then dropped, but I can't see why
>>> precisely.
>>>
>>> Best,
>>>
>>>
>>> Hugh.
>>>
>>>
>>>
>>>
>>>
>>>
>>>
>>> On Sat, 5 Dec 2020 at 04:07, Deepayan Sarkar
>>> <deepayan.sarkar at gmail.com> wrote:
>>>>
>>>> On Fri, Dec 4, 2020 at 7:35 PM Duncan Murdoch
>>>> <murdoch.duncan at gmail.com> wrote:
>>>>>
>>>>> On 04/12/2020 8:13 a.m., Hiroaki Yutani wrote:
>>>>>>>  ? Error: function '::' not supported in RHS call of a pipe
>>>>>>
>>>>>> To me, this error looks much more friendly than magrittr's error.
>>>>>> Some of them got too used to specify functions without (). This
>>>>>> is OK until they use `::`, but when they need to use it, it takes
>>>>>> hours to figure out why
>>>>>>
>>>>>> mtcars %>% base::head
>>>>>> #> Error in .::base : unused argument (head)
>>>>>>
>>>>>> won't work but
>>>>>>
>>>>>> mtcars %>% head
>>>>>>
>>>>>> works. I think this is a too harsh lesson for ordinary R users to
>>>>>> learn `::` is a function. I've been wanting for magrittr to drop the
>>>>>> support for a function name without () to avoid this confusion,
>>>>>> so I would very much welcome the new pipe operator's behavior.
>>>>>> Thank you all the developers who implemented this!
>>>>>
>>>>> I agree, it's an improvement on the corresponding magrittr error.
>>>>>
>>>>> I think the semantics of not evaluating the RHS, but treating the pipe
>>>>> as purely syntactical is a good decision.
>>>>>
>>>>> I'm not sure I like the recommended way to pipe into a particular
>>>>> argument:
>>>>>
>>>>>  ?? mtcars |> subset(cyl == 4) |> \(d) lm(mpg ~ disp, data = d)
>>>>>
>>>>> or
>>>>>
>>>>>  ?? mtcars |> subset(cyl == 4) |> function(d) lm(mpg ~ disp, data = d)
>>>>>
>>>>> both of which are equivalent to
>>>>>
>>>>>  ?? mtcars |> subset(cyl == 4) |> (function(d) lm(mpg ~ disp, data =
>>>>> d))()
>>>>>
>>>>> It's tempting to suggest it should allow something like
>>>>>
>>>>>  ?? mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
>>>>
>>>> Which is really not that far off from
>>>>
>>>> mtcars |> subset(cyl == 4) |> \(.) lm(mpg ~ disp, data = .)
>>>>
>>>> once you get used to it.
>>>>
>>>> One consequence of the implementation is that it's not clear how
>>>> multiple occurrences of the placeholder would be interpreted. With
>>>> magrittr,
>>>>
>>>> sort(runif(10)) %>% ecdf(.)(.)
>>>> ## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
>>>>
>>>> This is probably what you would expect, if you expect it to work at
>>>> all, and not
>>>>
>>>> ecdf(sort(runif(10)))(sort(runif(10)))
>>>>
>>>> There would be no such ambiguity with anonymous functions
>>>>
>>>> sort(runif(10)) |> \(.) ecdf(.)(.)
>>>>
>>>> -Deepayan
>>>>
>>>>> which would be expanded to something equivalent to the other versions:
>>>>> but that makes it quite a bit more complicated.? (Maybe _ or \. should
>>>>> be used instead of ., since those are not legal variable names.)
>>>>>
>>>>> I don't think there should be an attempt to copy magrittr's special
>>>>> casing of how . is used in determining whether to also include the
>>>>> previous value as first argument.
>>>>>
>>>>> Duncan Murdoch
>>>>>
>>>>>
>>>>>>
>>>>>> Best,
>>>>>> Hiroaki Yutani
>>>>>>
>>>>>> 2020?12?4?(?) 20:51 Duncan Murdoch <murdoch.duncan at gmail.com>:
>>>>>>>
>>>>>>> Just saw this on the R-devel news:
>>>>>>>
>>>>>>>
>>>>>>> R now provides a simple native pipe syntax ?|>? as well as a
>>>>>>> shorthand
>>>>>>> notation for creating functions, e.g. ?\(x) x + 1? is parsed as
>>>>>>> ?function(x) x + 1?. The pipe implementation as a syntax
>>>>>>> transformation
>>>>>>> was motivated by suggestions from Jim Hester and Lionel Henry. These
>>>>>>> features are experimental and may change prior to release.
>>>>>>>
>>>>>>>
>>>>>>> This is a good addition; by using "|>" instead of "%>%" there
>>>>>>> should be
>>>>>>> a chance to get operator precedence right.? That said, the ?Syntax
>>>>>>> help
>>>>>>> topic hasn't been updated, so I'm not sure where it fits in.
>>>>>>>
>>>>>>> There are some choices that take a little getting used to:
>>>>>>>
>>>>>>>  ?> mtcars |> head
>>>>>>> Error: The pipe operator requires a function call or an anonymous
>>>>>>> function expression as RHS
>>>>>>>
>>>>>>> (I need to say mtcars |> head() instead.)? This sometimes leads to
>>>>>>> error
>>>>>>> messages that are somewhat confusing:
>>>>>>>
>>>>>>>  ?> mtcars |> magrittr::debug_pipe |> head
>>>>>>> Error: function '::' not supported in RHS call of a pipe
>>>>>>>
>>>>>>> but
>>>>>>>
>>>>>>> mtcars |> magrittr::debug_pipe() |> head()
>>>>>>>
>>>>>>> works.
>>>>>>>
>>>>>>> Overall, I think this is a great addition, though it's going to be
>>>>>>> disruptive for a while.
>>>>>>>
>>>>>>> Duncan Murdoch
>>>>>>>
>>>>>>> ______________________________________________
>>>>>>> R-devel at r-project.org mailing list
>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>
>>>>>> ______________________________________________
>>>>>> R-devel at r-project.org mailing list
>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>
>>>>>
>>>>> ______________________________________________
>>>>> R-devel at r-project.org mailing list
>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>
>>>> ______________________________________________
>>>> R-devel at r-project.org mailing list
>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>
>>
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


From toth@dene@ @end|ng |rom kogentum@hu  Sun Dec  6 17:34:16 2020
From: toth@dene@ @end|ng |rom kogentum@hu (=?UTF-8?B?RMOpbmVzIFTDs3Ro?=)
Date: Sun, 6 Dec 2020 17:34:16 +0100
Subject: [Rd] [External] Re: New pipe operator
In-Reply-To: <294fa60b-565c-52d8-0494-10cfb61ea281@gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <alpine.DEB.2.21.2012051203250.3003@luke-Latitude-7480>
 <b1540fd5-339b-1a4c-440e-b683c86b4315@kogentum.hu>
 <294fa60b-565c-52d8-0494-10cfb61ea281@gmail.com>
Message-ID: <da1635f0-54c7-aa97-d0c1-c854b0c3ac2e@kogentum.hu>



On 12/6/20 4:32 PM, Duncan Murdoch wrote:
 > On 06/12/2020 9:43 a.m., D?nes T?th wrote:
 >> Dear Luke,
 >>
 >> In the meantime I checked the R-syntax branch and the docs; they are
 >> very helpful. I would also like to thank you for putting effort into
 >> this feature. Keeping it at the syntax level is also a very smart
 >> decision. However, the current API might not exploit the full power of
 >> the basic idea.
 >>
 >> 1) Requiring either an anonymous function or a function call, but not
 >> allowing for symbols which point to functions is inconsistent and will
 >> be misleading for non-experts.
 >>
 >> foo <- function(x) x
 >> identical(foo, function(x) x)
 >>
 >> mtcars |> foo               #bang!
 >> mtcars |> function(x) x     #fine?
 >
 > You are missing the point.  The value of the RHS is irrelevant to the
 > transformation.  All that matters is its form.  So "foo" and
 > "function(x) x" are completely different things, even if identical()
 > thinks their value is the same.

We are at the syntax level, so of course we do not know the value of the 
RHS when the parsing occurs. I *do* understand that the *form* is 
important here, but how do you explain this to a rookie R user? He will 
see that he entered two expressions which he thinks are identical, even 
though they are not identical at the level when the parsing occurs.

Also think of the potential users of this syntax. There are at least two 
groups:
1) ~95% of the users: active users of `%>%`. My experience is that the 
vast majority of them do not use the "advanced" features of magrittr; 
however, they are got used to things like mtcars |> print. Provide them 
with the RHS-as-symbol syntax and they will be happy - they have a 
plug-and-forget replacement. Or do enforce a function call - they will 
be unhappy, and will not adopt the new syntax.
2) ~5% of the users (including me): have not used magrittr or any other 
(probably better) implementations (e.g., pipeR, wrapr) of the pipe 
operator because it could lead to nasty performance issues, bugs, and 
debugging problems. However, from the functional-programming-style of 
view, these users might prefer the new syntax and as few typing as 
possible.

 >
 > It's also true that "foo()" and "function(x) x" are completely
 > different, but they are well-defined forms:  one is a call, the other is
 > an anonymous function definition.
 >
 > Accepting a plain "foo" would add a third form (a name), which might
 > make sense, but hardly gains anything:

I would reverse the argumentation: Luke has a working implementation for 
the case if the RHS is a single symbol. What do we loose if we keep it?

Best,
Denes

 > whereas dropping the anonymous
 > function definition costs quite a bit.  Without special-casing anonymous
 > function definitions you'd need to enter
 >
 > mtcars |> (function(x) x)()
 >
 > or
 >
 > mtcars |> (\(x) x)()
 >
 > which are both quite difficult to read.
 >
 > Duncan Murdoch
 >
 >>
 >> You stated in :
 >> "
 >> Another variation supported by the implementation is that a symbol on
 >> the RHS is interpreted as the name of a function to call with the LHS
 >> as argument:
 >>
 >> ```r
 >>   > quote(x |> f)
 >> f(x)
 >> ```
 >> "
 >>
 >> So clearly this is not an implementation issue but a design decision.
 >>
 >> As a remedy, two different pipe operators could be introduced:
 >>
 >> LHS |> RHS    -> RHS is treated as a function call
 >> LHS |>> RHS   -> RHS is treated as a function
 >>
 >> If |>> is used, it would not matter which notation is used for the RHS
 >> expression; the parser would assume it evaluates to a function.
 >>
 >> 2) Simplified lambda expression:
 >> IMHO in the vast majority of use cases, this is used for single-argument
 >> functions, so parenthesis would not be required. Hence, both forms would
 >> be valid and equivalent:
 >>
 >> \x x + 1
 >> \(x) x + 1
 >>
 >>
 >> 3) Function composition:
 >> Allowing for concise composition of functions would be a great feature.
 >> E.g., instead of
 >>
 >> foo <- function(x) print(mean(sqrt(x), na.rm = TRUE), digits = 2)
 >>
 >> or
 >>
 >> foo <- \x {x |> sqrt() |> mean(na.rm = TRUE) |> print(digits = 2)}
 >>
 >> one could write
 >>
 >> foo <- \x |> sqrt() |> mean(na.rm = TRUE) |> print(digits = 2)
 >>
 >> So basically if the lambda argument is followed by a pipe operator, the
 >> pipe chain is transformed to a function body where the first lambda
 >> argument is inserted into the first position of the pipeline.
 >>
 >>
 >> Best,
 >> Denes
 >>
 >>
 >> On 12/5/20 7:10 PM, luke-tierney at uiowa.edu wrote:
 >>> We went back and forth on this several times. The key advantage of
 >>> requiring parentheses is to keep things simple and consistent.  Let's
 >>> get some experience with that. If experience shows requiring
 >>> parentheses creates too many issues then we can add the option of
 >>> dropping them later (with special handling of :: and :::). It's easier
 >>> to add flexibility and complexity than to restrict it after the fact.
 >>>
 >>> Best,
 >>>
 >>> luke
 >>>
 >>> On Sat, 5 Dec 2020, Hugh Parsonage wrote:
 >>>
 >>>> I'm surprised by the aversion to
 >>>>
 >>>> mtcars |> nrow
 >>>>
 >>>> over
 >>>>
 >>>> mtcars |> nrow()
 >>>>
 >>>> and I think the decision to disallow the former should be
 >>>> reconsidered.  The pipe operator is only going to be used when the rhs
 >>>> is a function, so there is no ambiguity with omitting the parentheses.
 >>>> If it's disallowed, it becomes inconsistent with other treatments like
 >>>> sapply(mtcars, typeof) where sapply(mtcars, typeof()) would just be
 >>>> noise.  I'm not sure why this decision was taken
 >>>>
 >>>> If the only issue is with the double (and triple) colon operator, then
 >>>> ideally `mtcars |> base::head` should resolve to `base::head(mtcars)`
 >>>> -- in other words, demote the precedence of |>
 >>>>
 >>>> Obviously (looking at the R-Syntax branch) this decision was
 >>>> considered, put into place, then dropped, but I can't see why
 >>>> precisely.
 >>>>
 >>>> Best,
 >>>>
 >>>>
 >>>> Hugh.
 >>>>
 >>>>
 >>>>
 >>>>
 >>>>
 >>>>
 >>>>
 >>>> On Sat, 5 Dec 2020 at 04:07, Deepayan Sarkar
 >>>> <deepayan.sarkar at gmail.com> wrote:
 >>>>>
 >>>>> On Fri, Dec 4, 2020 at 7:35 PM Duncan Murdoch
 >>>>> <murdoch.duncan at gmail.com> wrote:
 >>>>>>
 >>>>>> On 04/12/2020 8:13 a.m., Hiroaki Yutani wrote:
 >>>>>>>>    Error: function '::' not supported in RHS call of a pipe
 >>>>>>>
 >>>>>>> To me, this error looks much more friendly than magrittr's error.
 >>>>>>> Some of them got too used to specify functions without (). This
 >>>>>>> is OK until they use `::`, but when they need to use it, it takes
 >>>>>>> hours to figure out why
 >>>>>>>
 >>>>>>> mtcars %>% base::head
 >>>>>>> #> Error in .::base : unused argument (head)
 >>>>>>>
 >>>>>>> won't work but
 >>>>>>>
 >>>>>>> mtcars %>% head
 >>>>>>>
 >>>>>>> works. I think this is a too harsh lesson for ordinary R users to
 >>>>>>> learn `::` is a function. I've been wanting for magrittr to 
drop the
 >>>>>>> support for a function name without () to avoid this confusion,
 >>>>>>> so I would very much welcome the new pipe operator's behavior.
 >>>>>>> Thank you all the developers who implemented this!
 >>>>>>
 >>>>>> I agree, it's an improvement on the corresponding magrittr error.
 >>>>>>
 >>>>>> I think the semantics of not evaluating the RHS, but treating the
 >>>>>> pipe
 >>>>>> as purely syntactical is a good decision.
 >>>>>>
 >>>>>> I'm not sure I like the recommended way to pipe into a particular
 >>>>>> argument:
 >>>>>>
 >>>>>>     mtcars |> subset(cyl == 4) |> \(d) lm(mpg ~ disp, data = d)
 >>>>>>
 >>>>>> or
 >>>>>>
 >>>>>>     mtcars |> subset(cyl == 4) |> function(d) lm(mpg ~ disp, data
 >>>>>> = d)
 >>>>>>
 >>>>>> both of which are equivalent to
 >>>>>>
 >>>>>>     mtcars |> subset(cyl == 4) |> (function(d) lm(mpg ~ disp, data =
 >>>>>> d))()
 >>>>>>
 >>>>>> It's tempting to suggest it should allow something like
 >>>>>>
 >>>>>>     mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
 >>>>>
 >>>>> Which is really not that far off from
 >>>>>
 >>>>> mtcars |> subset(cyl == 4) |> \(.) lm(mpg ~ disp, data = .)
 >>>>>
 >>>>> once you get used to it.
 >>>>>
 >>>>> One consequence of the implementation is that it's not clear how
 >>>>> multiple occurrences of the placeholder would be interpreted. With
 >>>>> magrittr,
 >>>>>
 >>>>> sort(runif(10)) %>% ecdf(.)(.)
 >>>>> ## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
 >>>>>
 >>>>> This is probably what you would expect, if you expect it to work at
 >>>>> all, and not
 >>>>>
 >>>>> ecdf(sort(runif(10)))(sort(runif(10)))
 >>>>>
 >>>>> There would be no such ambiguity with anonymous functions
 >>>>>
 >>>>> sort(runif(10)) |> \(.) ecdf(.)(.)
 >>>>>
 >>>>> -Deepayan
 >>>>>
 >>>>>> which would be expanded to something equivalent to the other
 >>>>>> versions:
 >>>>>> but that makes it quite a bit more complicated.  (Maybe _ or \.
 >>>>>> should
 >>>>>> be used instead of ., since those are not legal variable names.)
 >>>>>>
 >>>>>> I don't think there should be an attempt to copy magrittr's special
 >>>>>> casing of how . is used in determining whether to also include the
 >>>>>> previous value as first argument.
 >>>>>>
 >>>>>> Duncan Murdoch
 >>>>>>
 >>>>>>
 >>>>>>>
 >>>>>>> Best,
 >>>>>>> Hiroaki Yutani
 >>>>>>>
 >>>>>>> 2020?12?4?(?) 20:51 Duncan Murdoch <murdoch.duncan at gmail.com>:
 >>>>>>>>
 >>>>>>>> Just saw this on the R-devel news:
 >>>>>>>>
 >>>>>>>>
 >>>>>>>> R now provides a simple native pipe syntax ?|>? as well as a
 >>>>>>>> shorthand
 >>>>>>>> notation for creating functions, e.g. ?\(x) x + 1? is parsed as
 >>>>>>>> ?function(x) x + 1?. The pipe implementation as a syntax
 >>>>>>>> transformation
 >>>>>>>> was motivated by suggestions from Jim Hester and Lionel Henry.
 >>>>>>>> These
 >>>>>>>> features are experimental and may change prior to release.
 >>>>>>>>
 >>>>>>>>
 >>>>>>>> This is a good addition; by using "|>" instead of "%>%" there
 >>>>>>>> should be
 >>>>>>>> a chance to get operator precedence right.  That said, the ?Syntax
 >>>>>>>> help
 >>>>>>>> topic hasn't been updated, so I'm not sure where it fits in.
 >>>>>>>>
 >>>>>>>> There are some choices that take a little getting used to:
 >>>>>>>>
 >>>>>>>>   > mtcars |> head
 >>>>>>>> Error: The pipe operator requires a function call or an anonymous
 >>>>>>>> function expression as RHS
 >>>>>>>>
 >>>>>>>> (I need to say mtcars |> head() instead.)  This sometimes leads to
 >>>>>>>> error
 >>>>>>>> messages that are somewhat confusing:
 >>>>>>>>
 >>>>>>>>   > mtcars |> magrittr::debug_pipe |> head
 >>>>>>>> Error: function '::' not supported in RHS call of a pipe
 >>>>>>>>
 >>>>>>>> but
 >>>>>>>>
 >>>>>>>> mtcars |> magrittr::debug_pipe() |> head()
 >>>>>>>>
 >>>>>>>> works.
 >>>>>>>>
 >>>>>>>> Overall, I think this is a great addition, though it's going to be
 >>>>>>>> disruptive for a while.
 >>>>>>>>
 >>>>>>>> Duncan Murdoch
 >>>>>>>>
 >>>>>>>> ______________________________________________
 >>>>>>>> R-devel at r-project.org mailing list
 >>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
 >>>>>>>
 >>>>>>> ______________________________________________
 >>>>>>> R-devel at r-project.org mailing list
 >>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
 >>>>>>>
 >>>>>>
 >>>>>> ______________________________________________
 >>>>>> R-devel at r-project.org mailing list
 >>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
 >>>>>
 >>>>> ______________________________________________
 >>>>> R-devel at r-project.org mailing list
 >>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
 >>>>
 >>>> ______________________________________________
 >>>> R-devel at r-project.org mailing list
 >>>> https://stat.ethz.ch/mailman/listinfo/r-devel
 >>>>
 >>>
 >>
 >> ______________________________________________
 >> R-devel at r-project.org mailing list
 >> https://stat.ethz.ch/mailman/listinfo/r-devel
 >>
 >
 >


From murdoch@dunc@n @end|ng |rom gm@||@com  Sun Dec  6 17:50:11 2020
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Sun, 6 Dec 2020 11:50:11 -0500
Subject: [Rd] [External] Re: New pipe operator
In-Reply-To: <da1635f0-54c7-aa97-d0c1-c854b0c3ac2e@kogentum.hu>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <alpine.DEB.2.21.2012051203250.3003@luke-Latitude-7480>
 <b1540fd5-339b-1a4c-440e-b683c86b4315@kogentum.hu>
 <294fa60b-565c-52d8-0494-10cfb61ea281@gmail.com>
 <da1635f0-54c7-aa97-d0c1-c854b0c3ac2e@kogentum.hu>
Message-ID: <d3b16e2f-d6f8-9df5-2320-a00823d75053@gmail.com>

On 06/12/2020 11:34 a.m., D?nes T?th wrote:
> 
> 
> On 12/6/20 4:32 PM, Duncan Murdoch wrote:
>   > On 06/12/2020 9:43 a.m., D?nes T?th wrote:
>   >> Dear Luke,
>   >>
>   >> In the meantime I checked the R-syntax branch and the docs; they are
>   >> very helpful. I would also like to thank you for putting effort into
>   >> this feature. Keeping it at the syntax level is also a very smart
>   >> decision. However, the current API might not exploit the full power of
>   >> the basic idea.
>   >>
>   >> 1) Requiring either an anonymous function or a function call, but not
>   >> allowing for symbols which point to functions is inconsistent and will
>   >> be misleading for non-experts.
>   >>
>   >> foo <- function(x) x
>   >> identical(foo, function(x) x)
>   >>
>   >> mtcars |> foo               #bang!
>   >> mtcars |> function(x) x     #fine?
>   >
>   > You are missing the point.  The value of the RHS is irrelevant to the
>   > transformation.  All that matters is its form.  So "foo" and
>   > "function(x) x" are completely different things, even if identical()
>   > thinks their value is the same.
> 
> We are at the syntax level, so of course we do not know the value of the
> RHS when the parsing occurs. I *do* understand that the *form* is
> important here, but how do you explain this to a rookie R user? 

I would explain that you almost always need the parens.  Rookies don't 
need to learn about anonymous functions instantly.  Once they get to the 
point of learning about anonymous functions, I'd say they are the sole 
exception to needing parens.

He will
> see that he entered two expressions which he thinks are identical, even
> though they are not identical at the level when the parsing occurs.

Allowing a name will confuse people who think stats::sd is a name of a 
function in the stats package.  stats::sd() works with the current 
design, allowing stats::sd will add another special case (and then of 
course you'd need stats:::sd, object$method, etc.)

Duncan Murdoch

> 
> Also think of the potential users of this syntax. There are at least two
> groups:
> 1) ~95% of the users: active users of `%>%`. My experience is that the
> vast majority of them do not use the "advanced" features of magrittr;
> however, they are got used to things like mtcars |> print. Provide them
> with the RHS-as-symbol syntax and they will be happy - they have a
> plug-and-forget replacement. Or do enforce a function call - they will
> be unhappy, and will not adopt the new syntax.
> 2) ~5% of the users (including me): have not used magrittr or any other
> (probably better) implementations (e.g., pipeR, wrapr) of the pipe
> operator because it could lead to nasty performance issues, bugs, and
> debugging problems. However, from the functional-programming-style of
> view, these users might prefer the new syntax and as few typing as
> possible.
> 
>   >
>   > It's also true that "foo()" and "function(x) x" are completely
>   > different, but they are well-defined forms:  one is a call, the other is
>   > an anonymous function definition.
>   >
>   > Accepting a plain "foo" would add a third form (a name), which might
>   > make sense, but hardly gains anything:
> 
> I would reverse the argumentation: Luke has a working implementation for
> the case if the RHS is a single symbol. What do we loose if we keep it?
> 
> Best,
> Denes
> 
>   > whereas dropping the anonymous
>   > function definition costs quite a bit.  Without special-casing anonymous
>   > function definitions you'd need to enter
>   >
>   > mtcars |> (function(x) x)()
>   >
>   > or
>   >
>   > mtcars |> (\(x) x)()
>   >
>   > which are both quite difficult to read.
>   >
>   > Duncan Murdoch
>   >
>   >>
>   >> You stated in :
>   >> "
>   >> Another variation supported by the implementation is that a symbol on
>   >> the RHS is interpreted as the name of a function to call with the LHS
>   >> as argument:
>   >>
>   >> ```r
>   >>   > quote(x |> f)
>   >> f(x)
>   >> ```
>   >> "
>   >>
>   >> So clearly this is not an implementation issue but a design decision.
>   >>
>   >> As a remedy, two different pipe operators could be introduced:
>   >>
>   >> LHS |> RHS    -> RHS is treated as a function call
>   >> LHS |>> RHS   -> RHS is treated as a function
>   >>
>   >> If |>> is used, it would not matter which notation is used for the RHS
>   >> expression; the parser would assume it evaluates to a function.
>   >>
>   >> 2) Simplified lambda expression:
>   >> IMHO in the vast majority of use cases, this is used for single-argument
>   >> functions, so parenthesis would not be required. Hence, both forms would
>   >> be valid and equivalent:
>   >>
>   >> \x x + 1
>   >> \(x) x + 1
>   >>
>   >>
>   >> 3) Function composition:
>   >> Allowing for concise composition of functions would be a great feature.
>   >> E.g., instead of
>   >>
>   >> foo <- function(x) print(mean(sqrt(x), na.rm = TRUE), digits = 2)
>   >>
>   >> or
>   >>
>   >> foo <- \x {x |> sqrt() |> mean(na.rm = TRUE) |> print(digits = 2)}
>   >>
>   >> one could write
>   >>
>   >> foo <- \x |> sqrt() |> mean(na.rm = TRUE) |> print(digits = 2)
>   >>
>   >> So basically if the lambda argument is followed by a pipe operator, the
>   >> pipe chain is transformed to a function body where the first lambda
>   >> argument is inserted into the first position of the pipeline.
>   >>
>   >>
>   >> Best,
>   >> Denes
>   >>
>   >>
>   >> On 12/5/20 7:10 PM, luke-tierney at uiowa.edu wrote:
>   >>> We went back and forth on this several times. The key advantage of
>   >>> requiring parentheses is to keep things simple and consistent.  Let's
>   >>> get some experience with that. If experience shows requiring
>   >>> parentheses creates too many issues then we can add the option of
>   >>> dropping them later (with special handling of :: and :::). It's easier
>   >>> to add flexibility and complexity than to restrict it after the fact.
>   >>>
>   >>> Best,
>   >>>
>   >>> luke
>   >>>
>   >>> On Sat, 5 Dec 2020, Hugh Parsonage wrote:
>   >>>
>   >>>> I'm surprised by the aversion to
>   >>>>
>   >>>> mtcars |> nrow
>   >>>>
>   >>>> over
>   >>>>
>   >>>> mtcars |> nrow()
>   >>>>
>   >>>> and I think the decision to disallow the former should be
>   >>>> reconsidered.  The pipe operator is only going to be used when the rhs
>   >>>> is a function, so there is no ambiguity with omitting the parentheses.
>   >>>> If it's disallowed, it becomes inconsistent with other treatments like
>   >>>> sapply(mtcars, typeof) where sapply(mtcars, typeof()) would just be
>   >>>> noise.  I'm not sure why this decision was taken
>   >>>>
>   >>>> If the only issue is with the double (and triple) colon operator, then
>   >>>> ideally `mtcars |> base::head` should resolve to `base::head(mtcars)`
>   >>>> -- in other words, demote the precedence of |>
>   >>>>
>   >>>> Obviously (looking at the R-Syntax branch) this decision was
>   >>>> considered, put into place, then dropped, but I can't see why
>   >>>> precisely.
>   >>>>
>   >>>> Best,
>   >>>>
>   >>>>
>   >>>> Hugh.
>   >>>>
>   >>>>
>   >>>>
>   >>>>
>   >>>>
>   >>>>
>   >>>>
>   >>>> On Sat, 5 Dec 2020 at 04:07, Deepayan Sarkar
>   >>>> <deepayan.sarkar at gmail.com> wrote:
>   >>>>>
>   >>>>> On Fri, Dec 4, 2020 at 7:35 PM Duncan Murdoch
>   >>>>> <murdoch.duncan at gmail.com> wrote:
>   >>>>>>
>   >>>>>> On 04/12/2020 8:13 a.m., Hiroaki Yutani wrote:
>   >>>>>>>>    Error: function '::' not supported in RHS call of a pipe
>   >>>>>>>
>   >>>>>>> To me, this error looks much more friendly than magrittr's error.
>   >>>>>>> Some of them got too used to specify functions without (). This
>   >>>>>>> is OK until they use `::`, but when they need to use it, it takes
>   >>>>>>> hours to figure out why
>   >>>>>>>
>   >>>>>>> mtcars %>% base::head
>   >>>>>>> #> Error in .::base : unused argument (head)
>   >>>>>>>
>   >>>>>>> won't work but
>   >>>>>>>
>   >>>>>>> mtcars %>% head
>   >>>>>>>
>   >>>>>>> works. I think this is a too harsh lesson for ordinary R users to
>   >>>>>>> learn `::` is a function. I've been wanting for magrittr to
> drop the
>   >>>>>>> support for a function name without () to avoid this confusion,
>   >>>>>>> so I would very much welcome the new pipe operator's behavior.
>   >>>>>>> Thank you all the developers who implemented this!
>   >>>>>>
>   >>>>>> I agree, it's an improvement on the corresponding magrittr error.
>   >>>>>>
>   >>>>>> I think the semantics of not evaluating the RHS, but treating the
>   >>>>>> pipe
>   >>>>>> as purely syntactical is a good decision.
>   >>>>>>
>   >>>>>> I'm not sure I like the recommended way to pipe into a particular
>   >>>>>> argument:
>   >>>>>>
>   >>>>>>     mtcars |> subset(cyl == 4) |> \(d) lm(mpg ~ disp, data = d)
>   >>>>>>
>   >>>>>> or
>   >>>>>>
>   >>>>>>     mtcars |> subset(cyl == 4) |> function(d) lm(mpg ~ disp, data
>   >>>>>> = d)
>   >>>>>>
>   >>>>>> both of which are equivalent to
>   >>>>>>
>   >>>>>>     mtcars |> subset(cyl == 4) |> (function(d) lm(mpg ~ disp, data =
>   >>>>>> d))()
>   >>>>>>
>   >>>>>> It's tempting to suggest it should allow something like
>   >>>>>>
>   >>>>>>     mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
>   >>>>>
>   >>>>> Which is really not that far off from
>   >>>>>
>   >>>>> mtcars |> subset(cyl == 4) |> \(.) lm(mpg ~ disp, data = .)
>   >>>>>
>   >>>>> once you get used to it.
>   >>>>>
>   >>>>> One consequence of the implementation is that it's not clear how
>   >>>>> multiple occurrences of the placeholder would be interpreted. With
>   >>>>> magrittr,
>   >>>>>
>   >>>>> sort(runif(10)) %>% ecdf(.)(.)
>   >>>>> ## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
>   >>>>>
>   >>>>> This is probably what you would expect, if you expect it to work at
>   >>>>> all, and not
>   >>>>>
>   >>>>> ecdf(sort(runif(10)))(sort(runif(10)))
>   >>>>>
>   >>>>> There would be no such ambiguity with anonymous functions
>   >>>>>
>   >>>>> sort(runif(10)) |> \(.) ecdf(.)(.)
>   >>>>>
>   >>>>> -Deepayan
>   >>>>>
>   >>>>>> which would be expanded to something equivalent to the other
>   >>>>>> versions:
>   >>>>>> but that makes it quite a bit more complicated.  (Maybe _ or \.
>   >>>>>> should
>   >>>>>> be used instead of ., since those are not legal variable names.)
>   >>>>>>
>   >>>>>> I don't think there should be an attempt to copy magrittr's special
>   >>>>>> casing of how . is used in determining whether to also include the
>   >>>>>> previous value as first argument.
>   >>>>>>
>   >>>>>> Duncan Murdoch
>   >>>>>>
>   >>>>>>
>   >>>>>>>
>   >>>>>>> Best,
>   >>>>>>> Hiroaki Yutani
>   >>>>>>>
>   >>>>>>> 2020?12?4?(?) 20:51 Duncan Murdoch <murdoch.duncan at gmail.com>:
>   >>>>>>>>
>   >>>>>>>> Just saw this on the R-devel news:
>   >>>>>>>>
>   >>>>>>>>
>   >>>>>>>> R now provides a simple native pipe syntax ?|>? as well as a
>   >>>>>>>> shorthand
>   >>>>>>>> notation for creating functions, e.g. ?\(x) x + 1? is parsed as
>   >>>>>>>> ?function(x) x + 1?. The pipe implementation as a syntax
>   >>>>>>>> transformation
>   >>>>>>>> was motivated by suggestions from Jim Hester and Lionel Henry.
>   >>>>>>>> These
>   >>>>>>>> features are experimental and may change prior to release.
>   >>>>>>>>
>   >>>>>>>>
>   >>>>>>>> This is a good addition; by using "|>" instead of "%>%" there
>   >>>>>>>> should be
>   >>>>>>>> a chance to get operator precedence right.  That said, the ?Syntax
>   >>>>>>>> help
>   >>>>>>>> topic hasn't been updated, so I'm not sure where it fits in.
>   >>>>>>>>
>   >>>>>>>> There are some choices that take a little getting used to:
>   >>>>>>>>
>   >>>>>>>>   > mtcars |> head
>   >>>>>>>> Error: The pipe operator requires a function call or an anonymous
>   >>>>>>>> function expression as RHS
>   >>>>>>>>
>   >>>>>>>> (I need to say mtcars |> head() instead.)  This sometimes leads to
>   >>>>>>>> error
>   >>>>>>>> messages that are somewhat confusing:
>   >>>>>>>>
>   >>>>>>>>   > mtcars |> magrittr::debug_pipe |> head
>   >>>>>>>> Error: function '::' not supported in RHS call of a pipe
>   >>>>>>>>
>   >>>>>>>> but
>   >>>>>>>>
>   >>>>>>>> mtcars |> magrittr::debug_pipe() |> head()
>   >>>>>>>>
>   >>>>>>>> works.
>   >>>>>>>>
>   >>>>>>>> Overall, I think this is a great addition, though it's going to be
>   >>>>>>>> disruptive for a while.
>   >>>>>>>>
>   >>>>>>>> Duncan Murdoch
>   >>>>>>>>
>   >>>>>>>> ______________________________________________
>   >>>>>>>> R-devel at r-project.org mailing list
>   >>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>   >>>>>>>
>   >>>>>>> ______________________________________________
>   >>>>>>> R-devel at r-project.org mailing list
>   >>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>   >>>>>>>
>   >>>>>>
>   >>>>>> ______________________________________________
>   >>>>>> R-devel at r-project.org mailing list
>   >>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>   >>>>>
>   >>>>> ______________________________________________
>   >>>>> R-devel at r-project.org mailing list
>   >>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>   >>>>
>   >>>> ______________________________________________
>   >>>> R-devel at r-project.org mailing list
>   >>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>   >>>>
>   >>>
>   >>
>   >> ______________________________________________
>   >> R-devel at r-project.org mailing list
>   >> https://stat.ethz.ch/mailman/listinfo/r-devel
>   >>
>   >
>   >
>


From ggrothend|eck @end|ng |rom gm@||@com  Sun Dec  6 18:32:31 2020
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Sun, 6 Dec 2020 12:32:31 -0500
Subject: [Rd] [External] Re: New pipe operator
In-Reply-To: <alpine.DEB.2.21.2012051203250.3003@luke-Latitude-7480>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <alpine.DEB.2.21.2012051203250.3003@luke-Latitude-7480>
Message-ID: <CAP01uRmYN=6cM-x9Pa5DTxUN17Hn4ggDatGOBgMQ2om-ehWEBQ@mail.gmail.com>

The following gives an error.

   1 |> `+`(2)
   ## Error: function '+' is not supported in RHS call of a pipe

   1 |> `+`()
   ## Error: function '+' is not supported in RHS call of a pipe

but this does work:

   1 |> (`+`)(2)
   ## [1] 3

   1 |> (`+`)()
   ## [1] 1

The error message suggests that this was intentional.
It isn't mentioned in ?"|>"

On Sat, Dec 5, 2020 at 1:19 PM <luke-tierney at uiowa.edu> wrote:
>
> We went back and forth on this several times. The key advantage of
> requiring parentheses is to keep things simple and consistent.  Let's
> get some experience with that. If experience shows requiring
> parentheses creates too many issues then we can add the option of
> dropping them later (with special handling of :: and :::). It's easier
> to add flexibility and complexity than to restrict it after the fact.
>
> Best,
>
> luke
>
> On Sat, 5 Dec 2020, Hugh Parsonage wrote:
>
> > I'm surprised by the aversion to
> >
> > mtcars |> nrow
> >
> > over
> >
> > mtcars |> nrow()
> >
> > and I think the decision to disallow the former should be
> > reconsidered.  The pipe operator is only going to be used when the rhs
> > is a function, so there is no ambiguity with omitting the parentheses.
> > If it's disallowed, it becomes inconsistent with other treatments like
> > sapply(mtcars, typeof) where sapply(mtcars, typeof()) would just be
> > noise.  I'm not sure why this decision was taken
> >
> > If the only issue is with the double (and triple) colon operator, then
> > ideally `mtcars |> base::head` should resolve to `base::head(mtcars)`
> > -- in other words, demote the precedence of |>
> >
> > Obviously (looking at the R-Syntax branch) this decision was
> > considered, put into place, then dropped, but I can't see why
> > precisely.
> >
> > Best,
> >
> >
> > Hugh.
> >
> >
> >
> >
> >
> >
> >
> > On Sat, 5 Dec 2020 at 04:07, Deepayan Sarkar <deepayan.sarkar at gmail.com> wrote:
> >>
> >> On Fri, Dec 4, 2020 at 7:35 PM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
> >>>
> >>> On 04/12/2020 8:13 a.m., Hiroaki Yutani wrote:
> >>>>>   Error: function '::' not supported in RHS call of a pipe
> >>>>
> >>>> To me, this error looks much more friendly than magrittr's error.
> >>>> Some of them got too used to specify functions without (). This
> >>>> is OK until they use `::`, but when they need to use it, it takes
> >>>> hours to figure out why
> >>>>
> >>>> mtcars %>% base::head
> >>>> #> Error in .::base : unused argument (head)
> >>>>
> >>>> won't work but
> >>>>
> >>>> mtcars %>% head
> >>>>
> >>>> works. I think this is a too harsh lesson for ordinary R users to
> >>>> learn `::` is a function. I've been wanting for magrittr to drop the
> >>>> support for a function name without () to avoid this confusion,
> >>>> so I would very much welcome the new pipe operator's behavior.
> >>>> Thank you all the developers who implemented this!
> >>>
> >>> I agree, it's an improvement on the corresponding magrittr error.
> >>>
> >>> I think the semantics of not evaluating the RHS, but treating the pipe
> >>> as purely syntactical is a good decision.
> >>>
> >>> I'm not sure I like the recommended way to pipe into a particular argument:
> >>>
> >>>    mtcars |> subset(cyl == 4) |> \(d) lm(mpg ~ disp, data = d)
> >>>
> >>> or
> >>>
> >>>    mtcars |> subset(cyl == 4) |> function(d) lm(mpg ~ disp, data = d)
> >>>
> >>> both of which are equivalent to
> >>>
> >>>    mtcars |> subset(cyl == 4) |> (function(d) lm(mpg ~ disp, data = d))()
> >>>
> >>> It's tempting to suggest it should allow something like
> >>>
> >>>    mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
> >>
> >> Which is really not that far off from
> >>
> >> mtcars |> subset(cyl == 4) |> \(.) lm(mpg ~ disp, data = .)
> >>
> >> once you get used to it.
> >>
> >> One consequence of the implementation is that it's not clear how
> >> multiple occurrences of the placeholder would be interpreted. With
> >> magrittr,
> >>
> >> sort(runif(10)) %>% ecdf(.)(.)
> >> ## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
> >>
> >> This is probably what you would expect, if you expect it to work at all, and not
> >>
> >> ecdf(sort(runif(10)))(sort(runif(10)))
> >>
> >> There would be no such ambiguity with anonymous functions
> >>
> >> sort(runif(10)) |> \(.) ecdf(.)(.)
> >>
> >> -Deepayan
> >>
> >>> which would be expanded to something equivalent to the other versions:
> >>> but that makes it quite a bit more complicated.  (Maybe _ or \. should
> >>> be used instead of ., since those are not legal variable names.)
> >>>
> >>> I don't think there should be an attempt to copy magrittr's special
> >>> casing of how . is used in determining whether to also include the
> >>> previous value as first argument.
> >>>
> >>> Duncan Murdoch
> >>>
> >>>
> >>>>
> >>>> Best,
> >>>> Hiroaki Yutani
> >>>>
> >>>> 2020?12?4?(?) 20:51 Duncan Murdoch <murdoch.duncan at gmail.com>:
> >>>>>
> >>>>> Just saw this on the R-devel news:
> >>>>>
> >>>>>
> >>>>> R now provides a simple native pipe syntax ?|>? as well as a shorthand
> >>>>> notation for creating functions, e.g. ?\(x) x + 1? is parsed as
> >>>>> ?function(x) x + 1?. The pipe implementation as a syntax transformation
> >>>>> was motivated by suggestions from Jim Hester and Lionel Henry. These
> >>>>> features are experimental and may change prior to release.
> >>>>>
> >>>>>
> >>>>> This is a good addition; by using "|>" instead of "%>%" there should be
> >>>>> a chance to get operator precedence right.  That said, the ?Syntax help
> >>>>> topic hasn't been updated, so I'm not sure where it fits in.
> >>>>>
> >>>>> There are some choices that take a little getting used to:
> >>>>>
> >>>>>  > mtcars |> head
> >>>>> Error: The pipe operator requires a function call or an anonymous
> >>>>> function expression as RHS
> >>>>>
> >>>>> (I need to say mtcars |> head() instead.)  This sometimes leads to error
> >>>>> messages that are somewhat confusing:
> >>>>>
> >>>>>  > mtcars |> magrittr::debug_pipe |> head
> >>>>> Error: function '::' not supported in RHS call of a pipe
> >>>>>
> >>>>> but
> >>>>>
> >>>>> mtcars |> magrittr::debug_pipe() |> head()
> >>>>>
> >>>>> works.
> >>>>>
> >>>>> Overall, I think this is a great addition, though it's going to be
> >>>>> disruptive for a while.
> >>>>>
> >>>>> Duncan Murdoch
> >>>>>
> >>>>> ______________________________________________
> >>>>> R-devel at r-project.org mailing list
> >>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>>>
> >>>> ______________________________________________
> >>>> R-devel at r-project.org mailing list
> >>>> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>>>
> >>>
> >>> ______________________________________________
> >>> R-devel at r-project.org mailing list
> >>> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>
> >> ______________________________________________
> >> R-devel at r-project.org mailing list
> >> https://stat.ethz.ch/mailman/listinfo/r-devel
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
> >
>
> --
> Luke Tierney
> Ralph E. Wareham Professor of Mathematical Sciences
> University of Iowa                  Phone:             319-335-3386
> Department of Statistics and        Fax:               319-335-3017
>     Actuarial Science
> 241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
> Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel



-- 
Statistics & Software Consulting
GKX Group, GKX Associates Inc.
tel: 1-877-GKX-GROUP
email: ggrothendieck at gmail.com


From iuke-tier@ey m@iii@g oii uiow@@edu  Sun Dec  6 19:09:13 2020
From: iuke-tier@ey m@iii@g oii uiow@@edu (iuke-tier@ey m@iii@g oii uiow@@edu)
Date: Sun, 6 Dec 2020 12:09:13 -0600 (CST)
Subject: [Rd] [External] Re: New pipe operator
In-Reply-To: <CAP01uRmYN=6cM-x9Pa5DTxUN17Hn4ggDatGOBgMQ2om-ehWEBQ@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <alpine.DEB.2.21.2012051203250.3003@luke-Latitude-7480>
 <CAP01uRmYN=6cM-x9Pa5DTxUN17Hn4ggDatGOBgMQ2om-ehWEBQ@mail.gmail.com>
Message-ID: <alpine.DEB.2.21.2012061207430.3003@luke-Latitude-7480>

On Sun, 6 Dec 2020, Gabor Grothendieck wrote:

> The following gives an error.
>
>   1 |> `+`(2)
>   ## Error: function '+' is not supported in RHS call of a pipe
>
>   1 |> `+`()
>   ## Error: function '+' is not supported in RHS call of a pipe
>
> but this does work:
>
>   1 |> (`+`)(2)
>   ## [1] 3
>
>   1 |> (`+`)()
>   ## [1] 1
>
> The error message suggests that this was intentional.
> It isn't mentioned in ?"|>"

?"|>" says:

      To avoid ambiguities, functions in ?rhs? calls may not
      be syntactically special, such as ?+? or ?if?.

(used to say lhs; fixed now).

Best,

luke

>
> On Sat, Dec 5, 2020 at 1:19 PM <luke-tierney at uiowa.edu> wrote:
>>
>> We went back and forth on this several times. The key advantage of
>> requiring parentheses is to keep things simple and consistent.  Let's
>> get some experience with that. If experience shows requiring
>> parentheses creates too many issues then we can add the option of
>> dropping them later (with special handling of :: and :::). It's easier
>> to add flexibility and complexity than to restrict it after the fact.
>>
>> Best,
>>
>> luke
>>
>> On Sat, 5 Dec 2020, Hugh Parsonage wrote:
>>
>>> I'm surprised by the aversion to
>>>
>>> mtcars |> nrow
>>>
>>> over
>>>
>>> mtcars |> nrow()
>>>
>>> and I think the decision to disallow the former should be
>>> reconsidered.  The pipe operator is only going to be used when the rhs
>>> is a function, so there is no ambiguity with omitting the parentheses.
>>> If it's disallowed, it becomes inconsistent with other treatments like
>>> sapply(mtcars, typeof) where sapply(mtcars, typeof()) would just be
>>> noise.  I'm not sure why this decision was taken
>>>
>>> If the only issue is with the double (and triple) colon operator, then
>>> ideally `mtcars |> base::head` should resolve to `base::head(mtcars)`
>>> -- in other words, demote the precedence of |>
>>>
>>> Obviously (looking at the R-Syntax branch) this decision was
>>> considered, put into place, then dropped, but I can't see why
>>> precisely.
>>>
>>> Best,
>>>
>>>
>>> Hugh.
>>>
>>>
>>>
>>>
>>>
>>>
>>>
>>> On Sat, 5 Dec 2020 at 04:07, Deepayan Sarkar <deepayan.sarkar at gmail.com> wrote:
>>>>
>>>> On Fri, Dec 4, 2020 at 7:35 PM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>>>>>
>>>>> On 04/12/2020 8:13 a.m., Hiroaki Yutani wrote:
>>>>>>>   Error: function '::' not supported in RHS call of a pipe
>>>>>>
>>>>>> To me, this error looks much more friendly than magrittr's error.
>>>>>> Some of them got too used to specify functions without (). This
>>>>>> is OK until they use `::`, but when they need to use it, it takes
>>>>>> hours to figure out why
>>>>>>
>>>>>> mtcars %>% base::head
>>>>>> #> Error in .::base : unused argument (head)
>>>>>>
>>>>>> won't work but
>>>>>>
>>>>>> mtcars %>% head
>>>>>>
>>>>>> works. I think this is a too harsh lesson for ordinary R users to
>>>>>> learn `::` is a function. I've been wanting for magrittr to drop the
>>>>>> support for a function name without () to avoid this confusion,
>>>>>> so I would very much welcome the new pipe operator's behavior.
>>>>>> Thank you all the developers who implemented this!
>>>>>
>>>>> I agree, it's an improvement on the corresponding magrittr error.
>>>>>
>>>>> I think the semantics of not evaluating the RHS, but treating the pipe
>>>>> as purely syntactical is a good decision.
>>>>>
>>>>> I'm not sure I like the recommended way to pipe into a particular argument:
>>>>>
>>>>>    mtcars |> subset(cyl == 4) |> \(d) lm(mpg ~ disp, data = d)
>>>>>
>>>>> or
>>>>>
>>>>>    mtcars |> subset(cyl == 4) |> function(d) lm(mpg ~ disp, data = d)
>>>>>
>>>>> both of which are equivalent to
>>>>>
>>>>>    mtcars |> subset(cyl == 4) |> (function(d) lm(mpg ~ disp, data = d))()
>>>>>
>>>>> It's tempting to suggest it should allow something like
>>>>>
>>>>>    mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
>>>>
>>>> Which is really not that far off from
>>>>
>>>> mtcars |> subset(cyl == 4) |> \(.) lm(mpg ~ disp, data = .)
>>>>
>>>> once you get used to it.
>>>>
>>>> One consequence of the implementation is that it's not clear how
>>>> multiple occurrences of the placeholder would be interpreted. With
>>>> magrittr,
>>>>
>>>> sort(runif(10)) %>% ecdf(.)(.)
>>>> ## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
>>>>
>>>> This is probably what you would expect, if you expect it to work at all, and not
>>>>
>>>> ecdf(sort(runif(10)))(sort(runif(10)))
>>>>
>>>> There would be no such ambiguity with anonymous functions
>>>>
>>>> sort(runif(10)) |> \(.) ecdf(.)(.)
>>>>
>>>> -Deepayan
>>>>
>>>>> which would be expanded to something equivalent to the other versions:
>>>>> but that makes it quite a bit more complicated.  (Maybe _ or \. should
>>>>> be used instead of ., since those are not legal variable names.)
>>>>>
>>>>> I don't think there should be an attempt to copy magrittr's special
>>>>> casing of how . is used in determining whether to also include the
>>>>> previous value as first argument.
>>>>>
>>>>> Duncan Murdoch
>>>>>
>>>>>
>>>>>>
>>>>>> Best,
>>>>>> Hiroaki Yutani
>>>>>>
>>>>>> 2020?12?4?(?) 20:51 Duncan Murdoch <murdoch.duncan at gmail.com>:
>>>>>>>
>>>>>>> Just saw this on the R-devel news:
>>>>>>>
>>>>>>>
>>>>>>> R now provides a simple native pipe syntax ?|>? as well as a shorthand
>>>>>>> notation for creating functions, e.g. ?\(x) x + 1? is parsed as
>>>>>>> ?function(x) x + 1?. The pipe implementation as a syntax transformation
>>>>>>> was motivated by suggestions from Jim Hester and Lionel Henry. These
>>>>>>> features are experimental and may change prior to release.
>>>>>>>
>>>>>>>
>>>>>>> This is a good addition; by using "|>" instead of "%>%" there should be
>>>>>>> a chance to get operator precedence right.  That said, the ?Syntax help
>>>>>>> topic hasn't been updated, so I'm not sure where it fits in.
>>>>>>>
>>>>>>> There are some choices that take a little getting used to:
>>>>>>>
>>>>>>> > mtcars |> head
>>>>>>> Error: The pipe operator requires a function call or an anonymous
>>>>>>> function expression as RHS
>>>>>>>
>>>>>>> (I need to say mtcars |> head() instead.)  This sometimes leads to error
>>>>>>> messages that are somewhat confusing:
>>>>>>>
>>>>>>> > mtcars |> magrittr::debug_pipe |> head
>>>>>>> Error: function '::' not supported in RHS call of a pipe
>>>>>>>
>>>>>>> but
>>>>>>>
>>>>>>> mtcars |> magrittr::debug_pipe() |> head()
>>>>>>>
>>>>>>> works.
>>>>>>>
>>>>>>> Overall, I think this is a great addition, though it's going to be
>>>>>>> disruptive for a while.
>>>>>>>
>>>>>>> Duncan Murdoch
>>>>>>>
>>>>>>> ______________________________________________
>>>>>>> R-devel at r-project.org mailing list
>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>
>>>>>> ______________________________________________
>>>>>> R-devel at r-project.org mailing list
>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>
>>>>>
>>>>> ______________________________________________
>>>>> R-devel at r-project.org mailing list
>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>
>>>> ______________________________________________
>>>> R-devel at r-project.org mailing list
>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>
>>
>> --
>> Luke Tierney
>> Ralph E. Wareham Professor of Mathematical Sciences
>> University of Iowa                  Phone:             319-335-3386
>> Department of Statistics and        Fax:               319-335-3017
>>     Actuarial Science
>> 241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
>> Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>
>
>
>

-- 
Luke Tierney
Ralph E. Wareham Professor of Mathematical Sciences
University of Iowa                  Phone:             319-335-3386
Department of Statistics and        Fax:               319-335-3017
    Actuarial Science
241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu

From ggrothend|eck @end|ng |rom gm@||@com  Sun Dec  6 19:13:11 2020
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Sun, 6 Dec 2020 13:13:11 -0500
Subject: [Rd] [External] Re: New pipe operator
In-Reply-To: <alpine.DEB.2.21.2012061207430.3003@luke-Latitude-7480>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <alpine.DEB.2.21.2012051203250.3003@luke-Latitude-7480>
 <CAP01uRmYN=6cM-x9Pa5DTxUN17Hn4ggDatGOBgMQ2om-ehWEBQ@mail.gmail.com>
 <alpine.DEB.2.21.2012061207430.3003@luke-Latitude-7480>
Message-ID: <CAP01uRk+UXJh8jCCd9KB6d5Hzz4zf6VYjeuNjJshYtBZYRDt=A@mail.gmail.com>

Why is that ambiguous?  It works in magrittr.

> library(magrittr)
> 1 %>% `+`()
[1] 1

On Sun, Dec 6, 2020 at 1:09 PM <luke-tierney at uiowa.edu> wrote:
>
> On Sun, 6 Dec 2020, Gabor Grothendieck wrote:
>
> > The following gives an error.
> >
> >   1 |> `+`(2)
> >   ## Error: function '+' is not supported in RHS call of a pipe
> >
> >   1 |> `+`()
> >   ## Error: function '+' is not supported in RHS call of a pipe
> >
> > but this does work:
> >
> >   1 |> (`+`)(2)
> >   ## [1] 3
> >
> >   1 |> (`+`)()
> >   ## [1] 1
> >
> > The error message suggests that this was intentional.
> > It isn't mentioned in ?"|>"
>
> ?"|>" says:
>
>       To avoid ambiguities, functions in ?rhs? calls may not
>       be syntactically special, such as ?+? or ?if?.
>
> (used to say lhs; fixed now).
>
> Best,
>
> luke
>
> >
> > On Sat, Dec 5, 2020 at 1:19 PM <luke-tierney at uiowa.edu> wrote:
> >>
> >> We went back and forth on this several times. The key advantage of
> >> requiring parentheses is to keep things simple and consistent.  Let's
> >> get some experience with that. If experience shows requiring
> >> parentheses creates too many issues then we can add the option of
> >> dropping them later (with special handling of :: and :::). It's easier
> >> to add flexibility and complexity than to restrict it after the fact.
> >>
> >> Best,
> >>
> >> luke
> >>
> >> On Sat, 5 Dec 2020, Hugh Parsonage wrote:
> >>
> >>> I'm surprised by the aversion to
> >>>
> >>> mtcars |> nrow
> >>>
> >>> over
> >>>
> >>> mtcars |> nrow()
> >>>
> >>> and I think the decision to disallow the former should be
> >>> reconsidered.  The pipe operator is only going to be used when the rhs
> >>> is a function, so there is no ambiguity with omitting the parentheses.
> >>> If it's disallowed, it becomes inconsistent with other treatments like
> >>> sapply(mtcars, typeof) where sapply(mtcars, typeof()) would just be
> >>> noise.  I'm not sure why this decision was taken
> >>>
> >>> If the only issue is with the double (and triple) colon operator, then
> >>> ideally `mtcars |> base::head` should resolve to `base::head(mtcars)`
> >>> -- in other words, demote the precedence of |>
> >>>
> >>> Obviously (looking at the R-Syntax branch) this decision was
> >>> considered, put into place, then dropped, but I can't see why
> >>> precisely.
> >>>
> >>> Best,
> >>>
> >>>
> >>> Hugh.
> >>>
> >>>
> >>>
> >>>
> >>>
> >>>
> >>>
> >>> On Sat, 5 Dec 2020 at 04:07, Deepayan Sarkar <deepayan.sarkar at gmail.com> wrote:
> >>>>
> >>>> On Fri, Dec 4, 2020 at 7:35 PM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
> >>>>>
> >>>>> On 04/12/2020 8:13 a.m., Hiroaki Yutani wrote:
> >>>>>>>   Error: function '::' not supported in RHS call of a pipe
> >>>>>>
> >>>>>> To me, this error looks much more friendly than magrittr's error.
> >>>>>> Some of them got too used to specify functions without (). This
> >>>>>> is OK until they use `::`, but when they need to use it, it takes
> >>>>>> hours to figure out why
> >>>>>>
> >>>>>> mtcars %>% base::head
> >>>>>> #> Error in .::base : unused argument (head)
> >>>>>>
> >>>>>> won't work but
> >>>>>>
> >>>>>> mtcars %>% head
> >>>>>>
> >>>>>> works. I think this is a too harsh lesson for ordinary R users to
> >>>>>> learn `::` is a function. I've been wanting for magrittr to drop the
> >>>>>> support for a function name without () to avoid this confusion,
> >>>>>> so I would very much welcome the new pipe operator's behavior.
> >>>>>> Thank you all the developers who implemented this!
> >>>>>
> >>>>> I agree, it's an improvement on the corresponding magrittr error.
> >>>>>
> >>>>> I think the semantics of not evaluating the RHS, but treating the pipe
> >>>>> as purely syntactical is a good decision.
> >>>>>
> >>>>> I'm not sure I like the recommended way to pipe into a particular argument:
> >>>>>
> >>>>>    mtcars |> subset(cyl == 4) |> \(d) lm(mpg ~ disp, data = d)
> >>>>>
> >>>>> or
> >>>>>
> >>>>>    mtcars |> subset(cyl == 4) |> function(d) lm(mpg ~ disp, data = d)
> >>>>>
> >>>>> both of which are equivalent to
> >>>>>
> >>>>>    mtcars |> subset(cyl == 4) |> (function(d) lm(mpg ~ disp, data = d))()
> >>>>>
> >>>>> It's tempting to suggest it should allow something like
> >>>>>
> >>>>>    mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
> >>>>
> >>>> Which is really not that far off from
> >>>>
> >>>> mtcars |> subset(cyl == 4) |> \(.) lm(mpg ~ disp, data = .)
> >>>>
> >>>> once you get used to it.
> >>>>
> >>>> One consequence of the implementation is that it's not clear how
> >>>> multiple occurrences of the placeholder would be interpreted. With
> >>>> magrittr,
> >>>>
> >>>> sort(runif(10)) %>% ecdf(.)(.)
> >>>> ## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
> >>>>
> >>>> This is probably what you would expect, if you expect it to work at all, and not
> >>>>
> >>>> ecdf(sort(runif(10)))(sort(runif(10)))
> >>>>
> >>>> There would be no such ambiguity with anonymous functions
> >>>>
> >>>> sort(runif(10)) |> \(.) ecdf(.)(.)
> >>>>
> >>>> -Deepayan
> >>>>
> >>>>> which would be expanded to something equivalent to the other versions:
> >>>>> but that makes it quite a bit more complicated.  (Maybe _ or \. should
> >>>>> be used instead of ., since those are not legal variable names.)
> >>>>>
> >>>>> I don't think there should be an attempt to copy magrittr's special
> >>>>> casing of how . is used in determining whether to also include the
> >>>>> previous value as first argument.
> >>>>>
> >>>>> Duncan Murdoch
> >>>>>
> >>>>>
> >>>>>>
> >>>>>> Best,
> >>>>>> Hiroaki Yutani
> >>>>>>
> >>>>>> 2020?12?4?(?) 20:51 Duncan Murdoch <murdoch.duncan at gmail.com>:
> >>>>>>>
> >>>>>>> Just saw this on the R-devel news:
> >>>>>>>
> >>>>>>>
> >>>>>>> R now provides a simple native pipe syntax ?|>? as well as a shorthand
> >>>>>>> notation for creating functions, e.g. ?\(x) x + 1? is parsed as
> >>>>>>> ?function(x) x + 1?. The pipe implementation as a syntax transformation
> >>>>>>> was motivated by suggestions from Jim Hester and Lionel Henry. These
> >>>>>>> features are experimental and may change prior to release.
> >>>>>>>
> >>>>>>>
> >>>>>>> This is a good addition; by using "|>" instead of "%>%" there should be
> >>>>>>> a chance to get operator precedence right.  That said, the ?Syntax help
> >>>>>>> topic hasn't been updated, so I'm not sure where it fits in.
> >>>>>>>
> >>>>>>> There are some choices that take a little getting used to:
> >>>>>>>
> >>>>>>> > mtcars |> head
> >>>>>>> Error: The pipe operator requires a function call or an anonymous
> >>>>>>> function expression as RHS
> >>>>>>>
> >>>>>>> (I need to say mtcars |> head() instead.)  This sometimes leads to error
> >>>>>>> messages that are somewhat confusing:
> >>>>>>>
> >>>>>>> > mtcars |> magrittr::debug_pipe |> head
> >>>>>>> Error: function '::' not supported in RHS call of a pipe
> >>>>>>>
> >>>>>>> but
> >>>>>>>
> >>>>>>> mtcars |> magrittr::debug_pipe() |> head()
> >>>>>>>
> >>>>>>> works.
> >>>>>>>
> >>>>>>> Overall, I think this is a great addition, though it's going to be
> >>>>>>> disruptive for a while.
> >>>>>>>
> >>>>>>> Duncan Murdoch
> >>>>>>>
> >>>>>>> ______________________________________________
> >>>>>>> R-devel at r-project.org mailing list
> >>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>>>>>
> >>>>>> ______________________________________________
> >>>>>> R-devel at r-project.org mailing list
> >>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>>>>>
> >>>>>
> >>>>> ______________________________________________
> >>>>> R-devel at r-project.org mailing list
> >>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>>>
> >>>> ______________________________________________
> >>>> R-devel at r-project.org mailing list
> >>>> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>>
> >>> ______________________________________________
> >>> R-devel at r-project.org mailing list
> >>> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>>
> >>
> >> --
> >> Luke Tierney
> >> Ralph E. Wareham Professor of Mathematical Sciences
> >> University of Iowa                  Phone:             319-335-3386
> >> Department of Statistics and        Fax:               319-335-3017
> >>     Actuarial Science
> >> 241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
> >> Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu
> >> ______________________________________________
> >> R-devel at r-project.org mailing list
> >> https://stat.ethz.ch/mailman/listinfo/r-devel
> >
> >
> >
> >
>
> --
> Luke Tierney
> Ralph E. Wareham Professor of Mathematical Sciences
> University of Iowa                  Phone:             319-335-3386
> Department of Statistics and        Fax:               319-335-3017
>     Actuarial Science
> 241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
> Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu



-- 
Statistics & Software Consulting
GKX Group, GKX Associates Inc.
tel: 1-877-GKX-GROUP
email: ggrothendieck at gmail.com


From @v|gro@@ @end|ng |rom ver|zon@net  Sun Dec  6 20:03:23 2020
From: @v|gro@@ @end|ng |rom ver|zon@net (Avi Gross)
Date: Sun, 6 Dec 2020 14:03:23 -0500
Subject: [Rd] New pipe operator
In-Reply-To: <89237cb3-dcda-6957-f86f-8d359fb66fff@sapo.pt>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CAB8pepzDHvM+JJtOcSOudyJ0Fe6-Yk2sG7Ep7qDkOK52bcuwZw@mail.gmail.com>
 <CAKorm_usbqOAxS8Xk6BeeFbPK0rg1KwMNTavrDzRgm4We+mN4g@mail.gmail.com>
 <89237cb3-dcda-6957-f86f-8d359fb66fff@sapo.pt>
Message-ID: <049401d6cc02$78782930$69687b90$@verizon.net>

Topic is more about anonymous functions but also pipes.

Rui thought the proposed syntax was a bit ugly. I assume the \(x) ... was what he means, not the function(x)... version.

Many current languages have played games on adding some form of anonymous function that is defined and used in place. Some go to great pains to make various parts optional to the point where there are many valid way to create a function that takes no arguments so you can leave out almost everything else as optional.

I admit having to type "lambda" all the time (in some languages)  is not preferable but in English, something shorter like fun(...) or func(...) instead of function(...) might be more readable than the weird choice of \(. Yes. You can view the combo to bring attention to the fact the "(" is meant not as any old paren for other uses but specifically for function invocation/definition purposes. But overuse of the backslash to mean other things such as in regular expressions and the parentheses for so many things, makes parsing for humans harder. So does "|>" for the new pipe symbol as it can also look like "or greater than" and since some humans do not insert spaces to make code even shorter, it can be a challenge to rapidly see a line of code as tokens.

If programming were being invented today with a larger set of symbols, it might use more of them and perhaps look more like APL. We might have all of the built-in to the language tokens be single symbols including real arrows instead of -> and a not-equals symbol like  ? instead of != or ~= s some languages use. In that system, what might the pipe symbol look like?

?

But although making things concise is nice, sometimes there is clarity in using enough room, to make things clear or we might as well code in binary.

-----Original Message-----
From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Rui Barradas
Sent: Sunday, December 6, 2020 2:51 AM
To: Gregory Warnes <greg at warnes.net>; Abby Spurdle <spurdle.a at gmail.com>
Cc: r-devel <r-devel at r-project.org>
Subject: Re: [Rd] New pipe operator

Hello,

If Hilbert liked beer, I like "pipe".

More seriously, a new addition like this one is going to cause problems yet unknown. But it's a good idea to have a pipe operator available. As someone used to magrittr's data pipelines, I will play with this base one before making up my mind. I don't expect its behavior to be exactly like magrittr "%>%" (and it's not). For the moment all I can say is that it is something R users are used to and that it now avoids loading a package.
As for the new way to define anonymous functions, I am less sure. Too much syntatic sugar? Or am I finding the syntax ugly?

Hope this helps,

Rui Barradas


?s 03:22 de 06/12/20, Gregory Warnes escreveu:
> If we?re being mathematically pedantic, the ?pipe? operator is 
> actually function composition > That being said, pipes are a simple 
> and well-known idiom. While being less
> than mathematically exact, it seems a reasonable   label for the (very
> useful) behavior.
> 
> On Sat, Dec 5, 2020 at 9:43 PM Abby Spurdle <spurdle.a at gmail.com> wrote:
> 
>>> This is a good addition
>>
>> I can't understand why so many people are calling this a "pipe".
>> Pipes connect processes, via their I/O streams.
>> Arguably, a more general interpretation would include sockets and files.
>>
>> https://en.wikipedia.org/wiki/Pipeline_(Unix)
>> https://en.wikipedia.org/wiki/Named_pipe
>> https://en.wikipedia.org/wiki/Anonymous_pipe
>>
>> As far as I can tell, the magrittr-like operators are functions (not 
>> pipes), with nonstandard syntax.
>> This is not consistent with R's original design philosophy, building 
>> on C, Lisp and S, along with lots of *important* math and stats.
>>
>> It's possible that some parties are interested in creating a kind of 
>> "data pipeline".
>> I'm interested in this myself, and I think we could discuss this more.
>> But I'm not convinced the magrittr-like operators help to achieve 
>> this goal.
>> Which, in my opinion, would require one to model programs as directed 
>> graphs, along with some degree of asynchronous input.
>>
>> Presumably, these operators will be added to R anyway, and (almost) 
>> no one will listen to me.
>>
>> So, I would like to make one suggestion:
>> Is it possible for these operators to *not* be named:
>>      The R Pipe
>>      The S Pipe
>>      Or anything with a similar meaning.
>>
>> Maybe tidy pipe, or something else that links it to its proponents?
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>

______________________________________________
R-devel at r-project.org mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


Scanned by McAfee and confirmed virus-free.	
Find out more here: https://bit.ly/2zCJMrO


From iuke-tier@ey m@iii@g oii uiow@@edu  Sun Dec  6 20:15:40 2020
From: iuke-tier@ey m@iii@g oii uiow@@edu (iuke-tier@ey m@iii@g oii uiow@@edu)
Date: Sun, 6 Dec 2020 13:15:40 -0600 (CST)
Subject: [Rd] [External] Re: New pipe operator
In-Reply-To: <CAP01uRk+UXJh8jCCd9KB6d5Hzz4zf6VYjeuNjJshYtBZYRDt=A@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <alpine.DEB.2.21.2012051203250.3003@luke-Latitude-7480>
 <CAP01uRmYN=6cM-x9Pa5DTxUN17Hn4ggDatGOBgMQ2om-ehWEBQ@mail.gmail.com>
 <alpine.DEB.2.21.2012061207430.3003@luke-Latitude-7480>
 <CAP01uRk+UXJh8jCCd9KB6d5Hzz4zf6VYjeuNjJshYtBZYRDt=A@mail.gmail.com>
Message-ID: <alpine.DEB.2.21.2012061314280.3003@luke-Latitude-7480>

On Sun, 6 Dec 2020, Gabor Grothendieck wrote:

> Why is that ambiguous?  It works in magrittr.

For now, all functions marked internally as syntactically special are
disallowed. Not all of these lead to ambiguities.

Best,

luke

>
>> library(magrittr)
>> 1 %>% `+`()
> [1] 1
>
> On Sun, Dec 6, 2020 at 1:09 PM <luke-tierney at uiowa.edu> wrote:
>>
>> On Sun, 6 Dec 2020, Gabor Grothendieck wrote:
>>
>>> The following gives an error.
>>>
>>>   1 |> `+`(2)
>>>   ## Error: function '+' is not supported in RHS call of a pipe
>>>
>>>   1 |> `+`()
>>>   ## Error: function '+' is not supported in RHS call of a pipe
>>>
>>> but this does work:
>>>
>>>   1 |> (`+`)(2)
>>>   ## [1] 3
>>>
>>>   1 |> (`+`)()
>>>   ## [1] 1
>>>
>>> The error message suggests that this was intentional.
>>> It isn't mentioned in ?"|>"
>>
>> ?"|>" says:
>>
>>       To avoid ambiguities, functions in ?rhs? calls may not
>>       be syntactically special, such as ?+? or ?if?.
>>
>> (used to say lhs; fixed now).
>>
>> Best,
>>
>> luke
>>
>>>
>>> On Sat, Dec 5, 2020 at 1:19 PM <luke-tierney at uiowa.edu> wrote:
>>>>
>>>> We went back and forth on this several times. The key advantage of
>>>> requiring parentheses is to keep things simple and consistent.  Let's
>>>> get some experience with that. If experience shows requiring
>>>> parentheses creates too many issues then we can add the option of
>>>> dropping them later (with special handling of :: and :::). It's easier
>>>> to add flexibility and complexity than to restrict it after the fact.
>>>>
>>>> Best,
>>>>
>>>> luke
>>>>
>>>> On Sat, 5 Dec 2020, Hugh Parsonage wrote:
>>>>
>>>>> I'm surprised by the aversion to
>>>>>
>>>>> mtcars |> nrow
>>>>>
>>>>> over
>>>>>
>>>>> mtcars |> nrow()
>>>>>
>>>>> and I think the decision to disallow the former should be
>>>>> reconsidered.  The pipe operator is only going to be used when the rhs
>>>>> is a function, so there is no ambiguity with omitting the parentheses.
>>>>> If it's disallowed, it becomes inconsistent with other treatments like
>>>>> sapply(mtcars, typeof) where sapply(mtcars, typeof()) would just be
>>>>> noise.  I'm not sure why this decision was taken
>>>>>
>>>>> If the only issue is with the double (and triple) colon operator, then
>>>>> ideally `mtcars |> base::head` should resolve to `base::head(mtcars)`
>>>>> -- in other words, demote the precedence of |>
>>>>>
>>>>> Obviously (looking at the R-Syntax branch) this decision was
>>>>> considered, put into place, then dropped, but I can't see why
>>>>> precisely.
>>>>>
>>>>> Best,
>>>>>
>>>>>
>>>>> Hugh.
>>>>>
>>>>>
>>>>>
>>>>>
>>>>>
>>>>>
>>>>>
>>>>> On Sat, 5 Dec 2020 at 04:07, Deepayan Sarkar <deepayan.sarkar at gmail.com> wrote:
>>>>>>
>>>>>> On Fri, Dec 4, 2020 at 7:35 PM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>>>>>>>
>>>>>>> On 04/12/2020 8:13 a.m., Hiroaki Yutani wrote:
>>>>>>>>>   Error: function '::' not supported in RHS call of a pipe
>>>>>>>>
>>>>>>>> To me, this error looks much more friendly than magrittr's error.
>>>>>>>> Some of them got too used to specify functions without (). This
>>>>>>>> is OK until they use `::`, but when they need to use it, it takes
>>>>>>>> hours to figure out why
>>>>>>>>
>>>>>>>> mtcars %>% base::head
>>>>>>>> #> Error in .::base : unused argument (head)
>>>>>>>>
>>>>>>>> won't work but
>>>>>>>>
>>>>>>>> mtcars %>% head
>>>>>>>>
>>>>>>>> works. I think this is a too harsh lesson for ordinary R users to
>>>>>>>> learn `::` is a function. I've been wanting for magrittr to drop the
>>>>>>>> support for a function name without () to avoid this confusion,
>>>>>>>> so I would very much welcome the new pipe operator's behavior.
>>>>>>>> Thank you all the developers who implemented this!
>>>>>>>
>>>>>>> I agree, it's an improvement on the corresponding magrittr error.
>>>>>>>
>>>>>>> I think the semantics of not evaluating the RHS, but treating the pipe
>>>>>>> as purely syntactical is a good decision.
>>>>>>>
>>>>>>> I'm not sure I like the recommended way to pipe into a particular argument:
>>>>>>>
>>>>>>>    mtcars |> subset(cyl == 4) |> \(d) lm(mpg ~ disp, data = d)
>>>>>>>
>>>>>>> or
>>>>>>>
>>>>>>>    mtcars |> subset(cyl == 4) |> function(d) lm(mpg ~ disp, data = d)
>>>>>>>
>>>>>>> both of which are equivalent to
>>>>>>>
>>>>>>>    mtcars |> subset(cyl == 4) |> (function(d) lm(mpg ~ disp, data = d))()
>>>>>>>
>>>>>>> It's tempting to suggest it should allow something like
>>>>>>>
>>>>>>>    mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
>>>>>>
>>>>>> Which is really not that far off from
>>>>>>
>>>>>> mtcars |> subset(cyl == 4) |> \(.) lm(mpg ~ disp, data = .)
>>>>>>
>>>>>> once you get used to it.
>>>>>>
>>>>>> One consequence of the implementation is that it's not clear how
>>>>>> multiple occurrences of the placeholder would be interpreted. With
>>>>>> magrittr,
>>>>>>
>>>>>> sort(runif(10)) %>% ecdf(.)(.)
>>>>>> ## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
>>>>>>
>>>>>> This is probably what you would expect, if you expect it to work at all, and not
>>>>>>
>>>>>> ecdf(sort(runif(10)))(sort(runif(10)))
>>>>>>
>>>>>> There would be no such ambiguity with anonymous functions
>>>>>>
>>>>>> sort(runif(10)) |> \(.) ecdf(.)(.)
>>>>>>
>>>>>> -Deepayan
>>>>>>
>>>>>>> which would be expanded to something equivalent to the other versions:
>>>>>>> but that makes it quite a bit more complicated.  (Maybe _ or \. should
>>>>>>> be used instead of ., since those are not legal variable names.)
>>>>>>>
>>>>>>> I don't think there should be an attempt to copy magrittr's special
>>>>>>> casing of how . is used in determining whether to also include the
>>>>>>> previous value as first argument.
>>>>>>>
>>>>>>> Duncan Murdoch
>>>>>>>
>>>>>>>
>>>>>>>>
>>>>>>>> Best,
>>>>>>>> Hiroaki Yutani
>>>>>>>>
>>>>>>>> 2020?12?4?(?) 20:51 Duncan Murdoch <murdoch.duncan at gmail.com>:
>>>>>>>>>
>>>>>>>>> Just saw this on the R-devel news:
>>>>>>>>>
>>>>>>>>>
>>>>>>>>> R now provides a simple native pipe syntax ?|>? as well as a shorthand
>>>>>>>>> notation for creating functions, e.g. ?\(x) x + 1? is parsed as
>>>>>>>>> ?function(x) x + 1?. The pipe implementation as a syntax transformation
>>>>>>>>> was motivated by suggestions from Jim Hester and Lionel Henry. These
>>>>>>>>> features are experimental and may change prior to release.
>>>>>>>>>
>>>>>>>>>
>>>>>>>>> This is a good addition; by using "|>" instead of "%>%" there should be
>>>>>>>>> a chance to get operator precedence right.  That said, the ?Syntax help
>>>>>>>>> topic hasn't been updated, so I'm not sure where it fits in.
>>>>>>>>>
>>>>>>>>> There are some choices that take a little getting used to:
>>>>>>>>>
>>>>>>>>>> mtcars |> head
>>>>>>>>> Error: The pipe operator requires a function call or an anonymous
>>>>>>>>> function expression as RHS
>>>>>>>>>
>>>>>>>>> (I need to say mtcars |> head() instead.)  This sometimes leads to error
>>>>>>>>> messages that are somewhat confusing:
>>>>>>>>>
>>>>>>>>>> mtcars |> magrittr::debug_pipe |> head
>>>>>>>>> Error: function '::' not supported in RHS call of a pipe
>>>>>>>>>
>>>>>>>>> but
>>>>>>>>>
>>>>>>>>> mtcars |> magrittr::debug_pipe() |> head()
>>>>>>>>>
>>>>>>>>> works.
>>>>>>>>>
>>>>>>>>> Overall, I think this is a great addition, though it's going to be
>>>>>>>>> disruptive for a while.
>>>>>>>>>
>>>>>>>>> Duncan Murdoch
>>>>>>>>>
>>>>>>>>> ______________________________________________
>>>>>>>>> R-devel at r-project.org mailing list
>>>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>>>
>>>>>>>> ______________________________________________
>>>>>>>> R-devel at r-project.org mailing list
>>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>>>
>>>>>>>
>>>>>>> ______________________________________________
>>>>>>> R-devel at r-project.org mailing list
>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>
>>>>>> ______________________________________________
>>>>>> R-devel at r-project.org mailing list
>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>
>>>>> ______________________________________________
>>>>> R-devel at r-project.org mailing list
>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>
>>>>
>>>> --
>>>> Luke Tierney
>>>> Ralph E. Wareham Professor of Mathematical Sciences
>>>> University of Iowa                  Phone:             319-335-3386
>>>> Department of Statistics and        Fax:               319-335-3017
>>>>     Actuarial Science
>>>> 241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
>>>> Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu
>>>> ______________________________________________
>>>> R-devel at r-project.org mailing list
>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>
>>>
>>>
>>>
>>
>> --
>> Luke Tierney
>> Ralph E. Wareham Professor of Mathematical Sciences
>> University of Iowa                  Phone:             319-335-3386
>> Department of Statistics and        Fax:               319-335-3017
>>     Actuarial Science
>> 241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
>> Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu
>
>
>
>

-- 
Luke Tierney
Ralph E. Wareham Professor of Mathematical Sciences
University of Iowa                  Phone:             319-335-3386
Department of Statistics and        Fax:               319-335-3017
    Actuarial Science
241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu

From g@bembecker @end|ng |rom gm@||@com  Sun Dec  6 20:16:20 2020
From: g@bembecker @end|ng |rom gm@||@com (Gabriel Becker)
Date: Sun, 6 Dec 2020 11:16:20 -0800
Subject: [Rd] [External] Re: New pipe operator
In-Reply-To: <b1540fd5-339b-1a4c-440e-b683c86b4315@kogentum.hu>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <alpine.DEB.2.21.2012051203250.3003@luke-Latitude-7480>
 <b1540fd5-339b-1a4c-440e-b683c86b4315@kogentum.hu>
Message-ID: <CAD4oTHGa1FGn+sDcHSbPHegKhPK_ePZeyDZ58P-+pjm=Zc5N2Q@mail.gmail.com>

Hi Denes,

On Sun, Dec 6, 2020 at 6:43 AM D?nes T?th <toth.denes at kogentum.hu> wrote:

> Dear Luke,
>
> In the meantime I checked the R-syntax branch and the docs; they are
> very helpful. I would also like to thank you for putting effort into
> this feature. Keeping it at the syntax level is also a very smart
> decision. However, the current API might not exploit the full power of
> the basic idea.
>
> 1) Requiring either an anonymous function or a function call, but not
> allowing for symbols which point to functions is inconsistent and will
> be misleading for non-experts.
>
> foo <- function(x) x
> identical(foo, function(x) x)
>
> mtcars |> foo               #bang!
> mtcars |> function(x) x     #fine?
>
> You stated in :
> "
> Another variation supported by the implementation is that a symbol on
> the RHS is interpreted as the name of a function to call with the LHS
> as argument:
>
> ```r
>  > quote(x |> f)
> f(x)
> ```
> "
>
> So clearly this is not an implementation issue but a design decision.
>
> As a remedy, two different pipe operators could be introduced:
>
> LHS |> RHS    -> RHS is treated as a function call
> LHS |>> RHS   -> RHS is treated as a function
>
> If |>> is used, it would not matter which notation is used for the RHS
> expression; the parser would assume it evaluates to a function.
>

I think multiplying the operators would not be a net positive. You'd then
have to remember and mix them when you mix anonymous functions and
non-anonymous functions.  It would result in

LHS |> RHS1() |>> \(x,y) blablabla |> RHS3()

I think thats too much intricacy. Better to be a little more restrictive
in way that (honestly doesnt' really hurt anything afaics, and) guarantees
consistency.

>
> 2) Simplified lambda expression:
> IMHO in the vast majority of use cases, this is used for single-argument
> functions, so parenthesis would not be required. Hence, both forms would
> be valid and equivalent:
>
> \x x + 1
> \(x) x + 1
>
>
Why special case something here when soemtimes you'll want more than one
argument. The parentheses seem really not a big deal. So I don't understand
the motivation here, if I'm being honest.


>
> 3) Function composition:
> Allowing for concise composition of functions would be a great feature.
> E.g., instead of
>
> foo <- function(x) print(mean(sqrt(x), na.rm = TRUE), digits = 2)
>
> or
>
> foo <- \x {x |> sqrt() |> mean(na.rm = TRUE) |> print(digits = 2)}
>
> one could write
>
> foo <- \x |> sqrt() |> mean(na.rm = TRUE) |> print(digits = 2)
>
> So basically if the lambda argument is followed by a pipe operator, the
> pipe chain is transformed to a function body where the first lambda
> argument is inserted into the first position of the pipeline.
>

This one I disagree with very strongly. Reading pipelines would suddenly
require a *much* higher cognitive load than before because you have to
model that complexity just to read it and know what it says. The brackets
there seem like an extremely low price to pay to avoid that. Operator
precedence should be extremely and easily predictable.


>
>
> Best,
> Denes
>
>
> On 12/5/20 7:10 PM, luke-tierney at uiowa.edu wrote:
> > We went back and forth on this several times. The key advantage of
> > requiring parentheses is to keep things simple and consistent.  Let's
> > get some experience with that. If experience shows requiring
> > parentheses creates too many issues then we can add the option of
> > dropping them later (with special handling of :: and :::). It's easier
> > to add flexibility and complexity than to restrict it after the fact.
> >
> > Best,
> >
> > luke
> >
> > On Sat, 5 Dec 2020, Hugh Parsonage wrote:
> >
> >> I'm surprised by the aversion to
> >>
> >> mtcars |> nrow
> >>
> >> over
> >>
> >> mtcars |> nrow()
> >>
> >> and I think the decision to disallow the former should be
> >> reconsidered.  The pipe operator is only going to be used when the rhs
> >> is a function, so there is no ambiguity with omitting the parentheses.
> >> If it's disallowed, it becomes inconsistent with other treatments like
> >> sapply(mtcars, typeof) where sapply(mtcars, typeof()) would just be
> >> noise.  I'm not sure why this decision was taken
> >>
> >> If the only issue is with the double (and triple) colon operator, then
> >> ideally `mtcars |> base::head` should resolve to `base::head(mtcars)`
> >> -- in other words, demote the precedence of |>
> >>
> >> Obviously (looking at the R-Syntax branch) this decision was
> >> considered, put into place, then dropped, but I can't see why
> >> precisely.
> >>
> >> Best,
> >>
> >>
> >> Hugh.
> >>
> >>
> >>
> >>
> >>
> >>
> >>
> >> On Sat, 5 Dec 2020 at 04:07, Deepayan Sarkar
> >> <deepayan.sarkar at gmail.com> wrote:
> >>>
> >>> On Fri, Dec 4, 2020 at 7:35 PM Duncan Murdoch
> >>> <murdoch.duncan at gmail.com> wrote:
> >>>>
> >>>> On 04/12/2020 8:13 a.m., Hiroaki Yutani wrote:
> >>>>>>   Error: function '::' not supported in RHS call of a pipe
> >>>>>
> >>>>> To me, this error looks much more friendly than magrittr's error.
> >>>>> Some of them got too used to specify functions without (). This
> >>>>> is OK until they use `::`, but when they need to use it, it takes
> >>>>> hours to figure out why
> >>>>>
> >>>>> mtcars %>% base::head
> >>>>> #> Error in .::base : unused argument (head)
> >>>>>
> >>>>> won't work but
> >>>>>
> >>>>> mtcars %>% head
> >>>>>
> >>>>> works. I think this is a too harsh lesson for ordinary R users to
> >>>>> learn `::` is a function. I've been wanting for magrittr to drop the
> >>>>> support for a function name without () to avoid this confusion,
> >>>>> so I would very much welcome the new pipe operator's behavior.
> >>>>> Thank you all the developers who implemented this!
> >>>>
> >>>> I agree, it's an improvement on the corresponding magrittr error.
> >>>>
> >>>> I think the semantics of not evaluating the RHS, but treating the pipe
> >>>> as purely syntactical is a good decision.
> >>>>
> >>>> I'm not sure I like the recommended way to pipe into a particular
> >>>> argument:
> >>>>
> >>>>    mtcars |> subset(cyl == 4) |> \(d) lm(mpg ~ disp, data = d)
> >>>>
> >>>> or
> >>>>
> >>>>    mtcars |> subset(cyl == 4) |> function(d) lm(mpg ~ disp, data = d)
> >>>>
> >>>> both of which are equivalent to
> >>>>
> >>>>    mtcars |> subset(cyl == 4) |> (function(d) lm(mpg ~ disp, data =
> >>>> d))()
> >>>>
> >>>> It's tempting to suggest it should allow something like
> >>>>
> >>>>    mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
> >>>
> >>> Which is really not that far off from
> >>>
> >>> mtcars |> subset(cyl == 4) |> \(.) lm(mpg ~ disp, data = .)
> >>>
> >>> once you get used to it.
> >>>
> >>> One consequence of the implementation is that it's not clear how
> >>> multiple occurrences of the placeholder would be interpreted. With
> >>> magrittr,
> >>>
> >>> sort(runif(10)) %>% ecdf(.)(.)
> >>> ## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
> >>>
> >>> This is probably what you would expect, if you expect it to work at
> >>> all, and not
> >>>
> >>> ecdf(sort(runif(10)))(sort(runif(10)))
> >>>
> >>> There would be no such ambiguity with anonymous functions
> >>>
> >>> sort(runif(10)) |> \(.) ecdf(.)(.)
> >>>
> >>> -Deepayan
> >>>
> >>>> which would be expanded to something equivalent to the other versions:
> >>>> but that makes it quite a bit more complicated.  (Maybe _ or \. should
> >>>> be used instead of ., since those are not legal variable names.)
> >>>>
> >>>> I don't think there should be an attempt to copy magrittr's special
> >>>> casing of how . is used in determining whether to also include the
> >>>> previous value as first argument.
> >>>>
> >>>> Duncan Murdoch
> >>>>
> >>>>
> >>>>>
> >>>>> Best,
> >>>>> Hiroaki Yutani
> >>>>>
> >>>>> 2020?12?4?(?) 20:51 Duncan Murdoch <murdoch.duncan at gmail.com>:
> >>>>>>
> >>>>>> Just saw this on the R-devel news:
> >>>>>>
> >>>>>>
> >>>>>> R now provides a simple native pipe syntax ?|>? as well as a
> >>>>>> shorthand
> >>>>>> notation for creating functions, e.g. ?\(x) x + 1? is parsed as
> >>>>>> ?function(x) x + 1?. The pipe implementation as a syntax
> >>>>>> transformation
> >>>>>> was motivated by suggestions from Jim Hester and Lionel Henry. These
> >>>>>> features are experimental and may change prior to release.
> >>>>>>
> >>>>>>
> >>>>>> This is a good addition; by using "|>" instead of "%>%" there
> >>>>>> should be
> >>>>>> a chance to get operator precedence right.  That said, the ?Syntax
> >>>>>> help
> >>>>>> topic hasn't been updated, so I'm not sure where it fits in.
> >>>>>>
> >>>>>> There are some choices that take a little getting used to:
> >>>>>>
> >>>>>>  > mtcars |> head
> >>>>>> Error: The pipe operator requires a function call or an anonymous
> >>>>>> function expression as RHS
> >>>>>>
> >>>>>> (I need to say mtcars |> head() instead.)  This sometimes leads to
> >>>>>> error
> >>>>>> messages that are somewhat confusing:
> >>>>>>
> >>>>>>  > mtcars |> magrittr::debug_pipe |> head
> >>>>>> Error: function '::' not supported in RHS call of a pipe
> >>>>>>
> >>>>>> but
> >>>>>>
> >>>>>> mtcars |> magrittr::debug_pipe() |> head()
> >>>>>>
> >>>>>> works.
> >>>>>>
> >>>>>> Overall, I think this is a great addition, though it's going to be
> >>>>>> disruptive for a while.
> >>>>>>
> >>>>>> Duncan Murdoch
> >>>>>>
> >>>>>> ______________________________________________
> >>>>>> R-devel at r-project.org mailing list
> >>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>>>>
> >>>>> ______________________________________________
> >>>>> R-devel at r-project.org mailing list
> >>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>>>>
> >>>>
> >>>> ______________________________________________
> >>>> R-devel at r-project.org mailing list
> >>>> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>>
> >>> ______________________________________________
> >>> R-devel at r-project.org mailing list
> >>> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>
> >> ______________________________________________
> >> R-devel at r-project.org mailing list
> >> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>
> >
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From @v|gro@@ @end|ng |rom ver|zon@net  Sun Dec  6 20:34:03 2020
From: @v|gro@@ @end|ng |rom ver|zon@net (Avi Gross)
Date: Sun, 6 Dec 2020 14:34:03 -0500
Subject: [Rd] New pipe operator and gg plotz
References: <005a01d6cc06$c1192910$434b7b30$.ref@verizon.net>
Message-ID: <005a01d6cc06$c1192910$434b7b30$@verizon.net>

As someone who switches back and forth between using standard R methods and those of the tidyverse, depending on the problem, my mood and whether Jupiter aligns with Saturn in the new age of Aquarius, I have a question about the forthcoming built-in pipe. Will it motivate anyone to eventually change or enhance the ggplot functionality to have a version that gets rid of the odd use of the addition symbol?

I mean I now sometimes have a pipeline that looks like:

Data %>%
	Do_this %>%
	Do_that(whatever) %>%
	ggplot(...) +
		geom_whatever(...) +
		...

My understanding is this is a bit of a historical anomaly that might someday be modified back.

As I understand it, the call to ggplot() creates a partially filled-in object that holds all kinds of useful info. The additional calls to geom_point() and so on will add/change that hidden object. Nothing much happens till the object is implicitly or explicitly given to print() which switches to the print function for objects of that type and creates a graph based on the contents of the object at that time. So, in theory, you could have a pipelined version of ggplot where the first function accepts something like a  data.frame or tibble as the default first argument and at the end returns the object we have been describing. All additional functions would then accept such an object as the (hidden?) first argument and return the modified object. The final function in the pipe would either have the value captured in a variable for later use or print implicitly generating a graph.

So the above silly example might become:

Data %>%
	Do_this %>%
	Do_that(whatever) %>%
	ggplot(...) %>%
	geom_whatever(...) %>%
	...

Or, am I missing something here? 

The language and extensions such as are now in the tidyverse might be more streamlined and easier to read when using consistent notation. If we now build a reasonable version of the pipeline in, might we encourage other uses to gradually migrate back closer to the mainstream?

-----Original Message-----
From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Rui Barradas
Sent: Sunday, December 6, 2020 2:51 AM
To: Gregory Warnes <greg at warnes.net>; Abby Spurdle <spurdle.a at gmail.com>
Cc: r-devel <r-devel at r-project.org>
Subject: Re: [Rd] New pipe operator

Hello,

If Hilbert liked beer, I like "pipe".

More seriously, a new addition like this one is going to cause problems yet unknown. But it's a good idea to have a pipe operator available. As someone used to magrittr's data pipelines, I will play with this base one before making up my mind. I don't expect its behavior to be exactly like magrittr "%>%" (and it's not). For the moment all I can say is that it is something R users are used to and that it now avoids loading a package.
As for the new way to define anonymous functions, I am less sure. Too much syntatic sugar? Or am I finding the syntax ugly?

Hope this helps,

Rui Barradas


?s 03:22 de 06/12/20, Gregory Warnes escreveu:
> If we?re being mathematically pedantic, the ?pipe? operator is 
> actually function composition > That being said, pipes are a simple 
> and well-known idiom. While being less
> than mathematically exact, it seems a reasonable   label for the (very
> useful) behavior.
> 
> On Sat, Dec 5, 2020 at 9:43 PM Abby Spurdle <spurdle.a at gmail.com> wrote:
> 
>>> This is a good addition
>>
>> I can't understand why so many people are calling this a "pipe".
>> Pipes connect processes, via their I/O streams.
>> Arguably, a more general interpretation would include sockets and files.
>>
>> https://en.wikipedia.org/wiki/Pipeline_(Unix)
>> https://en.wikipedia.org/wiki/Named_pipe
>> https://en.wikipedia.org/wiki/Anonymous_pipe
>>
>> As far as I can tell, the magrittr-like operators are functions (not 
>> pipes), with nonstandard syntax.
>> This is not consistent with R's original design philosophy, building 
>> on C, Lisp and S, along with lots of *important* math and stats.
>>
>> It's possible that some parties are interested in creating a kind of 
>> "data pipeline".
>> I'm interested in this myself, and I think we could discuss this more.
>> But I'm not convinced the magrittr-like operators help to achieve 
>> this goal.
>> Which, in my opinion, would require one to model programs as directed 
>> graphs, along with some degree of asynchronous input.
>>
>> Presumably, these operators will be added to R anyway, and (almost) 
>> no one will listen to me.
>>
>> So, I would like to make one suggestion:
>> Is it possible for these operators to *not* be named:
>>      The R Pipe
>>      The S Pipe
>>      Or anything with a similar meaning.
>>
>> Maybe tidy pipe, or something else that links it to its proponents?
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>

______________________________________________
R-devel at r-project.org mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


Scanned by McAfee and confirmed virus-free.	
Find out more here: https://bit.ly/2zCJMrO


From murdoch@dunc@n @end|ng |rom gm@||@com  Sun Dec  6 20:50:17 2020
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Sun, 6 Dec 2020 14:50:17 -0500
Subject: [Rd] New pipe operator and gg plotz
In-Reply-To: <005a01d6cc06$c1192910$434b7b30$@verizon.net>
References: <005a01d6cc06$c1192910$434b7b30$.ref@verizon.net>
 <005a01d6cc06$c1192910$434b7b30$@verizon.net>
Message-ID: <342b718d-6616-3681-5302-d253c3041f14@gmail.com>

Hadley's answer (#7 here: 
https://community.rstudio.com/t/why-cant-ggplot2-use/4372) makes it 
pretty clear that he thinks it would have been nice now if he had made 
that choice when ggplot2 came out, but it's not worth the effort now to 
change it.

Duncan Murdoch

On 06/12/2020 2:34 p.m., Avi Gross via R-devel wrote:
> As someone who switches back and forth between using standard R methods and those of the tidyverse, depending on the problem, my mood and whether Jupiter aligns with Saturn in the new age of Aquarius, I have a question about the forthcoming built-in pipe. Will it motivate anyone to eventually change or enhance the ggplot functionality to have a version that gets rid of the odd use of the addition symbol?
> 
> I mean I now sometimes have a pipeline that looks like:
> 
> Data %>%
> 	Do_this %>%
> 	Do_that(whatever) %>%
> 	ggplot(...) +
> 		geom_whatever(...) +
> 		...
> 
> My understanding is this is a bit of a historical anomaly that might someday be modified back.
> 
> As I understand it, the call to ggplot() creates a partially filled-in object that holds all kinds of useful info. The additional calls to geom_point() and so on will add/change that hidden object. Nothing much happens till the object is implicitly or explicitly given to print() which switches to the print function for objects of that type and creates a graph based on the contents of the object at that time. So, in theory, you could have a pipelined version of ggplot where the first function accepts something like a  data.frame or tibble as the default first argument and at the end returns the object we have been describing. All additional functions would then accept such an object as the (hidden?) first argument and return the modified object. The final function in the pipe would either have the value captured in a variable for later use or print implicitly generating a graph.
> 
> So the above silly example might become:
> 
> Data %>%
> 	Do_this %>%
> 	Do_that(whatever) %>%
> 	ggplot(...) %>%
> 	geom_whatever(...) %>%
> 	...
> 
> Or, am I missing something here?
> 
> The language and extensions such as are now in the tidyverse might be more streamlined and easier to read when using consistent notation. If we now build a reasonable version of the pipeline in, might we encourage other uses to gradually migrate back closer to the mainstream?
> 
> -----Original Message-----
> From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Rui Barradas
> Sent: Sunday, December 6, 2020 2:51 AM
> To: Gregory Warnes <greg at warnes.net>; Abby Spurdle <spurdle.a at gmail.com>
> Cc: r-devel <r-devel at r-project.org>
> Subject: Re: [Rd] New pipe operator
> 
> Hello,
> 
> If Hilbert liked beer, I like "pipe".
> 
> More seriously, a new addition like this one is going to cause problems yet unknown. But it's a good idea to have a pipe operator available. As someone used to magrittr's data pipelines, I will play with this base one before making up my mind. I don't expect its behavior to be exactly like magrittr "%>%" (and it's not). For the moment all I can say is that it is something R users are used to and that it now avoids loading a package.
> As for the new way to define anonymous functions, I am less sure. Too much syntatic sugar? Or am I finding the syntax ugly?
> 
> Hope this helps,
> 
> Rui Barradas
> 
> 
> ?s 03:22 de 06/12/20, Gregory Warnes escreveu:
>> If we?re being mathematically pedantic, the ?pipe? operator is
>> actually function composition > That being said, pipes are a simple
>> and well-known idiom. While being less
>> than mathematically exact, it seems a reasonable   label for the (very
>> useful) behavior.
>>
>> On Sat, Dec 5, 2020 at 9:43 PM Abby Spurdle <spurdle.a at gmail.com> wrote:
>>
>>>> This is a good addition
>>>
>>> I can't understand why so many people are calling this a "pipe".
>>> Pipes connect processes, via their I/O streams.
>>> Arguably, a more general interpretation would include sockets and files.
>>>
>>> https://en.wikipedia.org/wiki/Pipeline_(Unix)
>>> https://en.wikipedia.org/wiki/Named_pipe
>>> https://en.wikipedia.org/wiki/Anonymous_pipe
>>>
>>> As far as I can tell, the magrittr-like operators are functions (not
>>> pipes), with nonstandard syntax.
>>> This is not consistent with R's original design philosophy, building
>>> on C, Lisp and S, along with lots of *important* math and stats.
>>>
>>> It's possible that some parties are interested in creating a kind of
>>> "data pipeline".
>>> I'm interested in this myself, and I think we could discuss this more.
>>> But I'm not convinced the magrittr-like operators help to achieve
>>> this goal.
>>> Which, in my opinion, would require one to model programs as directed
>>> graphs, along with some degree of asynchronous input.
>>>
>>> Presumably, these operators will be added to R anyway, and (almost)
>>> no one will listen to me.
>>>
>>> So, I would like to make one suggestion:
>>> Is it possible for these operators to *not* be named:
>>>       The R Pipe
>>>       The S Pipe
>>>       Or anything with a similar meaning.
>>>
>>> Maybe tidy pipe, or something else that links it to its proponents?
>>>
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> 
> Scanned by McAfee and confirmed virus-free.	
> Find out more here: https://bit.ly/2zCJMrO
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


From toth@dene@ @end|ng |rom kogentum@hu  Sun Dec  6 21:37:38 2020
From: toth@dene@ @end|ng |rom kogentum@hu (=?UTF-8?B?RMOpbmVzIFTDs3Ro?=)
Date: Sun, 6 Dec 2020 21:37:38 +0100
Subject: [Rd] [External] Re: New pipe operator
In-Reply-To: <CAD4oTHGa1FGn+sDcHSbPHegKhPK_ePZeyDZ58P-+pjm=Zc5N2Q@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <alpine.DEB.2.21.2012051203250.3003@luke-Latitude-7480>
 <b1540fd5-339b-1a4c-440e-b683c86b4315@kogentum.hu>
 <CAD4oTHGa1FGn+sDcHSbPHegKhPK_ePZeyDZ58P-+pjm=Zc5N2Q@mail.gmail.com>
Message-ID: <87987297-0f44-bc50-6486-c37149629406@kogentum.hu>

Hi Gabriel,

Thanks for the comments. See inline.

On 12/6/20 8:16 PM, Gabriel Becker wrote:
> Hi Denes,
> 
> On Sun, Dec 6, 2020 at 6:43 AM D?nes T?th <toth.denes at kogentum.hu 
> <mailto:toth.denes at kogentum.hu>> wrote:
> 
>     Dear Luke,
> 
>     In the meantime I checked the R-syntax branch and the docs; they are
>     very helpful. I would also like to thank you for putting effort into
>     this feature. Keeping it at the syntax level is also a very smart
>     decision. However, the current API might not exploit the full power of
>     the basic idea.
> 
>     1) Requiring either an anonymous function or a function call, but not
>     allowing for symbols which point to functions is inconsistent and will
>     be misleading for non-experts.
> 
>     foo <- function(x) x
>     identical(foo, function(x) x)
> 
>     mtcars |> foo? ? ? ? ? ? ? ?#bang!
>     mtcars |> function(x) x? ? ?#fine?
> 
>     You stated in :
>     "
>     Another variation supported by the implementation is that a symbol on
>     the RHS is interpreted as the name of a function to call with the LHS
>     as argument:
> 
>     ```r
>      ?> quote(x |> f)
>     f(x)
>     ```
>     "
> 
>     So clearly this is not an implementation issue but a design decision.
> 
>     As a remedy, two different pipe operators could be introduced:
> 
>     LHS |> RHS? ? -> RHS is treated as a function call
>     LHS |>> RHS? ?-> RHS is treated as a function
> 
>     If |>> is used, it would not matter which notation is used for the RHS
>     expression; the parser would assume it evaluates to a function.
> 
> 
> I think multiplying the operators would not be a net positive. You'd 
> then have to remember and mix them when you mix anonymous functions and 
> non-anonymous functions.? It would result in
> 
> LHS |> RHS1() |>> \(x,y) blablabla |> RHS3()
> 
> I think thats?too much intricacy. Better to be a little more 
> restrictive? in way that (honestly doesnt' really hurt anything afaics, 
> and) guarantees consistency.
> 

That was just a secondary option for the case if pure symbols are 
disallowed on the RHS. The point is that one can not avoid inconsistency 
here because of practical considerations; let us admit, R has tons of 
inconsistencies which are usually motivated by making interactive data 
analysis more convenient. To me it seems more inconsistent to allow for 
function calls and functions but not symbols - either allow all of them 
or be strict and enforce function calls.

> 
>     2) Simplified lambda expression:
>     IMHO in the vast majority of use cases, this is used for
>     single-argument
>     functions, so parenthesis would not be required. Hence, both forms
>     would
>     be valid and equivalent:
> 
>     \x x + 1
>     \(x) x + 1
> 
> 
> Why special case something here when soemtimes you'll want more than one 
> argument. The parentheses seem really not a big deal. So I don't 
> understand the motivation here, if I'm being honest.

Just as I told before: because of practical considerations. In a 
Hungarian keyboard layout, this is how one types the backslash 
character: RightAlt+Q. Parenthesis: Shift+8 (left), Shift+9 (Right). 
This is how you type 'function' in the R terminal: fu+TAB. I do not 
really see the point of the new notation as it is now.

> 
> 
>     3) Function composition:
>     Allowing for concise composition of functions would be a great feature.
>     E.g., instead of
> 
>     foo <- function(x) print(mean(sqrt(x), na.rm = TRUE), digits = 2)
> 
>     or
> 
>     foo <- \x {x |> sqrt() |> mean(na.rm = TRUE) |> print(digits = 2)}
> 
>     one could write
> 
>     foo <- \x |> sqrt() |> mean(na.rm = TRUE) |> print(digits = 2)
> 
>     So basically if the lambda argument is followed by a pipe operator, the
>     pipe chain is transformed to a function body where the first lambda
>     argument is inserted into the first position of the pipeline.
> 
> 
> This one I disagree with very strongly. Reading pipelines would suddenly 
> require a /much/?higher cognitive load than before because you have to 
> model that complexity just to read it and know what it says. The 
> brackets there seem like an extremely low price to pay to avoid that. 
> Operator precedence should be extremely and easily predictable.
> 

Unfortunately I could not come up with a better solution to approximate 
a function composition operator (supporting tacit/pointfree-style 
programming) which avoids the introduction of a separate function (like 
e.g. purrr::compose).

In Haskell:
floor . sqrt

In Julia (looks nice but requires \circTAB or custom keybinding):
floor ? sqrt

In R: ?


Best,
Denes



> 
> 
>     Best,
>     Denes
> 
> 
>     On 12/5/20 7:10 PM, luke-tierney at uiowa.edu
>     <mailto:luke-tierney at uiowa.edu> wrote:
>      > We went back and forth on this several times. The key advantage of
>      > requiring parentheses is to keep things simple and consistent.? Let's
>      > get some experience with that. If experience shows requiring
>      > parentheses creates too many issues then we can add the option of
>      > dropping them later (with special handling of :: and :::). It's
>     easier
>      > to add flexibility and complexity than to restrict it after the fact.
>      >
>      > Best,
>      >
>      > luke
>      >
>      > On Sat, 5 Dec 2020, Hugh Parsonage wrote:
>      >
>      >> I'm surprised by the aversion to
>      >>
>      >> mtcars |> nrow
>      >>
>      >> over
>      >>
>      >> mtcars |> nrow()
>      >>
>      >> and I think the decision to disallow the former should be
>      >> reconsidered.? The pipe operator is only going to be used when
>     the rhs
>      >> is a function, so there is no ambiguity with omitting the
>     parentheses.
>      >> If it's disallowed, it becomes inconsistent with other
>     treatments like
>      >> sapply(mtcars, typeof) where sapply(mtcars, typeof()) would just be
>      >> noise.? I'm not sure why this decision was taken
>      >>
>      >> If the only issue is with the double (and triple) colon
>     operator, then
>      >> ideally `mtcars |> base::head` should resolve to
>     `base::head(mtcars)`
>      >> -- in other words, demote the precedence of |>
>      >>
>      >> Obviously (looking at the R-Syntax branch) this decision was
>      >> considered, put into place, then dropped, but I can't see why
>      >> precisely.
>      >>
>      >> Best,
>      >>
>      >>
>      >> Hugh.
>      >>
>      >>
>      >>
>      >>
>      >>
>      >>
>      >>
>      >> On Sat, 5 Dec 2020 at 04:07, Deepayan Sarkar
>      >> <deepayan.sarkar at gmail.com <mailto:deepayan.sarkar at gmail.com>>
>     wrote:
>      >>>
>      >>> On Fri, Dec 4, 2020 at 7:35 PM Duncan Murdoch
>      >>> <murdoch.duncan at gmail.com <mailto:murdoch.duncan at gmail.com>> wrote:
>      >>>>
>      >>>> On 04/12/2020 8:13 a.m., Hiroaki Yutani wrote:
>      >>>>>> ? Error: function '::' not supported in RHS call of a pipe
>      >>>>>
>      >>>>> To me, this error looks much more friendly than magrittr's error.
>      >>>>> Some of them got too used to specify functions without (). This
>      >>>>> is OK until they use `::`, but when they need to use it, it takes
>      >>>>> hours to figure out why
>      >>>>>
>      >>>>> mtcars %>% base::head
>      >>>>> #> Error in .::base : unused argument (head)
>      >>>>>
>      >>>>> won't work but
>      >>>>>
>      >>>>> mtcars %>% head
>      >>>>>
>      >>>>> works. I think this is a too harsh lesson for ordinary R users to
>      >>>>> learn `::` is a function. I've been wanting for magrittr to
>     drop the
>      >>>>> support for a function name without () to avoid this confusion,
>      >>>>> so I would very much welcome the new pipe operator's behavior.
>      >>>>> Thank you all the developers who implemented this!
>      >>>>
>      >>>> I agree, it's an improvement on the corresponding magrittr error.
>      >>>>
>      >>>> I think the semantics of not evaluating the RHS, but treating
>     the pipe
>      >>>> as purely syntactical is a good decision.
>      >>>>
>      >>>> I'm not sure I like the recommended way to pipe into a particular
>      >>>> argument:
>      >>>>
>      >>>> ?? mtcars |> subset(cyl == 4) |> \(d) lm(mpg ~ disp, data = d)
>      >>>>
>      >>>> or
>      >>>>
>      >>>> ?? mtcars |> subset(cyl == 4) |> function(d) lm(mpg ~ disp,
>     data = d)
>      >>>>
>      >>>> both of which are equivalent to
>      >>>>
>      >>>> ?? mtcars |> subset(cyl == 4) |> (function(d) lm(mpg ~ disp,
>     data =
>      >>>> d))()
>      >>>>
>      >>>> It's tempting to suggest it should allow something like
>      >>>>
>      >>>> ?? mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
>      >>>
>      >>> Which is really not that far off from
>      >>>
>      >>> mtcars |> subset(cyl == 4) |> \(.) lm(mpg ~ disp, data = .)
>      >>>
>      >>> once you get used to it.
>      >>>
>      >>> One consequence of the implementation is that it's not clear how
>      >>> multiple occurrences of the placeholder would be interpreted. With
>      >>> magrittr,
>      >>>
>      >>> sort(runif(10)) %>% ecdf(.)(.)
>      >>> ## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
>      >>>
>      >>> This is probably what you would expect, if you expect it to
>     work at
>      >>> all, and not
>      >>>
>      >>> ecdf(sort(runif(10)))(sort(runif(10)))
>      >>>
>      >>> There would be no such ambiguity with anonymous functions
>      >>>
>      >>> sort(runif(10)) |> \(.) ecdf(.)(.)
>      >>>
>      >>> -Deepayan
>      >>>
>      >>>> which would be expanded to something equivalent to the other
>     versions:
>      >>>> but that makes it quite a bit more complicated.? (Maybe _ or
>     \. should
>      >>>> be used instead of ., since those are not legal variable names.)
>      >>>>
>      >>>> I don't think there should be an attempt to copy magrittr's
>     special
>      >>>> casing of how . is used in determining whether to also include the
>      >>>> previous value as first argument.
>      >>>>
>      >>>> Duncan Murdoch
>      >>>>
>      >>>>
>      >>>>>
>      >>>>> Best,
>      >>>>> Hiroaki Yutani
>      >>>>>
>      >>>>> 2020?12?4?(?) 20:51 Duncan Murdoch
>     <murdoch.duncan at gmail.com <mailto:murdoch.duncan at gmail.com>>:
>      >>>>>>
>      >>>>>> Just saw this on the R-devel news:
>      >>>>>>
>      >>>>>>
>      >>>>>> R now provides a simple native pipe syntax ?|>? as well as a
>      >>>>>> shorthand
>      >>>>>> notation for creating functions, e.g. ?\(x) x + 1? is parsed as
>      >>>>>> ?function(x) x + 1?. The pipe implementation as a syntax
>      >>>>>> transformation
>      >>>>>> was motivated by suggestions from Jim Hester and Lionel
>     Henry. These
>      >>>>>> features are experimental and may change prior to release.
>      >>>>>>
>      >>>>>>
>      >>>>>> This is a good addition; by using "|>" instead of "%>%" there
>      >>>>>> should be
>      >>>>>> a chance to get operator precedence right.? That said, the
>     ?Syntax
>      >>>>>> help
>      >>>>>> topic hasn't been updated, so I'm not sure where it fits in.
>      >>>>>>
>      >>>>>> There are some choices that take a little getting used to:
>      >>>>>>
>      >>>>>> ?> mtcars |> head
>      >>>>>> Error: The pipe operator requires a function call or an
>     anonymous
>      >>>>>> function expression as RHS
>      >>>>>>
>      >>>>>> (I need to say mtcars |> head() instead.)? This sometimes
>     leads to
>      >>>>>> error
>      >>>>>> messages that are somewhat confusing:
>      >>>>>>
>      >>>>>> ?> mtcars |> magrittr::debug_pipe |> head
>      >>>>>> Error: function '::' not supported in RHS call of a pipe
>      >>>>>>
>      >>>>>> but
>      >>>>>>
>      >>>>>> mtcars |> magrittr::debug_pipe() |> head()
>      >>>>>>
>      >>>>>> works.
>      >>>>>>
>      >>>>>> Overall, I think this is a great addition, though it's going
>     to be
>      >>>>>> disruptive for a while.
>      >>>>>>
>      >>>>>> Duncan Murdoch
>      >>>>>>
>      >>>>>> ______________________________________________
>      >>>>>> R-devel at r-project.org <mailto:R-devel at r-project.org> mailing
>     list
>      >>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>      >>>>>
>      >>>>> ______________________________________________
>      >>>>> R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
>      >>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>      >>>>>
>      >>>>
>      >>>> ______________________________________________
>      >>>> R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
>      >>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>      >>>
>      >>> ______________________________________________
>      >>> R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
>      >>> https://stat.ethz.ch/mailman/listinfo/r-devel
>      >>
>      >> ______________________________________________
>      >> R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
>      >> https://stat.ethz.ch/mailman/listinfo/r-devel
>      >>
>      >
> 
>     ______________________________________________
>     R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
>     https://stat.ethz.ch/mailman/listinfo/r-devel
>


From ggrothend|eck @end|ng |rom gm@||@com  Sun Dec  6 21:51:18 2020
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Sun, 6 Dec 2020 15:51:18 -0500
Subject: [Rd] New pipe operator
In-Reply-To: <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
Message-ID: <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>

I think the real issue here is that functions are supposed to be
first class objects in R
or are supposed to be and |> would break that if if is possible
to write function(x) x + 1 on the RHS but not foo (assuming foo
was defined as that function).

I don't think getting experience with using it can change that
inconsistency which seems serious to me and needs to
be addressed even if it complicates the implementation
since it drives to the heart of what R is.

On Sat, Dec 5, 2020 at 1:08 PM Gabor Grothendieck
<ggrothendieck at gmail.com> wrote:
>
> The construct utils::head  is not that common but bare functions are
> very common and to make it harder to use the common case so that
> the uncommon case is slightly easier is not desirable.
>
> Also it is trivial to write this which does work:
>
> mtcars %>% (utils::head)
>
> On Sat, Dec 5, 2020 at 11:59 AM Hugh Parsonage <hugh.parsonage at gmail.com> wrote:
> >
> > I'm surprised by the aversion to
> >
> > mtcars |> nrow
> >
> > over
> >
> > mtcars |> nrow()
> >
> > and I think the decision to disallow the former should be
> > reconsidered.  The pipe operator is only going to be used when the rhs
> > is a function, so there is no ambiguity with omitting the parentheses.
> > If it's disallowed, it becomes inconsistent with other treatments like
> > sapply(mtcars, typeof) where sapply(mtcars, typeof()) would just be
> > noise.  I'm not sure why this decision was taken
> >
> > If the only issue is with the double (and triple) colon operator, then
> > ideally `mtcars |> base::head` should resolve to `base::head(mtcars)`
> > -- in other words, demote the precedence of |>
> >
> > Obviously (looking at the R-Syntax branch) this decision was
> > considered, put into place, then dropped, but I can't see why
> > precisely.
> >
> > Best,
> >
> >
> > Hugh.
> >
> >
> >
> >
> >
> >
> >
> > On Sat, 5 Dec 2020 at 04:07, Deepayan Sarkar <deepayan.sarkar at gmail.com> wrote:
> > >
> > > On Fri, Dec 4, 2020 at 7:35 PM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
> > > >
> > > > On 04/12/2020 8:13 a.m., Hiroaki Yutani wrote:
> > > > >>   Error: function '::' not supported in RHS call of a pipe
> > > > >
> > > > > To me, this error looks much more friendly than magrittr's error.
> > > > > Some of them got too used to specify functions without (). This
> > > > > is OK until they use `::`, but when they need to use it, it takes
> > > > > hours to figure out why
> > > > >
> > > > > mtcars %>% base::head
> > > > > #> Error in .::base : unused argument (head)
> > > > >
> > > > > won't work but
> > > > >
> > > > > mtcars %>% head
> > > > >
> > > > > works. I think this is a too harsh lesson for ordinary R users to
> > > > > learn `::` is a function. I've been wanting for magrittr to drop the
> > > > > support for a function name without () to avoid this confusion,
> > > > > so I would very much welcome the new pipe operator's behavior.
> > > > > Thank you all the developers who implemented this!
> > > >
> > > > I agree, it's an improvement on the corresponding magrittr error.
> > > >
> > > > I think the semantics of not evaluating the RHS, but treating the pipe
> > > > as purely syntactical is a good decision.
> > > >
> > > > I'm not sure I like the recommended way to pipe into a particular argument:
> > > >
> > > >    mtcars |> subset(cyl == 4) |> \(d) lm(mpg ~ disp, data = d)
> > > >
> > > > or
> > > >
> > > >    mtcars |> subset(cyl == 4) |> function(d) lm(mpg ~ disp, data = d)
> > > >
> > > > both of which are equivalent to
> > > >
> > > >    mtcars |> subset(cyl == 4) |> (function(d) lm(mpg ~ disp, data = d))()
> > > >
> > > > It's tempting to suggest it should allow something like
> > > >
> > > >    mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
> > >
> > > Which is really not that far off from
> > >
> > > mtcars |> subset(cyl == 4) |> \(.) lm(mpg ~ disp, data = .)
> > >
> > > once you get used to it.
> > >
> > > One consequence of the implementation is that it's not clear how
> > > multiple occurrences of the placeholder would be interpreted. With
> > > magrittr,
> > >
> > > sort(runif(10)) %>% ecdf(.)(.)
> > > ## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
> > >
> > > This is probably what you would expect, if you expect it to work at all, and not
> > >
> > > ecdf(sort(runif(10)))(sort(runif(10)))
> > >
> > > There would be no such ambiguity with anonymous functions
> > >
> > > sort(runif(10)) |> \(.) ecdf(.)(.)
> > >
> > > -Deepayan
> > >
> > > > which would be expanded to something equivalent to the other versions:
> > > > but that makes it quite a bit more complicated.  (Maybe _ or \. should
> > > > be used instead of ., since those are not legal variable names.)
> > > >
> > > > I don't think there should be an attempt to copy magrittr's special
> > > > casing of how . is used in determining whether to also include the
> > > > previous value as first argument.
> > > >
> > > > Duncan Murdoch
> > > >
> > > >
> > > > >
> > > > > Best,
> > > > > Hiroaki Yutani
> > > > >
> > > > > 2020?12?4?(?) 20:51 Duncan Murdoch <murdoch.duncan at gmail.com>:
> > > > >>
> > > > >> Just saw this on the R-devel news:
> > > > >>
> > > > >>
> > > > >> R now provides a simple native pipe syntax ?|>? as well as a shorthand
> > > > >> notation for creating functions, e.g. ?\(x) x + 1? is parsed as
> > > > >> ?function(x) x + 1?. The pipe implementation as a syntax transformation
> > > > >> was motivated by suggestions from Jim Hester and Lionel Henry. These
> > > > >> features are experimental and may change prior to release.
> > > > >>
> > > > >>
> > > > >> This is a good addition; by using "|>" instead of "%>%" there should be
> > > > >> a chance to get operator precedence right.  That said, the ?Syntax help
> > > > >> topic hasn't been updated, so I'm not sure where it fits in.
> > > > >>
> > > > >> There are some choices that take a little getting used to:
> > > > >>
> > > > >>   > mtcars |> head
> > > > >> Error: The pipe operator requires a function call or an anonymous
> > > > >> function expression as RHS
> > > > >>
> > > > >> (I need to say mtcars |> head() instead.)  This sometimes leads to error
> > > > >> messages that are somewhat confusing:
> > > > >>
> > > > >>   > mtcars |> magrittr::debug_pipe |> head
> > > > >> Error: function '::' not supported in RHS call of a pipe
> > > > >>
> > > > >> but
> > > > >>
> > > > >> mtcars |> magrittr::debug_pipe() |> head()
> > > > >>
> > > > >> works.
> > > > >>
> > > > >> Overall, I think this is a great addition, though it's going to be
> > > > >> disruptive for a while.
> > > > >>
> > > > >> Duncan Murdoch
> > > > >>
> > > > >> ______________________________________________
> > > > >> R-devel at r-project.org mailing list
> > > > >> https://stat.ethz.ch/mailman/listinfo/r-devel
> > > > >
> > > > > ______________________________________________
> > > > > R-devel at r-project.org mailing list
> > > > > https://stat.ethz.ch/mailman/listinfo/r-devel
> > > > >
> > > >
> > > > ______________________________________________
> > > > R-devel at r-project.org mailing list
> > > > https://stat.ethz.ch/mailman/listinfo/r-devel
> > >
> > > ______________________________________________
> > > R-devel at r-project.org mailing list
> > > https://stat.ethz.ch/mailman/listinfo/r-devel
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
>
>
>
> --
> Statistics & Software Consulting
> GKX Group, GKX Associates Inc.
> tel: 1-877-GKX-GROUP
> email: ggrothendieck at gmail.com



-- 
Statistics & Software Consulting
GKX Group, GKX Associates Inc.
tel: 1-877-GKX-GROUP
email: ggrothendieck at gmail.com


From g@bembecker @end|ng |rom gm@||@com  Sun Dec  6 22:06:37 2020
From: g@bembecker @end|ng |rom gm@||@com (Gabriel Becker)
Date: Sun, 6 Dec 2020 13:06:37 -0800
Subject: [Rd] New pipe operator
In-Reply-To: <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
 <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
Message-ID: <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>

Hi Gabor,

On Sun, Dec 6, 2020 at 12:52 PM Gabor Grothendieck <ggrothendieck at gmail.com>
wrote:

> I think the real issue here is that functions are supposed to be
> first class objects in R
> or are supposed to be and |> would break that if if is possible
> to write function(x) x + 1 on the RHS but not foo (assuming foo
> was defined as that function).
>
> I don't think getting experience with using it can change that
> inconsistency which seems serious to me and needs to
> be addressed even if it complicates the implementation
> since it drives to the heart of what R is.
>
>
With respect I think this is a misunderstanding of what is happening here.

Functions are first class citizens. |> is, for all intents and purposes, a
*macro. *

LHS |> RHS(arg2=5)

*parses to*

RHS(LHS, arg2 = 5)

There are no functions at the point in time when the pipe transformation
happens, because no code has been evaluated. To know if a symbol is going
to evaluate to a function requires evaluation which is a step entirely
after the one where the |> pipe is implemented.

Another way to think about it is that

LHS |> RHS(arg2 = 5)

is another way of *writing* RHS(LHS, arg2 = 5), NOT R code that is (or even
can be) evaluated.


Now this is a subtle point that only really has implications in as much as
it is not the case for magrittr pipes, but its relevant for discussions
like this, I think.

~G

On Sat, Dec 5, 2020 at 1:08 PM Gabor Grothendieck
> <ggrothendieck at gmail.com> wrote:
> >
> > The construct utils::head  is not that common but bare functions are
> > very common and to make it harder to use the common case so that
> > the uncommon case is slightly easier is not desirable.
> >
> > Also it is trivial to write this which does work:
> >
> > mtcars %>% (utils::head)
> >
> > On Sat, Dec 5, 2020 at 11:59 AM Hugh Parsonage <hugh.parsonage at gmail.com>
> wrote:
> > >
> > > I'm surprised by the aversion to
> > >
> > > mtcars |> nrow
> > >
> > > over
> > >
> > > mtcars |> nrow()
> > >
> > > and I think the decision to disallow the former should be
> > > reconsidered.  The pipe operator is only going to be used when the rhs
> > > is a function, so there is no ambiguity with omitting the parentheses.
> > > If it's disallowed, it becomes inconsistent with other treatments like
> > > sapply(mtcars, typeof) where sapply(mtcars, typeof()) would just be
> > > noise.  I'm not sure why this decision was taken
> > >
> > > If the only issue is with the double (and triple) colon operator, then
> > > ideally `mtcars |> base::head` should resolve to `base::head(mtcars)`
> > > -- in other words, demote the precedence of |>
> > >
> > > Obviously (looking at the R-Syntax branch) this decision was
> > > considered, put into place, then dropped, but I can't see why
> > > precisely.
> > >
> > > Best,
> > >
> > >
> > > Hugh.
> > >
> > >
> > >
> > >
> > >
> > >
> > >
> > > On Sat, 5 Dec 2020 at 04:07, Deepayan Sarkar <
> deepayan.sarkar at gmail.com> wrote:
> > > >
> > > > On Fri, Dec 4, 2020 at 7:35 PM Duncan Murdoch <
> murdoch.duncan at gmail.com> wrote:
> > > > >
> > > > > On 04/12/2020 8:13 a.m., Hiroaki Yutani wrote:
> > > > > >>   Error: function '::' not supported in RHS call of a pipe
> > > > > >
> > > > > > To me, this error looks much more friendly than magrittr's error.
> > > > > > Some of them got too used to specify functions without (). This
> > > > > > is OK until they use `::`, but when they need to use it, it takes
> > > > > > hours to figure out why
> > > > > >
> > > > > > mtcars %>% base::head
> > > > > > #> Error in .::base : unused argument (head)
> > > > > >
> > > > > > won't work but
> > > > > >
> > > > > > mtcars %>% head
> > > > > >
> > > > > > works. I think this is a too harsh lesson for ordinary R users to
> > > > > > learn `::` is a function. I've been wanting for magrittr to drop
> the
> > > > > > support for a function name without () to avoid this confusion,
> > > > > > so I would very much welcome the new pipe operator's behavior.
> > > > > > Thank you all the developers who implemented this!
> > > > >
> > > > > I agree, it's an improvement on the corresponding magrittr error.
> > > > >
> > > > > I think the semantics of not evaluating the RHS, but treating the
> pipe
> > > > > as purely syntactical is a good decision.
> > > > >
> > > > > I'm not sure I like the recommended way to pipe into a particular
> argument:
> > > > >
> > > > >    mtcars |> subset(cyl == 4) |> \(d) lm(mpg ~ disp, data = d)
> > > > >
> > > > > or
> > > > >
> > > > >    mtcars |> subset(cyl == 4) |> function(d) lm(mpg ~ disp, data =
> d)
> > > > >
> > > > > both of which are equivalent to
> > > > >
> > > > >    mtcars |> subset(cyl == 4) |> (function(d) lm(mpg ~ disp, data
> = d))()
> > > > >
> > > > > It's tempting to suggest it should allow something like
> > > > >
> > > > >    mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
> > > >
> > > > Which is really not that far off from
> > > >
> > > > mtcars |> subset(cyl == 4) |> \(.) lm(mpg ~ disp, data = .)
> > > >
> > > > once you get used to it.
> > > >
> > > > One consequence of the implementation is that it's not clear how
> > > > multiple occurrences of the placeholder would be interpreted. With
> > > > magrittr,
> > > >
> > > > sort(runif(10)) %>% ecdf(.)(.)
> > > > ## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
> > > >
> > > > This is probably what you would expect, if you expect it to work at
> all, and not
> > > >
> > > > ecdf(sort(runif(10)))(sort(runif(10)))
> > > >
> > > > There would be no such ambiguity with anonymous functions
> > > >
> > > > sort(runif(10)) |> \(.) ecdf(.)(.)
> > > >
> > > > -Deepayan
> > > >
> > > > > which would be expanded to something equivalent to the other
> versions:
> > > > > but that makes it quite a bit more complicated.  (Maybe _ or \.
> should
> > > > > be used instead of ., since those are not legal variable names.)
> > > > >
> > > > > I don't think there should be an attempt to copy magrittr's special
> > > > > casing of how . is used in determining whether to also include the
> > > > > previous value as first argument.
> > > > >
> > > > > Duncan Murdoch
> > > > >
> > > > >
> > > > > >
> > > > > > Best,
> > > > > > Hiroaki Yutani
> > > > > >
> > > > > > 2020?12?4?(?) 20:51 Duncan Murdoch <murdoch.duncan at gmail.com>:
> > > > > >>
> > > > > >> Just saw this on the R-devel news:
> > > > > >>
> > > > > >>
> > > > > >> R now provides a simple native pipe syntax ?|>? as well as a
> shorthand
> > > > > >> notation for creating functions, e.g. ?\(x) x + 1? is parsed as
> > > > > >> ?function(x) x + 1?. The pipe implementation as a syntax
> transformation
> > > > > >> was motivated by suggestions from Jim Hester and Lionel Henry.
> These
> > > > > >> features are experimental and may change prior to release.
> > > > > >>
> > > > > >>
> > > > > >> This is a good addition; by using "|>" instead of "%>%" there
> should be
> > > > > >> a chance to get operator precedence right.  That said, the
> ?Syntax help
> > > > > >> topic hasn't been updated, so I'm not sure where it fits in.
> > > > > >>
> > > > > >> There are some choices that take a little getting used to:
> > > > > >>
> > > > > >>   > mtcars |> head
> > > > > >> Error: The pipe operator requires a function call or an
> anonymous
> > > > > >> function expression as RHS
> > > > > >>
> > > > > >> (I need to say mtcars |> head() instead.)  This sometimes leads
> to error
> > > > > >> messages that are somewhat confusing:
> > > > > >>
> > > > > >>   > mtcars |> magrittr::debug_pipe |> head
> > > > > >> Error: function '::' not supported in RHS call of a pipe
> > > > > >>
> > > > > >> but
> > > > > >>
> > > > > >> mtcars |> magrittr::debug_pipe() |> head()
> > > > > >>
> > > > > >> works.
> > > > > >>
> > > > > >> Overall, I think this is a great addition, though it's going to
> be
> > > > > >> disruptive for a while.
> > > > > >>
> > > > > >> Duncan Murdoch
> > > > > >>
> > > > > >> ______________________________________________
> > > > > >> R-devel at r-project.org mailing list
> > > > > >> https://stat.ethz.ch/mailman/listinfo/r-devel
> > > > > >
> > > > > > ______________________________________________
> > > > > > R-devel at r-project.org mailing list
> > > > > > https://stat.ethz.ch/mailman/listinfo/r-devel
> > > > > >
> > > > >
> > > > > ______________________________________________
> > > > > R-devel at r-project.org mailing list
> > > > > https://stat.ethz.ch/mailman/listinfo/r-devel
> > > >
> > > > ______________________________________________
> > > > R-devel at r-project.org mailing list
> > > > https://stat.ethz.ch/mailman/listinfo/r-devel
> > >
> > > ______________________________________________
> > > R-devel at r-project.org mailing list
> > > https://stat.ethz.ch/mailman/listinfo/r-devel
> >
> >
> >
> > --
> > Statistics & Software Consulting
> > GKX Group, GKX Associates Inc.
> > tel: 1-877-GKX-GROUP
> > email: ggrothendieck at gmail.com
>
>
>
> --
> Statistics & Software Consulting
> GKX Group, GKX Associates Inc.
> tel: 1-877-GKX-GROUP
> email: ggrothendieck at gmail.com
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From ggrothend|eck @end|ng |rom gm@||@com  Mon Dec  7 00:21:24 2020
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Sun, 6 Dec 2020 18:21:24 -0500
Subject: [Rd] New pipe operator
In-Reply-To: <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
 <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
 <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>
Message-ID: <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>

I understand very well that it is implemented at the syntax level;
however, in any case the implementation is irrelevant to the principles.

Here a similar example to the one I gave before but this time written out:

This works:

  3 |> function(x) x + 1

but this does not:

  foo <- function(x) x + 1
  3 |> foo

so it breaks the principle of functions being first class objects.  foo and its
definition are not interchangeable.  You have
to write 3 |> foo() but don't have to write 3 |> (function(x) x + 1)().

This isn't just a matter of notation, i.e. foo vs foo(), but is a
matter of breaking
the way R works as a functional language with first class functions.

On Sun, Dec 6, 2020 at 4:06 PM Gabriel Becker <gabembecker at gmail.com> wrote:
>
> Hi Gabor,
>
> On Sun, Dec 6, 2020 at 12:52 PM Gabor Grothendieck <ggrothendieck at gmail.com> wrote:
>>
>> I think the real issue here is that functions are supposed to be
>> first class objects in R
>> or are supposed to be and |> would break that if if is possible
>> to write function(x) x + 1 on the RHS but not foo (assuming foo
>> was defined as that function).
>>
>> I don't think getting experience with using it can change that
>> inconsistency which seems serious to me and needs to
>> be addressed even if it complicates the implementation
>> since it drives to the heart of what R is.
>>
>
> With respect I think this is a misunderstanding of what is happening here.
>
> Functions are first class citizens. |> is, for all intents and purposes, a macro.
>
> LHS |> RHS(arg2=5)
>
> parses to
>
> RHS(LHS, arg2 = 5)
>
> There are no functions at the point in time when the pipe transformation happens, because no code has been evaluated. To know if a symbol is going to evaluate to a function requires evaluation which is a step entirely after the one where the |> pipe is implemented.
>
> Another way to think about it is that
>
> LHS |> RHS(arg2 = 5)
>
> is another way of writing RHS(LHS, arg2 = 5), NOT R code that is (or even can be) evaluated.
>
>
> Now this is a subtle point that only really has implications in as much as it is not the case for magrittr pipes, but its relevant for discussions like this, I think.
>
> ~G
>
>> On Sat, Dec 5, 2020 at 1:08 PM Gabor Grothendieck
>> <ggrothendieck at gmail.com> wrote:
>> >
>> > The construct utils::head  is not that common but bare functions are
>> > very common and to make it harder to use the common case so that
>> > the uncommon case is slightly easier is not desirable.
>> >
>> > Also it is trivial to write this which does work:
>> >
>> > mtcars %>% (utils::head)
>> >
>> > On Sat, Dec 5, 2020 at 11:59 AM Hugh Parsonage <hugh.parsonage at gmail.com> wrote:
>> > >
>> > > I'm surprised by the aversion to
>> > >
>> > > mtcars |> nrow
>> > >
>> > > over
>> > >
>> > > mtcars |> nrow()
>> > >
>> > > and I think the decision to disallow the former should be
>> > > reconsidered.  The pipe operator is only going to be used when the rhs
>> > > is a function, so there is no ambiguity with omitting the parentheses.
>> > > If it's disallowed, it becomes inconsistent with other treatments like
>> > > sapply(mtcars, typeof) where sapply(mtcars, typeof()) would just be
>> > > noise.  I'm not sure why this decision was taken
>> > >
>> > > If the only issue is with the double (and triple) colon operator, then
>> > > ideally `mtcars |> base::head` should resolve to `base::head(mtcars)`
>> > > -- in other words, demote the precedence of |>
>> > >
>> > > Obviously (looking at the R-Syntax branch) this decision was
>> > > considered, put into place, then dropped, but I can't see why
>> > > precisely.
>> > >
>> > > Best,
>> > >
>> > >
>> > > Hugh.
>> > >
>> > >
>> > >
>> > >
>> > >
>> > >
>> > >
>> > > On Sat, 5 Dec 2020 at 04:07, Deepayan Sarkar <deepayan.sarkar at gmail.com> wrote:
>> > > >
>> > > > On Fri, Dec 4, 2020 at 7:35 PM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>> > > > >
>> > > > > On 04/12/2020 8:13 a.m., Hiroaki Yutani wrote:
>> > > > > >>   Error: function '::' not supported in RHS call of a pipe
>> > > > > >
>> > > > > > To me, this error looks much more friendly than magrittr's error.
>> > > > > > Some of them got too used to specify functions without (). This
>> > > > > > is OK until they use `::`, but when they need to use it, it takes
>> > > > > > hours to figure out why
>> > > > > >
>> > > > > > mtcars %>% base::head
>> > > > > > #> Error in .::base : unused argument (head)
>> > > > > >
>> > > > > > won't work but
>> > > > > >
>> > > > > > mtcars %>% head
>> > > > > >
>> > > > > > works. I think this is a too harsh lesson for ordinary R users to
>> > > > > > learn `::` is a function. I've been wanting for magrittr to drop the
>> > > > > > support for a function name without () to avoid this confusion,
>> > > > > > so I would very much welcome the new pipe operator's behavior.
>> > > > > > Thank you all the developers who implemented this!
>> > > > >
>> > > > > I agree, it's an improvement on the corresponding magrittr error.
>> > > > >
>> > > > > I think the semantics of not evaluating the RHS, but treating the pipe
>> > > > > as purely syntactical is a good decision.
>> > > > >
>> > > > > I'm not sure I like the recommended way to pipe into a particular argument:
>> > > > >
>> > > > >    mtcars |> subset(cyl == 4) |> \(d) lm(mpg ~ disp, data = d)
>> > > > >
>> > > > > or
>> > > > >
>> > > > >    mtcars |> subset(cyl == 4) |> function(d) lm(mpg ~ disp, data = d)
>> > > > >
>> > > > > both of which are equivalent to
>> > > > >
>> > > > >    mtcars |> subset(cyl == 4) |> (function(d) lm(mpg ~ disp, data = d))()
>> > > > >
>> > > > > It's tempting to suggest it should allow something like
>> > > > >
>> > > > >    mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
>> > > >
>> > > > Which is really not that far off from
>> > > >
>> > > > mtcars |> subset(cyl == 4) |> \(.) lm(mpg ~ disp, data = .)
>> > > >
>> > > > once you get used to it.
>> > > >
>> > > > One consequence of the implementation is that it's not clear how
>> > > > multiple occurrences of the placeholder would be interpreted. With
>> > > > magrittr,
>> > > >
>> > > > sort(runif(10)) %>% ecdf(.)(.)
>> > > > ## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
>> > > >
>> > > > This is probably what you would expect, if you expect it to work at all, and not
>> > > >
>> > > > ecdf(sort(runif(10)))(sort(runif(10)))
>> > > >
>> > > > There would be no such ambiguity with anonymous functions
>> > > >
>> > > > sort(runif(10)) |> \(.) ecdf(.)(.)
>> > > >
>> > > > -Deepayan
>> > > >
>> > > > > which would be expanded to something equivalent to the other versions:
>> > > > > but that makes it quite a bit more complicated.  (Maybe _ or \. should
>> > > > > be used instead of ., since those are not legal variable names.)
>> > > > >
>> > > > > I don't think there should be an attempt to copy magrittr's special
>> > > > > casing of how . is used in determining whether to also include the
>> > > > > previous value as first argument.
>> > > > >
>> > > > > Duncan Murdoch
>> > > > >
>> > > > >
>> > > > > >
>> > > > > > Best,
>> > > > > > Hiroaki Yutani
>> > > > > >
>> > > > > > 2020?12?4?(?) 20:51 Duncan Murdoch <murdoch.duncan at gmail.com>:
>> > > > > >>
>> > > > > >> Just saw this on the R-devel news:
>> > > > > >>
>> > > > > >>
>> > > > > >> R now provides a simple native pipe syntax ?|>? as well as a shorthand
>> > > > > >> notation for creating functions, e.g. ?\(x) x + 1? is parsed as
>> > > > > >> ?function(x) x + 1?. The pipe implementation as a syntax transformation
>> > > > > >> was motivated by suggestions from Jim Hester and Lionel Henry. These
>> > > > > >> features are experimental and may change prior to release.
>> > > > > >>
>> > > > > >>
>> > > > > >> This is a good addition; by using "|>" instead of "%>%" there should be
>> > > > > >> a chance to get operator precedence right.  That said, the ?Syntax help
>> > > > > >> topic hasn't been updated, so I'm not sure where it fits in.
>> > > > > >>
>> > > > > >> There are some choices that take a little getting used to:
>> > > > > >>
>> > > > > >>   > mtcars |> head
>> > > > > >> Error: The pipe operator requires a function call or an anonymous
>> > > > > >> function expression as RHS
>> > > > > >>
>> > > > > >> (I need to say mtcars |> head() instead.)  This sometimes leads to error
>> > > > > >> messages that are somewhat confusing:
>> > > > > >>
>> > > > > >>   > mtcars |> magrittr::debug_pipe |> head
>> > > > > >> Error: function '::' not supported in RHS call of a pipe
>> > > > > >>
>> > > > > >> but
>> > > > > >>
>> > > > > >> mtcars |> magrittr::debug_pipe() |> head()
>> > > > > >>
>> > > > > >> works.
>> > > > > >>
>> > > > > >> Overall, I think this is a great addition, though it's going to be
>> > > > > >> disruptive for a while.
>> > > > > >>
>> > > > > >> Duncan Murdoch
>> > > > > >>
>> > > > > >> ______________________________________________
>> > > > > >> R-devel at r-project.org mailing list
>> > > > > >> https://stat.ethz.ch/mailman/listinfo/r-devel
>> > > > > >
>> > > > > > ______________________________________________
>> > > > > > R-devel at r-project.org mailing list
>> > > > > > https://stat.ethz.ch/mailman/listinfo/r-devel
>> > > > > >
>> > > > >
>> > > > > ______________________________________________
>> > > > > R-devel at r-project.org mailing list
>> > > > > https://stat.ethz.ch/mailman/listinfo/r-devel
>> > > >
>> > > > ______________________________________________
>> > > > R-devel at r-project.org mailing list
>> > > > https://stat.ethz.ch/mailman/listinfo/r-devel
>> > >
>> > > ______________________________________________
>> > > R-devel at r-project.org mailing list
>> > > https://stat.ethz.ch/mailman/listinfo/r-devel
>> >
>> >
>> >
>> > --
>> > Statistics & Software Consulting
>> > GKX Group, GKX Associates Inc.
>> > tel: 1-877-GKX-GROUP
>> > email: ggrothendieck at gmail.com
>>
>>
>>
>> --
>> Statistics & Software Consulting
>> GKX Group, GKX Associates Inc.
>> tel: 1-877-GKX-GROUP
>> email: ggrothendieck at gmail.com
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel



-- 
Statistics & Software Consulting
GKX Group, GKX Associates Inc.
tel: 1-877-GKX-GROUP
email: ggrothendieck at gmail.com


From M@rk@Br@v|ngton @end|ng |rom d@t@61@c@|ro@@u  Mon Dec  7 02:22:32 2020
From: M@rk@Br@v|ngton @end|ng |rom d@t@61@c@|ro@@u (Bravington, Mark (Data61, Hobart))
Date: Mon, 7 Dec 2020 01:22:32 +0000
Subject: [Rd] New pipe operator
In-Reply-To: <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
 <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
 <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>,
 <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>
Message-ID: <MEAPR01MB2407865F5622461515F409EDB4CE0@MEAPR01MB2407.ausprd01.prod.outlook.com>

Seems like this *could* be a good thing, and thanks to R core for considering it. But, FWIW:

 - I agree with Gabor G that consistency of "syntax" should be paramount here. Enough problems have been caused by earlier superficially-convenient non-standard features in R.  In particular:

 -- there should not be any discrepancy between an in-place function-definition, and a predefined function attached to a symbol (as per Gabor's point). 
 
 -- Hence, the ability to say x |> foo  ie without parentheses, seems bound to lead to inconsistency, because x |> foo is allowed, x |> base::foo isn't allowed without tricks, but x |> function( y) foo( y) isn't... So, x |> foo is not worth keeping. Parentheses are a price well worth paying.
 
 -- it is still inconsistent and confusing to (apparently) invoke a function in some places--- normally--- via 'foo(x)', yet in others--- pipily--- via 'foo()'. Especially if 'foo' already has a default value for its first argument.

 - I don't see the problem with a placeholder--- doesn't it remove all ambiguity? Sure there needs to be a standard unclashable name and people can argue about what that should be, but the following seems clear and flexible... to me, anyway:
 
 thing |> 
   foo( _PIPE_) |>           # standard
   bah( arg1, _PIPE_) |>   # multi-arg function
   _ANON_({ x <- sum( _PIPE_); _PIPE_/x + x/_PIPE_ })   # anon function
  
where '_PIPE_' is the ordained name of the placeholder, and '_ANON_' constructs-and-calls a function with single argument '_PIPE_'. There is just one rule (I think...): each pipe-stage must be a *call* involving the argument '_PIPE_'.


 - The proposed anonymous-function syntax looks quite ugly to me, diminishing readability and inviting errors. The new pipe symbol |> already looks scarily like quantum mechanics; adding \( just puts fishbones into the symbolic soup.

 - IMO it's not worth going too far to try to lure magritter-etc fans to swap to the new; my experience is that many people keep using older inferior R syntax for years after better replacements become available (even if they are aware of replacements), for various reasons. Just provide a good framework, and let nature take its course.
 
 - Disclaimer: personally I'm not much of a pipehead anyway, so maybe I'm not the audience. But if I was to consider piping, I wouldn't be very tempted by the current proposal. OTOH, I might even be tempted to write--- and use!--- my own version of '%|>%' as above (maybe someone already has). And if R did it for me, that'd be great :)
 
[*] Definition of _ANON_ could be something like this--- almost certainly won't work as-is, this is just to point out that it could be done in standard R.

`_ANON_` <- function( expr) { 
  #1. Construct a function with arg '_PIPE_' and body 'expr'
  #2. Construct a call() to that function
  #3. Do the call

  f <- function( `_PIPE_`) NULL
  body( f) <- expr
  environment( f) <- parent.frame() # or something... yes these details are almost certainly wrong
  expr2 <- substitute( f( `_PIPE_`)) # or something...
  eval.parent( expr2) # or something... 
}

cheers
Mark

Mark Bravington
CSIRO Marine Lab
Hobart
Australia


________________________________________
From: R-devel <r-devel-bounces at r-project.org> on behalf of Gabor Grothendieck <ggrothendieck at gmail.com>
Sent: Monday, 7 December 2020 10:21
To: Gabriel Becker
Cc: r-devel at r-project.org
Subject: Re: [Rd] New pipe operator

I understand very well that it is implemented at the syntax level;
however, in any case the implementation is irrelevant to the principles.

Here a similar example to the one I gave before but this time written out:

This works:

  3 |> function(x) x + 1

but this does not:

  foo <- function(x) x + 1
  3 |> foo

so it breaks the principle of functions being first class objects.  foo and its
definition are not interchangeable.  You have
to write 3 |> foo() but don't have to write 3 |> (function(x) x + 1)().

This isn't just a matter of notation, i.e. foo vs foo(), but is a
matter of breaking
the way R works as a functional language with first class functions.

On Sun, Dec 6, 2020 at 4:06 PM Gabriel Becker <gabembecker at gmail.com> wrote:
>
> Hi Gabor,
>
> On Sun, Dec 6, 2020 at 12:52 PM Gabor Grothendieck <ggrothendieck at gmail.com> wrote:
>>
>> I think the real issue here is that functions are supposed to be
>> first class objects in R
>> or are supposed to be and |> would break that if if is possible
>> to write function(x) x + 1 on the RHS but not foo (assuming foo
>> was defined as that function).
>>
>> I don't think getting experience with using it can change that
>> inconsistency which seems serious to me and needs to
>> be addressed even if it complicates the implementation
>> since it drives to the heart of what R is.
>>
>
> With respect I think this is a misunderstanding of what is happening here.
>
> Functions are first class citizens. |> is, for all intents and purposes, a macro.
>
> LHS |> RHS(arg2=5)
>
> parses to
>
> RHS(LHS, arg2 = 5)
>
> There are no functions at the point in time when the pipe transformation happens, because no code has been evaluated. To know if a symbol is going to evaluate to a function requires evaluation which is a step entirely after the one where the |> pipe is implemented.
>
> Another way to think about it is that
>
> LHS |> RHS(arg2 = 5)
>
> is another way of writing RHS(LHS, arg2 = 5), NOT R code that is (or even can be) evaluated.
>
>
> Now this is a subtle point that only really has implications in as much as it is not the case for magrittr pipes, but its relevant for discussions like this, I think.
>
> ~G
>
>> On Sat, Dec 5, 2020 at 1:08 PM Gabor Grothendieck
>> <ggrothendieck at gmail.com> wrote:
>> >
>> > The construct utils::head  is not that common but bare functions are
>> > very common and to make it harder to use the common case so that
>> > the uncommon case is slightly easier is not desirable.
>> >
>> > Also it is trivial to write this which does work:
>> >
>> > mtcars %>% (utils::head)
>> >
>> > On Sat, Dec 5, 2020 at 11:59 AM Hugh Parsonage <hugh.parsonage at gmail.com> wrote:
>> > >
>> > > I'm surprised by the aversion to
>> > >
>> > > mtcars |> nrow
>> > >
>> > > over
>> > >
>> > > mtcars |> nrow()
>> > >
>> > > and I think the decision to disallow the former should be
>> > > reconsidered.  The pipe operator is only going to be used when the rhs
>> > > is a function, so there is no ambiguity with omitting the parentheses.
>> > > If it's disallowed, it becomes inconsistent with other treatments like
>> > > sapply(mtcars, typeof) where sapply(mtcars, typeof()) would just be
>> > > noise.  I'm not sure why this decision was taken
>> > >
>> > > If the only issue is with the double (and triple) colon operator, then
>> > > ideally `mtcars |> base::head` should resolve to `base::head(mtcars)`
>> > > -- in other words, demote the precedence of |>
>> > >
>> > > Obviously (looking at the R-Syntax branch) this decision was
>> > > considered, put into place, then dropped, but I can't see why
>> > > precisely.
>> > >
>> > > Best,
>> > >
>> > >
>> > > Hugh.
>> > >
>> > >
>> > >
>> > >
>> > >
>> > >
>> > >
>> > > On Sat, 5 Dec 2020 at 04:07, Deepayan Sarkar <deepayan.sarkar at gmail.com> wrote:
>> > > >
>> > > > On Fri, Dec 4, 2020 at 7:35 PM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>> > > > >
>> > > > > On 04/12/2020 8:13 a.m., Hiroaki Yutani wrote:
>> > > > > >>   Error: function '::' not supported in RHS call of a pipe
>> > > > > >
>> > > > > > To me, this error looks much more friendly than magrittr's error.
>> > > > > > Some of them got too used to specify functions without (). This
>> > > > > > is OK until they use `::`, but when they need to use it, it takes
>> > > > > > hours to figure out why
>> > > > > >
>> > > > > > mtcars %>% base::head
>> > > > > > #> Error in .::base : unused argument (head)
>> > > > > >
>> > > > > > won't work but
>> > > > > >
>> > > > > > mtcars %>% head
>> > > > > >
>> > > > > > works. I think this is a too harsh lesson for ordinary R users to
>> > > > > > learn `::` is a function. I've been wanting for magrittr to drop the
>> > > > > > support for a function name without () to avoid this confusion,
>> > > > > > so I would very much welcome the new pipe operator's behavior.
>> > > > > > Thank you all the developers who implemented this!
>> > > > >
>> > > > > I agree, it's an improvement on the corresponding magrittr error.
>> > > > >
>> > > > > I think the semantics of not evaluating the RHS, but treating the pipe
>> > > > > as purely syntactical is a good decision.
>> > > > >
>> > > > > I'm not sure I like the recommended way to pipe into a particular argument:
>> > > > >
>> > > > >    mtcars |> subset(cyl == 4) |> \(d) lm(mpg ~ disp, data = d)
>> > > > >
>> > > > > or
>> > > > >
>> > > > >    mtcars |> subset(cyl == 4) |> function(d) lm(mpg ~ disp, data = d)
>> > > > >
>> > > > > both of which are equivalent to
>> > > > >
>> > > > >    mtcars |> subset(cyl == 4) |> (function(d) lm(mpg ~ disp, data = d))()
>> > > > >
>> > > > > It's tempting to suggest it should allow something like
>> > > > >
>> > > > >    mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
>> > > >
>> > > > Which is really not that far off from
>> > > >
>> > > > mtcars |> subset(cyl == 4) |> \(.) lm(mpg ~ disp, data = .)
>> > > >
>> > > > once you get used to it.
>> > > >
>> > > > One consequence of the implementation is that it's not clear how
>> > > > multiple occurrences of the placeholder would be interpreted. With
>> > > > magrittr,
>> > > >
>> > > > sort(runif(10)) %>% ecdf(.)(.)
>> > > > ## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
>> > > >
>> > > > This is probably what you would expect, if you expect it to work at all, and not
>> > > >
>> > > > ecdf(sort(runif(10)))(sort(runif(10)))
>> > > >
>> > > > There would be no such ambiguity with anonymous functions
>> > > >
>> > > > sort(runif(10)) |> \(.) ecdf(.)(.)
>> > > >
>> > > > -Deepayan
>> > > >
>> > > > > which would be expanded to something equivalent to the other versions:
>> > > > > but that makes it quite a bit more complicated.  (Maybe _ or \. should
>> > > > > be used instead of ., since those are not legal variable names.)
>> > > > >
>> > > > > I don't think there should be an attempt to copy magrittr's special
>> > > > > casing of how . is used in determining whether to also include the
>> > > > > previous value as first argument.
>> > > > >
>> > > > > Duncan Murdoch
>> > > > >
>> > > > >
>> > > > > >
>> > > > > > Best,
>> > > > > > Hiroaki Yutani
>> > > > > >
>> > > > > > 2020?12?4?(?) 20:51 Duncan Murdoch <murdoch.duncan at gmail.com>:
>> > > > > >>
>> > > > > >> Just saw this on the R-devel news:
>> > > > > >>
>> > > > > >>
>> > > > > >> R now provides a simple native pipe syntax ?|>? as well as a shorthand
>> > > > > >> notation for creating functions, e.g. ?\(x) x + 1? is parsed as
>> > > > > >> ?function(x) x + 1?. The pipe implementation as a syntax transformation
>> > > > > >> was motivated by suggestions from Jim Hester and Lionel Henry. These
>> > > > > >> features are experimental and may change prior to release.
>> > > > > >>
>> > > > > >>
>> > > > > >> This is a good addition; by using "|>" instead of "%>%" there should be
>> > > > > >> a chance to get operator precedence right.  That said, the ?Syntax help
>> > > > > >> topic hasn't been updated, so I'm not sure where it fits in.
>> > > > > >>
>> > > > > >> There are some choices that take a little getting used to:
>> > > > > >>
>> > > > > >>   > mtcars |> head
>> > > > > >> Error: The pipe operator requires a function call or an anonymous
>> > > > > >> function expression as RHS
>> > > > > >>
>> > > > > >> (I need to say mtcars |> head() instead.)  This sometimes leads to error
>> > > > > >> messages that are somewhat confusing:
>> > > > > >>
>> > > > > >>   > mtcars |> magrittr::debug_pipe |> head
>> > > > > >> Error: function '::' not supported in RHS call of a pipe
>> > > > > >>
>> > > > > >> but
>> > > > > >>
>> > > > > >> mtcars |> magrittr::debug_pipe() |> head()
>> > > > > >>
>> > > > > >> works.
>> > > > > >>
>> > > > > >> Overall, I think this is a great addition, though it's going to be
>> > > > > >> disruptive for a while.
>> > > > > >>
>> > > > > >> Duncan Murdoch
>> > > > > >>
>> > > > > >> ______________________________________________
>> > > > > >> R-devel at r-project.org mailing list
>> > > > > >> https://stat.ethz.ch/mailman/listinfo/r-devel
>> > > > > >
>> > > > > > ______________________________________________
>> > > > > > R-devel at r-project.org mailing list
>> > > > > > https://stat.ethz.ch/mailman/listinfo/r-devel
>> > > > > >
>> > > > >
>> > > > > ______________________________________________
>> > > > > R-devel at r-project.org mailing list
>> > > > > https://stat.ethz.ch/mailman/listinfo/r-devel
>> > > >
>> > > > ______________________________________________
>> > > > R-devel at r-project.org mailing list
>> > > > https://stat.ethz.ch/mailman/listinfo/r-devel
>> > >
>> > > ______________________________________________
>> > > R-devel at r-project.org mailing list
>> > > https://stat.ethz.ch/mailman/listinfo/r-devel
>> >
>> >
>> >
>> > --
>> > Statistics & Software Consulting
>> > GKX Group, GKX Associates Inc.
>> > tel: 1-877-GKX-GROUP
>> > email: ggrothendieck at gmail.com
>>
>>
>>
>> --
>> Statistics & Software Consulting
>> GKX Group, GKX Associates Inc.
>> tel: 1-877-GKX-GROUP
>> email: ggrothendieck at gmail.com
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel



--
Statistics & Software Consulting
GKX Group, GKX Associates Inc.
tel: 1-877-GKX-GROUP
email: ggrothendieck at gmail.com

______________________________________________
R-devel at r-project.org mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


From @v|gro@@ @end|ng |rom ver|zon@net  Mon Dec  7 03:18:13 2020
From: @v|gro@@ @end|ng |rom ver|zon@net (Avi Gross)
Date: Sun, 6 Dec 2020 21:18:13 -0500
Subject: [Rd] New pipe operator and gg plotz
In-Reply-To: <342b718d-6616-3681-5302-d253c3041f14@gmail.com>
References: <005a01d6cc06$c1192910$434b7b30$.ref@verizon.net>
 <005a01d6cc06$c1192910$434b7b30$@verizon.net>
 <342b718d-6616-3681-5302-d253c3041f14@gmail.com>
Message-ID: <034e01d6cc3f$3752af60$a5f80e20$@verizon.net>

Thanks, Duncan. That answers my question fairly definitively.

Although it can be DONE it likely won't be for the reasons Hadley mentioned until we get some other product that replaces it entirely. There are some interesting work-arounds mentioned. 

I was thinking of one that has overhead but might be a pain. Hadley mentioned a slight variant. The first argument to a function now is expected to be the data argument. The second might be the mapping. Now if the function is called with a new first argument that is a ggplot object, it could be possible to test the type and if it is a ggplot object than slide over carefully any additional matched arguments that were not explicitly named. Not sure that is at all easy to do.

Alternately, you can ask that when used in such a pipeline that the user call all other arguments using names like data=whatever, mapping=aes(whatever) so no other args need to be adjusted by position.

But all this is academic and I concede will likely not be done. I can live with the plus signs.


-----Original Message-----
From: Duncan Murdoch <murdoch.duncan at gmail.com> 
Sent: Sunday, December 6, 2020 2:50 PM
To: Avi Gross <avigross at verizon.net>; 'r-devel' <r-devel at r-project.org>
Subject: Re: [Rd] New pipe operator and gg plotz

Hadley's answer (#7 here: 
https://community.rstudio.com/t/why-cant-ggplot2-use/4372) makes it pretty clear that he thinks it would have been nice now if he had made that choice when ggplot2 came out, but it's not worth the effort now to change it.

Duncan Murdoch

On 06/12/2020 2:34 p.m., Avi Gross via R-devel wrote:
> As someone who switches back and forth between using standard R methods and those of the tidyverse, depending on the problem, my mood and whether Jupiter aligns with Saturn in the new age of Aquarius, I have a question about the forthcoming built-in pipe. Will it motivate anyone to eventually change or enhance the ggplot functionality to have a version that gets rid of the odd use of the addition symbol?
> 
> I mean I now sometimes have a pipeline that looks like:
> 
> Data %>%
> 	Do_this %>%
> 	Do_that(whatever) %>%
> 	ggplot(...) +
> 		geom_whatever(...) +
> 		...
> 
> My understanding is this is a bit of a historical anomaly that might someday be modified back.
> 
> As I understand it, the call to ggplot() creates a partially filled-in object that holds all kinds of useful info. The additional calls to geom_point() and so on will add/change that hidden object. Nothing much happens till the object is implicitly or explicitly given to print() which switches to the print function for objects of that type and creates a graph based on the contents of the object at that time. So, in theory, you could have a pipelined version of ggplot where the first function accepts something like a  data.frame or tibble as the default first argument and at the end returns the object we have been describing. All additional functions would then accept such an object as the (hidden?) first argument and return the modified object. The final function in the pipe would either have the value captured in a variable for later use or print implicitly generating a graph.
> 
> So the above silly example might become:
> 
> Data %>%
> 	Do_this %>%
> 	Do_that(whatever) %>%
> 	ggplot(...) %>%
> 	geom_whatever(...) %>%
> 	...
> 
> Or, am I missing something here?
> 
> The language and extensions such as are now in the tidyverse might be more streamlined and easier to read when using consistent notation. If we now build a reasonable version of the pipeline in, might we encourage other uses to gradually migrate back closer to the mainstream?
> 
> -----Original Message-----
> From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Rui 
> Barradas
> Sent: Sunday, December 6, 2020 2:51 AM
> To: Gregory Warnes <greg at warnes.net>; Abby Spurdle 
> <spurdle.a at gmail.com>
> Cc: r-devel <r-devel at r-project.org>
> Subject: Re: [Rd] New pipe operator
> 
> Hello,
> 
> If Hilbert liked beer, I like "pipe".
> 
> More seriously, a new addition like this one is going to cause problems yet unknown. But it's a good idea to have a pipe operator available. As someone used to magrittr's data pipelines, I will play with this base one before making up my mind. I don't expect its behavior to be exactly like magrittr "%>%" (and it's not). For the moment all I can say is that it is something R users are used to and that it now avoids loading a package.
> As for the new way to define anonymous functions, I am less sure. Too much syntatic sugar? Or am I finding the syntax ugly?
> 
> Hope this helps,
> 
> Rui Barradas
> 
> 
> ?s 03:22 de 06/12/20, Gregory Warnes escreveu:
>> If we?re being mathematically pedantic, the ?pipe? operator is 
>> actually function composition > That being said, pipes are a simple 
>> and well-known idiom. While being less
>> than mathematically exact, it seems a reasonable   label for the (very
>> useful) behavior.
>>
>> On Sat, Dec 5, 2020 at 9:43 PM Abby Spurdle <spurdle.a at gmail.com> wrote:
>>
>>>> This is a good addition
>>>
>>> I can't understand why so many people are calling this a "pipe".
>>> Pipes connect processes, via their I/O streams.
>>> Arguably, a more general interpretation would include sockets and files.
>>>
>>> https://en.wikipedia.org/wiki/Pipeline_(Unix)
>>> https://en.wikipedia.org/wiki/Named_pipe
>>> https://en.wikipedia.org/wiki/Anonymous_pipe
>>>
>>> As far as I can tell, the magrittr-like operators are functions (not 
>>> pipes), with nonstandard syntax.
>>> This is not consistent with R's original design philosophy, building 
>>> on C, Lisp and S, along with lots of *important* math and stats.
>>>
>>> It's possible that some parties are interested in creating a kind of 
>>> "data pipeline".
>>> I'm interested in this myself, and I think we could discuss this more.
>>> But I'm not convinced the magrittr-like operators help to achieve 
>>> this goal.
>>> Which, in my opinion, would require one to model programs as 
>>> directed graphs, along with some degree of asynchronous input.
>>>
>>> Presumably, these operators will be added to R anyway, and (almost) 
>>> no one will listen to me.
>>>
>>> So, I would like to make one suggestion:
>>> Is it possible for these operators to *not* be named:
>>>       The R Pipe
>>>       The S Pipe
>>>       Or anything with a similar meaning.
>>>
>>> Maybe tidy pipe, or something else that links it to its proponents?
>>>
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> 
> Scanned by McAfee and confirmed virus-free.	
> Find out more here: https://bit.ly/2zCJMrO
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 


From g@bembecker @end|ng |rom gm@||@com  Mon Dec  7 03:23:47 2020
From: g@bembecker @end|ng |rom gm@||@com (Gabriel Becker)
Date: Sun, 6 Dec 2020 18:23:47 -0800
Subject: [Rd] New pipe operator
In-Reply-To: <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
 <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
 <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>
 <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>
Message-ID: <CAD4oTHHFWkiirncPRWngY+_k9HcB=8zo7VdXAONXQoXdNhKzDA@mail.gmail.com>

Hi Gabor,

On Sun, Dec 6, 2020 at 3:22 PM Gabor Grothendieck <ggrothendieck at gmail.com>
wrote:

> I understand very well that it is implemented at the syntax level;
> however, in any case the implementation is irrelevant to the principles.
>
> Here a similar example to the one I gave before but this time written out:
>
> This works:
>
>   3 |> function(x) x + 1
>
> but this does not:
>
>   foo <- function(x) x + 1
>   3 |> foo
>
> so it breaks the principle of functions being first class objects.  foo
> and its
> definition are not interchangeable.


I understood what you meant as well.

The issue is that neither foo nor its definition are being operated on, or
even exist within the scope of what |> is defined to do. You are used to
magrittr's %>% where arguably what you are saying would be true. But its
not here, in my view.

Again, I think the issue is that |>, in as much as it "operates" on
anything at all (it not being a function, regardless of appearances),
operates on call expression objects, NOT on functions, ever.

function(x) x *parses to a call expression *as does RHSfun(), while RHSfun does
not, it parses to a name, *regardless of whether that symbol will
eventually evaluate to a closure or not.*

So in fact, it seems to me that, technically, all name symbols are being
treated exactly the same (none are allowed, including those which will
lookup to functions during evaluation), while all* call expressions are
also being treated the same. And again, there are no functions anywhere in
either case.

* except those that include that the parser flags as syntactically special.


> You have
> to write 3 |> foo() but don't have to write 3 |> (function(x) x + 1)().
>

I think you should probably be careful what you wish for here. I'm not
involved with this work and do not speak for any of those who were, but the
principled way to make that consistent while remaining entirely in the
parser seems very likely to be to require the latter, rather than not
require the former.


> This isn't just a matter of notation, i.e. foo vs foo(), but is a
> matter of breaking
> the way R works as a functional language with first class functions.
>

I don't agree. Consider `+`

Having

foo <- get("+") ## note no `` here
foo(x,y)

parse and work correctly while

+(x,y)

 does not does not mean + isn't a function or that it is a "second class
citizen", it simply means that the parser has constraints on the syntax for
writing code that calls it that calling other functions are not subject to.
The fact that such *syntactic* constraints can exist proves that there is
not some overarching inviolable principle being violated here, I think. Now
you may say "well thats just the parser, it has to parse + specially
because its an operator with specific precedence etc". Well, the same exact
thing is true of |> I think.

Best,
~G

>
> On Sun, Dec 6, 2020 at 4:06 PM Gabriel Becker <gabembecker at gmail.com>
> wrote:
> >
> > Hi Gabor,
> >
> > On Sun, Dec 6, 2020 at 12:52 PM Gabor Grothendieck <
> ggrothendieck at gmail.com> wrote:
> >>
> >> I think the real issue here is that functions are supposed to be
> >> first class objects in R
> >> or are supposed to be and |> would break that if if is possible
> >> to write function(x) x + 1 on the RHS but not foo (assuming foo
> >> was defined as that function).
> >>
> >> I don't think getting experience with using it can change that
> >> inconsistency which seems serious to me and needs to
> >> be addressed even if it complicates the implementation
> >> since it drives to the heart of what R is.
> >>
> >
> > With respect I think this is a misunderstanding of what is happening
> here.
> >
> > Functions are first class citizens. |> is, for all intents and purposes,
> a macro.
> >
> > LHS |> RHS(arg2=5)
> >
> > parses to
> >
> > RHS(LHS, arg2 = 5)
> >
> > There are no functions at the point in time when the pipe transformation
> happens, because no code has been evaluated. To know if a symbol is going
> to evaluate to a function requires evaluation which is a step entirely
> after the one where the |> pipe is implemented.
> >
> > Another way to think about it is that
> >
> > LHS |> RHS(arg2 = 5)
> >
> > is another way of writing RHS(LHS, arg2 = 5), NOT R code that is (or
> even can be) evaluated.
> >
> >
> > Now this is a subtle point that only really has implications in as much
> as it is not the case for magrittr pipes, but its relevant for discussions
> like this, I think.
> >
> > ~G
> >
> >> On Sat, Dec 5, 2020 at 1:08 PM Gabor Grothendieck
> >> <ggrothendieck at gmail.com> wrote:
> >> >
> >> > The construct utils::head  is not that common but bare functions are
> >> > very common and to make it harder to use the common case so that
> >> > the uncommon case is slightly easier is not desirable.
> >> >
> >> > Also it is trivial to write this which does work:
> >> >
> >> > mtcars %>% (utils::head)
> >> >
> >> > On Sat, Dec 5, 2020 at 11:59 AM Hugh Parsonage <
> hugh.parsonage at gmail.com> wrote:
> >> > >
> >> > > I'm surprised by the aversion to
> >> > >
> >> > > mtcars |> nrow
> >> > >
> >> > > over
> >> > >
> >> > > mtcars |> nrow()
> >> > >
> >> > > and I think the decision to disallow the former should be
> >> > > reconsidered.  The pipe operator is only going to be used when the
> rhs
> >> > > is a function, so there is no ambiguity with omitting the
> parentheses.
> >> > > If it's disallowed, it becomes inconsistent with other treatments
> like
> >> > > sapply(mtcars, typeof) where sapply(mtcars, typeof()) would just be
> >> > > noise.  I'm not sure why this decision was taken
> >> > >
> >> > > If the only issue is with the double (and triple) colon operator,
> then
> >> > > ideally `mtcars |> base::head` should resolve to
> `base::head(mtcars)`
> >> > > -- in other words, demote the precedence of |>
> >> > >
> >> > > Obviously (looking at the R-Syntax branch) this decision was
> >> > > considered, put into place, then dropped, but I can't see why
> >> > > precisely.
> >> > >
> >> > > Best,
> >> > >
> >> > >
> >> > > Hugh.
> >> > >
> >> > >
> >> > >
> >> > >
> >> > >
> >> > >
> >> > >
> >> > > On Sat, 5 Dec 2020 at 04:07, Deepayan Sarkar <
> deepayan.sarkar at gmail.com> wrote:
> >> > > >
> >> > > > On Fri, Dec 4, 2020 at 7:35 PM Duncan Murdoch <
> murdoch.duncan at gmail.com> wrote:
> >> > > > >
> >> > > > > On 04/12/2020 8:13 a.m., Hiroaki Yutani wrote:
> >> > > > > >>   Error: function '::' not supported in RHS call of a pipe
> >> > > > > >
> >> > > > > > To me, this error looks much more friendly than magrittr's
> error.
> >> > > > > > Some of them got too used to specify functions without ().
> This
> >> > > > > > is OK until they use `::`, but when they need to use it, it
> takes
> >> > > > > > hours to figure out why
> >> > > > > >
> >> > > > > > mtcars %>% base::head
> >> > > > > > #> Error in .::base : unused argument (head)
> >> > > > > >
> >> > > > > > won't work but
> >> > > > > >
> >> > > > > > mtcars %>% head
> >> > > > > >
> >> > > > > > works. I think this is a too harsh lesson for ordinary R
> users to
> >> > > > > > learn `::` is a function. I've been wanting for magrittr to
> drop the
> >> > > > > > support for a function name without () to avoid this
> confusion,
> >> > > > > > so I would very much welcome the new pipe operator's behavior.
> >> > > > > > Thank you all the developers who implemented this!
> >> > > > >
> >> > > > > I agree, it's an improvement on the corresponding magrittr
> error.
> >> > > > >
> >> > > > > I think the semantics of not evaluating the RHS, but treating
> the pipe
> >> > > > > as purely syntactical is a good decision.
> >> > > > >
> >> > > > > I'm not sure I like the recommended way to pipe into a
> particular argument:
> >> > > > >
> >> > > > >    mtcars |> subset(cyl == 4) |> \(d) lm(mpg ~ disp, data = d)
> >> > > > >
> >> > > > > or
> >> > > > >
> >> > > > >    mtcars |> subset(cyl == 4) |> function(d) lm(mpg ~ disp,
> data = d)
> >> > > > >
> >> > > > > both of which are equivalent to
> >> > > > >
> >> > > > >    mtcars |> subset(cyl == 4) |> (function(d) lm(mpg ~ disp,
> data = d))()
> >> > > > >
> >> > > > > It's tempting to suggest it should allow something like
> >> > > > >
> >> > > > >    mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
> >> > > >
> >> > > > Which is really not that far off from
> >> > > >
> >> > > > mtcars |> subset(cyl == 4) |> \(.) lm(mpg ~ disp, data = .)
> >> > > >
> >> > > > once you get used to it.
> >> > > >
> >> > > > One consequence of the implementation is that it's not clear how
> >> > > > multiple occurrences of the placeholder would be interpreted. With
> >> > > > magrittr,
> >> > > >
> >> > > > sort(runif(10)) %>% ecdf(.)(.)
> >> > > > ## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
> >> > > >
> >> > > > This is probably what you would expect, if you expect it to work
> at all, and not
> >> > > >
> >> > > > ecdf(sort(runif(10)))(sort(runif(10)))
> >> > > >
> >> > > > There would be no such ambiguity with anonymous functions
> >> > > >
> >> > > > sort(runif(10)) |> \(.) ecdf(.)(.)
> >> > > >
> >> > > > -Deepayan
> >> > > >
> >> > > > > which would be expanded to something equivalent to the other
> versions:
> >> > > > > but that makes it quite a bit more complicated.  (Maybe _ or \.
> should
> >> > > > > be used instead of ., since those are not legal variable names.)
> >> > > > >
> >> > > > > I don't think there should be an attempt to copy magrittr's
> special
> >> > > > > casing of how . is used in determining whether to also include
> the
> >> > > > > previous value as first argument.
> >> > > > >
> >> > > > > Duncan Murdoch
> >> > > > >
> >> > > > >
> >> > > > > >
> >> > > > > > Best,
> >> > > > > > Hiroaki Yutani
> >> > > > > >
> >> > > > > > 2020?12?4?(?) 20:51 Duncan Murdoch <murdoch.duncan at gmail.com
> >:
> >> > > > > >>
> >> > > > > >> Just saw this on the R-devel news:
> >> > > > > >>
> >> > > > > >>
> >> > > > > >> R now provides a simple native pipe syntax ?|>? as well as a
> shorthand
> >> > > > > >> notation for creating functions, e.g. ?\(x) x + 1? is parsed
> as
> >> > > > > >> ?function(x) x + 1?. The pipe implementation as a syntax
> transformation
> >> > > > > >> was motivated by suggestions from Jim Hester and Lionel
> Henry. These
> >> > > > > >> features are experimental and may change prior to release.
> >> > > > > >>
> >> > > > > >>
> >> > > > > >> This is a good addition; by using "|>" instead of "%>%"
> there should be
> >> > > > > >> a chance to get operator precedence right.  That said, the
> ?Syntax help
> >> > > > > >> topic hasn't been updated, so I'm not sure where it fits in.
> >> > > > > >>
> >> > > > > >> There are some choices that take a little getting used to:
> >> > > > > >>
> >> > > > > >>   > mtcars |> head
> >> > > > > >> Error: The pipe operator requires a function call or an
> anonymous
> >> > > > > >> function expression as RHS
> >> > > > > >>
> >> > > > > >> (I need to say mtcars |> head() instead.)  This sometimes
> leads to error
> >> > > > > >> messages that are somewhat confusing:
> >> > > > > >>
> >> > > > > >>   > mtcars |> magrittr::debug_pipe |> head
> >> > > > > >> Error: function '::' not supported in RHS call of a pipe
> >> > > > > >>
> >> > > > > >> but
> >> > > > > >>
> >> > > > > >> mtcars |> magrittr::debug_pipe() |> head()
> >> > > > > >>
> >> > > > > >> works.
> >> > > > > >>
> >> > > > > >> Overall, I think this is a great addition, though it's going
> to be
> >> > > > > >> disruptive for a while.
> >> > > > > >>
> >> > > > > >> Duncan Murdoch
> >> > > > > >>
> >> > > > > >> ______________________________________________
> >> > > > > >> R-devel at r-project.org mailing list
> >> > > > > >> https://stat.ethz.ch/mailman/listinfo/r-devel
> >> > > > > >
> >> > > > > > ______________________________________________
> >> > > > > > R-devel at r-project.org mailing list
> >> > > > > > https://stat.ethz.ch/mailman/listinfo/r-devel
> >> > > > > >
> >> > > > >
> >> > > > > ______________________________________________
> >> > > > > R-devel at r-project.org mailing list
> >> > > > > https://stat.ethz.ch/mailman/listinfo/r-devel
> >> > > >
> >> > > > ______________________________________________
> >> > > > R-devel at r-project.org mailing list
> >> > > > https://stat.ethz.ch/mailman/listinfo/r-devel
> >> > >
> >> > > ______________________________________________
> >> > > R-devel at r-project.org mailing list
> >> > > https://stat.ethz.ch/mailman/listinfo/r-devel
> >> >
> >> >
> >> >
> >> > --
> >> > Statistics & Software Consulting
> >> > GKX Group, GKX Associates Inc.
> >> > tel: 1-877-GKX-GROUP
> >> > email: ggrothendieck at gmail.com
> >>
> >>
> >>
> >> --
> >> Statistics & Software Consulting
> >> GKX Group, GKX Associates Inc.
> >> tel: 1-877-GKX-GROUP
> >> email: ggrothendieck at gmail.com
> >>
> >> ______________________________________________
> >> R-devel at r-project.org mailing list
> >> https://stat.ethz.ch/mailman/listinfo/r-devel
>
>
>
> --
> Statistics & Software Consulting
> GKX Group, GKX Associates Inc.
> tel: 1-877-GKX-GROUP
> email: ggrothendieck at gmail.com
>

	[[alternative HTML version deleted]]


From ggrothend|eck @end|ng |rom gm@||@com  Mon Dec  7 03:32:14 2020
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Sun, 6 Dec 2020 21:32:14 -0500
Subject: [Rd] New pipe operator
In-Reply-To: <CAD4oTHHFWkiirncPRWngY+_k9HcB=8zo7VdXAONXQoXdNhKzDA@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
 <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
 <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>
 <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>
 <CAD4oTHHFWkiirncPRWngY+_k9HcB=8zo7VdXAONXQoXdNhKzDA@mail.gmail.com>
Message-ID: <CAP01uRkNyjfXE00=KfTQejdAX2PCokwYrKHwC9DVPQnNUu5o4Q@mail.gmail.com>

This is really irrelevant.

On Sun, Dec 6, 2020 at 9:23 PM Gabriel Becker <gabembecker at gmail.com> wrote:
>
> Hi Gabor,
>
> On Sun, Dec 6, 2020 at 3:22 PM Gabor Grothendieck <ggrothendieck at gmail.com> wrote:
>>
>> I understand very well that it is implemented at the syntax level;
>> however, in any case the implementation is irrelevant to the principles.
>>
>> Here a similar example to the one I gave before but this time written out:
>>
>> This works:
>>
>>   3 |> function(x) x + 1
>>
>> but this does not:
>>
>>   foo <- function(x) x + 1
>>   3 |> foo
>>
>> so it breaks the principle of functions being first class objects.  foo and its
>> definition are not interchangeable.
>
>
> I understood what you meant as well.
>
> The issue is that neither foo nor its definition are being operated on, or even exist within the scope of what |> is defined to do. You are used to magrittr's %>% where arguably what you are saying would be true. But its not here, in my view.
>
> Again, I think the issue is that |>, in as much as it "operates" on anything at all (it not being a function, regardless of appearances), operates on call expression objects, NOT on functions, ever.
>
> function(x) x parses to a call expression as does RHSfun(), while RHSfun does not, it parses to a name, regardless of whether that symbol will eventually evaluate to a closure or not.
>
> So in fact, it seems to me that, technically, all name symbols are being treated exactly the same (none are allowed, including those which will lookup to functions during evaluation), while all* call expressions are also being treated the same. And again, there are no functions anywhere in either case.
>
> * except those that include that the parser flags as syntactically special.
>
>>
>> You have
>> to write 3 |> foo() but don't have to write 3 |> (function(x) x + 1)().
>
>
> I think you should probably be careful what you wish for here. I'm not involved with this work and do not speak for any of those who were, but the principled way to make that consistent while remaining entirely in the parser seems very likely to be to require the latter, rather than not require the former.
>
>>
>> This isn't just a matter of notation, i.e. foo vs foo(), but is a
>> matter of breaking
>> the way R works as a functional language with first class functions.
>
>
> I don't agree. Consider `+`
>
> Having
>
> foo <- get("+") ## note no `` here
> foo(x,y)
>
> parse and work correctly while
>
> +(x,y)
>
>  does not does not mean + isn't a function or that it is a "second class citizen", it simply means that the parser has constraints on the syntax for writing code that calls it that calling other functions are not subject to. The fact that such syntactic constraints can exist proves that there is not some overarching inviolable principle being violated here, I think. Now you may say "well thats just the parser, it has to parse + specially because its an operator with specific precedence etc". Well, the same exact thing is true of |> I think.
>
> Best,
> ~G
>>
>>
>> On Sun, Dec 6, 2020 at 4:06 PM Gabriel Becker <gabembecker at gmail.com> wrote:
>> >
>> > Hi Gabor,
>> >
>> > On Sun, Dec 6, 2020 at 12:52 PM Gabor Grothendieck <ggrothendieck at gmail.com> wrote:
>> >>
>> >> I think the real issue here is that functions are supposed to be
>> >> first class objects in R
>> >> or are supposed to be and |> would break that if if is possible
>> >> to write function(x) x + 1 on the RHS but not foo (assuming foo
>> >> was defined as that function).
>> >>
>> >> I don't think getting experience with using it can change that
>> >> inconsistency which seems serious to me and needs to
>> >> be addressed even if it complicates the implementation
>> >> since it drives to the heart of what R is.
>> >>
>> >
>> > With respect I think this is a misunderstanding of what is happening here.
>> >
>> > Functions are first class citizens. |> is, for all intents and purposes, a macro.
>> >
>> > LHS |> RHS(arg2=5)
>> >
>> > parses to
>> >
>> > RHS(LHS, arg2 = 5)
>> >
>> > There are no functions at the point in time when the pipe transformation happens, because no code has been evaluated. To know if a symbol is going to evaluate to a function requires evaluation which is a step entirely after the one where the |> pipe is implemented.
>> >
>> > Another way to think about it is that
>> >
>> > LHS |> RHS(arg2 = 5)
>> >
>> > is another way of writing RHS(LHS, arg2 = 5), NOT R code that is (or even can be) evaluated.
>> >
>> >
>> > Now this is a subtle point that only really has implications in as much as it is not the case for magrittr pipes, but its relevant for discussions like this, I think.
>> >
>> > ~G
>> >
>> >> On Sat, Dec 5, 2020 at 1:08 PM Gabor Grothendieck
>> >> <ggrothendieck at gmail.com> wrote:
>> >> >
>> >> > The construct utils::head  is not that common but bare functions are
>> >> > very common and to make it harder to use the common case so that
>> >> > the uncommon case is slightly easier is not desirable.
>> >> >
>> >> > Also it is trivial to write this which does work:
>> >> >
>> >> > mtcars %>% (utils::head)
>> >> >
>> >> > On Sat, Dec 5, 2020 at 11:59 AM Hugh Parsonage <hugh.parsonage at gmail.com> wrote:
>> >> > >
>> >> > > I'm surprised by the aversion to
>> >> > >
>> >> > > mtcars |> nrow
>> >> > >
>> >> > > over
>> >> > >
>> >> > > mtcars |> nrow()
>> >> > >
>> >> > > and I think the decision to disallow the former should be
>> >> > > reconsidered.  The pipe operator is only going to be used when the rhs
>> >> > > is a function, so there is no ambiguity with omitting the parentheses.
>> >> > > If it's disallowed, it becomes inconsistent with other treatments like
>> >> > > sapply(mtcars, typeof) where sapply(mtcars, typeof()) would just be
>> >> > > noise.  I'm not sure why this decision was taken
>> >> > >
>> >> > > If the only issue is with the double (and triple) colon operator, then
>> >> > > ideally `mtcars |> base::head` should resolve to `base::head(mtcars)`
>> >> > > -- in other words, demote the precedence of |>
>> >> > >
>> >> > > Obviously (looking at the R-Syntax branch) this decision was
>> >> > > considered, put into place, then dropped, but I can't see why
>> >> > > precisely.
>> >> > >
>> >> > > Best,
>> >> > >
>> >> > >
>> >> > > Hugh.
>> >> > >
>> >> > >
>> >> > >
>> >> > >
>> >> > >
>> >> > >
>> >> > >
>> >> > > On Sat, 5 Dec 2020 at 04:07, Deepayan Sarkar <deepayan.sarkar at gmail.com> wrote:
>> >> > > >
>> >> > > > On Fri, Dec 4, 2020 at 7:35 PM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>> >> > > > >
>> >> > > > > On 04/12/2020 8:13 a.m., Hiroaki Yutani wrote:
>> >> > > > > >>   Error: function '::' not supported in RHS call of a pipe
>> >> > > > > >
>> >> > > > > > To me, this error looks much more friendly than magrittr's error.
>> >> > > > > > Some of them got too used to specify functions without (). This
>> >> > > > > > is OK until they use `::`, but when they need to use it, it takes
>> >> > > > > > hours to figure out why
>> >> > > > > >
>> >> > > > > > mtcars %>% base::head
>> >> > > > > > #> Error in .::base : unused argument (head)
>> >> > > > > >
>> >> > > > > > won't work but
>> >> > > > > >
>> >> > > > > > mtcars %>% head
>> >> > > > > >
>> >> > > > > > works. I think this is a too harsh lesson for ordinary R users to
>> >> > > > > > learn `::` is a function. I've been wanting for magrittr to drop the
>> >> > > > > > support for a function name without () to avoid this confusion,
>> >> > > > > > so I would very much welcome the new pipe operator's behavior.
>> >> > > > > > Thank you all the developers who implemented this!
>> >> > > > >
>> >> > > > > I agree, it's an improvement on the corresponding magrittr error.
>> >> > > > >
>> >> > > > > I think the semantics of not evaluating the RHS, but treating the pipe
>> >> > > > > as purely syntactical is a good decision.
>> >> > > > >
>> >> > > > > I'm not sure I like the recommended way to pipe into a particular argument:
>> >> > > > >
>> >> > > > >    mtcars |> subset(cyl == 4) |> \(d) lm(mpg ~ disp, data = d)
>> >> > > > >
>> >> > > > > or
>> >> > > > >
>> >> > > > >    mtcars |> subset(cyl == 4) |> function(d) lm(mpg ~ disp, data = d)
>> >> > > > >
>> >> > > > > both of which are equivalent to
>> >> > > > >
>> >> > > > >    mtcars |> subset(cyl == 4) |> (function(d) lm(mpg ~ disp, data = d))()
>> >> > > > >
>> >> > > > > It's tempting to suggest it should allow something like
>> >> > > > >
>> >> > > > >    mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
>> >> > > >
>> >> > > > Which is really not that far off from
>> >> > > >
>> >> > > > mtcars |> subset(cyl == 4) |> \(.) lm(mpg ~ disp, data = .)
>> >> > > >
>> >> > > > once you get used to it.
>> >> > > >
>> >> > > > One consequence of the implementation is that it's not clear how
>> >> > > > multiple occurrences of the placeholder would be interpreted. With
>> >> > > > magrittr,
>> >> > > >
>> >> > > > sort(runif(10)) %>% ecdf(.)(.)
>> >> > > > ## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
>> >> > > >
>> >> > > > This is probably what you would expect, if you expect it to work at all, and not
>> >> > > >
>> >> > > > ecdf(sort(runif(10)))(sort(runif(10)))
>> >> > > >
>> >> > > > There would be no such ambiguity with anonymous functions
>> >> > > >
>> >> > > > sort(runif(10)) |> \(.) ecdf(.)(.)
>> >> > > >
>> >> > > > -Deepayan
>> >> > > >
>> >> > > > > which would be expanded to something equivalent to the other versions:
>> >> > > > > but that makes it quite a bit more complicated.  (Maybe _ or \. should
>> >> > > > > be used instead of ., since those are not legal variable names.)
>> >> > > > >
>> >> > > > > I don't think there should be an attempt to copy magrittr's special
>> >> > > > > casing of how . is used in determining whether to also include the
>> >> > > > > previous value as first argument.
>> >> > > > >
>> >> > > > > Duncan Murdoch
>> >> > > > >
>> >> > > > >
>> >> > > > > >
>> >> > > > > > Best,
>> >> > > > > > Hiroaki Yutani
>> >> > > > > >
>> >> > > > > > 2020?12?4?(?) 20:51 Duncan Murdoch <murdoch.duncan at gmail.com>:
>> >> > > > > >>
>> >> > > > > >> Just saw this on the R-devel news:
>> >> > > > > >>
>> >> > > > > >>
>> >> > > > > >> R now provides a simple native pipe syntax ?|>? as well as a shorthand
>> >> > > > > >> notation for creating functions, e.g. ?\(x) x + 1? is parsed as
>> >> > > > > >> ?function(x) x + 1?. The pipe implementation as a syntax transformation
>> >> > > > > >> was motivated by suggestions from Jim Hester and Lionel Henry. These
>> >> > > > > >> features are experimental and may change prior to release.
>> >> > > > > >>
>> >> > > > > >>
>> >> > > > > >> This is a good addition; by using "|>" instead of "%>%" there should be
>> >> > > > > >> a chance to get operator precedence right.  That said, the ?Syntax help
>> >> > > > > >> topic hasn't been updated, so I'm not sure where it fits in.
>> >> > > > > >>
>> >> > > > > >> There are some choices that take a little getting used to:
>> >> > > > > >>
>> >> > > > > >>   > mtcars |> head
>> >> > > > > >> Error: The pipe operator requires a function call or an anonymous
>> >> > > > > >> function expression as RHS
>> >> > > > > >>
>> >> > > > > >> (I need to say mtcars |> head() instead.)  This sometimes leads to error
>> >> > > > > >> messages that are somewhat confusing:
>> >> > > > > >>
>> >> > > > > >>   > mtcars |> magrittr::debug_pipe |> head
>> >> > > > > >> Error: function '::' not supported in RHS call of a pipe
>> >> > > > > >>
>> >> > > > > >> but
>> >> > > > > >>
>> >> > > > > >> mtcars |> magrittr::debug_pipe() |> head()
>> >> > > > > >>
>> >> > > > > >> works.
>> >> > > > > >>
>> >> > > > > >> Overall, I think this is a great addition, though it's going to be
>> >> > > > > >> disruptive for a while.
>> >> > > > > >>
>> >> > > > > >> Duncan Murdoch
>> >> > > > > >>
>> >> > > > > >> ______________________________________________
>> >> > > > > >> R-devel at r-project.org mailing list
>> >> > > > > >> https://stat.ethz.ch/mailman/listinfo/r-devel
>> >> > > > > >
>> >> > > > > > ______________________________________________
>> >> > > > > > R-devel at r-project.org mailing list
>> >> > > > > > https://stat.ethz.ch/mailman/listinfo/r-devel
>> >> > > > > >
>> >> > > > >
>> >> > > > > ______________________________________________
>> >> > > > > R-devel at r-project.org mailing list
>> >> > > > > https://stat.ethz.ch/mailman/listinfo/r-devel
>> >> > > >
>> >> > > > ______________________________________________
>> >> > > > R-devel at r-project.org mailing list
>> >> > > > https://stat.ethz.ch/mailman/listinfo/r-devel
>> >> > >
>> >> > > ______________________________________________
>> >> > > R-devel at r-project.org mailing list
>> >> > > https://stat.ethz.ch/mailman/listinfo/r-devel
>> >> >
>> >> >
>> >> >
>> >> > --
>> >> > Statistics & Software Consulting
>> >> > GKX Group, GKX Associates Inc.
>> >> > tel: 1-877-GKX-GROUP
>> >> > email: ggrothendieck at gmail.com
>> >>
>> >>
>> >>
>> >> --
>> >> Statistics & Software Consulting
>> >> GKX Group, GKX Associates Inc.
>> >> tel: 1-877-GKX-GROUP
>> >> email: ggrothendieck at gmail.com
>> >>
>> >> ______________________________________________
>> >> R-devel at r-project.org mailing list
>> >> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>>
>>
>> --
>> Statistics & Software Consulting
>> GKX Group, GKX Associates Inc.
>> tel: 1-877-GKX-GROUP
>> email: ggrothendieck at gmail.com



-- 
Statistics & Software Consulting
GKX Group, GKX Associates Inc.
tel: 1-877-GKX-GROUP
email: ggrothendieck at gmail.com


From murdoch@dunc@n @end|ng |rom gm@||@com  Mon Dec  7 11:31:32 2020
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Mon, 7 Dec 2020 05:31:32 -0500
Subject: [Rd] New pipe operator
In-Reply-To: <MEAPR01MB2407865F5622461515F409EDB4CE0@MEAPR01MB2407.ausprd01.prod.outlook.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
 <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
 <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>
 <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>
 <MEAPR01MB2407865F5622461515F409EDB4CE0@MEAPR01MB2407.ausprd01.prod.outlook.com>
Message-ID: <5179b8d4-628e-ff73-fa53-92fe942e12ea@gmail.com>

On 06/12/2020 8:22 p.m., Bravington, Mark (Data61, Hobart) wrote:
> Seems like this *could* be a good thing, and thanks to R core for considering it. But, FWIW:
> 
>   - I agree with Gabor G that consistency of "syntax" should be paramount here. Enough problems have been caused by earlier superficially-convenient non-standard features in R.  In particular:
> 
>   -- there should not be any discrepancy between an in-place function-definition, and a predefined function attached to a symbol (as per Gabor's point).
>   
>   -- Hence, the ability to say x |> foo  ie without parentheses, seems bound to lead to inconsistency, because x |> foo is allowed, x |> base::foo isn't allowed without tricks, but x |> function( y) foo( y) isn't... So, x |> foo is not worth keeping. Parentheses are a price well worth paying.
>   
>   -- it is still inconsistent and confusing to (apparently) invoke a function in some places--- normally--- via 'foo(x)', yet in others--- pipily--- via 'foo()'. Especially if 'foo' already has a default value for its first argument.
> 
>   - I don't see the problem with a placeholder--- doesn't it remove all ambiguity? Sure there needs to be a standard unclashable name and people can argue about what that should be, but the following seems clear and flexible... to me, anyway:
>   
>   thing |>
>     foo( _PIPE_) |>           # standard
>     bah( arg1, _PIPE_) |>   # multi-arg function
>     _ANON_({ x <- sum( _PIPE_); _PIPE_/x + x/_PIPE_ })   # anon function
>    
> where '_PIPE_' is the ordained name of the placeholder, and '_ANON_' constructs-and-calls a function with single argument '_PIPE_'. There is just one rule (I think...): each pipe-stage must be a *call* involving the argument '_PIPE_'.

I believe there's no ambiguity if the placeholder is *only* allowed in  
the RHS of a pipe expression.  I think the ambiguity arises if you allow  
the same syntax to be used to generate anonymous functions.  We can't  
use _PIPE_ as the placeholder, because it's a legal name.  But we could  
use _.  Then

   x |> (_ + 1) + mean(_)

could expand unambiguously to

   (function(_) (_  + 1) + mean(_))(x)

but

   (_ + 1) + mean(_)

shouldn't be taken to be an anonymous function declaration, otherwise  
things like

   mean(_ |> _)

do become ambiguous:  is the second placeholder the argument to the anon  
function, or is it the placeholder for the embedded pipe?

However, implementing this makes the parser pretty ugly:  its handling  
of _ depends on the outer context.  I now agree that leaving out  
placeholder syntax was the right decision.


> 
> 
>   - The proposed anonymous-function syntax looks quite ugly to me, diminishing readability and inviting errors. The new pipe symbol |> already looks scarily like quantum mechanics; adding \( just puts fishbones into the symbolic soup.
> 
>   - IMO it's not worth going too far to try to lure magritter-etc fans to swap to the new; my experience is that many people keep using older inferior R syntax for years after better replacements become available (even if they are aware of replacements), for various reasons. Just provide a good framework, and let nature take its course.
>   
>   - Disclaimer: personally I'm not much of a pipehead anyway, so maybe I'm not the audience. But if I was to consider piping, I wouldn't be very tempted by the current proposal. OTOH, I might even be tempted to write--- and use!--- my own version of '%|>%' as above (maybe someone already has). And if R did it for me, that'd be great :)

Yours would suffer one of the same problems as magrittr's:  it has the  
wrong operator precedence.  The current precedence ordering (from  
?Syntax) is, from highest to lowest:


:: :::	access variables in a namespace
$ @	component / slot extraction
[ [[	indexing
^	exponentiation (right to left)
- +	unary minus and plus
:	sequence operator
%any%	special operators (including %% and %/%)
* /	multiply, divide
+ -	(binary) add, subtract
< > <= >= == !=	ordering and comparison
!	negation
& &&	and
| ||	or
~	as in formulae
-> ->>	rightwards assignment
<- <<-	assignment (right to left)
=	assignment (right to left)
?	help (unary and binary)


The %>% operator has higher precedence than the arithmetic operators, so

x*y %>% f()

is equivalent to x*f(y), not

f(x*y)

as it should "obviously" be.  I believe the new |> operator falls  
between "| ||" and "~", so

x || y |> f()

is the same as f(x || y), and

x ~ y |> f()

is x ~ f(y).   There could be arguments about where the new one appears  
(and there probably have been), but *clearly* magrittr's precedence is  
wrong, and yours would be too, because they are both fixed at the quite  
high precedence given to %any%.

Duncan Murdoch

>   
> [*] Definition of _ANON_ could be something like this--- almost certainly won't work as-is, this is just to point out that it could be done in standard R.
> 
> `_ANON_` <- function( expr) {
>    #1. Construct a function with arg '_PIPE_' and body 'expr'
>    #2. Construct a call() to that function
>    #3. Do the call
> 
>    f <- function( `_PIPE_`) NULL
>    body( f) <- expr
>    environment( f) <- parent.frame() # or something... yes these details are almost certainly wrong
>    expr2 <- substitute( f( `_PIPE_`)) # or something...
>    eval.parent( expr2) # or something...
> }
> 
> cheers
> Mark
> 
> Mark Bravington
> CSIRO Marine Lab
> Hobart
> Australia
> 
> 
> ________________________________________
> From: R-devel <r-devel-bounces at r-project.org> on behalf of Gabor Grothendieck <ggrothendieck at gmail.com>
> Sent: Monday, 7 December 2020 10:21
> To: Gabriel Becker
> Cc: r-devel at r-project.org
> Subject: Re: [Rd] New pipe operator
> 
> I understand very well that it is implemented at the syntax level;
> however, in any case the implementation is irrelevant to the principles.
> 
> Here a similar example to the one I gave before but this time written out:
> 
> This works:
> 
>    3 |> function(x) x + 1
> 
> but this does not:
> 
>    foo <- function(x) x + 1
>    3 |> foo
> 
> so it breaks the principle of functions being first class objects.  foo and its
> definition are not interchangeable.  You have
> to write 3 |> foo() but don't have to write 3 |> (function(x) x + 1)().
> 
> This isn't just a matter of notation, i.e. foo vs foo(), but is a
> matter of breaking
> the way R works as a functional language with first class functions.
> 
> On Sun, Dec 6, 2020 at 4:06 PM Gabriel Becker <gabembecker at gmail.com> wrote:
>>
>> Hi Gabor,
>>
>> On Sun, Dec 6, 2020 at 12:52 PM Gabor Grothendieck <ggrothendieck at gmail.com> wrote:
>>>
>>> I think the real issue here is that functions are supposed to be
>>> first class objects in R
>>> or are supposed to be and |> would break that if if is possible
>>> to write function(x) x + 1 on the RHS but not foo (assuming foo
>>> was defined as that function).
>>>
>>> I don't think getting experience with using it can change that
>>> inconsistency which seems serious to me and needs to
>>> be addressed even if it complicates the implementation
>>> since it drives to the heart of what R is.
>>>
>>
>> With respect I think this is a misunderstanding of what is happening here.
>>
>> Functions are first class citizens. |> is, for all intents and purposes, a macro.
>>
>> LHS |> RHS(arg2=5)
>>
>> parses to
>>
>> RHS(LHS, arg2 = 5)
>>
>> There are no functions at the point in time when the pipe transformation happens, because no code has been evaluated. To know if a symbol is going to evaluate to a function requires evaluation which is a step entirely after the one where the |> pipe is implemented.
>>
>> Another way to think about it is that
>>
>> LHS |> RHS(arg2 = 5)
>>
>> is another way of writing RHS(LHS, arg2 = 5), NOT R code that is (or even can be) evaluated.
>>
>>
>> Now this is a subtle point that only really has implications in as much as it is not the case for magrittr pipes, but its relevant for discussions like this, I think.
>>
>> ~G
>>
>>> On Sat, Dec 5, 2020 at 1:08 PM Gabor Grothendieck
>>> <ggrothendieck at gmail.com> wrote:
>>>>
>>>> The construct utils::head  is not that common but bare functions are
>>>> very common and to make it harder to use the common case so that
>>>> the uncommon case is slightly easier is not desirable.
>>>>
>>>> Also it is trivial to write this which does work:
>>>>
>>>> mtcars %>% (utils::head)
>>>>
>>>> On Sat, Dec 5, 2020 at 11:59 AM Hugh Parsonage <hugh.parsonage at gmail.com> wrote:
>>>>>
>>>>> I'm surprised by the aversion to
>>>>>
>>>>> mtcars |> nrow
>>>>>
>>>>> over
>>>>>
>>>>> mtcars |> nrow()
>>>>>
>>>>> and I think the decision to disallow the former should be
>>>>> reconsidered.  The pipe operator is only going to be used when the rhs
>>>>> is a function, so there is no ambiguity with omitting the parentheses.
>>>>> If it's disallowed, it becomes inconsistent with other treatments like
>>>>> sapply(mtcars, typeof) where sapply(mtcars, typeof()) would just be
>>>>> noise.  I'm not sure why this decision was taken
>>>>>
>>>>> If the only issue is with the double (and triple) colon operator, then
>>>>> ideally `mtcars |> base::head` should resolve to `base::head(mtcars)`
>>>>> -- in other words, demote the precedence of |>
>>>>>
>>>>> Obviously (looking at the R-Syntax branch) this decision was
>>>>> considered, put into place, then dropped, but I can't see why
>>>>> precisely.
>>>>>
>>>>> Best,
>>>>>
>>>>>
>>>>> Hugh.
>>>>>
>>>>>
>>>>>
>>>>>
>>>>>
>>>>>
>>>>>
>>>>> On Sat, 5 Dec 2020 at 04:07, Deepayan Sarkar <deepayan.sarkar at gmail.com> wrote:
>>>>>>
>>>>>> On Fri, Dec 4, 2020 at 7:35 PM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>>>>>>>
>>>>>>> On 04/12/2020 8:13 a.m., Hiroaki Yutani wrote:
>>>>>>>>>    Error: function '::' not supported in RHS call of a pipe
>>>>>>>>
>>>>>>>> To me, this error looks much more friendly than magrittr's error.
>>>>>>>> Some of them got too used to specify functions without (). This
>>>>>>>> is OK until they use `::`, but when they need to use it, it takes
>>>>>>>> hours to figure out why
>>>>>>>>
>>>>>>>> mtcars %>% base::head
>>>>>>>> #> Error in .::base : unused argument (head)
>>>>>>>>
>>>>>>>> won't work but
>>>>>>>>
>>>>>>>> mtcars %>% head
>>>>>>>>
>>>>>>>> works. I think this is a too harsh lesson for ordinary R users to
>>>>>>>> learn `::` is a function. I've been wanting for magrittr to drop the
>>>>>>>> support for a function name without () to avoid this confusion,
>>>>>>>> so I would very much welcome the new pipe operator's behavior.
>>>>>>>> Thank you all the developers who implemented this!
>>>>>>>
>>>>>>> I agree, it's an improvement on the corresponding magrittr error.
>>>>>>>
>>>>>>> I think the semantics of not evaluating the RHS, but treating the pipe
>>>>>>> as purely syntactical is a good decision.
>>>>>>>
>>>>>>> I'm not sure I like the recommended way to pipe into a particular argument:
>>>>>>>
>>>>>>>     mtcars |> subset(cyl == 4) |> \(d) lm(mpg ~ disp, data = d)
>>>>>>>
>>>>>>> or
>>>>>>>
>>>>>>>     mtcars |> subset(cyl == 4) |> function(d) lm(mpg ~ disp, data = d)
>>>>>>>
>>>>>>> both of which are equivalent to
>>>>>>>
>>>>>>>     mtcars |> subset(cyl == 4) |> (function(d) lm(mpg ~ disp, data = d))()
>>>>>>>
>>>>>>> It's tempting to suggest it should allow something like
>>>>>>>
>>>>>>>     mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
>>>>>>
>>>>>> Which is really not that far off from
>>>>>>
>>>>>> mtcars |> subset(cyl == 4) |> \(.) lm(mpg ~ disp, data = .)
>>>>>>
>>>>>> once you get used to it.
>>>>>>
>>>>>> One consequence of the implementation is that it's not clear how
>>>>>> multiple occurrences of the placeholder would be interpreted. With
>>>>>> magrittr,
>>>>>>
>>>>>> sort(runif(10)) %>% ecdf(.)(.)
>>>>>> ## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
>>>>>>
>>>>>> This is probably what you would expect, if you expect it to work at all, and not
>>>>>>
>>>>>> ecdf(sort(runif(10)))(sort(runif(10)))
>>>>>>
>>>>>> There would be no such ambiguity with anonymous functions
>>>>>>
>>>>>> sort(runif(10)) |> \(.) ecdf(.)(.)
>>>>>>
>>>>>> -Deepayan
>>>>>>
>>>>>>> which would be expanded to something equivalent to the other versions:
>>>>>>> but that makes it quite a bit more complicated.  (Maybe _ or \. should
>>>>>>> be used instead of ., since those are not legal variable names.)
>>>>>>>
>>>>>>> I don't think there should be an attempt to copy magrittr's special
>>>>>>> casing of how . is used in determining whether to also include the
>>>>>>> previous value as first argument.
>>>>>>>
>>>>>>> Duncan Murdoch
>>>>>>>
>>>>>>>
>>>>>>>>
>>>>>>>> Best,
>>>>>>>> Hiroaki Yutani
>>>>>>>>
>>>>>>>> 2020?12?4?(?) 20:51 Duncan Murdoch <murdoch.duncan at gmail.com>:
>>>>>>>>>
>>>>>>>>> Just saw this on the R-devel news:
>>>>>>>>>
>>>>>>>>>
>>>>>>>>> R now provides a simple native pipe syntax ?|>? as well as a shorthand
>>>>>>>>> notation for creating functions, e.g. ?\(x) x + 1? is parsed as
>>>>>>>>> ?function(x) x + 1?. The pipe implementation as a syntax transformation
>>>>>>>>> was motivated by suggestions from Jim Hester and Lionel Henry. These
>>>>>>>>> features are experimental and may change prior to release.
>>>>>>>>>
>>>>>>>>>
>>>>>>>>> This is a good addition; by using "|>" instead of "%>%" there should be
>>>>>>>>> a chance to get operator precedence right.  That said, the ?Syntax help
>>>>>>>>> topic hasn't been updated, so I'm not sure where it fits in.
>>>>>>>>>
>>>>>>>>> There are some choices that take a little getting used to:
>>>>>>>>>
>>>>>>>>>    > mtcars |> head
>>>>>>>>> Error: The pipe operator requires a function call or an anonymous
>>>>>>>>> function expression as RHS
>>>>>>>>>
>>>>>>>>> (I need to say mtcars |> head() instead.)  This sometimes leads to error
>>>>>>>>> messages that are somewhat confusing:
>>>>>>>>>
>>>>>>>>>    > mtcars |> magrittr::debug_pipe |> head
>>>>>>>>> Error: function '::' not supported in RHS call of a pipe
>>>>>>>>>
>>>>>>>>> but
>>>>>>>>>
>>>>>>>>> mtcars |> magrittr::debug_pipe() |> head()
>>>>>>>>>
>>>>>>>>> works.
>>>>>>>>>
>>>>>>>>> Overall, I think this is a great addition, though it's going to be
>>>>>>>>> disruptive for a while.
>>>>>>>>>
>>>>>>>>> Duncan Murdoch
>>>>>>>>>
>>>>>>>>> ______________________________________________
>>>>>>>>> R-devel at r-project.org mailing list
>>>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>>>
>>>>>>>> ______________________________________________
>>>>>>>> R-devel at r-project.org mailing list
>>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>>>
>>>>>>>
>>>>>>> ______________________________________________
>>>>>>> R-devel at r-project.org mailing list
>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>
>>>>>> ______________________________________________
>>>>>> R-devel at r-project.org mailing list
>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>
>>>>> ______________________________________________
>>>>> R-devel at r-project.org mailing list
>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>
>>>>
>>>>
>>>> --
>>>> Statistics & Software Consulting
>>>> GKX Group, GKX Associates Inc.
>>>> tel: 1-877-GKX-GROUP
>>>> email: ggrothendieck at gmail.com
>>>
>>>
>>>
>>> --
>>> Statistics & Software Consulting
>>> GKX Group, GKX Associates Inc.
>>> tel: 1-877-GKX-GROUP
>>> email: ggrothendieck at gmail.com
>>>
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> 
> 
> --
> Statistics & Software Consulting
> GKX Group, GKX Associates Inc.
> tel: 1-877-GKX-GROUP
> email: ggrothendieck at gmail.com
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


From murdoch@dunc@n @end|ng |rom gm@||@com  Mon Dec  7 11:41:16 2020
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Mon, 7 Dec 2020 05:41:16 -0500
Subject: [Rd] New pipe operator
In-Reply-To: <CAD4oTHHFWkiirncPRWngY+_k9HcB=8zo7VdXAONXQoXdNhKzDA@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
 <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
 <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>
 <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>
 <CAD4oTHHFWkiirncPRWngY+_k9HcB=8zo7VdXAONXQoXdNhKzDA@mail.gmail.com>
Message-ID: <7e28d84a-f6d0-1e18-c131-163650e7cd75@gmail.com>

On 06/12/2020 9:23 p.m., Gabriel Becker wrote:
> Hi Gabor,
> 
> On Sun, Dec 6, 2020 at 3:22 PM Gabor Grothendieck <ggrothendieck at gmail.com>
> wrote:
> 
>> I understand very well that it is implemented at the syntax level;
>> however, in any case the implementation is irrelevant to the principles.
>>
>> Here a similar example to the one I gave before but this time written out:
>>
>> This works:
>>
>>    3 |> function(x) x + 1
>>
>> but this does not:
>>
>>    foo <- function(x) x + 1
>>    3 |> foo
>>
>> so it breaks the principle of functions being first class objects.  foo
>> and its
>> definition are not interchangeable.
> 
> 
> I understood what you meant as well.
> 
> The issue is that neither foo nor its definition are being operated on, or
> even exist within the scope of what |> is defined to do. You are used to
> magrittr's %>% where arguably what you are saying would be true. But its
> not here, in my view.
> 
> Again, I think the issue is that |>, in as much as it "operates" on
> anything at all (it not being a function, regardless of appearances),
> operates on call expression objects, NOT on functions, ever.
> 
> function(x) x *parses to a call expression *as does RHSfun(), while RHSfun does
> not, it parses to a name, *regardless of whether that symbol will
> eventually evaluate to a closure or not.*
> 
> So in fact, it seems to me that, technically, all name symbols are being
> treated exactly the same (none are allowed, including those which will
> lookup to functions during evaluation), while all* call expressions are
> also being treated the same. And again, there are no functions anywhere in
> either case.

I agree it's all about call expressions, but they aren't all being 
treated equally:

x |> f(...)

expands to f(x, ...), while

x |> `function`(...)

expands to `function`(...)(x).  This is an exception to the rule for 
other calls, but I think it's a justified one.

Duncan Murdoch

> 
> * except those that include that the parser flags as syntactically special.
> 
> 
>> You have
>> to write 3 |> foo() but don't have to write 3 |> (function(x) x + 1)().
>>
> 
> I think you should probably be careful what you wish for here. I'm not
> involved with this work and do not speak for any of those who were, but the
> principled way to make that consistent while remaining entirely in the
> parser seems very likely to be to require the latter, rather than not
> require the former.
> 
> 
>> This isn't just a matter of notation, i.e. foo vs foo(), but is a
>> matter of breaking
>> the way R works as a functional language with first class functions.
>>
> 
> I don't agree. Consider `+`
> 
> Having
> 
> foo <- get("+") ## note no `` here
> foo(x,y)
> 
> parse and work correctly while
> 
> +(x,y)
> 
>   does not does not mean + isn't a function or that it is a "second class
> citizen", it simply means that the parser has constraints on the syntax for
> writing code that calls it that calling other functions are not subject to.
> The fact that such *syntactic* constraints can exist proves that there is
> not some overarching inviolable principle being violated here, I think. Now
> you may say "well thats just the parser, it has to parse + specially
> because its an operator with specific precedence etc". Well, the same exact
> thing is true of |> I think.
> 
> Best,
> ~G
> 
>>
>> On Sun, Dec 6, 2020 at 4:06 PM Gabriel Becker <gabembecker at gmail.com>
>> wrote:
>>>
>>> Hi Gabor,
>>>
>>> On Sun, Dec 6, 2020 at 12:52 PM Gabor Grothendieck <
>> ggrothendieck at gmail.com> wrote:
>>>>
>>>> I think the real issue here is that functions are supposed to be
>>>> first class objects in R
>>>> or are supposed to be and |> would break that if if is possible
>>>> to write function(x) x + 1 on the RHS but not foo (assuming foo
>>>> was defined as that function).
>>>>
>>>> I don't think getting experience with using it can change that
>>>> inconsistency which seems serious to me and needs to
>>>> be addressed even if it complicates the implementation
>>>> since it drives to the heart of what R is.
>>>>
>>>
>>> With respect I think this is a misunderstanding of what is happening
>> here.
>>>
>>> Functions are first class citizens. |> is, for all intents and purposes,
>> a macro.
>>>
>>> LHS |> RHS(arg2=5)
>>>
>>> parses to
>>>
>>> RHS(LHS, arg2 = 5)
>>>
>>> There are no functions at the point in time when the pipe transformation
>> happens, because no code has been evaluated. To know if a symbol is going
>> to evaluate to a function requires evaluation which is a step entirely
>> after the one where the |> pipe is implemented.
>>>
>>> Another way to think about it is that
>>>
>>> LHS |> RHS(arg2 = 5)
>>>
>>> is another way of writing RHS(LHS, arg2 = 5), NOT R code that is (or
>> even can be) evaluated.
>>>
>>>
>>> Now this is a subtle point that only really has implications in as much
>> as it is not the case for magrittr pipes, but its relevant for discussions
>> like this, I think.
>>>
>>> ~G
>>>
>>>> On Sat, Dec 5, 2020 at 1:08 PM Gabor Grothendieck
>>>> <ggrothendieck at gmail.com> wrote:
>>>>>
>>>>> The construct utils::head  is not that common but bare functions are
>>>>> very common and to make it harder to use the common case so that
>>>>> the uncommon case is slightly easier is not desirable.
>>>>>
>>>>> Also it is trivial to write this which does work:
>>>>>
>>>>> mtcars %>% (utils::head)
>>>>>
>>>>> On Sat, Dec 5, 2020 at 11:59 AM Hugh Parsonage <
>> hugh.parsonage at gmail.com> wrote:
>>>>>>
>>>>>> I'm surprised by the aversion to
>>>>>>
>>>>>> mtcars |> nrow
>>>>>>
>>>>>> over
>>>>>>
>>>>>> mtcars |> nrow()
>>>>>>
>>>>>> and I think the decision to disallow the former should be
>>>>>> reconsidered.  The pipe operator is only going to be used when the
>> rhs
>>>>>> is a function, so there is no ambiguity with omitting the
>> parentheses.
>>>>>> If it's disallowed, it becomes inconsistent with other treatments
>> like
>>>>>> sapply(mtcars, typeof) where sapply(mtcars, typeof()) would just be
>>>>>> noise.  I'm not sure why this decision was taken
>>>>>>
>>>>>> If the only issue is with the double (and triple) colon operator,
>> then
>>>>>> ideally `mtcars |> base::head` should resolve to
>> `base::head(mtcars)`
>>>>>> -- in other words, demote the precedence of |>
>>>>>>
>>>>>> Obviously (looking at the R-Syntax branch) this decision was
>>>>>> considered, put into place, then dropped, but I can't see why
>>>>>> precisely.
>>>>>>
>>>>>> Best,
>>>>>>
>>>>>>
>>>>>> Hugh.
>>>>>>
>>>>>>
>>>>>>
>>>>>>
>>>>>>
>>>>>>
>>>>>>
>>>>>> On Sat, 5 Dec 2020 at 04:07, Deepayan Sarkar <
>> deepayan.sarkar at gmail.com> wrote:
>>>>>>>
>>>>>>> On Fri, Dec 4, 2020 at 7:35 PM Duncan Murdoch <
>> murdoch.duncan at gmail.com> wrote:
>>>>>>>>
>>>>>>>> On 04/12/2020 8:13 a.m., Hiroaki Yutani wrote:
>>>>>>>>>>    Error: function '::' not supported in RHS call of a pipe
>>>>>>>>>
>>>>>>>>> To me, this error looks much more friendly than magrittr's
>> error.
>>>>>>>>> Some of them got too used to specify functions without ().
>> This
>>>>>>>>> is OK until they use `::`, but when they need to use it, it
>> takes
>>>>>>>>> hours to figure out why
>>>>>>>>>
>>>>>>>>> mtcars %>% base::head
>>>>>>>>> #> Error in .::base : unused argument (head)
>>>>>>>>>
>>>>>>>>> won't work but
>>>>>>>>>
>>>>>>>>> mtcars %>% head
>>>>>>>>>
>>>>>>>>> works. I think this is a too harsh lesson for ordinary R
>> users to
>>>>>>>>> learn `::` is a function. I've been wanting for magrittr to
>> drop the
>>>>>>>>> support for a function name without () to avoid this
>> confusion,
>>>>>>>>> so I would very much welcome the new pipe operator's behavior.
>>>>>>>>> Thank you all the developers who implemented this!
>>>>>>>>
>>>>>>>> I agree, it's an improvement on the corresponding magrittr
>> error.
>>>>>>>>
>>>>>>>> I think the semantics of not evaluating the RHS, but treating
>> the pipe
>>>>>>>> as purely syntactical is a good decision.
>>>>>>>>
>>>>>>>> I'm not sure I like the recommended way to pipe into a
>> particular argument:
>>>>>>>>
>>>>>>>>     mtcars |> subset(cyl == 4) |> \(d) lm(mpg ~ disp, data = d)
>>>>>>>>
>>>>>>>> or
>>>>>>>>
>>>>>>>>     mtcars |> subset(cyl == 4) |> function(d) lm(mpg ~ disp,
>> data = d)
>>>>>>>>
>>>>>>>> both of which are equivalent to
>>>>>>>>
>>>>>>>>     mtcars |> subset(cyl == 4) |> (function(d) lm(mpg ~ disp,
>> data = d))()
>>>>>>>>
>>>>>>>> It's tempting to suggest it should allow something like
>>>>>>>>
>>>>>>>>     mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
>>>>>>>
>>>>>>> Which is really not that far off from
>>>>>>>
>>>>>>> mtcars |> subset(cyl == 4) |> \(.) lm(mpg ~ disp, data = .)
>>>>>>>
>>>>>>> once you get used to it.
>>>>>>>
>>>>>>> One consequence of the implementation is that it's not clear how
>>>>>>> multiple occurrences of the placeholder would be interpreted. With
>>>>>>> magrittr,
>>>>>>>
>>>>>>> sort(runif(10)) %>% ecdf(.)(.)
>>>>>>> ## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
>>>>>>>
>>>>>>> This is probably what you would expect, if you expect it to work
>> at all, and not
>>>>>>>
>>>>>>> ecdf(sort(runif(10)))(sort(runif(10)))
>>>>>>>
>>>>>>> There would be no such ambiguity with anonymous functions
>>>>>>>
>>>>>>> sort(runif(10)) |> \(.) ecdf(.)(.)
>>>>>>>
>>>>>>> -Deepayan
>>>>>>>
>>>>>>>> which would be expanded to something equivalent to the other
>> versions:
>>>>>>>> but that makes it quite a bit more complicated.  (Maybe _ or \.
>> should
>>>>>>>> be used instead of ., since those are not legal variable names.)
>>>>>>>>
>>>>>>>> I don't think there should be an attempt to copy magrittr's
>> special
>>>>>>>> casing of how . is used in determining whether to also include
>> the
>>>>>>>> previous value as first argument.
>>>>>>>>
>>>>>>>> Duncan Murdoch
>>>>>>>>
>>>>>>>>
>>>>>>>>>
>>>>>>>>> Best,
>>>>>>>>> Hiroaki Yutani
>>>>>>>>>
>>>>>>>>> 2020?12?4?(?) 20:51 Duncan Murdoch <murdoch.duncan at gmail.com
>>> :
>>>>>>>>>>
>>>>>>>>>> Just saw this on the R-devel news:
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> R now provides a simple native pipe syntax ?|>? as well as a
>> shorthand
>>>>>>>>>> notation for creating functions, e.g. ?\(x) x + 1? is parsed
>> as
>>>>>>>>>> ?function(x) x + 1?. The pipe implementation as a syntax
>> transformation
>>>>>>>>>> was motivated by suggestions from Jim Hester and Lionel
>> Henry. These
>>>>>>>>>> features are experimental and may change prior to release.
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> This is a good addition; by using "|>" instead of "%>%"
>> there should be
>>>>>>>>>> a chance to get operator precedence right.  That said, the
>> ?Syntax help
>>>>>>>>>> topic hasn't been updated, so I'm not sure where it fits in.
>>>>>>>>>>
>>>>>>>>>> There are some choices that take a little getting used to:
>>>>>>>>>>
>>>>>>>>>>    > mtcars |> head
>>>>>>>>>> Error: The pipe operator requires a function call or an
>> anonymous
>>>>>>>>>> function expression as RHS
>>>>>>>>>>
>>>>>>>>>> (I need to say mtcars |> head() instead.)  This sometimes
>> leads to error
>>>>>>>>>> messages that are somewhat confusing:
>>>>>>>>>>
>>>>>>>>>>    > mtcars |> magrittr::debug_pipe |> head
>>>>>>>>>> Error: function '::' not supported in RHS call of a pipe
>>>>>>>>>>
>>>>>>>>>> but
>>>>>>>>>>
>>>>>>>>>> mtcars |> magrittr::debug_pipe() |> head()
>>>>>>>>>>
>>>>>>>>>> works.
>>>>>>>>>>
>>>>>>>>>> Overall, I think this is a great addition, though it's going
>> to be
>>>>>>>>>> disruptive for a while.
>>>>>>>>>>
>>>>>>>>>> Duncan Murdoch
>>>>>>>>>>
>>>>>>>>>> ______________________________________________
>>>>>>>>>> R-devel at r-project.org mailing list
>>>>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>>>>
>>>>>>>>> ______________________________________________
>>>>>>>>> R-devel at r-project.org mailing list
>>>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>>>>
>>>>>>>>
>>>>>>>> ______________________________________________
>>>>>>>> R-devel at r-project.org mailing list
>>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>>
>>>>>>> ______________________________________________
>>>>>>> R-devel at r-project.org mailing list
>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>
>>>>>> ______________________________________________
>>>>>> R-devel at r-project.org mailing list
>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>
>>>>>
>>>>>
>>>>> --
>>>>> Statistics & Software Consulting
>>>>> GKX Group, GKX Associates Inc.
>>>>> tel: 1-877-GKX-GROUP
>>>>> email: ggrothendieck at gmail.com
>>>>
>>>>
>>>>
>>>> --
>>>> Statistics & Software Consulting
>>>> GKX Group, GKX Associates Inc.
>>>> tel: 1-877-GKX-GROUP
>>>> email: ggrothendieck at gmail.com
>>>>
>>>> ______________________________________________
>>>> R-devel at r-project.org mailing list
>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>>
>>
>> --
>> Statistics & Software Consulting
>> GKX Group, GKX Associates Inc.
>> tel: 1-877-GKX-GROUP
>> email: ggrothendieck at gmail.com
>>
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


From ggrothend|eck @end|ng |rom gm@||@com  Mon Dec  7 14:22:11 2020
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Mon, 7 Dec 2020 08:22:11 -0500
Subject: [Rd] New pipe operator
In-Reply-To: <7e28d84a-f6d0-1e18-c131-163650e7cd75@gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
 <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
 <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>
 <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>
 <CAD4oTHHFWkiirncPRWngY+_k9HcB=8zo7VdXAONXQoXdNhKzDA@mail.gmail.com>
 <7e28d84a-f6d0-1e18-c131-163650e7cd75@gmail.com>
Message-ID: <CAP01uRkCpLQ0uwJgFdTFTNG+80C+F1hn=TnQqRS2Z-nFuU5MmA@mail.gmail.com>

On Mon, Dec 7, 2020 at 5:41 AM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
> I agree it's all about call expressions, but they aren't all being
> treated equally:
>
> x |> f(...)
>
> expands to f(x, ...), while
>
> x |> `function`(...)
>
> expands to `function`(...)(x).  This is an exception to the rule for
> other calls, but I think it's a justified one.

This admitted inconsistency is justified by what?  No argument has been
presented.  The justification seems to be implicitly driven by implementation
concerns at the expense of usability and language consistency.


From ggrothend|eck @end|ng |rom gm@||@com  Mon Dec  7 15:09:41 2020
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Mon, 7 Dec 2020 09:09:41 -0500
Subject: [Rd] [External] Re: New pipe operator
In-Reply-To: <alpine.DEB.2.21.2012051203250.3003@luke-Latitude-7480>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <alpine.DEB.2.21.2012051203250.3003@luke-Latitude-7480>
Message-ID: <CAP01uRmd0tRM4xYnegK=YijJv6htqq+fuOwBMBns--0+2a7Opw@mail.gmail.com>

On Sat, Dec 5, 2020 at 1:19 PM <luke-tierney at uiowa.edu> wrote:
> Let's get some experience

Here is my last SO post using dplyr rewritten to use R 4.1 devel.  Seems
not too bad.  Was able to work around the placeholder for gsub by specifying
the arg names and used \(...)... elsewhere.  This does not address the
inconsistency discussed though.  I have indented by 2 spaced in case the
email wraps around.  The objective is to read myfile.csv including columns that
contain c(...) and integer(0), parsing and evaluating them.


  # taken from:
  # https://stackoverflow.com/questions/65174764/reading-in-a-csv-that-contains-vectors-cx-y-in-r/65175172#65175172

  # create input file for testing
  Lines <- "\"col1\",\"col2\",\"col3\"\n\"a\",1,integer(0)\n\"c\",c(3,4),5\n\"e\",6,7\n"
  cat(Lines, file = "myfile.csv")

  #########################################################################
  # base R 4.1 (devel)
  DF <- "myfile.csv" |>
    readLines() |>
    gsub(pattern = r'{(c\(.*?\)|integer\(0\))}', replacement = r'{"\1"}') |>
    \(.) read.csv(text = .) |>
    \(.) replace(., 2:3, lapply(.[2:3], \(col) lapply(col, \(x)
eval(parse(text = x)))))

  #########################################################################
  # dplyr/magrittr
  library(dplyr)

  DF <- "myfile.csv" %>%
    readLines %>%
    gsub(r'{(c\(.*?\)|integer\(0\))}', r'{"\1"}', .) %>%
    { read.csv(text = .) } %>%
    mutate(across(2:3, ~ lapply(., function(x) eval(parse(text = x)))))


From iuke-tier@ey m@iii@g oii uiow@@edu  Mon Dec  7 16:11:10 2020
From: iuke-tier@ey m@iii@g oii uiow@@edu (iuke-tier@ey m@iii@g oii uiow@@edu)
Date: Mon, 7 Dec 2020 09:11:10 -0600 (CST)
Subject: [Rd] [External] Re: New pipe operator
In-Reply-To: <CAP01uRmd0tRM4xYnegK=YijJv6htqq+fuOwBMBns--0+2a7Opw@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <alpine.DEB.2.21.2012051203250.3003@luke-Latitude-7480>
 <CAP01uRmd0tRM4xYnegK=YijJv6htqq+fuOwBMBns--0+2a7Opw@mail.gmail.com>
Message-ID: <alpine.DEB.2.21.2012070908010.3377@luke-Latitude-7480>

Or, keeping dplyr but with R-devel pipe and function shorthand:

DF <- "myfile.csv" %>%
    readLines() |>
    \(.) gsub(r'{(c\(.*?\)|integer\(0\))}', r'{"\1"}', .) |>
    \(.) read.csv(text = .) |>
    mutate(across(2:3, \(col) lapply(col, \(x) eval(parse(text = x)))))

Using named arguments to redirect to the implicit first does work,
also in magrittr, but for me at least it is the kind of thing I would
probably regret a month later when trying to figure out the code.

Best,

luke

On Mon, 7 Dec 2020, Gabor Grothendieck wrote:

> On Sat, Dec 5, 2020 at 1:19 PM <luke-tierney at uiowa.edu> wrote:
>> Let's get some experience
>
> Here is my last SO post using dplyr rewritten to use R 4.1 devel.  Seems
> not too bad.  Was able to work around the placeholder for gsub by specifying
> the arg names and used \(...)... elsewhere.  This does not address the
> inconsistency discussed though.  I have indented by 2 spaced in case the
> email wraps around.  The objective is to read myfile.csv including columns that
> contain c(...) and integer(0), parsing and evaluating them.
>
>
>  # taken from:
>  # https://stackoverflow.com/questions/65174764/reading-in-a-csv-that-contains-vectors-cx-y-in-r/65175172#65175172
>
>  # create input file for testing
>  Lines <- "\"col1\",\"col2\",\"col3\"\n\"a\",1,integer(0)\n\"c\",c(3,4),5\n\"e\",6,7\n"
>  cat(Lines, file = "myfile.csv")
>
>  #########################################################################
>  # base R 4.1 (devel)
>  DF <- "myfile.csv" |>
>    readLines() |>
>    gsub(pattern = r'{(c\(.*?\)|integer\(0\))}', replacement = r'{"\1"}') |>
>    \(.) read.csv(text = .) |>
>    \(.) replace(., 2:3, lapply(.[2:3], \(col) lapply(col, \(x)
> eval(parse(text = x)))))
>
>  #########################################################################
>  # dplyr/magrittr
>  library(dplyr)
>
>  DF <- "myfile.csv" %>%
>    readLines %>%
>    gsub(r'{(c\(.*?\)|integer\(0\))}', r'{"\1"}', .) %>%
>    { read.csv(text = .) } %>%
>    mutate(across(2:3, ~ lapply(., function(x) eval(parse(text = x)))))
>

-- 
Luke Tierney
Ralph E. Wareham Professor of Mathematical Sciences
University of Iowa                  Phone:             319-335-3386
Department of Statistics and        Fax:               319-335-3017
    Actuarial Science
241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu


From deep@y@n@@@rk@r @end|ng |rom gm@||@com  Mon Dec  7 16:20:09 2020
From: deep@y@n@@@rk@r @end|ng |rom gm@||@com (Deepayan Sarkar)
Date: Mon, 7 Dec 2020 20:50:09 +0530
Subject: [Rd] New pipe operator
In-Reply-To: <CAP01uRkCpLQ0uwJgFdTFTNG+80C+F1hn=TnQqRS2Z-nFuU5MmA@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
 <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
 <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>
 <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>
 <CAD4oTHHFWkiirncPRWngY+_k9HcB=8zo7VdXAONXQoXdNhKzDA@mail.gmail.com>
 <7e28d84a-f6d0-1e18-c131-163650e7cd75@gmail.com>
 <CAP01uRkCpLQ0uwJgFdTFTNG+80C+F1hn=TnQqRS2Z-nFuU5MmA@mail.gmail.com>
Message-ID: <CADfFDC74ostfecs5mhOznSXEedGBA=_78SiNTfysz5B8JU=YUQ@mail.gmail.com>

On Mon, Dec 7, 2020 at 6:53 PM Gabor Grothendieck
<ggrothendieck at gmail.com> wrote:
>
> On Mon, Dec 7, 2020 at 5:41 AM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
> > I agree it's all about call expressions, but they aren't all being
> > treated equally:
> >
> > x |> f(...)
> >
> > expands to f(x, ...), while
> >
> > x |> `function`(...)
> >
> > expands to `function`(...)(x).  This is an exception to the rule for
> > other calls, but I think it's a justified one.
>
> This admitted inconsistency is justified by what?  No argument has been
> presented.  The justification seems to be implicitly driven by implementation
> concerns at the expense of usability and language consistency.

Sorry if I have missed something, but is your consistency argument
basically that if

foo <- function(x) x + 1

then

x |> foo
x |> function(x) x + 1

should both work the same? Suppose it did. Would you then be OK if

x |> foo()

no longer worked as it does now, and produced foo()(x) instead of foo(x)?

If you are not OK with that and want to retain the current behaviour,
what would you want to happen with the following?

bar <- function(x) function(n) rnorm(n, mean = x)

10 |> bar(runif(1))() # works 'as expected' ~ bar(runif(1))(10)
10 |> bar(runif(1)) # currently bar(10, runif(1))

both of which you probably want. But then

baz <-  bar(runif(1))
10 |> baz

(not currently allowed) will not be the same as what you would want from

10 |> bar(runif(1))

which leads to a different kind of inconsistency, doesn't it?

-Deepayan


From ggrothend|eck @end|ng |rom gm@||@com  Mon Dec  7 16:53:22 2020
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Mon, 7 Dec 2020 10:53:22 -0500
Subject: [Rd] New pipe operator
In-Reply-To: <CADfFDC74ostfecs5mhOznSXEedGBA=_78SiNTfysz5B8JU=YUQ@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
 <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
 <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>
 <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>
 <CAD4oTHHFWkiirncPRWngY+_k9HcB=8zo7VdXAONXQoXdNhKzDA@mail.gmail.com>
 <7e28d84a-f6d0-1e18-c131-163650e7cd75@gmail.com>
 <CAP01uRkCpLQ0uwJgFdTFTNG+80C+F1hn=TnQqRS2Z-nFuU5MmA@mail.gmail.com>
 <CADfFDC74ostfecs5mhOznSXEedGBA=_78SiNTfysz5B8JU=YUQ@mail.gmail.com>
Message-ID: <CAP01uRneP4C-TjMQ7EOmP_D==yuqU2zWsp8SW1R5Yg8q3ZFeYg@mail.gmail.com>

One could examine how magrittr works as a reference implementation if
there is a question on how something should function.  It's in
widespread use and seems to work well.

On Mon, Dec 7, 2020 at 10:20 AM Deepayan Sarkar
<deepayan.sarkar at gmail.com> wrote:
>
> On Mon, Dec 7, 2020 at 6:53 PM Gabor Grothendieck
> <ggrothendieck at gmail.com> wrote:
> >
> > On Mon, Dec 7, 2020 at 5:41 AM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
> > > I agree it's all about call expressions, but they aren't all being
> > > treated equally:
> > >
> > > x |> f(...)
> > >
> > > expands to f(x, ...), while
> > >
> > > x |> `function`(...)
> > >
> > > expands to `function`(...)(x).  This is an exception to the rule for
> > > other calls, but I think it's a justified one.
> >
> > This admitted inconsistency is justified by what?  No argument has been
> > presented.  The justification seems to be implicitly driven by implementation
> > concerns at the expense of usability and language consistency.
>
> Sorry if I have missed something, but is your consistency argument
> basically that if
>
> foo <- function(x) x + 1
>
> then
>
> x |> foo
> x |> function(x) x + 1
>
> should both work the same? Suppose it did. Would you then be OK if
>
> x |> foo()
>
> no longer worked as it does now, and produced foo()(x) instead of foo(x)?
>
> If you are not OK with that and want to retain the current behaviour,
> what would you want to happen with the following?
>
> bar <- function(x) function(n) rnorm(n, mean = x)
>
> 10 |> bar(runif(1))() # works 'as expected' ~ bar(runif(1))(10)
> 10 |> bar(runif(1)) # currently bar(10, runif(1))
>
> both of which you probably want. But then
>
> baz <-  bar(runif(1))
> 10 |> baz
>
> (not currently allowed) will not be the same as what you would want from
>
> 10 |> bar(runif(1))
>
> which leads to a different kind of inconsistency, doesn't it?
>
> -Deepayan



-- 
Statistics & Software Consulting
GKX Group, GKX Associates Inc.
tel: 1-877-GKX-GROUP
email: ggrothendieck at gmail.com


From deep@y@n@@@rk@r @end|ng |rom gm@||@com  Mon Dec  7 16:59:46 2020
From: deep@y@n@@@rk@r @end|ng |rom gm@||@com (Deepayan Sarkar)
Date: Mon, 7 Dec 2020 21:29:46 +0530
Subject: [Rd] New pipe operator
In-Reply-To: <CAP01uRneP4C-TjMQ7EOmP_D==yuqU2zWsp8SW1R5Yg8q3ZFeYg@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
 <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
 <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>
 <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>
 <CAD4oTHHFWkiirncPRWngY+_k9HcB=8zo7VdXAONXQoXdNhKzDA@mail.gmail.com>
 <7e28d84a-f6d0-1e18-c131-163650e7cd75@gmail.com>
 <CAP01uRkCpLQ0uwJgFdTFTNG+80C+F1hn=TnQqRS2Z-nFuU5MmA@mail.gmail.com>
 <CADfFDC74ostfecs5mhOznSXEedGBA=_78SiNTfysz5B8JU=YUQ@mail.gmail.com>
 <CAP01uRneP4C-TjMQ7EOmP_D==yuqU2zWsp8SW1R5Yg8q3ZFeYg@mail.gmail.com>
Message-ID: <CADfFDC6dj2z_DH5KdReWYmbjsqn=tKaxC3WpheH=NWQr2VfrDA@mail.gmail.com>

On Mon, Dec 7, 2020 at 9:23 PM Gabor Grothendieck
<ggrothendieck at gmail.com> wrote:
>
> One could examine how magrittr works as a reference implementation if
> there is a question on how something should function.  It's in
> widespread use and seems to work well.

Yes, but it has many inconsistencies (including for the example I
gave). Do you want a magrittr clone, or do you want consistency? It's
OK to want either, but I don't think you can get both.

What we actually end up with is another matter, depending on many
other factors. I was just trying to understand your consistency
argument.

-Deepayan

> On Mon, Dec 7, 2020 at 10:20 AM Deepayan Sarkar
> <deepayan.sarkar at gmail.com> wrote:
> >
> > On Mon, Dec 7, 2020 at 6:53 PM Gabor Grothendieck
> > <ggrothendieck at gmail.com> wrote:
> > >
> > > On Mon, Dec 7, 2020 at 5:41 AM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
> > > > I agree it's all about call expressions, but they aren't all being
> > > > treated equally:
> > > >
> > > > x |> f(...)
> > > >
> > > > expands to f(x, ...), while
> > > >
> > > > x |> `function`(...)
> > > >
> > > > expands to `function`(...)(x).  This is an exception to the rule for
> > > > other calls, but I think it's a justified one.
> > >
> > > This admitted inconsistency is justified by what?  No argument has been
> > > presented.  The justification seems to be implicitly driven by implementation
> > > concerns at the expense of usability and language consistency.
> >
> > Sorry if I have missed something, but is your consistency argument
> > basically that if
> >
> > foo <- function(x) x + 1
> >
> > then
> >
> > x |> foo
> > x |> function(x) x + 1
> >
> > should both work the same? Suppose it did. Would you then be OK if
> >
> > x |> foo()
> >
> > no longer worked as it does now, and produced foo()(x) instead of foo(x)?
> >
> > If you are not OK with that and want to retain the current behaviour,
> > what would you want to happen with the following?
> >
> > bar <- function(x) function(n) rnorm(n, mean = x)
> >
> > 10 |> bar(runif(1))() # works 'as expected' ~ bar(runif(1))(10)
> > 10 |> bar(runif(1)) # currently bar(10, runif(1))
> >
> > both of which you probably want. But then
> >
> > baz <-  bar(runif(1))
> > 10 |> baz
> >
> > (not currently allowed) will not be the same as what you would want from
> >
> > 10 |> bar(runif(1))
> >
> > which leads to a different kind of inconsistency, doesn't it?
> >
> > -Deepayan
>
>
>
> --
> Statistics & Software Consulting
> GKX Group, GKX Associates Inc.
> tel: 1-877-GKX-GROUP
> email: ggrothendieck at gmail.com


From pd@|gd @end|ng |rom gm@||@com  Mon Dec  7 17:18:34 2020
From: pd@|gd @end|ng |rom gm@||@com (peter dalgaard)
Date: Mon, 7 Dec 2020 17:18:34 +0100
Subject: [Rd] New pipe operator
In-Reply-To: <CADfFDC74ostfecs5mhOznSXEedGBA=_78SiNTfysz5B8JU=YUQ@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
 <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
 <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>
 <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>
 <CAD4oTHHFWkiirncPRWngY+_k9HcB=8zo7VdXAONXQoXdNhKzDA@mail.gmail.com>
 <7e28d84a-f6d0-1e18-c131-163650e7cd75@gmail.com>
 <CAP01uRkCpLQ0uwJgFdTFTNG+80C+F1hn=TnQqRS2Z-nFuU5MmA@mail.gmail.com>
 <CADfFDC74ostfecs5mhOznSXEedGBA=_78SiNTfysz5B8JU=YUQ@mail.gmail.com>
Message-ID: <F7AF463A-B9A1-4AEB-9EE3-1062B6AD3CFF@gmail.com>

Hmm,

I feel a bit bad coming late to this, but I think I am beginning to side with those who want  "... |> head" to work. And yes, that has to happen at the expense of |> head().

As I think it was Gabor points out, the current structure goes down a nonstandard evaluation route, which may be difficult to explain and departs from usual operator evaluation paradigms by being an odd mix of syntax and semantics. R lets you do these sorts of thing, witness ggplot and tidyverse, but the transparency of the language tends to suffer. 

It would be neater if it was simply so that the class/type of the object on the right hand side decided what should happen. So we could have a rule that we could have an object, an expression, and possibly an unevaluated call on the RHS. Or maybe a formula, I.e., we could have

... |> head

but not  

... |> head() 

because head() does not evaluate to anything useful. Instead, we could have some of these

... |> quote(head())
... |> expression(head())
... |> ~ head()
... |> \(_) head(_)

possibly also using a placeholder mechanism for the three first ones. I kind of like the idea that the ~ could be equivalent to \(_).

(And yes, I am kicking myself a bit for not using ~ in the NSE arguments in subset() and transform())

-pd

> On 7 Dec 2020, at 16:20 , Deepayan Sarkar <deepayan.sarkar at gmail.com> wrote:
> 
> On Mon, Dec 7, 2020 at 6:53 PM Gabor Grothendieck
> <ggrothendieck at gmail.com> wrote:
>> 
>> On Mon, Dec 7, 2020 at 5:41 AM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>>> I agree it's all about call expressions, but they aren't all being
>>> treated equally:
>>> 
>>> x |> f(...)
>>> 
>>> expands to f(x, ...), while
>>> 
>>> x |> `function`(...)
>>> 
>>> expands to `function`(...)(x).  This is an exception to the rule for
>>> other calls, but I think it's a justified one.
>> 
>> This admitted inconsistency is justified by what?  No argument has been
>> presented.  The justification seems to be implicitly driven by implementation
>> concerns at the expense of usability and language consistency.
> 
> Sorry if I have missed something, but is your consistency argument
> basically that if
> 
> foo <- function(x) x + 1
> 
> then
> 
> x |> foo
> x |> function(x) x + 1
> 
> should both work the same? Suppose it did. Would you then be OK if
> 
> x |> foo()
> 
> no longer worked as it does now, and produced foo()(x) instead of foo(x)?
> 
> If you are not OK with that and want to retain the current behaviour,
> what would you want to happen with the following?
> 
> bar <- function(x) function(n) rnorm(n, mean = x)
> 
> 10 |> bar(runif(1))() # works 'as expected' ~ bar(runif(1))(10)
> 10 |> bar(runif(1)) # currently bar(10, runif(1))
> 
> both of which you probably want. But then
> 
> baz <-  bar(runif(1))
> 10 |> baz
> 
> (not currently allowed) will not be the same as what you would want from
> 
> 10 |> bar(runif(1))
> 
> which leads to a different kind of inconsistency, doesn't it?
> 
> -Deepayan
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel

-- 
Peter Dalgaard, Professor,
Center for Statistics, Copenhagen Business School
Solbjerg Plads 3, 2000 Frederiksberg, Denmark
Phone: (+45)38153501
Office: A 4.23
Email: pd.mes at cbs.dk  Priv: PDalgd at gmail.com


From ggrothend|eck @end|ng |rom gm@||@com  Mon Dec  7 17:20:52 2020
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Mon, 7 Dec 2020 11:20:52 -0500
Subject: [Rd] [External] Re: New pipe operator
In-Reply-To: <alpine.DEB.2.21.2012070908010.3377@luke-Latitude-7480>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <alpine.DEB.2.21.2012051203250.3003@luke-Latitude-7480>
 <CAP01uRmd0tRM4xYnegK=YijJv6htqq+fuOwBMBns--0+2a7Opw@mail.gmail.com>
 <alpine.DEB.2.21.2012070908010.3377@luke-Latitude-7480>
Message-ID: <CAP01uRmP=1vtHUeqS6yAX1BeP1am_2auZCEFbgzm6kb_nafDzA@mail.gmail.com>

On Mon, Dec 7, 2020 at 10:11 AM <luke-tierney at uiowa.edu> wrote:
> Or, keeping dplyr but with R-devel pipe and function shorthand:
>
> DF <- "myfile.csv" %>%
>     readLines() |>
>     \(.) gsub(r'{(c\(.*?\)|integer\(0\))}', r'{"\1"}', .) |>
>     \(.) read.csv(text = .) |>
>     mutate(across(2:3, \(col) lapply(col, \(x) eval(parse(text = x)))))
>
> Using named arguments to redirect to the implicit first does work,
> also in magrittr, but for me at least it is the kind of thing I would
> probably regret a month later when trying to figure out the code.

The gsub issue suggests that if one were to start afresh
that the arguments to gsub (and many other R functions)
should be rearranged.  Of course, that is precisely what
the tidyverse did.


From murdoch@dunc@n @end|ng |rom gm@||@com  Mon Dec  7 17:35:24 2020
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Mon, 7 Dec 2020 11:35:24 -0500
Subject: [Rd] New pipe operator
In-Reply-To: <F7AF463A-B9A1-4AEB-9EE3-1062B6AD3CFF@gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
 <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
 <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>
 <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>
 <CAD4oTHHFWkiirncPRWngY+_k9HcB=8zo7VdXAONXQoXdNhKzDA@mail.gmail.com>
 <7e28d84a-f6d0-1e18-c131-163650e7cd75@gmail.com>
 <CAP01uRkCpLQ0uwJgFdTFTNG+80C+F1hn=TnQqRS2Z-nFuU5MmA@mail.gmail.com>
 <CADfFDC74ostfecs5mhOznSXEedGBA=_78SiNTfysz5B8JU=YUQ@mail.gmail.com>
 <F7AF463A-B9A1-4AEB-9EE3-1062B6AD3CFF@gmail.com>
Message-ID: <7e1eb5e9-4ee7-4a80-ad7b-58ed67c830df@gmail.com>

On 07/12/2020 11:18 a.m., peter dalgaard wrote:
> Hmm,
> 
> I feel a bit bad coming late to this, but I think I am beginning to side with those who want  "... |> head" to work. And yes, that has to happen at the expense of |> head().

Just curious, how would you express head(df, 10)?  Currently it is

  df |> head(10)

Would I have to write it as

  df |> function(d) head(d, 10)


> As I think it was Gabor points out, the current structure goes down a nonstandard evaluation route, which may be difficult to explain and departs from usual operator evaluation paradigms by being an odd mix of syntax and semantics. R lets you do these sorts of thing, witness ggplot and tidyverse, but the transparency of the language tends to suffer.

I wouldn't call it non-standard evaluation.  There is no function 
corresponding to |>, so there's no evaluation at all.  It is more like 
the way "x -> y" is parsed as "y <- x", or "if (x) y" is transformed to 
`if`(x, y).

Duncan Murdoch

> It would be neater if it was simply so that the class/type of the object on the right hand side decided what should happen. So we could have a rule that we could have an object, an expression, and possibly an unevaluated call on the RHS. Or maybe a formula, I.e., we could hav
> 
> ... |> head
> 
> but not
> 
> ... |> head()
> 
> because head() does not evaluate to anything useful. Instead, we could have some of these
> 
> ... |> quote(head())
> ... |> expression(head())
> ... |> ~ head()
> ... |> \(_) head(_)
> 
> possibly also using a placeholder mechanism for the three first ones. I kind of like the idea that the ~ could be equivalent to \(_).
> 
> (And yes, I am kicking myself a bit for not using ~ in the NSE arguments in subset() and transform())
> 
> -pd
> 
>> On 7 Dec 2020, at 16:20 , Deepayan Sarkar <deepayan.sarkar at gmail.com> wrote:
>>
>> On Mon, Dec 7, 2020 at 6:53 PM Gabor Grothendieck
>> <ggrothendieck at gmail.com> wrote:
>>>
>>> On Mon, Dec 7, 2020 at 5:41 AM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>>>> I agree it's all about call expressions, but they aren't all being
>>>> treated equally:
>>>>
>>>> x |> f(...)
>>>>
>>>> expands to f(x, ...), while
>>>>
>>>> x |> `function`(...)
>>>>
>>>> expands to `function`(...)(x).  This is an exception to the rule for
>>>> other calls, but I think it's a justified one.
>>>
>>> This admitted inconsistency is justified by what?  No argument has been
>>> presented.  The justification seems to be implicitly driven by implementation
>>> concerns at the expense of usability and language consistency.
>>
>> Sorry if I have missed something, but is your consistency argument
>> basically that if
>>
>> foo <- function(x) x + 1
>>
>> then
>>
>> x |> foo
>> x |> function(x) x + 1
>>
>> should both work the same? Suppose it did. Would you then be OK if
>>
>> x |> foo()
>>
>> no longer worked as it does now, and produced foo()(x) instead of foo(x)?
>>
>> If you are not OK with that and want to retain the current behaviour,
>> what would you want to happen with the following?
>>
>> bar <- function(x) function(n) rnorm(n, mean = x)
>>
>> 10 |> bar(runif(1))() # works 'as expected' ~ bar(runif(1))(10)
>> 10 |> bar(runif(1)) # currently bar(10, runif(1))
>>
>> both of which you probably want. But then
>>
>> baz <-  bar(runif(1))
>> 10 |> baz
>>
>> (not currently allowed) will not be the same as what you would want from
>>
>> 10 |> bar(runif(1))
>>
>> which leads to a different kind of inconsistency, doesn't it?
>>
>> -Deepayan
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>


From therne@u @end|ng |rom m@yo@edu  Mon Dec  7 17:54:15 2020
From: therne@u @end|ng |rom m@yo@edu (Therneau, Terry M., Ph.D.)
Date: Mon, 07 Dec 2020 10:54:15 -0600
Subject: [Rd] anonymous functions
Message-ID: <28fddd$f2ifur@ironport10.mayo.edu>

?The shorthand form \(x) x + 1 is parsed as function(x) x + 1. It may be helpful in making 
code containing simple function expressions more readable.?

Color me unimpressed.
Over the decades I've seen several "who can write the shortest code" threads: in Fortran, 
in C, in Splus, ...   The same old idea that "short" is a synonym for either elegant, 
readable, or efficient is now being recylced in the tidyverse.   The truth is that "short" 
is actually an antonym for all of these things, at least for anyone else reading the code; 
or for the original coder 30-60 minutes after the "clever" lines were written.  Minimal 
use of the spacebar and/or the return key isn't usually held up as a goal, but creeps into 
many practiioner's code as well.

People are excited by replacing "function(" with "\("?  Really?   Are people typing code 
with their thumbs?
I am ambivalent about pipes: I think it is a great concept, but too many of my colleagues 
think that using pipes = no need for any comments.

As time goes on, I find my goal is to make my code less compact and more readable.  Every 
bug fix or new feature in the survival package now adds more lines of comments or other 
documentation than lines of code.  If I have to puzzle out what a line does, what about 
the poor sod who inherits the maintainance?


-- 
Terry M Therneau, PhD
Department of Health Science Research
Mayo Clinic
therneau at mayo.edu

"TERR-ree THUR-noh"


From greg @end|ng |rom w@rne@@net  Mon Dec  7 18:03:16 2020
From: greg @end|ng |rom w@rne@@net (Gregory Warnes)
Date: Mon, 7 Dec 2020 12:03:16 -0500
Subject: [Rd] [External] Re: New pipe operator
In-Reply-To: <CAP01uRmP=1vtHUeqS6yAX1BeP1am_2auZCEFbgzm6kb_nafDzA@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <alpine.DEB.2.21.2012051203250.3003@luke-Latitude-7480>
 <CAP01uRmd0tRM4xYnegK=YijJv6htqq+fuOwBMBns--0+2a7Opw@mail.gmail.com>
 <alpine.DEB.2.21.2012070908010.3377@luke-Latitude-7480>
 <CAP01uRmP=1vtHUeqS6yAX1BeP1am_2auZCEFbgzm6kb_nafDzA@mail.gmail.com>
Message-ID: <CAKorm_uh1pbJ8pOr0m7MYvE6kDCYETBXAQ1ogzc-g1nvy8d52A@mail.gmail.com>

My vote is for the consistency of function calls always having parentheses,
including in pipes.  Making them optional only saves two keystrokes, but
will add yet another inconsistency to confuse or trip folks up.

As for the new anonymous function syntax, I would prefer something more
human friendly, perhaps provide ?fun? as a shortcut for ?function?,
enabling:

DF <- "myfile.csv" %>%
    readLines() |>
    fun(x) gsub(r'{(c\(.*?\)|integer\(0\))}', r'{"\1"}', x) |>
    fun(x) read.csv(text = x)|>
   mutate(
        across(2:3,
              fun(col) lapply(col,
                   fun(x) eval(parse(text = x))
              )
        )
   )

which seems much easier to read and understand, at the cost of only a few
extra characters.

-G

On Mon, Dec 7, 2020 at 11:21 AM Gabor Grothendieck <ggrothendieck at gmail.com>
wrote:

> On Mon, Dec 7, 2020 at 10:11 AM <luke-tierney at uiowa.edu> wrote:
> > Or, keeping dplyr but with R-devel pipe and function shorthand:
> >
> > DF <- "myfile.csv" %>%
> >     readLines() |>
> >     \(.) gsub(r'{(c\(.*?\)|integer\(0\))}', r'{"\1"}', .) |>
> >     \(.) read.csv(text = .) |>
> >     mutate(across(2:3, \(col) lapply(col, \(x) eval(parse(text = x)))))
> >
> > Using named arguments to redirect to the implicit first does work,
> > also in magrittr, but for me at least it is the kind of thing I would
> > probably regret a month later when trying to figure out the code.
>
> The gsub issue suggests that if one were to start afresh
> that the arguments to gsub (and many other R functions)
> should be rearranged.  Of course, that is precisely what
> the tidyverse did.
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>
-- 
"Whereas true religion and good morals are the only solid foundations of
public liberty and happiness . . . it is hereby earnestly recommended to
the several States to take the most effectual measures for the
encouragement thereof." Continental Congress, 1778

	[[alternative HTML version deleted]]


From pd@|gd @end|ng |rom gm@||@com  Mon Dec  7 18:09:36 2020
From: pd@|gd @end|ng |rom gm@||@com (Peter Dalgaard)
Date: Mon, 7 Dec 2020 18:09:36 +0100
Subject: [Rd] New pipe operator
In-Reply-To: <7e1eb5e9-4ee7-4a80-ad7b-58ed67c830df@gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
 <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
 <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>
 <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>
 <CAD4oTHHFWkiirncPRWngY+_k9HcB=8zo7VdXAONXQoXdNhKzDA@mail.gmail.com>
 <7e28d84a-f6d0-1e18-c131-163650e7cd75@gmail.com>
 <CAP01uRkCpLQ0uwJgFdTFTNG+80C+F1hn=TnQqRS2Z-nFuU5MmA@mail.gmail.com>
 <CADfFDC74ostfecs5mhOznSXEedGBA=_78SiNTfysz5B8JU=YUQ@mail.gmail.com>
 <F7AF463A-B9A1-4AEB-9EE3-1062B6AD3CFF@gmail.com>
 <7e1eb5e9-4ee7-4a80-ad7b-58ed67c830df@gmail.com>
Message-ID: <91C38945-B1BA-4E7A-B2E0-79790A894240@gmail.com>



> On 7 Dec 2020, at 17:35 , Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
> 
> On 07/12/2020 11:18 a.m., peter dalgaard wrote:
>> Hmm,
>> I feel a bit bad coming late to this, but I think I am beginning to side with those who want  "... |> head" to work. And yes, that has to happen at the expense of |> head().
> 
> Just curious, how would you express head(df, 10)?  Currently it is
> 
> df |> head(10)
> 
> Would I have to write it as
> 
> df |> function(d) head(d, 10)

It could be 

df |> ~ head(_, 10)

which in a sense is "yes" to your question.

> 
>> As I think it was Gabor points out, the current structure goes down a nonstandard evaluation route, which may be difficult to explain and departs from usual operator evaluation paradigms by being an odd mix of syntax and semantics. R lets you do these sorts of thing, witness ggplot and tidyverse, but the transparency of the language tends to suffer.
> 
> I wouldn't call it non-standard evaluation.  There is no function corresponding to |>, so there's no evaluation at all.  It is more like the way "x -> y" is parsed as "y <- x", or "if (x) y" is transformed to `if`(x, y).

That's a point, but maybe also my point. Currently, the parser is inserting the LHS as the 1st argument of the RHS, right? Things might be simpler if it was more like a simple binop.

-pd

> Duncan Murdoch
> 
>> It would be neater if it was simply so that the class/type of the object on the right hand side decided what should happen. So we could have a rule that we could have an object, an expression, and possibly an unevaluated call on the RHS. Or maybe a formula, I.e., we could hav
>> ... |> head
>> but not
>> ... |> head()
>> because head() does not evaluate to anything useful. Instead, we could have some of these
>> ... |> quote(head())
>> ... |> expression(head())
>> ... |> ~ head()
>> ... |> \(_) head(_)
>> possibly also using a placeholder mechanism for the three first ones. I kind of like the idea that the ~ could be equivalent to \(_).
>> (And yes, I am kicking myself a bit for not using ~ in the NSE arguments in subset() and transform())
>> -pd
>>> On 7 Dec 2020, at 16:20 , Deepayan Sarkar <deepayan.sarkar at gmail.com> wrote:
>>> 
>>> On Mon, Dec 7, 2020 at 6:53 PM Gabor Grothendieck
>>> <ggrothendieck at gmail.com> wrote:
>>>> 
>>>> On Mon, Dec 7, 2020 at 5:41 AM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>>>>> I agree it's all about call expressions, but they aren't all being
>>>>> treated equally:
>>>>> 
>>>>> x |> f(...)
>>>>> 
>>>>> expands to f(x, ...), while
>>>>> 
>>>>> x |> `function`(...)
>>>>> 
>>>>> expands to `function`(...)(x).  This is an exception to the rule for
>>>>> other calls, but I think it's a justified one.
>>>> 
>>>> This admitted inconsistency is justified by what?  No argument has been
>>>> presented.  The justification seems to be implicitly driven by implementation
>>>> concerns at the expense of usability and language consistency.
>>> 
>>> Sorry if I have missed something, but is your consistency argument
>>> basically that if
>>> 
>>> foo <- function(x) x + 1
>>> 
>>> then
>>> 
>>> x |> foo
>>> x |> function(x) x + 1
>>> 
>>> should both work the same? Suppose it did. Would you then be OK if
>>> 
>>> x |> foo()
>>> 
>>> no longer worked as it does now, and produced foo()(x) instead of foo(x)?
>>> 
>>> If you are not OK with that and want to retain the current behaviour,
>>> what would you want to happen with the following?
>>> 
>>> bar <- function(x) function(n) rnorm(n, mean = x)
>>> 
>>> 10 |> bar(runif(1))() # works 'as expected' ~ bar(runif(1))(10)
>>> 10 |> bar(runif(1)) # currently bar(10, runif(1))
>>> 
>>> both of which you probably want. But then
>>> 
>>> baz <-  bar(runif(1))
>>> 10 |> baz
>>> 
>>> (not currently allowed) will not be the same as what you would want from
>>> 
>>> 10 |> bar(runif(1))
>>> 
>>> which leads to a different kind of inconsistency, doesn't it?
>>> 
>>> -Deepayan
>>> 
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
> 

-- 
Peter Dalgaard, Professor,
Center for Statistics, Copenhagen Business School
Solbjerg Plads 3, 2000 Frederiksberg, Denmark
Phone: (+45)38153501
Office: A 4.23
Email: pd.mes at cbs.dk  Priv: PDalgd at gmail.com


From greg @end|ng |rom w@rne@@net  Mon Dec  7 18:11:18 2020
From: greg @end|ng |rom w@rne@@net (Gregory Warnes)
Date: Mon, 7 Dec 2020 12:11:18 -0500
Subject: [Rd] anonymous functions
In-Reply-To: <28fddd$f2ifur@ironport10.mayo.edu>
References: <28fddd$f2ifur@ironport10.mayo.edu>
Message-ID: <CAKorm_v26Hb7SmMvfk5+872h5_W9MQe7xOa_V5af0MKbjDT-og@mail.gmail.com>

Thanks for expressing this eloquently. I heartily agree.

On Mon, Dec 7, 2020 at 12:04 PM Therneau, Terry M., Ph.D. via R-devel <
r-devel at r-project.org> wrote:

> ?The shorthand form \(x) x + 1 is parsed as function(x) x + 1. It may be
> helpful in making
> code containing simple function expressions more readable.?
>
> Color me unimpressed.
> Over the decades I've seen several "who can write the shortest code"
> threads: in Fortran,
> in C, in Splus, ...   The same old idea that "short" is a synonym for
> either elegant,
> readable, or efficient is now being recylced in the tidyverse.   The truth
> is that "short"
> is actually an antonym for all of these things, at least for anyone else
> reading the code;
> or for the original coder 30-60 minutes after the "clever" lines were
> written.  Minimal
> use of the spacebar and/or the return key isn't usually held up as a goal,
> but creeps into
> many practiioner's code as well.
>
> People are excited by replacing "function(" with "\("?  Really?   Are
> people typing code
> with their thumbs?
> I am ambivalent about pipes: I think it is a great concept, but too many
> of my colleagues
> think that using pipes = no need for any comments.
>
> As time goes on, I find my goal is to make my code less compact and more
> readable.  Every
> bug fix or new feature in the survival package now adds more lines of
> comments or other
> documentation than lines of code.  If I have to puzzle out what a line
> does, what about
> the poor sod who inherits the maintainance?
>
>
> --
> Terry M Therneau, PhD
> Department of Health Science Research
> Mayo Clinic
> therneau at mayo.edu
>
> "TERR-ree THUR-noh"
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>
-- 
"Whereas true religion and good morals are the only solid foundations of
public liberty and happiness . . . it is hereby earnestly recommended to
the several States to take the most effectual measures for the
encouragement thereof." Continental Congress, 1778

	[[alternative HTML version deleted]]


From iuke-tier@ey m@iii@g oii uiow@@edu  Mon Dec  7 18:26:50 2020
From: iuke-tier@ey m@iii@g oii uiow@@edu (iuke-tier@ey m@iii@g oii uiow@@edu)
Date: Mon, 7 Dec 2020 11:26:50 -0600 (CST)
Subject: [Rd] [External]  anonymous functions
In-Reply-To: <28fddd$f2ifur@ironport10.mayo.edu>
References: <28fddd$f2ifur@ironport10.mayo.edu>
Message-ID: <alpine.DEB.2.21.2012071119120.3377@luke-Latitude-7480>

I don't disagree in principle, but the reality is users want shortcuts
and as a result various packages, in particular tidyverse, have been
providing them. Mostly based on formulas, mostly with significant
issues since formulas weren't designed for this, and mostly
incompatible (tidyverse ones are compatible within tidyverse but not
with others). And of course none work in sapply or lapply. Providing a
shorthand in base may help to improve this. You don't have to use it
if you don't want to, and you can establish coding standards that
disallow it if you like.

Best,

luke

On Mon, 7 Dec 2020, Therneau, Terry M., Ph.D. via R-devel wrote:

> ?The shorthand form \(x) x + 1 is parsed as function(x) x + 1. It may be 
> helpful in making code containing simple function expressions more readable.?
>
> Color me unimpressed.
> Over the decades I've seen several "who can write the shortest code" threads: 
> in Fortran, in C, in Splus, ...   The same old idea that "short" is a synonym 
> for either elegant, readable, or efficient is now being recylced in the 
> tidyverse.   The truth is that "short" is actually an antonym for all of 
> these things, at least for anyone else reading the code; or for the original 
> coder 30-60 minutes after the "clever" lines were written.  Minimal use of 
> the spacebar and/or the return key isn't usually held up as a goal, but 
> creeps into many practiioner's code as well.
>
> People are excited by replacing "function(" with "\("?  Really?   Are people 
> typing code with their thumbs?
> I am ambivalent about pipes: I think it is a great concept, but too many of 
> my colleagues think that using pipes = no need for any comments.
>
> As time goes on, I find my goal is to make my code less compact and more 
> readable.  Every bug fix or new feature in the survival package now adds more 
> lines of comments or other documentation than lines of code.  If I have to 
> puzzle out what a line does, what about the poor sod who inherits the 
> maintainance?
>
>
>

-- 
Luke Tierney
Ralph E. Wareham Professor of Mathematical Sciences
University of Iowa                  Phone:             319-335-3386
Department of Statistics and        Fax:               319-335-3017
    Actuarial Science
241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu

From murdoch@dunc@n @end|ng |rom gm@||@com  Mon Dec  7 18:29:24 2020
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Mon, 7 Dec 2020 12:29:24 -0500
Subject: [Rd] [External] Re: New pipe operator
In-Reply-To: <CAKorm_uh1pbJ8pOr0m7MYvE6kDCYETBXAQ1ogzc-g1nvy8d52A@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <alpine.DEB.2.21.2012051203250.3003@luke-Latitude-7480>
 <CAP01uRmd0tRM4xYnegK=YijJv6htqq+fuOwBMBns--0+2a7Opw@mail.gmail.com>
 <alpine.DEB.2.21.2012070908010.3377@luke-Latitude-7480>
 <CAP01uRmP=1vtHUeqS6yAX1BeP1am_2auZCEFbgzm6kb_nafDzA@mail.gmail.com>
 <CAKorm_uh1pbJ8pOr0m7MYvE6kDCYETBXAQ1ogzc-g1nvy8d52A@mail.gmail.com>
Message-ID: <af5fbe49-5261-2360-0073-d1fcd058936e@gmail.com>

On 07/12/2020 12:03 p.m., Gregory Warnes wrote:
> My vote is for the consistency of function calls always having parentheses,
> including in pipes.  Making them optional only saves two keystrokes, but
> will add yet another inconsistency to confuse or trip folks up.
>
> As for the new anonymous function syntax, I would prefer something more
> human friendly, perhaps provide ?fun? as a shortcut for ?function?,
> enabling:
> 
> DF <- "myfile.csv" %>%
>      readLines() |>
>      fun(x) gsub(r'{(c\(.*?\)|integer\(0\))}', r'{"\1"}', x) |>
>      fun(x) read.csv(text = x)|>
>     mutate(
>          across(2:3,
>                fun(col) lapply(col,
>                     fun(x) eval(parse(text = x))
>                )
>          )
>     )
> 
> which seems much easier to read and understand, at the cost of only a few
> extra characters.

But you didn't "always" include parentheses, you skipped them on the 
calls to the anonymous functions.  I think that's the one place I'd make 
the exception, so maybe we agree:  parens are almost always needed, with 
the sole exception being anonymous functions.

As to using "fun", I think that's a bad idea.  I haven't checked, but I 
wouldn't be too surprised if "fun" has been used thousands of times in 
CRAN packages as the name of a function.  So

  x |> fun(y)

would mean "fun(x, y)", whereas

  x |> fun(y) y+1

would mean (function(y) y+1)(x).

Duncan Murdoch


From murdoch@dunc@n @end|ng |rom gm@||@com  Mon Dec  7 18:53:41 2020
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Mon, 7 Dec 2020 12:53:41 -0500
Subject: [Rd] New pipe operator
In-Reply-To: <91C38945-B1BA-4E7A-B2E0-79790A894240@gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
 <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
 <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>
 <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>
 <CAD4oTHHFWkiirncPRWngY+_k9HcB=8zo7VdXAONXQoXdNhKzDA@mail.gmail.com>
 <7e28d84a-f6d0-1e18-c131-163650e7cd75@gmail.com>
 <CAP01uRkCpLQ0uwJgFdTFTNG+80C+F1hn=TnQqRS2Z-nFuU5MmA@mail.gmail.com>
 <CADfFDC74ostfecs5mhOznSXEedGBA=_78SiNTfysz5B8JU=YUQ@mail.gmail.com>
 <F7AF463A-B9A1-4AEB-9EE3-1062B6AD3CFF@gmail.com>
 <7e1eb5e9-4ee7-4a80-ad7b-58ed67c830df@gmail.com>
 <91C38945-B1BA-4E7A-B2E0-79790A894240@gmail.com>
Message-ID: <7f8cf17d-d5fa-0cd1-7760-7157ef1fe7bf@gmail.com>

On 07/12/2020 12:09 p.m., Peter Dalgaard wrote:
> 
> 
>> On 7 Dec 2020, at 17:35 , Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>>
>> On 07/12/2020 11:18 a.m., peter dalgaard wrote:
>>> Hmm,
>>> I feel a bit bad coming late to this, but I think I am beginning to side with those who want  "... |> head" to work. And yes, that has to happen at the expense of |> head().
>>
>> Just curious, how would you express head(df, 10)?  Currently it is
>>
>> df |> head(10)
>>
>> Would I have to write it as
>>
>> df |> function(d) head(d, 10)
> 
> It could be
> 
> df |> ~ head(_, 10)
> 
> which in a sense is "yes" to your question.

I think that's doing too much weird stuff.  I wouldn't want to have to 
teach it to beginners, whereas I think I could teach "df |> head(10)". 
That's doing one weird thing, but I'd count about three things I'd 
consider weird in yours.


> 
>>
>>> As I think it was Gabor points out, the current structure goes down a nonstandard evaluation route, which may be difficult to explain and departs from usual operator evaluation paradigms by being an odd mix of syntax and semantics. R lets you do these sorts of thing, witness ggplot and tidyverse, but the transparency of the language tends to suffer.
>>
>> I wouldn't call it non-standard evaluation.  There is no function corresponding to |>, so there's no evaluation at all.  It is more like the way "x -> y" is parsed as "y <- x", or "if (x) y" is transformed to `if`(x, y).
> 
> That's a point, but maybe also my point. Currently, the parser is inserting the LHS as the 1st argument of the RHS, right? Things might be simpler if it was more like a simple binop.

An advantage of the current implementation is that it's simple and easy 
to understand.  Once you make it a user-modifiable binary operator, 
things will go kind of nuts.

For example, I doubt if there are many users of magrittr's pipe who 
really understand its subtleties, e.g. the example in Luke's paper where 
1 %>% c(., 2) gives c(1,2), but 1 %>% c(c(.), 2) gives c(1, 1, 2). (And 
I could add 1 %>% c(c(.), 2, .) and  1 %>% c(c(.), 2, . + 2)  to 
continue the fun.)

Duncan Murdoch


> 
> -pd
> 
>> Duncan Murdoch
>>
>>> It would be neater if it was simply so that the class/type of the object on the right hand side decided what should happen. So we could have a rule that we could have an object, an expression, and possibly an unevaluated call on the RHS. Or maybe a formula, I.e., we could hav
>>> ... |> head
>>> but not
>>> ... |> head()
>>> because head() does not evaluate to anything useful. Instead, we could have some of these
>>> ... |> quote(head())
>>> ... |> expression(head())
>>> ... |> ~ head()
>>> ... |> \(_) head(_)
>>> possibly also using a placeholder mechanism for the three first ones. I kind of like the idea that the ~ could be equivalent to \(_).
>>> (And yes, I am kicking myself a bit for not using ~ in the NSE arguments in subset() and transform())
>>> -pd
>>>> On 7 Dec 2020, at 16:20 , Deepayan Sarkar <deepayan.sarkar at gmail.com> wrote:
>>>>
>>>> On Mon, Dec 7, 2020 at 6:53 PM Gabor Grothendieck
>>>> <ggrothendieck at gmail.com> wrote:
>>>>>
>>>>> On Mon, Dec 7, 2020 at 5:41 AM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>>>>>> I agree it's all about call expressions, but they aren't all being
>>>>>> treated equally:
>>>>>>
>>>>>> x |> f(...)
>>>>>>
>>>>>> expands to f(x, ...), while
>>>>>>
>>>>>> x |> `function`(...)
>>>>>>
>>>>>> expands to `function`(...)(x).  This is an exception to the rule for
>>>>>> other calls, but I think it's a justified one.
>>>>>
>>>>> This admitted inconsistency is justified by what?  No argument has been
>>>>> presented.  The justification seems to be implicitly driven by implementation
>>>>> concerns at the expense of usability and language consistency.
>>>>
>>>> Sorry if I have missed something, but is your consistency argument
>>>> basically that if
>>>>
>>>> foo <- function(x) x + 1
>>>>
>>>> then
>>>>
>>>> x |> foo
>>>> x |> function(x) x + 1
>>>>
>>>> should both work the same? Suppose it did. Would you then be OK if
>>>>
>>>> x |> foo()
>>>>
>>>> no longer worked as it does now, and produced foo()(x) instead of foo(x)?
>>>>
>>>> If you are not OK with that and want to retain the current behaviour,
>>>> what would you want to happen with the following?
>>>>
>>>> bar <- function(x) function(n) rnorm(n, mean = x)
>>>>
>>>> 10 |> bar(runif(1))() # works 'as expected' ~ bar(runif(1))(10)
>>>> 10 |> bar(runif(1)) # currently bar(10, runif(1))
>>>>
>>>> both of which you probably want. But then
>>>>
>>>> baz <-  bar(runif(1))
>>>> 10 |> baz
>>>>
>>>> (not currently allowed) will not be the same as what you would want from
>>>>
>>>> 10 |> bar(runif(1))
>>>>
>>>> which leads to a different kind of inconsistency, doesn't it?
>>>>
>>>> -Deepayan
>>>>
>>>> ______________________________________________
>>>> R-devel at r-project.org mailing list
>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>


From iuke-tier@ey m@iii@g oii uiow@@edu  Mon Dec  7 19:01:06 2020
From: iuke-tier@ey m@iii@g oii uiow@@edu (iuke-tier@ey m@iii@g oii uiow@@edu)
Date: Mon, 7 Dec 2020 12:01:06 -0600 (CST)
Subject: [Rd] [External] Re:  New pipe operator
In-Reply-To: <91C38945-B1BA-4E7A-B2E0-79790A894240@gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
 <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
 <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>
 <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>
 <CAD4oTHHFWkiirncPRWngY+_k9HcB=8zo7VdXAONXQoXdNhKzDA@mail.gmail.com>
 <7e28d84a-f6d0-1e18-c131-163650e7cd75@gmail.com>
 <CAP01uRkCpLQ0uwJgFdTFTNG+80C+F1hn=TnQqRS2Z-nFuU5MmA@mail.gmail.com>
 <CADfFDC74ostfecs5mhOznSXEedGBA=_78SiNTfysz5B8JU=YUQ@mail.gmail.com>
 <F7AF463A-B9A1-4AEB-9EE3-1062B6AD3CFF@gmail.com>
 <7e1eb5e9-4ee7-4a80-ad7b-58ed67c830df@gmail.com>
 <91C38945-B1BA-4E7A-B2E0-79790A894240@gmail.com>
Message-ID: <alpine.DEB.2.21.2012071128340.3377@luke-Latitude-7480>

On Mon, 7 Dec 2020, Peter Dalgaard wrote:

>
>
>> On 7 Dec 2020, at 17:35 , Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>>
>> On 07/12/2020 11:18 a.m., peter dalgaard wrote:
>>> Hmm,
>>> I feel a bit bad coming late to this, but I think I am beginning to side with those who want  "... |> head" to work. And yes, that has to happen at the expense of |> head().
>>
>> Just curious, how would you express head(df, 10)?  Currently it is
>>
>> df |> head(10)
>>
>> Would I have to write it as
>>
>> df |> function(d) head(d, 10)
>
> It could be
>
> df |> ~ head(_, 10)
>
> which in a sense is "yes" to your question.
>
>>
>>> As I think it was Gabor points out, the current structure goes down a nonstandard evaluation route, which may be difficult to explain and departs from usual operator evaluation paradigms by being an odd mix of syntax and semantics. R lets you do these sorts of thing, witness ggplot and tidyverse, but the transparency of the language tends to suffer.
>>
>> I wouldn't call it non-standard evaluation.  There is no function corresponding to |>, so there's no evaluation at all.  It is more like the way "x -> y" is parsed as "y <- x", or "if (x) y" is transformed to `if`(x, y).
>
> That's a point, but maybe also my point. Currently, the parser is inserting the LHS as the 1st argument of the RHS, right? Things might be simpler if it was more like a simple binop.

It can only be a simple binop if you only allow RHS functions of one argument.
Which would require currying along the lines Duncan showed. Something like:

`%>>%` <- function(x, f) f(x)
C1 <- function(f, ...) function(x) f(x, ...)

mtcars %>>% head
mtcars %>>% C1(head, 2)
mtcars %>>% C1(subset, cyl == 4) %>>% \(d) lm(mpg ~ disp, data = d)

This might fly if we lived in a world where most RHS functions take
one argument and only a few needed currying. That is the case in many
functional languages, but not for R. Making the common case of
multiple arguments easy means you have to work at the source level,
either in the parser or with some form of NSE.

Best,

luke

>
> -pd
>
>> Duncan Murdoch
>>
>>> It would be neater if it was simply so that the class/type of the object on the right hand side decided what should happen. So we could have a rule that we could have an object, an expression, and possibly an unevaluated call on the RHS. Or maybe a formula, I.e., we could hav
>>> ... |> head
>>> but not
>>> ... |> head()
>>> because head() does not evaluate to anything useful. Instead, we could have some of these
>>> ... |> quote(head())
>>> ... |> expression(head())
>>> ... |> ~ head()
>>> ... |> \(_) head(_)
>>> possibly also using a placeholder mechanism for the three first ones. I kind of like the idea that the ~ could be equivalent to \(_).
>>> (And yes, I am kicking myself a bit for not using ~ in the NSE arguments in subset() and transform())
>>> -pd
>>>> On 7 Dec 2020, at 16:20 , Deepayan Sarkar <deepayan.sarkar at gmail.com> wrote:
>>>>
>>>> On Mon, Dec 7, 2020 at 6:53 PM Gabor Grothendieck
>>>> <ggrothendieck at gmail.com> wrote:
>>>>>
>>>>> On Mon, Dec 7, 2020 at 5:41 AM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>>>>>> I agree it's all about call expressions, but they aren't all being
>>>>>> treated equally:
>>>>>>
>>>>>> x |> f(...)
>>>>>>
>>>>>> expands to f(x, ...), while
>>>>>>
>>>>>> x |> `function`(...)
>>>>>>
>>>>>> expands to `function`(...)(x).  This is an exception to the rule for
>>>>>> other calls, but I think it's a justified one.
>>>>>
>>>>> This admitted inconsistency is justified by what?  No argument has been
>>>>> presented.  The justification seems to be implicitly driven by implementation
>>>>> concerns at the expense of usability and language consistency.
>>>>
>>>> Sorry if I have missed something, but is your consistency argument
>>>> basically that if
>>>>
>>>> foo <- function(x) x + 1
>>>>
>>>> then
>>>>
>>>> x |> foo
>>>> x |> function(x) x + 1
>>>>
>>>> should both work the same? Suppose it did. Would you then be OK if
>>>>
>>>> x |> foo()
>>>>
>>>> no longer worked as it does now, and produced foo()(x) instead of foo(x)?
>>>>
>>>> If you are not OK with that and want to retain the current behaviour,
>>>> what would you want to happen with the following?
>>>>
>>>> bar <- function(x) function(n) rnorm(n, mean = x)
>>>>
>>>> 10 |> bar(runif(1))() # works 'as expected' ~ bar(runif(1))(10)
>>>> 10 |> bar(runif(1)) # currently bar(10, runif(1))
>>>>
>>>> both of which you probably want. But then
>>>>
>>>> baz <-  bar(runif(1))
>>>> 10 |> baz
>>>>
>>>> (not currently allowed) will not be the same as what you would want from
>>>>
>>>> 10 |> bar(runif(1))
>>>>
>>>> which leads to a different kind of inconsistency, doesn't it?
>>>>
>>>> -Deepayan
>>>>
>>>> ______________________________________________
>>>> R-devel at r-project.org mailing list
>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>
>

-- 
Luke Tierney
Ralph E. Wareham Professor of Mathematical Sciences
University of Iowa                  Phone:             319-335-3386
Department of Statistics and        Fax:               319-335-3017
    Actuarial Science
241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu


From ggrothend|eck @end|ng |rom gm@||@com  Mon Dec  7 19:11:17 2020
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Mon, 7 Dec 2020 13:11:17 -0500
Subject: [Rd] anonymous functions
In-Reply-To: <28fddd$f2ifur@ironport10.mayo.edu>
References: <28fddd$f2ifur@ironport10.mayo.edu>
Message-ID: <CAP01uRm+=NJKQL9u01oCiYiuoTrNwAw+uzDrk8myfaGLoEueVg@mail.gmail.com>

It is easier to understand a function if you can see the entire
function body at once on a page or screen and excessive verbosity
interferes with that.

On Mon, Dec 7, 2020 at 12:04 PM Therneau, Terry M., Ph.D. via R-devel
<r-devel at r-project.org> wrote:
>
> ?The shorthand form \(x) x + 1 is parsed as function(x) x + 1. It may be helpful in making
> code containing simple function expressions more readable.?
>
> Color me unimpressed.
> Over the decades I've seen several "who can write the shortest code" threads: in Fortran,
> in C, in Splus, ...   The same old idea that "short" is a synonym for either elegant,
> readable, or efficient is now being recylced in the tidyverse.   The truth is that "short"
> is actually an antonym for all of these things, at least for anyone else reading the code;
> or for the original coder 30-60 minutes after the "clever" lines were written.  Minimal
> use of the spacebar and/or the return key isn't usually held up as a goal, but creeps into
> many practiioner's code as well.
>
> People are excited by replacing "function(" with "\("?  Really?   Are people typing code
> with their thumbs?
> I am ambivalent about pipes: I think it is a great concept, but too many of my colleagues
> think that using pipes = no need for any comments.
>
> As time goes on, I find my goal is to make my code less compact and more readable.  Every
> bug fix or new feature in the survival package now adds more lines of comments or other
> documentation than lines of code.  If I have to puzzle out what a line does, what about
> the poor sod who inherits the maintainance?
>
>
> --
> Terry M Therneau, PhD
> Department of Health Science Research
> Mayo Clinic
> therneau at mayo.edu
>
> "TERR-ree THUR-noh"
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel



-- 
Statistics & Software Consulting
GKX Group, GKX Associates Inc.
tel: 1-877-GKX-GROUP
email: ggrothendieck at gmail.com


From therne@u @end|ng |rom m@yo@edu  Mon Dec  7 19:29:06 2020
From: therne@u @end|ng |rom m@yo@edu (Therneau, Terry M., Ph.D.)
Date: Mon, 07 Dec 2020 12:29:06 -0600
Subject: [Rd] [R/S-PLUS] [EXTERNAL] Re: [External]  anonymous functions
In-Reply-To: <alpine.DEB.2.21.2012071119120.3377@luke-Latitude-7480>
References: <28fddd$f2ifur@ironport10.mayo.edu>
 <alpine.DEB.2.21.2012071119120.3377@luke-Latitude-7480>
Message-ID: <28fddd$f2jf83@ironport10.mayo.edu>

Luke,
 ? Mostly an aside.? I think that pipes are a good addition, and it is clear that you and 
other R-core thought through many of the details.?? Congratulations on what appears to be 
solid work. I've used Unix since '79, so it is almost guarranteed that I like the basic 
idiom, and I expect to make use of it.? Users who think that pipes -- or any other code -- 
is so clear that comments are superfluous is no reflection on R core, and also a bit of a 
hobby horse for me.

I am a bit bemused by the flood of change suggestions, before people have had a chance to 
fully exercise the new code. ? I'd suggest waiting several months, or a year, before major 
updates, straight up bugs excepted. ? The same advice holds when moving into a new house.
One? experience with the survival package has been that most new ideas have been 
implemented locally, and we run with them for half a year before submission to CRAN.? I've 
had a few "really great" modifications that, thankfully, were never inflicted on the rest 
of the R community.

Terry T.

On 12/7/20 11:26 AM, luke-tierney at uiowa.edu wrote:
> I don't disagree in principle, but the reality is users want shortcuts
> and as a result various packages, in particular tidyverse, have been
> providing them. Mostly based on formulas, mostly with significant
> issues since formulas weren't designed for this, and mostly
> incompatible (tidyverse ones are compatible within tidyverse but not
> with others). And of course none work in sapply or lapply. Providing a
> shorthand in base may help to improve this. You don't have to use it
> if you don't want to, and you can establish coding standards that
> disallow it if you like.
>
> Best,
>
> luke
>
> On Mon, 7 Dec 2020, Therneau, Terry M., Ph.D. via R-devel wrote:
>
>> ?The shorthand form \(x) x + 1 is parsed as function(x) x + 1. It may be helpful in 
>> making code containing simple function expressions more readable.?
>>
>> Color me unimpressed.
>> Over the decades I've seen several "who can write the shortest code" threads: in 
>> Fortran, in C, in Splus, ...?? The same old idea that "short" is a synonym for either 
>> elegant, readable, or efficient is now being recylced in the tidyverse.?? The truth is 
>> that "short" is actually an antonym for all of these things, at least for anyone else 
>> reading the code; or for the original coder 30-60 minutes after the "clever" lines were 
>> written. Minimal use of the spacebar and/or the return key isn't usually held up as a 
>> goal, but creeps into many practiioner's code as well.
>>
>> People are excited by replacing "function(" with "\("? Really??? Are people typing code 
>> with their thumbs?
>> I am ambivalent about pipes: I think it is a great concept, but too many of my 
>> colleagues think that using pipes = no need for any comments.
>>
>> As time goes on, I find my goal is to make my code less compact and more readable.? 
>> Every bug fix or new feature in the survival package now adds more lines of comments or 
>> other documentation than lines of code.? If I have to puzzle out what a line does, what 
>> about the poor sod who inherits the maintainance?
>>
>>
>>
>


	[[alternative HTML version deleted]]


From ggrothend|eck @end|ng |rom gm@||@com  Mon Dec  7 19:31:35 2020
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Mon, 7 Dec 2020 13:31:35 -0500
Subject: [Rd] New pipe operator
In-Reply-To: <7f8cf17d-d5fa-0cd1-7760-7157ef1fe7bf@gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
 <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
 <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>
 <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>
 <CAD4oTHHFWkiirncPRWngY+_k9HcB=8zo7VdXAONXQoXdNhKzDA@mail.gmail.com>
 <7e28d84a-f6d0-1e18-c131-163650e7cd75@gmail.com>
 <CAP01uRkCpLQ0uwJgFdTFTNG+80C+F1hn=TnQqRS2Z-nFuU5MmA@mail.gmail.com>
 <CADfFDC74ostfecs5mhOznSXEedGBA=_78SiNTfysz5B8JU=YUQ@mail.gmail.com>
 <F7AF463A-B9A1-4AEB-9EE3-1062B6AD3CFF@gmail.com>
 <7e1eb5e9-4ee7-4a80-ad7b-58ed67c830df@gmail.com>
 <91C38945-B1BA-4E7A-B2E0-79790A894240@gmail.com>
 <7f8cf17d-d5fa-0cd1-7760-7157ef1fe7bf@gmail.com>
Message-ID: <CAP01uRkphV1txi+59LXi3uQO-4RCL+gAt9gbOpDCLXOV-484Yw@mail.gmail.com>

On Mon, Dec 7, 2020 at 12:54 PM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
> An advantage of the current implementation is that it's simple and easy
> to understand.  Once you make it a user-modifiable binary operator,
> things will go kind of nuts.
>
> For example, I doubt if there are many users of magrittr's pipe who
> really understand its subtleties, e.g. the example in Luke's paper where
> 1 %>% c(., 2) gives c(1,2), but 1 %>% c(c(.), 2) gives c(1, 1, 2). (And
> I could add 1 %>% c(c(.), 2, .) and  1 %>% c(c(.), 2, . + 2)  to
> continue the fun.)

The rule is not so complicated.  Automatic insertion is done unless
you use dot in the top level function or if you surround it with
{...}.  It really makes sense since if you use gsub(pattern,
replacement, .) then surely you don't want automatic insertion and if
you surround it with { ... } then you are explicitly telling it not
to.

Assuming the existence of placeholders a possible simplification would
be to NOT do automatic insertion if { ... } is used and to use it
otherwise although personally having used it for some time I find the
existing rule in magrittr generally does what you want.


From kev|nu@hey @end|ng |rom gm@||@com  Mon Dec  7 20:02:22 2020
From: kev|nu@hey @end|ng |rom gm@||@com (Kevin Ushey)
Date: Mon, 7 Dec 2020 11:02:22 -0800
Subject: [Rd] New pipe operator
In-Reply-To: <CAP01uRkphV1txi+59LXi3uQO-4RCL+gAt9gbOpDCLXOV-484Yw@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
 <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
 <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>
 <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>
 <CAD4oTHHFWkiirncPRWngY+_k9HcB=8zo7VdXAONXQoXdNhKzDA@mail.gmail.com>
 <7e28d84a-f6d0-1e18-c131-163650e7cd75@gmail.com>
 <CAP01uRkCpLQ0uwJgFdTFTNG+80C+F1hn=TnQqRS2Z-nFuU5MmA@mail.gmail.com>
 <CADfFDC74ostfecs5mhOznSXEedGBA=_78SiNTfysz5B8JU=YUQ@mail.gmail.com>
 <F7AF463A-B9A1-4AEB-9EE3-1062B6AD3CFF@gmail.com>
 <7e1eb5e9-4ee7-4a80-ad7b-58ed67c830df@gmail.com>
 <91C38945-B1BA-4E7A-B2E0-79790A894240@gmail.com>
 <7f8cf17d-d5fa-0cd1-7760-7157ef1fe7bf@gmail.com>
 <CAP01uRkphV1txi+59LXi3uQO-4RCL+gAt9gbOpDCLXOV-484Yw@mail.gmail.com>
Message-ID: <CAJXgQP1Jpo3BNVGvEf6ctKu9Bv3SV-QFJa5BRByOO-yjYE2XFA@mail.gmail.com>

IMHO the use of anonymous functions is a very clean solution to the
placeholder problem, and the shorthand lambda syntax makes it much
more ergonomic to use. Pipe implementations that crawl the RHS for
usages of `.` are going to be more expensive than the alternatives. It
is nice that the `|>` operator is effectively the same as a regular R
function call, and given the identical semantics could then also be
reasoned about the same way regular R function calls are.

I also agree usages of the `.` placeholder can make the code more
challenging to read, since understanding the behavior of a piped
expression then requires scouring the RHS for usages of `.`, which can
be challenging in dense code. Piping to an anonymous function makes
the intent clear to the reader: the programmer is likely piping to an
anonymous function because they care where the argument is used in the
call, and so the reader of code should be aware of that.

Best,
Kevin



On Mon, Dec 7, 2020 at 10:35 AM Gabor Grothendieck
<ggrothendieck at gmail.com> wrote:
>
> On Mon, Dec 7, 2020 at 12:54 PM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
> > An advantage of the current implementation is that it's simple and easy
> > to understand.  Once you make it a user-modifiable binary operator,
> > things will go kind of nuts.
> >
> > For example, I doubt if there are many users of magrittr's pipe who
> > really understand its subtleties, e.g. the example in Luke's paper where
> > 1 %>% c(., 2) gives c(1,2), but 1 %>% c(c(.), 2) gives c(1, 1, 2). (And
> > I could add 1 %>% c(c(.), 2, .) and  1 %>% c(c(.), 2, . + 2)  to
> > continue the fun.)
>
> The rule is not so complicated.  Automatic insertion is done unless
> you use dot in the top level function or if you surround it with
> {...}.  It really makes sense since if you use gsub(pattern,
> replacement, .) then surely you don't want automatic insertion and if
> you surround it with { ... } then you are explicitly telling it not
> to.
>
> Assuming the existence of placeholders a possible simplification would
> be to NOT do automatic insertion if { ... } is used and to use it
> otherwise although personally having used it for some time I find the
> existing rule in magrittr generally does what you want.
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From @v|gro@@ @end|ng |rom ver|zon@net  Mon Dec  7 20:13:29 2020
From: @v|gro@@ @end|ng |rom ver|zon@net (Avi Gross)
Date: Mon, 7 Dec 2020 14:13:29 -0500
Subject: [Rd] sequential chained operator thoughts
References: <061f01d6cccd$0c25e3a0$2471aae0$.ref@verizon.net>
Message-ID: <061f01d6cccd$0c25e3a0$2471aae0$@verizon.net>

It has been very enlightening watching the discussion not only about the
existing and proposed variations of a data "pipe" operator in R but also
cognates in many other languages.

So I am throwing out a QUESTION that just asks if the pipeline as done is
pretty much what could also be done without the need for an operator using a
sort of one-time brac]keted  construct where you call a function with a
sequence of operations you want performed and just have it handle the
in-between parts.

I mean something like:

return_val <- do_chain_sequence( { initial_data,
				function1(_VAL_);
				function2(_VAL_, more_args);
				function3(args, 2 * _VAL_, more_args);
				...
				function_n(_VAL_)
				})

The above is not meant to be taken literally. I don't care if the symbol is
_VAL_ or you use semi-colon characters between statements. There are many
possible variants such as each step being in its own curly braces. The idea
is to hand over one or more unevaluated blocks of code. There are such
functions in use in R already.

And yes, it can be written with explicit BEFORE/AFTER clauses to handle
things but those are implementation details and I want to focus on a
concept.

The point is you can potentially write a function that given such a series
of arguments, delays evaluation of them until each is needed or used. About
all it might need to do is set the value of something like _VAL_ from the
first argument if present and then take the text of each subsequent argument
and run it while saving the result back into _VAL_ and at the end, return
the last _VAL_. Along the way, of course, the temporary values stored each
time in _VAL_ would disappear.

Is something like this any improvement over this done by the user:

Initial <- whatever
Temp1 <- function1(initial)
Temp2 <- function2(Temp1, ...)
rm(Temp1)
...

Well, maybe not much. But it does hide some details and allows you to insert
or delete steps without worrying about pesky details like variable names
being in the right sequence or not over-riding other things in your
namespace. It makes your intent clear.

Now obviously being evaluated inside a function is not necessarily the same
as remaining in the original environment so having something like this as a
built-in running in place might be a better idea.

I admit the details of how to get one piece at a time as some unevaluated
form and recognize clearly what each piece is takes some careful thought. If
you want to automatically throw in a first argument of _VAL_ after the first
parenthesis found or inserted in new parens if just the name of a function
was presented,  or other such manipulations as already seem to happen with
the Magritrr pipe where a period is the placeholder, that can be delicate
work and also fail for some lines of code.  There may be many reasons
various versions of this proposal can fail for some cases. But functionally,
it would be a way to specify in a linear fashion that a sequence of steps is
to be connected with data being passed along as it changes.

I can also imagine how this kind of method might allow twists like asking
for _VAL_$second or other changes such as sorted(_VAL_) or minmax(_VAL_)
that would shrink the sequence.

This general idea looks like something that some programming language may
already do in some form and functionally and is a bit like the pipe idea,
albeit with different overhead.

And do note many languages already support this in subtle ways. R has a
variable called ".Last.value" that always holds the result of the last
statement evaluated. If the template above is used properly, that alone
might work, albeit be a bit wordy. But it may be more transient in some
cases such as a multi-part statement where it ends up being reset within the
statement.

I am NOT asking for a new feature in R, or any language. I am just asking if
the various pipeline ideas  used could be done in a general way like I
describe as a sequence where the statements are chained as described and
intermediate results are transient. But, yes, some implementations might
require some changes to the language to be implemented properly and it might
not satisfy people used to thinking a certain way.

I end by saying that R is a language that only returns one (sometimes
complex) return value. Other languages allow multiple return values and
pipelines there might be hard to implement or have weird features that allow
various of the returns to be captured or even a more general graph of
command sequences  rather than just a linear pipeline. My thoughts here are
for R alone. And I shudder at what happens if you allow exceptions and other
kinds of breaks/returns out of such a sequential grouping in mid-stride. I
view most such additions and changes as needing careful thought to make sure
they have the functionality most people want, are as consistent as possible
with the existing language, and do not have lots of potential for bugs or
bad programs or ones very hard to read and understand.




Scanned by McAfee and confirmed virus-free.	
Find out more here: https://bit.ly/2zCJMrO


From ggrothend|eck @end|ng |rom gm@||@com  Mon Dec  7 20:23:35 2020
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Mon, 7 Dec 2020 14:23:35 -0500
Subject: [Rd] New pipe operator
In-Reply-To: <CAJXgQP1Jpo3BNVGvEf6ctKu9Bv3SV-QFJa5BRByOO-yjYE2XFA@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
 <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
 <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>
 <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>
 <CAD4oTHHFWkiirncPRWngY+_k9HcB=8zo7VdXAONXQoXdNhKzDA@mail.gmail.com>
 <7e28d84a-f6d0-1e18-c131-163650e7cd75@gmail.com>
 <CAP01uRkCpLQ0uwJgFdTFTNG+80C+F1hn=TnQqRS2Z-nFuU5MmA@mail.gmail.com>
 <CADfFDC74ostfecs5mhOznSXEedGBA=_78SiNTfysz5B8JU=YUQ@mail.gmail.com>
 <F7AF463A-B9A1-4AEB-9EE3-1062B6AD3CFF@gmail.com>
 <7e1eb5e9-4ee7-4a80-ad7b-58ed67c830df@gmail.com>
 <91C38945-B1BA-4E7A-B2E0-79790A894240@gmail.com>
 <7f8cf17d-d5fa-0cd1-7760-7157ef1fe7bf@gmail.com>
 <CAP01uRkphV1txi+59LXi3uQO-4RCL+gAt9gbOpDCLXOV-484Yw@mail.gmail.com>
 <CAJXgQP1Jpo3BNVGvEf6ctKu9Bv3SV-QFJa5BRByOO-yjYE2XFA@mail.gmail.com>
Message-ID: <CAP01uRneyDgY8K6+ko7vHvjC+DC25GTPkdoP6=qc29cuHY1Heg@mail.gmail.com>

On Mon, Dec 7, 2020 at 2:02 PM Kevin Ushey <kevinushey at gmail.com> wrote:
>
> IMHO the use of anonymous functions is a very clean solution to the
> placeholder problem, and the shorthand lambda syntax makes it much
> more ergonomic to use. Pipe implementations that crawl the RHS for
> usages of `.` are going to be more expensive than the alternatives. It

You wouldn't have to crawl the expression.  This does it at the syntax level.

  e <- quote( { gsub("x", "y", .) } )
  c(e[[1]], quote(. <- LHS), e[-1])


From w||||@mwdun|@p @end|ng |rom gm@||@com  Mon Dec  7 21:31:40 2020
From: w||||@mwdun|@p @end|ng |rom gm@||@com (Bill Dunlap)
Date: Mon, 7 Dec 2020 12:31:40 -0800
Subject: [Rd] [R/S-PLUS] [EXTERNAL] Re: [External] anonymous functions
In-Reply-To: <28fddd$f2jf83@ironport10.mayo.edu>
References: <28fddd$f2ifur@ironport10.mayo.edu>
 <alpine.DEB.2.21.2012071119120.3377@luke-Latitude-7480>
 <28fddd$f2jf83@ironport10.mayo.edu>
Message-ID: <CAHqSRuSDGDFP_BrJ+z+kUPcbLqrOk7c3BmJzeghQedL1OpTunQ@mail.gmail.com>

One advantage of the new pipe operator over magrittr's is that the former
works with substitute().
> f <- function(x, xlab=deparse1(substitute(x))) paste(sep="", xlab, ": ",
paste(collapse=", ",x))
> 2^(1:4)  |> f()
[1] "2^(1:4): 2, 4, 8, 16"
> 2^(1:4)  %>% f()
[1] ".: 2, 4, 8, 16"

This is because the new one is at the parser level, so f() sees an ordinary
function call.
> dput(quote(2^(1:4)  |> f()))
f(2^(1:4))


On Mon, Dec 7, 2020 at 10:35 AM Therneau, Terry M., Ph.D. via R-devel <
r-devel at r-project.org> wrote:

> Luke,
>    Mostly an aside.  I think that pipes are a good addition, and it is
> clear that you and
> other R-core thought through many of the details.   Congratulations on
> what appears to be
> solid work. I've used Unix since '79, so it is almost guarranteed that I
> like the basic
> idiom, and I expect to make use of it.  Users who think that pipes -- or
> any other code --
> is so clear that comments are superfluous is no reflection on R core, and
> also a bit of a
> hobby horse for me.
>
> I am a bit bemused by the flood of change suggestions, before people have
> had a chance to
> fully exercise the new code.   I'd suggest waiting several months, or a
> year, before major
> updates, straight up bugs excepted.   The same advice holds when moving
> into a new house.
> One  experience with the survival package has been that most new ideas
> have been
> implemented locally, and we run with them for half a year before
> submission to CRAN.  I've
> had a few "really great" modifications that, thankfully, were never
> inflicted on the rest
> of the R community.
>
> Terry T.
>
> On 12/7/20 11:26 AM, luke-tierney at uiowa.edu wrote:
> > I don't disagree in principle, but the reality is users want shortcuts
> > and as a result various packages, in particular tidyverse, have been
> > providing them. Mostly based on formulas, mostly with significant
> > issues since formulas weren't designed for this, and mostly
> > incompatible (tidyverse ones are compatible within tidyverse but not
> > with others). And of course none work in sapply or lapply. Providing a
> > shorthand in base may help to improve this. You don't have to use it
> > if you don't want to, and you can establish coding standards that
> > disallow it if you like.
> >
> > Best,
> >
> > luke
> >
> > On Mon, 7 Dec 2020, Therneau, Terry M., Ph.D. via R-devel wrote:
> >
> >> ?The shorthand form \(x) x + 1 is parsed as function(x) x + 1. It may
> be helpful in
> >> making code containing simple function expressions more readable.?
> >>
> >> Color me unimpressed.
> >> Over the decades I've seen several "who can write the shortest code"
> threads: in
> >> Fortran, in C, in Splus, ...   The same old idea that "short" is a
> synonym for either
> >> elegant, readable, or efficient is now being recylced in the
> tidyverse.   The truth is
> >> that "short" is actually an antonym for all of these things, at least
> for anyone else
> >> reading the code; or for the original coder 30-60 minutes after the
> "clever" lines were
> >> written. Minimal use of the spacebar and/or the return key isn't
> usually held up as a
> >> goal, but creeps into many practiioner's code as well.
> >>
> >> People are excited by replacing "function(" with "\("? Really?   Are
> people typing code
> >> with their thumbs?
> >> I am ambivalent about pipes: I think it is a great concept, but too
> many of my
> >> colleagues think that using pipes = no need for any comments.
> >>
> >> As time goes on, I find my goal is to make my code less compact and
> more readable.
> >> Every bug fix or new feature in the survival package now adds more
> lines of comments or
> >> other documentation than lines of code.  If I have to puzzle out what a
> line does, what
> >> about the poor sod who inherits the maintainance?
> >>
> >>
> >>
> >
>
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From g@bembecker @end|ng |rom gm@||@com  Mon Dec  7 23:04:34 2020
From: g@bembecker @end|ng |rom gm@||@com (Gabriel Becker)
Date: Mon, 7 Dec 2020 14:04:34 -0800
Subject: [Rd] New pipe operator
In-Reply-To: <CAP01uRkphV1txi+59LXi3uQO-4RCL+gAt9gbOpDCLXOV-484Yw@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
 <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
 <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>
 <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>
 <CAD4oTHHFWkiirncPRWngY+_k9HcB=8zo7VdXAONXQoXdNhKzDA@mail.gmail.com>
 <7e28d84a-f6d0-1e18-c131-163650e7cd75@gmail.com>
 <CAP01uRkCpLQ0uwJgFdTFTNG+80C+F1hn=TnQqRS2Z-nFuU5MmA@mail.gmail.com>
 <CADfFDC74ostfecs5mhOznSXEedGBA=_78SiNTfysz5B8JU=YUQ@mail.gmail.com>
 <F7AF463A-B9A1-4AEB-9EE3-1062B6AD3CFF@gmail.com>
 <7e1eb5e9-4ee7-4a80-ad7b-58ed67c830df@gmail.com>
 <91C38945-B1BA-4E7A-B2E0-79790A894240@gmail.com>
 <7f8cf17d-d5fa-0cd1-7760-7157ef1fe7bf@gmail.com>
 <CAP01uRkphV1txi+59LXi3uQO-4RCL+gAt9gbOpDCLXOV-484Yw@mail.gmail.com>
Message-ID: <CAD4oTHF3exzSZDKQh7ZvNXhXYznLprO_R-jMzBTe10m8w0u2zQ@mail.gmail.com>

On Mon, Dec 7, 2020 at 10:35 AM Gabor Grothendieck <ggrothendieck at gmail.com>
wrote:

> On Mon, Dec 7, 2020 at 12:54 PM Duncan Murdoch <murdoch.duncan at gmail.com>
> wrote:
> > An advantage of the current implementation is that it's simple and easy
> > to understand.  Once you make it a user-modifiable binary operator,
> > things will go kind of nuts.
> >
> > For example, I doubt if there are many users of magrittr's pipe who
> > really understand its subtleties, e.g. the example in Luke's paper where
> > 1 %>% c(., 2) gives c(1,2), but 1 %>% c(c(.), 2) gives c(1, 1, 2). (And
> > I could add 1 %>% c(c(.), 2, .) and  1 %>% c(c(.), 2, . + 2)  to
> > continue the fun.)
>
> The rule is not so complicated.  Automatic insertion is done unless
> you use dot in the top level function or if you surround it with
> {...}.  It really makes sense since if you use gsub(pattern,
> replacement, .) then surely you don't want automatic insertion and if
> you surround it with { ... } then you are explicitly telling it not
> to.
>
>
This is the point that I believe Duncan is trying to make (and I agree
with) though. Consider the question "after piping LHS into RHS, what is the
first argument in the resulting call?".

For the base pipe, the answer, completely unambiguously, is LHS. Full stop.
That is easy to understand.

For magrittr the answer is "Well, it depends, let me see your RHS
expression, is it wrapped in braces? If not, are you using the placeholder?
If you are using the placeholder, where/how are you using it?".

That is inherently much more complicated. Yes, you understand how the
magrittr pipe behaves, and yes you find it very convenient. Thats great,
but neither of those things equate to simplicity. They just mean that you,
a very experienced pipe user, carry around the cognitive load necessary to
have that understanding.

More concretely, the current base pipe  is extremely simple, all it does i


   1. Figure out RHS exprssion call
         1. If RHS is an anonymous function declaration, construct a call
         to it for a new RHS
      2. Insert LHS expression into first argument position of RHS call
      expression


Done. And (1) would be removed if anonymous functions required () after
them, which would be consistent, and even simpler, but kind of annoying. I
think it is a good compromise which is guaranteed to be safe because
anonymous functions are something the parser recognizes.  Either way, if
that was dropped, what |> does would be *entirely* trivial to understand
and explain. With a single sentence.

I had the equivalent pseudocode for the magrittr pipe written out here but
honestly felt like overkill that came across as mean, so I'll leave that as
an exercise to interested readers.

~G

> Assuming the existence of placeholders a possible simplification would
> be to NOT do automatic insertion if { ... } is used and to use it
> otherwise although personally having used it for some time I find the
> existing rule in magrittr generally does what you want.
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From g@bembecker @end|ng |rom gm@||@com  Mon Dec  7 23:09:10 2020
From: g@bembecker @end|ng |rom gm@||@com (Gabriel Becker)
Date: Mon, 7 Dec 2020 14:09:10 -0800
Subject: [Rd] New pipe operator
In-Reply-To: <CAJXgQP1Jpo3BNVGvEf6ctKu9Bv3SV-QFJa5BRByOO-yjYE2XFA@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
 <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
 <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>
 <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>
 <CAD4oTHHFWkiirncPRWngY+_k9HcB=8zo7VdXAONXQoXdNhKzDA@mail.gmail.com>
 <7e28d84a-f6d0-1e18-c131-163650e7cd75@gmail.com>
 <CAP01uRkCpLQ0uwJgFdTFTNG+80C+F1hn=TnQqRS2Z-nFuU5MmA@mail.gmail.com>
 <CADfFDC74ostfecs5mhOznSXEedGBA=_78SiNTfysz5B8JU=YUQ@mail.gmail.com>
 <F7AF463A-B9A1-4AEB-9EE3-1062B6AD3CFF@gmail.com>
 <7e1eb5e9-4ee7-4a80-ad7b-58ed67c830df@gmail.com>
 <91C38945-B1BA-4E7A-B2E0-79790A894240@gmail.com>
 <7f8cf17d-d5fa-0cd1-7760-7157ef1fe7bf@gmail.com>
 <CAP01uRkphV1txi+59LXi3uQO-4RCL+gAt9gbOpDCLXOV-484Yw@mail.gmail.com>
 <CAJXgQP1Jpo3BNVGvEf6ctKu9Bv3SV-QFJa5BRByOO-yjYE2XFA@mail.gmail.com>
Message-ID: <CAD4oTHE6oWztx7BB+jp_EFs28jDNpUoznOS9jehz_P7iuUexRA@mail.gmail.com>

On Mon, Dec 7, 2020 at 11:05 AM Kevin Ushey <kevinushey at gmail.com> wrote:

> IMHO the use of anonymous functions is a very clean solution to the
> placeholder problem, and the shorthand lambda syntax makes it much
> more ergonomic to use. Pipe implementations that crawl the RHS for
> usages of `.` are going to be more expensive than the alternatives. It
> is nice that the `|>` operator is effectively the same as a regular R
> function call, and given the identical semantics could then also be
> reasoned about the same way regular R function calls are.
>

I agree. That said, one thing that maybe could be done, though I'm not
super convinced its needed, is make a "curry-stuffed pipe", where something
like

LHS |^pipearg^> RHS(arg1 = 5, arg3 = 7)

Would parse to

RHS(pipearg = LHS, arg1 = 5, arg3 = 7)


(Assuming we could get the parser to handle |^bla^> correctly)

For argument position issues would be sufficient. For more complicated
expressions, e.g., those that would use the placeholder multiple times or
inside compound expressions, requiring anonymous functions seems quite
reasonable to me. And honestly, while I kind of like it, I'm not sure if
that "stuffed pipe" expression (assuming we could get the parser to capture
it correctly) reads to me as nicer than the following, anyway.

LHS |> \(x) RHS(arg1 = 5, pipearg = x, arg3 = 7)

~G

>
> I also agree usages of the `.` placeholder can make the code more
> challenging to read, since understanding the behavior of a piped
> expression then requires scouring the RHS for usages of `.`, which can
> be challenging in dense code. Piping to an anonymous function makes
> the intent clear to the reader: the programmer is likely piping to an
> anonymous function because they care where the argument is used in the
> call, and so the reader of code should be aware of that.
>
> Best,
> Kevin
>
>
>
> On Mon, Dec 7, 2020 at 10:35 AM Gabor Grothendieck
> <ggrothendieck at gmail.com> wrote:
> >
> > On Mon, Dec 7, 2020 at 12:54 PM Duncan Murdoch <murdoch.duncan at gmail.com>
> wrote:
> > > An advantage of the current implementation is that it's simple and easy
> > > to understand.  Once you make it a user-modifiable binary operator,
> > > things will go kind of nuts.
> > >
> > > For example, I doubt if there are many users of magrittr's pipe who
> > > really understand its subtleties, e.g. the example in Luke's paper
> where
> > > 1 %>% c(., 2) gives c(1,2), but 1 %>% c(c(.), 2) gives c(1, 1, 2). (And
> > > I could add 1 %>% c(c(.), 2, .) and  1 %>% c(c(.), 2, . + 2)  to
> > > continue the fun.)
> >
> > The rule is not so complicated.  Automatic insertion is done unless
> > you use dot in the top level function or if you surround it with
> > {...}.  It really makes sense since if you use gsub(pattern,
> > replacement, .) then surely you don't want automatic insertion and if
> > you surround it with { ... } then you are explicitly telling it not
> > to.
> >
> > Assuming the existence of placeholders a possible simplification would
> > be to NOT do automatic insertion if { ... } is used and to use it
> > otherwise although personally having used it for some time I find the
> > existing rule in magrittr generally does what you want.
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From toth@dene@ @end|ng |rom kogentum@hu  Mon Dec  7 23:52:36 2020
From: toth@dene@ @end|ng |rom kogentum@hu (=?UTF-8?B?RMOpbmVzIFTDs3Ro?=)
Date: Mon, 7 Dec 2020 23:52:36 +0100
Subject: [Rd] New pipe operator
In-Reply-To: <CAD4oTHE6oWztx7BB+jp_EFs28jDNpUoznOS9jehz_P7iuUexRA@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
 <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
 <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>
 <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>
 <CAD4oTHHFWkiirncPRWngY+_k9HcB=8zo7VdXAONXQoXdNhKzDA@mail.gmail.com>
 <7e28d84a-f6d0-1e18-c131-163650e7cd75@gmail.com>
 <CAP01uRkCpLQ0uwJgFdTFTNG+80C+F1hn=TnQqRS2Z-nFuU5MmA@mail.gmail.com>
 <CADfFDC74ostfecs5mhOznSXEedGBA=_78SiNTfysz5B8JU=YUQ@mail.gmail.com>
 <F7AF463A-B9A1-4AEB-9EE3-1062B6AD3CFF@gmail.com>
 <7e1eb5e9-4ee7-4a80-ad7b-58ed67c830df@gmail.com>
 <91C38945-B1BA-4E7A-B2E0-79790A894240@gmail.com>
 <7f8cf17d-d5fa-0cd1-7760-7157ef1fe7bf@gmail.com>
 <CAP01uRkphV1txi+59LXi3uQO-4RCL+gAt9gbOpDCLXOV-484Yw@mail.gmail.com>
 <CAJXgQP1Jpo3BNVGvEf6ctKu9Bv3SV-QFJa5BRByOO-yjYE2XFA@mail.gmail.com>
 <CAD4oTHE6oWztx7BB+jp_EFs28jDNpUoznOS9jehz_P7iuUexRA@mail.gmail.com>
Message-ID: <8c468025-3d9f-1ace-6203-e58834f7dfdc@kogentum.hu>



On 12/7/20 11:09 PM, Gabriel Becker wrote:
> On Mon, Dec 7, 2020 at 11:05 AM Kevin Ushey <kevinushey at gmail.com> wrote:
> 
>> IMHO the use of anonymous functions is a very clean solution to the
>> placeholder problem, and the shorthand lambda syntax makes it much
>> more ergonomic to use. Pipe implementations that crawl the RHS for
>> usages of `.` are going to be more expensive than the alternatives. It
>> is nice that the `|>` operator is effectively the same as a regular R
>> function call, and given the identical semantics could then also be
>> reasoned about the same way regular R function calls are.
>>
> 
> I agree. That said, one thing that maybe could be done, though I'm not
> super convinced its needed, is make a "curry-stuffed pipe", where something
> like
> 
> LHS |^pipearg^> RHS(arg1 = 5, arg3 = 7)
> 
> Would parse to
> 
> RHS(pipearg = LHS, arg1 = 5, arg3 = 7)
> 

This gave me the idea that naming the arguments can be used to skip the 
placeholder issue:

"funny" |> sub(pattern = "f", replacement = "b")

Of course this breaks if the maintainer changes the order of the 
function arguments (which is not a nice practice but happens).

An option could be to allow for missing argument in the first position, 
but this might add further undesired complexity, so probably not worth 
the effort:

"funny" |> sub(x =, "f", "b")

So basically the parsing rule would be:

LHS |> RHS(arg=, ...)     -> RHS(arg=LHS, ...)


> 
> (Assuming we could get the parser to handle |^bla^> correctly)
> 
> For argument position issues would be sufficient. For more complicated
> expressions, e.g., those that would use the placeholder multiple times or
> inside compound expressions, requiring anonymous functions seems quite
> reasonable to me. And honestly, while I kind of like it, I'm not sure if
> that "stuffed pipe" expression (assuming we could get the parser to capture
> it correctly) reads to me as nicer than the following, anyway.
> 
> LHS |> \(x) RHS(arg1 = 5, pipearg = x, arg3 = 7)
> 
> ~G
> 
>>
>> I also agree usages of the `.` placeholder can make the code more
>> challenging to read, since understanding the behavior of a piped
>> expression then requires scouring the RHS for usages of `.`, which can
>> be challenging in dense code. Piping to an anonymous function makes
>> the intent clear to the reader: the programmer is likely piping to an
>> anonymous function because they care where the argument is used in the
>> call, and so the reader of code should be aware of that.
>>
>> Best,
>> Kevin
>>
>>
>>
>> On Mon, Dec 7, 2020 at 10:35 AM Gabor Grothendieck
>> <ggrothendieck at gmail.com> wrote:
>>>
>>> On Mon, Dec 7, 2020 at 12:54 PM Duncan Murdoch <murdoch.duncan at gmail.com>
>> wrote:
>>>> An advantage of the current implementation is that it's simple and easy
>>>> to understand.  Once you make it a user-modifiable binary operator,
>>>> things will go kind of nuts.
>>>>
>>>> For example, I doubt if there are many users of magrittr's pipe who
>>>> really understand its subtleties, e.g. the example in Luke's paper
>> where
>>>> 1 %>% c(., 2) gives c(1,2), but 1 %>% c(c(.), 2) gives c(1, 1, 2). (And
>>>> I could add 1 %>% c(c(.), 2, .) and  1 %>% c(c(.), 2, . + 2)  to
>>>> continue the fun.)
>>>
>>> The rule is not so complicated.  Automatic insertion is done unless
>>> you use dot in the top level function or if you surround it with
>>> {...}.  It really makes sense since if you use gsub(pattern,
>>> replacement, .) then surely you don't want automatic insertion and if
>>> you surround it with { ... } then you are explicitly telling it not
>>> to.
>>>
>>> Assuming the existence of placeholders a possible simplification would
>>> be to NOT do automatic insertion if { ... } is used and to use it
>>> otherwise although personally having used it for some time I find the
>>> existing rule in magrittr generally does what you want.
>>>
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


From @purd|e@@ @end|ng |rom gm@||@com  Mon Dec  7 23:56:45 2020
From: @purd|e@@ @end|ng |rom gm@||@com (Abby Spurdle)
Date: Tue, 8 Dec 2020 11:56:45 +1300
Subject: [Rd] anonymous functions
In-Reply-To: <28fddd$f2ifur@ironport10.mayo.edu>
References: <28fddd$f2ifur@ironport10.mayo.edu>
Message-ID: <CAB8pepzTJNwrcyi=MS0OwX7pZc8jYCc5E3dykkdAGWqbLbeWCg@mail.gmail.com>

I mostly agree with your comments on anonymous functions.

However, I think the main problem is cryptic-ness, rather than succinct-ness.
The backslash is a relatively universal symbol within programming
languages with C-like (ALGOL-like?) syntax.
Where it denotes escape sequences within strings.

Using the leading character for escape sequences, to define functions,
is like using integers to define floating point numbers:

    my.integer <- as.integer (2) * pi

Arguably, the motive is more to be ultra-succinct than cryptic.
But either way, we get syntax which is difficult to read, from a
mathematical and statistical perspective.


On Tue, Dec 8, 2020 at 6:04 AM Therneau, Terry M., Ph.D. via R-devel
<r-devel at r-project.org> wrote:
>
> ?The shorthand form \(x) x + 1 is parsed as function(x) x + 1. It may be helpful in making
> code containing simple function expressions more readable.?
>
> Color me unimpressed.
> Over the decades I've seen several "who can write the shortest code" threads: in Fortran,
> in C, in Splus, ...   The same old idea that "short" is a synonym for either elegant,
> readable, or efficient is now being recylced in the tidyverse.   The truth is that "short"
> is actually an antonym for all of these things, at least for anyone else reading the code;
> or for the original coder 30-60 minutes after the "clever" lines were written.  Minimal
> use of the spacebar and/or the return key isn't usually held up as a goal, but creeps into
> many practiioner's code as well.
>
> People are excited by replacing "function(" with "\("?  Really?   Are people typing code
> with their thumbs?
> I am ambivalent about pipes: I think it is a great concept, but too many of my colleagues
> think that using pipes = no need for any comments.
>
> As time goes on, I find my goal is to make my code less compact and more readable.  Every
> bug fix or new feature in the survival package now adds more lines of comments or other
> documentation than lines of code.  If I have to puzzle out what a line does, what about
> the poor sod who inherits the maintainance?
>
>
> --
> Terry M Therneau, PhD
> Department of Health Science Research
> Mayo Clinic
> therneau at mayo.edu
>
> "TERR-ree THUR-noh"
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From g@bembecker @end|ng |rom gm@||@com  Tue Dec  8 00:30:27 2020
From: g@bembecker @end|ng |rom gm@||@com (Gabriel Becker)
Date: Mon, 7 Dec 2020 15:30:27 -0800
Subject: [Rd] New pipe operator
In-Reply-To: <8c468025-3d9f-1ace-6203-e58834f7dfdc@kogentum.hu>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
 <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
 <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>
 <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>
 <CAD4oTHHFWkiirncPRWngY+_k9HcB=8zo7VdXAONXQoXdNhKzDA@mail.gmail.com>
 <7e28d84a-f6d0-1e18-c131-163650e7cd75@gmail.com>
 <CAP01uRkCpLQ0uwJgFdTFTNG+80C+F1hn=TnQqRS2Z-nFuU5MmA@mail.gmail.com>
 <CADfFDC74ostfecs5mhOznSXEedGBA=_78SiNTfysz5B8JU=YUQ@mail.gmail.com>
 <F7AF463A-B9A1-4AEB-9EE3-1062B6AD3CFF@gmail.com>
 <7e1eb5e9-4ee7-4a80-ad7b-58ed67c830df@gmail.com>
 <91C38945-B1BA-4E7A-B2E0-79790A894240@gmail.com>
 <7f8cf17d-d5fa-0cd1-7760-7157ef1fe7bf@gmail.com>
 <CAP01uRkphV1txi+59LXi3uQO-4RCL+gAt9gbOpDCLXOV-484Yw@mail.gmail.com>
 <CAJXgQP1Jpo3BNVGvEf6ctKu9Bv3SV-QFJa5BRByOO-yjYE2XFA@mail.gmail.com>
 <CAD4oTHE6oWztx7BB+jp_EFs28jDNpUoznOS9jehz_P7iuUexRA@mail.gmail.com>
 <8c468025-3d9f-1ace-6203-e58834f7dfdc@kogentum.hu>
Message-ID: <CAD4oTHGdBAog9QweCFrCz8TQcSe0ZBSM2JNCBufpx19mR0QvLQ@mail.gmail.com>

Hi Denes,

On Mon, Dec 7, 2020 at 2:52 PM D?nes T?th <toth.denes at kogentum.hu> wrote:

>
>
> This gave me the idea that naming the arguments can be used to skip the
> placeholder issue:
>
> "funny" |> sub(pattern = "f", replacement = "b")
>
> Of course this breaks if the maintainer changes the order of the
> function arguments (which is not a nice practice but happens).
>

This is true, but only if you are specifying all arguments that appear
before the one you want explicitly. In practice that may often be true? But
I don't really have a strong intuition about that as a non-pipe user. It
would require zero changes to the pipe by the R-core team though, so in
that sense it could be a solution in the cases it does work. It does make
the code subtler to read though, which is a pretty big downside, imho.


> An option could be to allow for missing argument in the first position,
> but this might add further undesired complexity, so probably not worth
> the effort:
>
> "funny" |> sub(x =, "f", "b")
>
> So basically the parsing rule would be:
>
> LHS |> RHS(arg=, ...)     -> RHS(arg=LHS, ...)
>

The problem here is that its ambiguous, because myfun(x, y=, z) is
technically syntactically valid, so this would make code that parses now
into valid syntax change its meaning, and would prevent existing,
syntactically valid (Though hopefully quite rare) code in the pipe context.

~G


>
> >
> > (Assuming we could get the parser to handle |^bla^> correctly)
> >
> > For argument position issues would be sufficient. For more complicated
> > expressions, e.g., those that would use the placeholder multiple times or
> > inside compound expressions, requiring anonymous functions seems quite
> > reasonable to me. And honestly, while I kind of like it, I'm not sure if
> > that "stuffed pipe" expression (assuming we could get the parser to
> capture
> > it correctly) reads to me as nicer than the following, anyway.
> >
> > LHS |> \(x) RHS(arg1 = 5, pipearg = x, arg3 = 7)
> >
> > ~G
> >
> >>
> >> I also agree usages of the `.` placeholder can make the code more
> >> challenging to read, since understanding the behavior of a piped
> >> expression then requires scouring the RHS for usages of `.`, which can
> >> be challenging in dense code. Piping to an anonymous function makes
> >> the intent clear to the reader: the programmer is likely piping to an
> >> anonymous function because they care where the argument is used in the
> >> call, and so the reader of code should be aware of that.
> >>
> >> Best,
> >> Kevin
> >>
> >>
> >>
> >> On Mon, Dec 7, 2020 at 10:35 AM Gabor Grothendieck
> >> <ggrothendieck at gmail.com> wrote:
> >>>
> >>> On Mon, Dec 7, 2020 at 12:54 PM Duncan Murdoch <
> murdoch.duncan at gmail.com>
> >> wrote:
> >>>> An advantage of the current implementation is that it's simple and
> easy
> >>>> to understand.  Once you make it a user-modifiable binary operator,
> >>>> things will go kind of nuts.
> >>>>
> >>>> For example, I doubt if there are many users of magrittr's pipe who
> >>>> really understand its subtleties, e.g. the example in Luke's paper
> >> where
> >>>> 1 %>% c(., 2) gives c(1,2), but 1 %>% c(c(.), 2) gives c(1, 1, 2).
> (And
> >>>> I could add 1 %>% c(c(.), 2, .) and  1 %>% c(c(.), 2, . + 2)  to
> >>>> continue the fun.)
> >>>
> >>> The rule is not so complicated.  Automatic insertion is done unless
> >>> you use dot in the top level function or if you surround it with
> >>> {...}.  It really makes sense since if you use gsub(pattern,
> >>> replacement, .) then surely you don't want automatic insertion and if
> >>> you surround it with { ... } then you are explicitly telling it not
> >>> to.
> >>>
> >>> Assuming the existence of placeholders a possible simplification would
> >>> be to NOT do automatic insertion if { ... } is used and to use it
> >>> otherwise although personally having used it for some time I find the
> >>> existing rule in magrittr generally does what you want.
> >>>
> >>> ______________________________________________
> >>> R-devel at r-project.org mailing list
> >>> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>
> >> ______________________________________________
> >> R-devel at r-project.org mailing list
> >> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>
> >
> >       [[alternative HTML version deleted]]
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
> >
>

	[[alternative HTML version deleted]]


From @purd|e@@ @end|ng |rom gm@||@com  Tue Dec  8 01:05:04 2020
From: @purd|e@@ @end|ng |rom gm@||@com (Abby Spurdle)
Date: Tue, 8 Dec 2020 13:05:04 +1300
Subject: [Rd] anonymous functions
In-Reply-To: <CAB8pepzTJNwrcyi=MS0OwX7pZc8jYCc5E3dykkdAGWqbLbeWCg@mail.gmail.com>
References: <28fddd$f2ifur@ironport10.mayo.edu>
 <CAB8pepzTJNwrcyi=MS0OwX7pZc8jYCc5E3dykkdAGWqbLbeWCg@mail.gmail.com>
Message-ID: <CAB8pepw8u+9E1XmweMsWDmfuMJPVov6iGDj=MBUCUNRU1j4k2Q@mail.gmail.com>

Sorry, I should replace "cryptic-ness" from my last post, with
"unnecessary cryptic-ness".
Sometimes short symbolic expressions are necessary.


P.S.
Often, I wish I could write: f (x) = x^2.
But that's replacement function syntax.


On Tue, Dec 8, 2020 at 11:56 AM Abby Spurdle <spurdle.a at gmail.com> wrote:
>
> I mostly agree with your comments on anonymous functions.
>
> However, I think the main problem is cryptic-ness, rather than succinct-ness.
> The backslash is a relatively universal symbol within programming
> languages with C-like (ALGOL-like?) syntax.
> Where it denotes escape sequences within strings.
>
> Using the leading character for escape sequences, to define functions,
> is like using integers to define floating point numbers:
>
>     my.integer <- as.integer (2) * pi
>
> Arguably, the motive is more to be ultra-succinct than cryptic.
> But either way, we get syntax which is difficult to read, from a
> mathematical and statistical perspective.
>
>
> On Tue, Dec 8, 2020 at 6:04 AM Therneau, Terry M., Ph.D. via R-devel
> <r-devel at r-project.org> wrote:
> >
> > ?The shorthand form \(x) x + 1 is parsed as function(x) x + 1. It may be helpful in making
> > code containing simple function expressions more readable.?
> >
> > Color me unimpressed.
> > Over the decades I've seen several "who can write the shortest code" threads: in Fortran,
> > in C, in Splus, ...   The same old idea that "short" is a synonym for either elegant,
> > readable, or efficient is now being recylced in the tidyverse.   The truth is that "short"
> > is actually an antonym for all of these things, at least for anyone else reading the code;
> > or for the original coder 30-60 minutes after the "clever" lines were written.  Minimal
> > use of the spacebar and/or the return key isn't usually held up as a goal, but creeps into
> > many practiioner's code as well.
> >
> > People are excited by replacing "function(" with "\("?  Really?   Are people typing code
> > with their thumbs?
> > I am ambivalent about pipes: I think it is a great concept, but too many of my colleagues
> > think that using pipes = no need for any comments.
> >
> > As time goes on, I find my goal is to make my code less compact and more readable.  Every
> > bug fix or new feature in the survival package now adds more lines of comments or other
> > documentation than lines of code.  If I have to puzzle out what a line does, what about
> > the poor sod who inherits the maintainance?
> >
> >
> > --
> > Terry M Therneau, PhD
> > Department of Health Science Research
> > Mayo Clinic
> > therneau at mayo.edu
> >
> > "TERR-ree THUR-noh"
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel


From d@v|dhughjone@ @end|ng |rom gm@||@com  Tue Dec  8 04:23:54 2020
From: d@v|dhughjone@ @end|ng |rom gm@||@com (David Hugh-Jones)
Date: Tue, 8 Dec 2020 03:23:54 +0000
Subject: [Rd] anonymous functions
In-Reply-To: <CAB8pepw8u+9E1XmweMsWDmfuMJPVov6iGDj=MBUCUNRU1j4k2Q@mail.gmail.com>
References: <CAB8pepw8u+9E1XmweMsWDmfuMJPVov6iGDj=MBUCUNRU1j4k2Q@mail.gmail.com>
Message-ID: <E5190F3B-A86D-45D5-B859-1DCBA06D39CF@gmail.com>

I will stick my oar in here as a user to say that I find the \(x) syntax a bit line-noise-ish. 

David

> On 8 Dec 2020, at 00:05, Abby Spurdle <spurdle.a at gmail.com> wrote:
> 
> ?Sorry, I should replace "cryptic-ness" from my last post, with
> "unnecessary cryptic-ness".
> Sometimes short symbolic expressions are necessary.
> 
> 
> P.S.
> Often, I wish I could write: f (x) = x^2.
> But that's replacement function syntax.
> 
> 
>> On Tue, Dec 8, 2020 at 11:56 AM Abby Spurdle <spurdle.a at gmail.com> wrote:
>> 
>> I mostly agree with your comments on anonymous functions.
>> 
>> However, I think the main problem is cryptic-ness, rather than succinct-ness.
>> The backslash is a relatively universal symbol within programming
>> languages with C-like (ALGOL-like?) syntax.
>> Where it denotes escape sequences within strings.
>> 
>> Using the leading character for escape sequences, to define functions,
>> is like using integers to define floating point numbers:
>> 
>>    my.integer <- as.integer (2) * pi
>> 
>> Arguably, the motive is more to be ultra-succinct than cryptic.
>> But either way, we get syntax which is difficult to read, from a
>> mathematical and statistical perspective.
>> 
>> 
>>> On Tue, Dec 8, 2020 at 6:04 AM Therneau, Terry M., Ph.D. via R-devel
>>> <r-devel at r-project.org> wrote:
>>> 
>>> ?The shorthand form \(x) x + 1 is parsed as function(x) x + 1. It may be helpful in making
>>> code containing simple function expressions more readable.?
>>> 
>>> Color me unimpressed.
>>> Over the decades I've seen several "who can write the shortest code" threads: in Fortran,
>>> in C, in Splus, ...   The same old idea that "short" is a synonym for either elegant,
>>> readable, or efficient is now being recylced in the tidyverse.   The truth is that "short"
>>> is actually an antonym for all of these things, at least for anyone else reading the code;
>>> or for the original coder 30-60 minutes after the "clever" lines were written.  Minimal
>>> use of the spacebar and/or the return key isn't usually held up as a goal, but creeps into
>>> many practiioner's code as well.
>>> 
>>> People are excited by replacing "function(" with "\("?  Really?   Are people typing code
>>> with their thumbs?
>>> I am ambivalent about pipes: I think it is a great concept, but too many of my colleagues
>>> think that using pipes = no need for any comments.
>>> 
>>> As time goes on, I find my goal is to make my code less compact and more readable.  Every
>>> bug fix or new feature in the survival package now adds more lines of comments or other
>>> documentation than lines of code.  If I have to puzzle out what a line does, what about
>>> the poor sod who inherits the maintainance?
>>> 
>>> 
>>> --
>>> Terry M Therneau, PhD
>>> Department of Health Science Research
>>> Mayo Clinic
>>> therneau at mayo.edu
>>> 
>>> "TERR-ree THUR-noh"
>>> 
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From murdoch@dunc@n @end|ng |rom gm@||@com  Tue Dec  8 12:21:57 2020
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Tue, 8 Dec 2020 06:21:57 -0500
Subject: [Rd] [External] anonymous functions
In-Reply-To: <alpine.DEB.2.21.2012071119120.3377@luke-Latitude-7480>
References: <28fddd$f2ifur@ironport10.mayo.edu>
 <alpine.DEB.2.21.2012071119120.3377@luke-Latitude-7480>
Message-ID: <985b9b0c-69a2-c36e-24d6-294f13973ff5@gmail.com>

On 07/12/2020 12:26 p.m., luke-tierney at uiowa.edu wrote:
> I don't disagree in principle, but the reality is users want shortcuts
> and as a result various packages, in particular tidyverse, have been
> providing them. Mostly based on formulas, mostly with significant
> issues since formulas weren't designed for this, and mostly
> incompatible (tidyverse ones are compatible within tidyverse but not
> with others). And of course none work in sapply or lapply. Providing a
> shorthand in base may help to improve this. You don't have to use it
> if you don't want to, and you can establish coding standards that
> disallow it if you like.
Here's a suggestion to let people define their own shorthands and work 
with the current |> definition.

Define "as.call" as an S3 generic, with a default definition something like

as.call.default <- function(x, f, ...) f(x, ...)

so one could use

  x |> as.call(mean)

to get the same result as

  x |> mean()

or (if working in the tidyverse)

  x |> as.call(~ .x + 1)

to use a method to be provided by rlang or purrr to convert their 
shorthand into a call that the pipe can work with.

We already have the generic as.function, which could be used internally 
by lapply and sapply for the same sort of purpose.  tidyverse has 
rlang::as_function, so they could pretty easily add methods for 
as.function if they wanted to allow people to use their shorthand in 
*apply functions.

Duncan Murdoch


From ggrothend|eck @end|ng |rom gm@||@com  Tue Dec  8 12:46:14 2020
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Tue, 8 Dec 2020 06:46:14 -0500
Subject: [Rd] New pipe operator
In-Reply-To: <7e28d84a-f6d0-1e18-c131-163650e7cd75@gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
 <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
 <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>
 <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>
 <CAD4oTHHFWkiirncPRWngY+_k9HcB=8zo7VdXAONXQoXdNhKzDA@mail.gmail.com>
 <7e28d84a-f6d0-1e18-c131-163650e7cd75@gmail.com>
Message-ID: <CAP01uR=vTJ_uy+RURVZnA8vbnnPRTOUkn6a2AEkg4HG2Lu3kaQ@mail.gmail.com>

Duncan Murdoch:
> I agree it's all about call expressions, but they aren't all being
> treated equally:
>
> x |> f(...)
>
> expands to f(x, ...), while
>
> x |> `function`(...)
>
> expands to `function`(...)(x).  This is an exception to the rule for

Yes, this is the problem.  It is trying to handle two different sorts of right
hand sides, calls and functions, using only syntax level operations and
it really needs to either make use of deeper information or have some
method that is available at the syntax level for identifying whether the
right hand side is a call or function.  In the latter case having two
operators would be one way to do it.

  f <- \(x) x + 1
  x |> f()  # call
  x |:> f  # function
  x |:> \(x) x + 1  # function

In the other case where deeper information is used there would only be one
operator and it would handle all cases but would use more than just syntax
level knowledge.

R solved these sorts of problems long ago using S3 and other object oriented
systems which dispatch different methods based on what the right hand side is.
The attempt to avoid using the existing or equivalent mechanisms seems to have
led to this problem.


From h@w|ckh@m @end|ng |rom gm@||@com  Tue Dec  8 14:40:47 2020
From: h@w|ckh@m @end|ng |rom gm@||@com (Hadley Wickham)
Date: Tue, 8 Dec 2020 07:40:47 -0600
Subject: [Rd] New pipe operator
In-Reply-To: <CAJXgQP1Jpo3BNVGvEf6ctKu9Bv3SV-QFJa5BRByOO-yjYE2XFA@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
 <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
 <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>
 <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>
 <CAD4oTHHFWkiirncPRWngY+_k9HcB=8zo7VdXAONXQoXdNhKzDA@mail.gmail.com>
 <7e28d84a-f6d0-1e18-c131-163650e7cd75@gmail.com>
 <CAP01uRkCpLQ0uwJgFdTFTNG+80C+F1hn=TnQqRS2Z-nFuU5MmA@mail.gmail.com>
 <CADfFDC74ostfecs5mhOznSXEedGBA=_78SiNTfysz5B8JU=YUQ@mail.gmail.com>
 <F7AF463A-B9A1-4AEB-9EE3-1062B6AD3CFF@gmail.com>
 <7e1eb5e9-4ee7-4a80-ad7b-58ed67c830df@gmail.com>
 <91C38945-B1BA-4E7A-B2E0-79790A894240@gmail.com>
 <7f8cf17d-d5fa-0cd1-7760-7157ef1fe7bf@gmail.com>
 <CAP01uRkphV1txi+59LXi3uQO-4RCL+gAt9gbOpDCLXOV-484Yw@mail.gmail.com>
 <CAJXgQP1Jpo3BNVGvEf6ctKu9Bv3SV-QFJa5BRByOO-yjYE2XFA@mail.gmail.com>
Message-ID: <CABdHhvF+XFhb5M2q2QErUG7_tfVe19DMsnm27qrrBmwGxdoW_A@mail.gmail.com>

I just wanted to pipe in here (HA HA) to say that I agree with Kevin.
I've never loved the complicated magrittr rule (which has personally
tripped me up a couple of times) and I think the compact inline
function syntax provides a more general solution. It is a bit more
typing, and it will require a little time for your eyes to get used to
the new syntax, but overall I think it's a better solution.

In general, I think the base pipe does an excellent job of taking what
we've learned from 6 years of magrittr, keeping what has been most
successful while discarding complications around the edges.

Hadley

On Mon, Dec 7, 2020 at 1:05 PM Kevin Ushey <kevinushey at gmail.com> wrote:
>
> IMHO the use of anonymous functions is a very clean solution to the
> placeholder problem, and the shorthand lambda syntax makes it much
> more ergonomic to use. Pipe implementations that crawl the RHS for
> usages of `.` are going to be more expensive than the alternatives. It
> is nice that the `|>` operator is effectively the same as a regular R
> function call, and given the identical semantics could then also be
> reasoned about the same way regular R function calls are.
>
> I also agree usages of the `.` placeholder can make the code more
> challenging to read, since understanding the behavior of a piped
> expression then requires scouring the RHS for usages of `.`, which can
> be challenging in dense code. Piping to an anonymous function makes
> the intent clear to the reader: the programmer is likely piping to an
> anonymous function because they care where the argument is used in the
> call, and so the reader of code should be aware of that.
>
> Best,
> Kevin
>
>
>
> On Mon, Dec 7, 2020 at 10:35 AM Gabor Grothendieck
> <ggrothendieck at gmail.com> wrote:
> >
> > On Mon, Dec 7, 2020 at 12:54 PM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
> > > An advantage of the current implementation is that it's simple and easy
> > > to understand.  Once you make it a user-modifiable binary operator,
> > > things will go kind of nuts.
> > >
> > > For example, I doubt if there are many users of magrittr's pipe who
> > > really understand its subtleties, e.g. the example in Luke's paper where
> > > 1 %>% c(., 2) gives c(1,2), but 1 %>% c(c(.), 2) gives c(1, 1, 2). (And
> > > I could add 1 %>% c(c(.), 2, .) and  1 %>% c(c(.), 2, . + 2)  to
> > > continue the fun.)
> >
> > The rule is not so complicated.  Automatic insertion is done unless
> > you use dot in the top level function or if you surround it with
> > {...}.  It really makes sense since if you use gsub(pattern,
> > replacement, .) then surely you don't want automatic insertion and if
> > you surround it with { ... } then you are explicitly telling it not
> > to.
> >
> > Assuming the existence of placeholders a possible simplification would
> > be to NOT do automatic insertion if { ... } is used and to use it
> > otherwise although personally having used it for some time I find the
> > existing rule in magrittr generally does what you want.
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel



-- 
http://hadley.nz


From murdoch@dunc@n @end|ng |rom gm@||@com  Tue Dec  8 14:58:54 2020
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Tue, 8 Dec 2020 08:58:54 -0500
Subject: [Rd] [External] anonymous functions
In-Reply-To: <985b9b0c-69a2-c36e-24d6-294f13973ff5@gmail.com>
References: <28fddd$f2ifur@ironport10.mayo.edu>
 <alpine.DEB.2.21.2012071119120.3377@luke-Latitude-7480>
 <985b9b0c-69a2-c36e-24d6-294f13973ff5@gmail.com>
Message-ID: <d8e2c1b0-0faf-600b-7a07-db5050b9ccce@gmail.com>

On 08/12/2020 6:21 a.m., Duncan Murdoch wrote:
> On 07/12/2020 12:26 p.m., luke-tierney at uiowa.edu wrote:
>> I don't disagree in principle, but the reality is users want shortcuts
>> and as a result various packages, in particular tidyverse, have been
>> providing them. Mostly based on formulas, mostly with significant
>> issues since formulas weren't designed for this, and mostly
>> incompatible (tidyverse ones are compatible within tidyverse but not
>> with others). And of course none work in sapply or lapply. Providing a
>> shorthand in base may help to improve this. You don't have to use it
>> if you don't want to, and you can establish coding standards that
>> disallow it if you like.
> Here's a suggestion to let people define their own shorthands and work
> with the current |> definition.
> 
> Define "as.call" as an S3 generic, with a default definition something like >
> as.call.default <- function(x, f, ...) f(x, ...)

That's probably a bad choice of name for the generic in that it doesn't 
convert x to a call and it's only useful in a pipe, but I do think the 
idea of some generic function would be useful.

Duncan Murdoch

> 
> so one could use
> 
>    x |> as.call(mean)
> 
> to get the same result as
> 
>    x |> mean()
> 
> or (if working in the tidyverse)
> 
>    x |> as.call(~ .x + 1)
> 
> to use a method to be provided by rlang or purrr to convert their
> shorthand into a call that the pipe can work with.
> 
> We already have the generic as.function, which could be used internally
> by lapply and sapply for the same sort of purpose.  tidyverse has
> rlang::as_function, so they could pretty easily add methods for
> as.function if they wanted to allow people to use their shorthand in
> *apply functions.
> 
> Duncan Murdoch
>


From ggrothend|eck @end|ng |rom gm@||@com  Tue Dec  8 16:32:04 2020
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Tue, 8 Dec 2020 10:32:04 -0500
Subject: [Rd] [External] anonymous functions
In-Reply-To: <alpine.DEB.2.21.2012071119120.3377@luke-Latitude-7480>
References: <28fddd$f2ifur@ironport10.mayo.edu>
 <alpine.DEB.2.21.2012071119120.3377@luke-Latitude-7480>
Message-ID: <CAP01uRktvLhnUWRtTe97MRx1UCYEvwRDyGDLVzGkLq55hXZg-w@mail.gmail.com>

On Mon, Dec 7, 2020 at 12:34 PM <luke-tierney at uiowa.edu> wrote:
> I don't disagree in principle, but the reality is users want shortcuts
> and as a result various packages, in particular tidyverse, have been
> providing them. Mostly based on formulas, mostly with significant
> issues since formulas weren't designed for this, and mostly
> incompatible (tidyverse ones are compatible within tidyverse but not
> with others). And of course none work in sapply or lapply.

The formulas as functions in the gsubfn package work with nearly any function
including sapply and lapply.

  library(gsubfn)
  fn$lapply(1:3, ~ x + 1)
  ## [1] 2 3 4


From ggrothend|eck @end|ng |rom gm@||@com  Tue Dec  8 22:23:30 2020
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Tue, 8 Dec 2020 16:23:30 -0500
Subject: [Rd] [External] Re: New pipe operator
In-Reply-To: <CAP01uRmd0tRM4xYnegK=YijJv6htqq+fuOwBMBns--0+2a7Opw@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <alpine.DEB.2.21.2012051203250.3003@luke-Latitude-7480>
 <CAP01uRmd0tRM4xYnegK=YijJv6htqq+fuOwBMBns--0+2a7Opw@mail.gmail.com>
Message-ID: <CAP01uRmjHcduh8ugqaNK-qA5HGh-GvaqbbbuFdnjBbymU+bpWg@mail.gmail.com>

On Mon, Dec 7, 2020 at 9:09 AM Gabor Grothendieck
<ggrothendieck at gmail.com> wrote:
>
> On Sat, Dec 5, 2020 at 1:19 PM <luke-tierney at uiowa.edu> wrote:
> > Let's get some experience
>
> Here is my last SO post using dplyr rewritten to use R 4.1 devel.  Seems

It occurred to me it would also be interesting to show this example
rewritten using John Mount's bizarro pipe
(which is clever use of syntax to get the effect of a pipe) with the
new \(x) ...
This can be done entirely in base R 4.1.  It does not use \>, just \(x)...

  "myfile.csv" ->.;
    readLines(.) ->.;
    gsub(r'{(c\(.*?\)|integer\(0\))}', r'{"\1"}', .) ->.;
    read.csv(text = .) ->.;
    replace(., 2:3, lapply(.[2:3], \(col) lapply(col, \(x)
eval(parse(text = x))))) ->.;
    . -> DF


From M@rk@Br@v|ngton @end|ng |rom d@t@61@c@|ro@@u  Tue Dec  8 22:26:00 2020
From: M@rk@Br@v|ngton @end|ng |rom d@t@61@c@|ro@@u (Bravington, Mark (Data61, Hobart))
Date: Tue, 8 Dec 2020 21:26:00 +0000
Subject: [Rd] New pipe operator
In-Reply-To: <5179b8d4-628e-ff73-fa53-92fe942e12ea@gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
 <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
 <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>
 <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>
 <MEAPR01MB2407865F5622461515F409EDB4CE0@MEAPR01MB2407.ausprd01.prod.outlook.com>,
 <5179b8d4-628e-ff73-fa53-92fe942e12ea@gmail.com>
Message-ID: <MEAPR01MB240762B89E5DCF1CF23B09B5B4CD0@MEAPR01MB2407.ausprd01.prod.outlook.com>

> > On 06/12/2020 8:22 p.m., Bravington, Mark (Data61, Hobart) wrote:
> (and Duncan Murdoch responded, as below)

It still seems to me that placeholders are viable and unambiguous (only as things in RHS of pipes), and that something like  

x |> foo( _PIPE_) 
x |> bah( otherarg, _PIPE_)
x |> { y <- _PIPE_+1; _PIPE_ / y } # anonymous function

would be a viable solution that doesn't break syntax. This suggestion expands slightly on my previous post, to deal with anonymous functions without either ugly or cumbersome syntax. Specifically, the parser could expand curly-braces in a pipe RHS like this:

x |> {expr} 

into

_ANON_( _PIPE_, {expr})( x)

where '_ANON_' itself  constructs-and-calls a function with one argument called '_PIPE_' whose body consists of 'expr' (which presumably refers to '_PIPE_')

No new weird operators like \(, and the only break with normal syntax is the expansion of curly-braces--- plus treating one symbol, _PIPE_ or any other pre-agreed one perhaps even just _, as a legal name inside a pipe.

Now back to my previous post and responding to Duncan's comments:

> >   - I don't see the problem with a placeholder--- doesn't it remove all ambiguity? Sure there needs to be a standard unclashable name and people can argue about what that should be, but the following seems clear and flexible... to me, anyway:
> >   
> >   thing |>
> >     foo( _PIPE_) |>           # standard
> >     bah( arg1, _PIPE_) |>   # multi-arg function
> >     _ANON_({ x <- sum( _PIPE_); _PIPE_/x + x/_PIPE_ })   # anon function
> >    
> > where '_PIPE_' is the ordained name of the placeholder, and '_ANON_' constructs-and-calls a function with single argument '_PIPE_'. There is just one rule (I think...): each pipe-stage must be a *call* involving the argument '_PIPE_'.

and (see end) I think the line with _ANON_ above could in fact just be

  ... |> { x <- sum( _PIPE_); _PIPE_/x + x/_PIPE_ }
  
> I believe there's no ambiguity if the placeholder is *only* allowed in the RHS of a pipe expression.

Yes--- that's my suggestion: there and only there. Hence an otherwise-illegal name like _PIPE_.

> I think the ambiguity arises if you allow 
> the same syntax to be used to generate anonymous functions.

Agreed; don't allow that outside of pipes.

> We can't use _PIPE_ as the placeholder, because it's a legal name.

Surely _PIPE_ is not a legal R name though? Not in my R4.1.0dev, anyway. Of course, the parser can _make_ it legal *only* in the context of RHS of pipe. Anyway, I'm not suggesting the names must be _PIPE_ and _ANON_--- the name is secondary to the concept.

> But we could use _.  

Yes, any unclashable name would do--- though "_" is hard to read (as per complaints about "." as placeholder, which I use in my own code). And I remember back when R decided to disallow "_" as an assignment operator. Which forced me to change about 50000 lines of code that wasn't stored in text files, so I wasn't happy--- and the only reason that was ever given to me, was "it's ugly" ! Which is kinda true.

> However, implementing this makes the parser pretty ugly: its handling of _ depends on the outer context.  

That context issue is already the case under the current proposal though; eg 'head(10)' in 

x |> head(10) # really head( <arg>, 10)

or indeed 'head' in 

x |> head # actually a call to head(<arg>), not a symbol


> I now agree that leaving out placeholder syntax was the right decision.

Others are not so sure!

Re operator precedence: thanks for pointing that out, I accept that R's current operator-precedence rules make it impossible for people to cleanly implement their own preferred homemade %my_pipe_op%.

All the more reason to be careful with the pipe syntax choice for base-R, of course...


> Then

>    x |> (_ + 1) + mean(_)

> could expand unambiguously to

>    (function(_) (_  + 1) + mean(_))(x)

> but

>    (_ + 1) + mean(_)

> shouldn't be taken to be an anonymous function declaration, otherwise 
> things like

>    mean(_ |> _)

> do become ambiguous:  is the second placeholder the argument to the anon 
> function, or is it the placeholder for the embedded pipe?

That wouldn't be allowed in my proposal; the "_ |> _" is illegal because the RHS is not a call. For the whole thing, I'd require

x |> _ANON_((_PIPE_ + 1) + mean( _PIPE_))

or the just-curly version

x |> { (_PIPE_ + 1) + mean( _PIPE_)} 

but with the implication that this would parse out to 

(`_ANON_`( { (_PIPE_ + 1) + mean( _PIPE_)}))( x)

> > [*] Definition of _ANON_ could be something like this--- almost certainly won't work as-is, this is just to point out that it could be done in standard R.

> > `_ANON_` <- function( expr) { 
> >   #1. Construct a function with arg '_PIPE_' and body 'expr'
> >   #2. Construct a call() to that function
> >   #3. Do the call

> >   f <- function( `_PIPE_`) NULL
> >   body( f) <- expr
> >   environment( f) <- parent.frame() # or something... yes these details are almost certainly wrong
> >   expr2 <- substitute( f( `_PIPE_`)) # or something...
> >   eval.parent( expr2) # or something... 
> > }


Mark Bravington
CSIRO Marine Lab
Hobart
Australia


________________________________________
From: Duncan Murdoch <murdoch.duncan at gmail.com>
Sent: Monday, 7 December 2020 21:31
To: Bravington, Mark (Data61, Hobart); Gabor Grothendieck; Gabriel Becker
Cc: r-devel at r-project.org
Subject: Re: [Rd] New pipe operator

On 06/12/2020 8:22 p.m., Bravington, Mark (Data61, Hobart) wrote:
> Seems like this *could* be a good thing, and thanks to R core for considering it. But, FWIW:
>
>   - I agree with Gabor G that consistency of "syntax" should be paramount here. Enough problems have been caused by earlier superficially-convenient non-standard features in R.  In particular:
>
>   -- there should not be any discrepancy between an in-place function-definition, and a predefined function attached to a symbol (as per Gabor's point).
>
>   -- Hence, the ability to say x |> foo  ie without parentheses, seems bound to lead to inconsistency, because x |> foo is allowed, x |> base::foo isn't allowed without tricks, but x |> function( y) foo( y) isn't... So, x |> foo is not worth keeping. Parentheses are a price well worth paying.
>
>   -- it is still inconsistent and confusing to (apparently) invoke a function in some places--- normally--- via 'foo(x)', yet in others--- pipily--- via 'foo()'. Especially if 'foo' already has a default value for its first argument.
>
>   - I don't see the problem with a placeholder--- doesn't it remove all ambiguity? Sure there needs to be a standard unclashable name and people can argue about what that should be, but the following seems clear and flexible... to me, anyway:
>
>   thing |>
>     foo( _PIPE_) |>           # standard
>     bah( arg1, _PIPE_) |>   # multi-arg function
>     _ANON_({ x <- sum( _PIPE_); _PIPE_/x + x/_PIPE_ })   # anon function
>
> where '_PIPE_' is the ordained name of the placeholder, and '_ANON_' constructs-and-calls a function with single argument '_PIPE_'. There is just one rule (I think...): each pipe-stage must be a *call* involving the argument '_PIPE_'.

I believe there's no ambiguity if the placeholder is *only* allowed in
the RHS of a pipe expression.  I think the ambiguity arises if you allow
the same syntax to be used to generate anonymous functions.  We can't
use _PIPE_ as the placeholder, because it's a legal name.  But we could
use _.  Then

   x |> (_ + 1) + mean(_)

could expand unambiguously to

   (function(_) (_  + 1) + mean(_))(x)

but

   (_ + 1) + mean(_)

shouldn't be taken to be an anonymous function declaration, otherwise
things like

   mean(_ |> _)

do become ambiguous:  is the second placeholder the argument to the anon
function, or is it the placeholder for the embedded pipe?

However, implementing this makes the parser pretty ugly:  its handling
of _ depends on the outer context.  I now agree that leaving out
placeholder syntax was the right decision.


>
>
>   - The proposed anonymous-function syntax looks quite ugly to me, diminishing readability and inviting errors. The new pipe symbol |> already looks scarily like quantum mechanics; adding \( just puts fishbones into the symbolic soup.
>
>   - IMO it's not worth going too far to try to lure magritter-etc fans to swap to the new; my experience is that many people keep using older inferior R syntax for years after better replacements become available (even if they are aware of replacements), for various reasons. Just provide a good framework, and let nature take its course.
>
>   - Disclaimer: personally I'm not much of a pipehead anyway, so maybe I'm not the audience. But if I was to consider piping, I wouldn't be very tempted by the current proposal. OTOH, I might even be tempted to write--- and use!--- my own version of '%|>%' as above (maybe someone already has). And if R did it for me, that'd be great :)

Yours would suffer one of the same problems as magrittr's:  it has the
wrong operator precedence.  The current precedence ordering (from
?Syntax) is, from highest to lowest:


:: :::  access variables in a namespace
$ @     component / slot extraction
[ [[    indexing
^       exponentiation (right to left)
- +     unary minus and plus
:       sequence operator
%any%   special operators (including %% and %/%)
* /     multiply, divide
+ -     (binary) add, subtract
< > <= >= == != ordering and comparison
!       negation
& &&    and
| ||    or
~       as in formulae
-> ->>  rightwards assignment
<- <<-  assignment (right to left)
=       assignment (right to left)
?       help (unary and binary)


The %>% operator has higher precedence than the arithmetic operators, so

x*y %>% f()

is equivalent to x*f(y), not

f(x*y)

as it should "obviously" be.  I believe the new |> operator falls
between "| ||" and "~", so

x || y |> f()

is the same as f(x || y), and

x ~ y |> f()

is x ~ f(y).   There could be arguments about where the new one appears
(and there probably have been), but *clearly* magrittr's precedence is
wrong, and yours would be too, because they are both fixed at the quite
high precedence given to %any%.

Duncan Murdoch

>
> [*] Definition of _ANON_ could be something like this--- almost certainly won't work as-is, this is just to point out that it could be done in standard R.
>
> `_ANON_` <- function( expr) {
>    #1. Construct a function with arg '_PIPE_' and body 'expr'
>    #2. Construct a call() to that function
>    #3. Do the call
>
>    f <- function( `_PIPE_`) NULL
>    body( f) <- expr
>    environment( f) <- parent.frame() # or something... yes these details are almost certainly wrong
>    expr2 <- substitute( f( `_PIPE_`)) # or something...
>    eval.parent( expr2) # or something...
> }
>
> cheers
> Mark
>
> Mark Bravington
> CSIRO Marine Lab
> Hobart
> Australia
>
>
> ________________________________________
> From: R-devel <r-devel-bounces at r-project.org> on behalf of Gabor Grothendieck <ggrothendieck at gmail.com>
> Sent: Monday, 7 December 2020 10:21
> To: Gabriel Becker
> Cc: r-devel at r-project.org
> Subject: Re: [Rd] New pipe operator
>
> I understand very well that it is implemented at the syntax level;
> however, in any case the implementation is irrelevant to the principles.
>
> Here a similar example to the one I gave before but this time written out:
>
> This works:
>
>    3 |> function(x) x + 1
>
> but this does not:
>
>    foo <- function(x) x + 1
>    3 |> foo
>
> so it breaks the principle of functions being first class objects.  foo and its
> definition are not interchangeable.  You have
> to write 3 |> foo() but don't have to write 3 |> (function(x) x + 1)().
>
> This isn't just a matter of notation, i.e. foo vs foo(), but is a
> matter of breaking
> the way R works as a functional language with first class functions.
>
> On Sun, Dec 6, 2020 at 4:06 PM Gabriel Becker <gabembecker at gmail.com> wrote:
>>
>> Hi Gabor,
>>
>> On Sun, Dec 6, 2020 at 12:52 PM Gabor Grothendieck <ggrothendieck at gmail.com> wrote:
>>>
>>> I think the real issue here is that functions are supposed to be
>>> first class objects in R
>>> or are supposed to be and |> would break that if if is possible
>>> to write function(x) x + 1 on the RHS but not foo (assuming foo
>>> was defined as that function).
>>>
>>> I don't think getting experience with using it can change that
>>> inconsistency which seems serious to me and needs to
>>> be addressed even if it complicates the implementation
>>> since it drives to the heart of what R is.
>>>
>>
>> With respect I think this is a misunderstanding of what is happening here.
>>
>> Functions are first class citizens. |> is, for all intents and purposes, a macro.
>>
>> LHS |> RHS(arg2=5)
>>
>> parses to
>>
>> RHS(LHS, arg2 = 5)
>>
>> There are no functions at the point in time when the pipe transformation happens, because no code has been evaluated. To know if a symbol is going to evaluate to a function requires evaluation which is a step entirely after the one where the |> pipe is implemented.
>>
>> Another way to think about it is that
>>
>> LHS |> RHS(arg2 = 5)
>>
>> is another way of writing RHS(LHS, arg2 = 5), NOT R code that is (or even can be) evaluated.
>>
>>
>> Now this is a subtle point that only really has implications in as much as it is not the case for magrittr pipes, but its relevant for discussions like this, I think.
>>
>> ~G
>>
>>> On Sat, Dec 5, 2020 at 1:08 PM Gabor Grothendieck
>>> <ggrothendieck at gmail.com> wrote:
>>>>
>>>> The construct utils::head  is not that common but bare functions are
>>>> very common and to make it harder to use the common case so that
>>>> the uncommon case is slightly easier is not desirable.
>>>>
>>>> Also it is trivial to write this which does work:
>>>>
>>>> mtcars %>% (utils::head)
>>>>
>>>> On Sat, Dec 5, 2020 at 11:59 AM Hugh Parsonage <hugh.parsonage at gmail.com> wrote:
>>>>>
>>>>> I'm surprised by the aversion to
>>>>>
>>>>> mtcars |> nrow
>>>>>
>>>>> over
>>>>>
>>>>> mtcars |> nrow()
>>>>>
>>>>> and I think the decision to disallow the former should be
>>>>> reconsidered.  The pipe operator is only going to be used when the rhs
>>>>> is a function, so there is no ambiguity with omitting the parentheses.
>>>>> If it's disallowed, it becomes inconsistent with other treatments like
>>>>> sapply(mtcars, typeof) where sapply(mtcars, typeof()) would just be
>>>>> noise.  I'm not sure why this decision was taken
>>>>>
>>>>> If the only issue is with the double (and triple) colon operator, then
>>>>> ideally `mtcars |> base::head` should resolve to `base::head(mtcars)`
>>>>> -- in other words, demote the precedence of |>
>>>>>
>>>>> Obviously (looking at the R-Syntax branch) this decision was
>>>>> considered, put into place, then dropped, but I can't see why
>>>>> precisely.
>>>>>
>>>>> Best,
>>>>>
>>>>>
>>>>> Hugh.
>>>>>
>>>>>
>>>>>
>>>>>
>>>>>
>>>>>
>>>>>
>>>>> On Sat, 5 Dec 2020 at 04:07, Deepayan Sarkar <deepayan.sarkar at gmail.com> wrote:
>>>>>>
>>>>>> On Fri, Dec 4, 2020 at 7:35 PM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>>>>>>>
>>>>>>> On 04/12/2020 8:13 a.m., Hiroaki Yutani wrote:
>>>>>>>>>    Error: function '::' not supported in RHS call of a pipe
>>>>>>>>
>>>>>>>> To me, this error looks much more friendly than magrittr's error.
>>>>>>>> Some of them got too used to specify functions without (). This
>>>>>>>> is OK until they use `::`, but when they need to use it, it takes
>>>>>>>> hours to figure out why
>>>>>>>>
>>>>>>>> mtcars %>% base::head
>>>>>>>> #> Error in .::base : unused argument (head)
>>>>>>>>
>>>>>>>> won't work but
>>>>>>>>
>>>>>>>> mtcars %>% head
>>>>>>>>
>>>>>>>> works. I think this is a too harsh lesson for ordinary R users to
>>>>>>>> learn `::` is a function. I've been wanting for magrittr to drop the
>>>>>>>> support for a function name without () to avoid this confusion,
>>>>>>>> so I would very much welcome the new pipe operator's behavior.
>>>>>>>> Thank you all the developers who implemented this!
>>>>>>>
>>>>>>> I agree, it's an improvement on the corresponding magrittr error.
>>>>>>>
>>>>>>> I think the semantics of not evaluating the RHS, but treating the pipe
>>>>>>> as purely syntactical is a good decision.
>>>>>>>
>>>>>>> I'm not sure I like the recommended way to pipe into a particular argument:
>>>>>>>
>>>>>>>     mtcars |> subset(cyl == 4) |> \(d) lm(mpg ~ disp, data = d)
>>>>>>>
>>>>>>> or
>>>>>>>
>>>>>>>     mtcars |> subset(cyl == 4) |> function(d) lm(mpg ~ disp, data = d)
>>>>>>>
>>>>>>> both of which are equivalent to
>>>>>>>
>>>>>>>     mtcars |> subset(cyl == 4) |> (function(d) lm(mpg ~ disp, data = d))()
>>>>>>>
>>>>>>> It's tempting to suggest it should allow something like
>>>>>>>
>>>>>>>     mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
>>>>>>
>>>>>> Which is really not that far off from
>>>>>>
>>>>>> mtcars |> subset(cyl == 4) |> \(.) lm(mpg ~ disp, data = .)
>>>>>>
>>>>>> once you get used to it.
>>>>>>
>>>>>> One consequence of the implementation is that it's not clear how
>>>>>> multiple occurrences of the placeholder would be interpreted. With
>>>>>> magrittr,
>>>>>>
>>>>>> sort(runif(10)) %>% ecdf(.)(.)
>>>>>> ## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
>>>>>>
>>>>>> This is probably what you would expect, if you expect it to work at all, and not
>>>>>>
>>>>>> ecdf(sort(runif(10)))(sort(runif(10)))
>>>>>>
>>>>>> There would be no such ambiguity with anonymous functions
>>>>>>
>>>>>> sort(runif(10)) |> \(.) ecdf(.)(.)
>>>>>>
>>>>>> -Deepayan
>>>>>>
>>>>>>> which would be expanded to something equivalent to the other versions:
>>>>>>> but that makes it quite a bit more complicated.  (Maybe _ or \. should
>>>>>>> be used instead of ., since those are not legal variable names.)
>>>>>>>
>>>>>>> I don't think there should be an attempt to copy magrittr's special
>>>>>>> casing of how . is used in determining whether to also include the
>>>>>>> previous value as first argument.
>>>>>>>
>>>>>>> Duncan Murdoch
>>>>>>>
>>>>>>>
>>>>>>>>
>>>>>>>> Best,
>>>>>>>> Hiroaki Yutani
>>>>>>>>
>>>>>>>> 2020?12?4?(?) 20:51 Duncan Murdoch <murdoch.duncan at gmail.com>:
>>>>>>>>>
>>>>>>>>> Just saw this on the R-devel news:
>>>>>>>>>
>>>>>>>>>
>>>>>>>>> R now provides a simple native pipe syntax ?|>? as well as a shorthand
>>>>>>>>> notation for creating functions, e.g. ?\(x) x + 1? is parsed as
>>>>>>>>> ?function(x) x + 1?. The pipe implementation as a syntax transformation
>>>>>>>>> was motivated by suggestions from Jim Hester and Lionel Henry. These
>>>>>>>>> features are experimental and may change prior to release.
>>>>>>>>>
>>>>>>>>>
>>>>>>>>> This is a good addition; by using "|>" instead of "%>%" there should be
>>>>>>>>> a chance to get operator precedence right.  That said, the ?Syntax help
>>>>>>>>> topic hasn't been updated, so I'm not sure where it fits in.
>>>>>>>>>
>>>>>>>>> There are some choices that take a little getting used to:
>>>>>>>>>
>>>>>>>>>    > mtcars |> head
>>>>>>>>> Error: The pipe operator requires a function call or an anonymous
>>>>>>>>> function expression as RHS
>>>>>>>>>
>>>>>>>>> (I need to say mtcars |> head() instead.)  This sometimes leads to error
>>>>>>>>> messages that are somewhat confusing:
>>>>>>>>>
>>>>>>>>>    > mtcars |> magrittr::debug_pipe |> head
>>>>>>>>> Error: function '::' not supported in RHS call of a pipe
>>>>>>>>>
>>>>>>>>> but
>>>>>>>>>
>>>>>>>>> mtcars |> magrittr::debug_pipe() |> head()
>>>>>>>>>
>>>>>>>>> works.
>>>>>>>>>
>>>>>>>>> Overall, I think this is a great addition, though it's going to be
>>>>>>>>> disruptive for a while.
>>>>>>>>>
>>>>>>>>> Duncan Murdoch
>>>>>>>>>
>>>>>>>>> ______________________________________________
>>>>>>>>> R-devel at r-project.org mailing list
>>>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>>>
>>>>>>>> ______________________________________________
>>>>>>>> R-devel at r-project.org mailing list
>>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>>>
>>>>>>>
>>>>>>> ______________________________________________
>>>>>>> R-devel at r-project.org mailing list
>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>
>>>>>> ______________________________________________
>>>>>> R-devel at r-project.org mailing list
>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>
>>>>> ______________________________________________
>>>>> R-devel at r-project.org mailing list
>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>
>>>>
>>>>
>>>> --
>>>> Statistics & Software Consulting
>>>> GKX Group, GKX Associates Inc.
>>>> tel: 1-877-GKX-GROUP
>>>> email: ggrothendieck at gmail.com
>>>
>>>
>>>
>>> --
>>> Statistics & Software Consulting
>>> GKX Group, GKX Associates Inc.
>>> tel: 1-877-GKX-GROUP
>>> email: ggrothendieck at gmail.com
>>>
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>
>
>
> --
> Statistics & Software Consulting
> GKX Group, GKX Associates Inc.
> tel: 1-877-GKX-GROUP
> email: ggrothendieck at gmail.com
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>



From murdoch@dunc@n @end|ng |rom gm@||@com  Tue Dec  8 23:28:35 2020
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Tue, 8 Dec 2020 17:28:35 -0500
Subject: [Rd] New pipe operator
In-Reply-To: <MEAPR01MB240762B89E5DCF1CF23B09B5B4CD0@MEAPR01MB2407.ausprd01.prod.outlook.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
 <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
 <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>
 <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>
 <MEAPR01MB2407865F5622461515F409EDB4CE0@MEAPR01MB2407.ausprd01.prod.outlook.com>
 <5179b8d4-628e-ff73-fa53-92fe942e12ea@gmail.com>
 <MEAPR01MB240762B89E5DCF1CF23B09B5B4CD0@MEAPR01MB2407.ausprd01.prod.outlook.com>
Message-ID: <34c419e1-7fea-61e1-2e5b-05f40b8c768a@gmail.com>

First, one comment:

You're right about the illegality of _PIPE_ as a name, I had  
misremembered the rule.

About your proposal:

I don't find it attractive, but I can see that some people would.  But I  
don't think it's necessary to put it into the base parser.  Other than  
using an illegal name, there doesn't seem to be a reason you couldn't  
write a small function to convert your placeholder proposal to a call to  
a function.  So instead of typing

  x |> { y <- _PIPE_+1; _PIPE_ / y }

you would type

  x |> forpipe({ y <- PIPE_+1; PIPE_ / y })

I don't think "forpipe" is the right name here.  I proposed a generic  
"as.call" before, but I don't like that one either.  I'm still trying to  
think of a good name, and whether or not it makes sense for it to be  
generic.

But the point is that we don't need to choose just one from all the  
proposed replacements for anonymous function syntax, we can try them out  
and see which ones we like.  We might end up with more than one (like we  
have at least 4 different high level graphics paradigms!), and that's  
not the end of the world.

Duncan Murdoch

On 08/12/2020 4:26 p.m., Bravington, Mark (Data61, Hobart) wrote:
>>> On 06/12/2020 8:22 p.m., Bravington, Mark (Data61, Hobart) wrote:
>> (and Duncan Murdoch responded, as below)
> 
> It still seems to me that placeholders are viable and unambiguous (only as things in RHS of pipes), and that something like
> 
> x |> foo( _PIPE_)
> x |> bah( otherarg, _PIPE_)
> x |> { y <- _PIPE_+1; _PIPE_ / y } # anonymous function
> 
> would be a viable solution that doesn't break syntax. This suggestion expands slightly on my previous post, to deal with anonymous functions without either ugly or cumbersome syntax. Specifically, the parser could expand curly-braces in a pipe RHS like this:
> 
> x |> {expr}
> 
> into
> 
> _ANON_( _PIPE_, {expr})( x)
> 
> where '_ANON_' itself  constructs-and-calls a function with one argument called '_PIPE_' whose body consists of 'expr' (which presumably refers to '_PIPE_')
> 
> No new weird operators like \(, and the only break with normal syntax is the expansion of curly-braces--- plus treating one symbol, _PIPE_ or any other pre-agreed one perhaps even just _, as a legal name inside a pipe.
> 
> Now back to my previous post and responding to Duncan's comments:
> 
>>>    - I don't see the problem with a placeholder--- doesn't it remove all ambiguity? Sure there needs to be a standard unclashable name and people can argue about what that should be, but the following seems clear and flexible... to me, anyway:
>>>    
>>>    thing |>
>>>      foo( _PIPE_) |>           # standard
>>>      bah( arg1, _PIPE_) |>   # multi-arg function
>>>      _ANON_({ x <- sum( _PIPE_); _PIPE_/x + x/_PIPE_ })   # anon function
>>>     
>>> where '_PIPE_' is the ordained name of the placeholder, and '_ANON_' constructs-and-calls a function with single argument '_PIPE_'. There is just one rule (I think...): each pipe-stage must be a *call* involving the argument '_PIPE_'.
> 
> and (see end) I think the line with _ANON_ above could in fact just be
> 
>    ... |> { x <- sum( _PIPE_); _PIPE_/x + x/_PIPE_ }
>    
>> I believe there's no ambiguity if the placeholder is *only* allowed in the RHS of a pipe expression.
> 
> Yes--- that's my suggestion: there and only there. Hence an otherwise-illegal name like _PIPE_.
> 
>> I think the ambiguity arises if you allow
>> the same syntax to be used to generate anonymous functions.
> 
> Agreed; don't allow that outside of pipes.
> 
>> We can't use _PIPE_ as the placeholder, because it's a legal name.
> 
> Surely _PIPE_ is not a legal R name though? Not in my R4.1.0dev, anyway. Of course, the parser can _make_ it legal *only* in the context of RHS of pipe. Anyway, I'm not suggesting the names must be _PIPE_ and _ANON_--- the name is secondary to the concept.
> 
>> But we could use _.
> 
> Yes, any unclashable name would do--- though "_" is hard to read (as per complaints about "." as placeholder, which I use in my own code). And I remember back when R decided to disallow "_" as an assignment operator. Which forced me to change about 50000 lines of code that wasn't stored in text files, so I wasn't happy--- and the only reason that was ever given to me, was "it's ugly" ! Which is kinda true.
> 
>> However, implementing this makes the parser pretty ugly: its handling of _ depends on the outer context.
> 
> That context issue is already the case under the current proposal though; eg 'head(10)' in
> 
> x |> head(10) # really head( <arg>, 10)
> 
> or indeed 'head' in
> 
> x |> head # actually a call to head(<arg>), not a symbol
> 
> 
>> I now agree that leaving out placeholder syntax was the right decision.
> 
> Others are not so sure!
> 
> Re operator precedence: thanks for pointing that out, I accept that R's current operator-precedence rules make it impossible for people to cleanly implement their own preferred homemade %my_pipe_op%.
> 
> All the more reason to be careful with the pipe syntax choice for base-R, of course...
> 
> 
>> Then
> 
>>     x |> (_ + 1) + mean(_)
> 
>> could expand unambiguously to
> 
>>     (function(_) (_  + 1) + mean(_))(x)
> 
>> but
> 
>>     (_ + 1) + mean(_)
> 
>> shouldn't be taken to be an anonymous function declaration, otherwise
>> things like
> 
>>     mean(_ |> _)
> 
>> do become ambiguous:  is the second placeholder the argument to the anon
>> function, or is it the placeholder for the embedded pipe?
> 
> That wouldn't be allowed in my proposal; the "_ |> _" is illegal because the RHS is not a call. For the whole thing, I'd require
> 
> x |> _ANON_((_PIPE_ + 1) + mean( _PIPE_))
> 
> or the just-curly version
> 
> x |> { (_PIPE_ + 1) + mean( _PIPE_)}
> 
> but with the implication that this would parse out to
> 
> (`_ANON_`( { (_PIPE_ + 1) + mean( _PIPE_)}))( x)
> 
>>> [*] Definition of _ANON_ could be something like this--- almost certainly won't work as-is, this is just to point out that it could be done in standard R.
> 
>>> `_ANON_` <- function( expr) {
>>>    #1. Construct a function with arg '_PIPE_' and body 'expr'
>>>    #2. Construct a call() to that function
>>>    #3. Do the call
> 
>>>    f <- function( `_PIPE_`) NULL
>>>    body( f) <- expr
>>>    environment( f) <- parent.frame() # or something... yes these details are almost certainly wrong
>>>    expr2 <- substitute( f( `_PIPE_`)) # or something...
>>>    eval.parent( expr2) # or something...
>>> }
> 
> 
> Mark Bravington
> CSIRO Marine Lab
> Hobart
> Australia
> 
> 
> ________________________________________
> From: Duncan Murdoch <murdoch.duncan at gmail.com>
> Sent: Monday, 7 December 2020 21:31
> To: Bravington, Mark (Data61, Hobart); Gabor Grothendieck; Gabriel Becker
> Cc: r-devel at r-project.org
> Subject: Re: [Rd] New pipe operator
> 
> On 06/12/2020 8:22 p.m., Bravington, Mark (Data61, Hobart) wrote:
>> Seems like this *could* be a good thing, and thanks to R core for considering it. But, FWIW:
>>
>>    - I agree with Gabor G that consistency of "syntax" should be paramount here. Enough problems have been caused by earlier superficially-convenient non-standard features in R.  In particular:
>>
>>    -- there should not be any discrepancy between an in-place function-definition, and a predefined function attached to a symbol (as per Gabor's point).
>>
>>    -- Hence, the ability to say x |> foo  ie without parentheses, seems bound to lead to inconsistency, because x |> foo is allowed, x |> base::foo isn't allowed without tricks, but x |> function( y) foo( y) isn't... So, x |> foo is not worth keeping. Parentheses are a price well worth paying.
>>
>>    -- it is still inconsistent and confusing to (apparently) invoke a function in some places--- normally--- via 'foo(x)', yet in others--- pipily--- via 'foo()'. Especially if 'foo' already has a default value for its first argument.
>>
>>    - I don't see the problem with a placeholder--- doesn't it remove all ambiguity? Sure there needs to be a standard unclashable name and people can argue about what that should be, but the following seems clear and flexible... to me, anyway:
>>
>>    thing |>
>>      foo( _PIPE_) |>           # standard
>>      bah( arg1, _PIPE_) |>   # multi-arg function
>>      _ANON_({ x <- sum( _PIPE_); _PIPE_/x + x/_PIPE_ })   # anon function
>>
>> where '_PIPE_' is the ordained name of the placeholder, and '_ANON_' constructs-and-calls a function with single argument '_PIPE_'. There is just one rule (I think...): each pipe-stage must be a *call* involving the argument '_PIPE_'.
> 
> I believe there's no ambiguity if the placeholder is *only* allowed in
> the RHS of a pipe expression.  I think the ambiguity arises if you allow
> the same syntax to be used to generate anonymous functions.  We can't
> use _PIPE_ as the placeholder, because it's a legal name.  But we could
> use _.  Then
> 
>     x |> (_ + 1) + mean(_)
> 
> could expand unambiguously to
> 
>     (function(_) (_  + 1) + mean(_))(x)
> 
> but
> 
>     (_ + 1) + mean(_)
> 
> shouldn't be taken to be an anonymous function declaration, otherwise
> things like
> 
>     mean(_ |> _)
> 
> do become ambiguous:  is the second placeholder the argument to the anon
> function, or is it the placeholder for the embedded pipe?
> 
> However, implementing this makes the parser pretty ugly:  its handling
> of _ depends on the outer context.  I now agree that leaving out
> placeholder syntax was the right decision.
> 
> 
>>
>>
>>    - The proposed anonymous-function syntax looks quite ugly to me, diminishing readability and inviting errors. The new pipe symbol |> already looks scarily like quantum mechanics; adding \( just puts fishbones into the symbolic soup.
>>
>>    - IMO it's not worth going too far to try to lure magritter-etc fans to swap to the new; my experience is that many people keep using older inferior R syntax for years after better replacements become available (even if they are aware of replacements), for various reasons. Just provide a good framework, and let nature take its course.
>>
>>    - Disclaimer: personally I'm not much of a pipehead anyway, so maybe I'm not the audience. But if I was to consider piping, I wouldn't be very tempted by the current proposal. OTOH, I might even be tempted to write--- and use!--- my own version of '%|>%' as above (maybe someone already has). And if R did it for me, that'd be great :)
> 
> Yours would suffer one of the same problems as magrittr's:  it has the
> wrong operator precedence.  The current precedence ordering (from
> ?Syntax) is, from highest to lowest:
> 
> 
> :: :::  access variables in a namespace
> $ @     component / slot extraction
> [ [[    indexing
> ^       exponentiation (right to left)
> - +     unary minus and plus
> :       sequence operator
> %any%   special operators (including %% and %/%)
> * /     multiply, divide
> + -     (binary) add, subtract
> < > <= >= == != ordering and comparison
> !       negation
> & &&    and
> | ||    or
> ~       as in formulae
> -> ->>  rightwards assignment
> <- <<-  assignment (right to left)
> =       assignment (right to left)
> ?       help (unary and binary)
> 
> 
> The %>% operator has higher precedence than the arithmetic operators, so
> 
> x*y %>% f()
> 
> is equivalent to x*f(y), not
> 
> f(x*y)
> 
> as it should "obviously" be.  I believe the new |> operator falls
> between "| ||" and "~", so
> 
> x || y |> f()
> 
> is the same as f(x || y), and
> 
> x ~ y |> f()
> 
> is x ~ f(y).   There could be arguments about where the new one appears
> (and there probably have been), but *clearly* magrittr's precedence is
> wrong, and yours would be too, because they are both fixed at the quite
> high precedence given to %any%.
> 
> Duncan Murdoch
> 
>>
>> [*] Definition of _ANON_ could be something like this--- almost certainly won't work as-is, this is just to point out that it could be done in standard R.
>>
>> `_ANON_` <- function( expr) {
>>     #1. Construct a function with arg '_PIPE_' and body 'expr'
>>     #2. Construct a call() to that function
>>     #3. Do the call
>>
>>     f <- function( `_PIPE_`) NULL
>>     body( f) <- expr
>>     environment( f) <- parent.frame() # or something... yes these details are almost certainly wrong
>>     expr2 <- substitute( f( `_PIPE_`)) # or something...
>>     eval.parent( expr2) # or something...
>> }
>>
>> cheers
>> Mark
>>
>> Mark Bravington
>> CSIRO Marine Lab
>> Hobart
>> Australia
>>
>>
>> ________________________________________
>> From: R-devel <r-devel-bounces at r-project.org> on behalf of Gabor Grothendieck <ggrothendieck at gmail.com>
>> Sent: Monday, 7 December 2020 10:21
>> To: Gabriel Becker
>> Cc: r-devel at r-project.org
>> Subject: Re: [Rd] New pipe operator
>>
>> I understand very well that it is implemented at the syntax level;
>> however, in any case the implementation is irrelevant to the principles.
>>
>> Here a similar example to the one I gave before but this time written out:
>>
>> This works:
>>
>>     3 |> function(x) x + 1
>>
>> but this does not:
>>
>>     foo <- function(x) x + 1
>>     3 |> foo
>>
>> so it breaks the principle of functions being first class objects.  foo and its
>> definition are not interchangeable.  You have
>> to write 3 |> foo() but don't have to write 3 |> (function(x) x + 1)().
>>
>> This isn't just a matter of notation, i.e. foo vs foo(), but is a
>> matter of breaking
>> the way R works as a functional language with first class functions.
>>
>> On Sun, Dec 6, 2020 at 4:06 PM Gabriel Becker <gabembecker at gmail.com> wrote:
>>>
>>> Hi Gabor,
>>>
>>> On Sun, Dec 6, 2020 at 12:52 PM Gabor Grothendieck <ggrothendieck at gmail.com> wrote:
>>>>
>>>> I think the real issue here is that functions are supposed to be
>>>> first class objects in R
>>>> or are supposed to be and |> would break that if if is possible
>>>> to write function(x) x + 1 on the RHS but not foo (assuming foo
>>>> was defined as that function).
>>>>
>>>> I don't think getting experience with using it can change that
>>>> inconsistency which seems serious to me and needs to
>>>> be addressed even if it complicates the implementation
>>>> since it drives to the heart of what R is.
>>>>
>>>
>>> With respect I think this is a misunderstanding of what is happening here.
>>>
>>> Functions are first class citizens. |> is, for all intents and purposes, a macro.
>>>
>>> LHS |> RHS(arg2=5)
>>>
>>> parses to
>>>
>>> RHS(LHS, arg2 = 5)
>>>
>>> There are no functions at the point in time when the pipe transformation happens, because no code has been evaluated. To know if a symbol is going to evaluate to a function requires evaluation which is a step entirely after the one where the |> pipe is implemented.
>>>
>>> Another way to think about it is that
>>>
>>> LHS |> RHS(arg2 = 5)
>>>
>>> is another way of writing RHS(LHS, arg2 = 5), NOT R code that is (or even can be) evaluated.
>>>
>>>
>>> Now this is a subtle point that only really has implications in as much as it is not the case for magrittr pipes, but its relevant for discussions like this, I think.
>>>
>>> ~G
>>>
>>>> On Sat, Dec 5, 2020 at 1:08 PM Gabor Grothendieck
>>>> <ggrothendieck at gmail.com> wrote:
>>>>>
>>>>> The construct utils::head  is not that common but bare functions are
>>>>> very common and to make it harder to use the common case so that
>>>>> the uncommon case is slightly easier is not desirable.
>>>>>
>>>>> Also it is trivial to write this which does work:
>>>>>
>>>>> mtcars %>% (utils::head)
>>>>>
>>>>> On Sat, Dec 5, 2020 at 11:59 AM Hugh Parsonage <hugh.parsonage at gmail.com> wrote:
>>>>>>
>>>>>> I'm surprised by the aversion to
>>>>>>
>>>>>> mtcars |> nrow
>>>>>>
>>>>>> over
>>>>>>
>>>>>> mtcars |> nrow()
>>>>>>
>>>>>> and I think the decision to disallow the former should be
>>>>>> reconsidered.  The pipe operator is only going to be used when the rhs
>>>>>> is a function, so there is no ambiguity with omitting the parentheses.
>>>>>> If it's disallowed, it becomes inconsistent with other treatments like
>>>>>> sapply(mtcars, typeof) where sapply(mtcars, typeof()) would just be
>>>>>> noise.  I'm not sure why this decision was taken
>>>>>>
>>>>>> If the only issue is with the double (and triple) colon operator, then
>>>>>> ideally `mtcars |> base::head` should resolve to `base::head(mtcars)`
>>>>>> -- in other words, demote the precedence of |>
>>>>>>
>>>>>> Obviously (looking at the R-Syntax branch) this decision was
>>>>>> considered, put into place, then dropped, but I can't see why
>>>>>> precisely.
>>>>>>
>>>>>> Best,
>>>>>>
>>>>>>
>>>>>> Hugh.
>>>>>>
>>>>>>
>>>>>>
>>>>>>
>>>>>>
>>>>>>
>>>>>>
>>>>>> On Sat, 5 Dec 2020 at 04:07, Deepayan Sarkar <deepayan.sarkar at gmail.com> wrote:
>>>>>>>
>>>>>>> On Fri, Dec 4, 2020 at 7:35 PM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>>>>>>>>
>>>>>>>> On 04/12/2020 8:13 a.m., Hiroaki Yutani wrote:
>>>>>>>>>>     Error: function '::' not supported in RHS call of a pipe
>>>>>>>>>
>>>>>>>>> To me, this error looks much more friendly than magrittr's error.
>>>>>>>>> Some of them got too used to specify functions without (). This
>>>>>>>>> is OK until they use `::`, but when they need to use it, it takes
>>>>>>>>> hours to figure out why
>>>>>>>>>
>>>>>>>>> mtcars %>% base::head
>>>>>>>>> #> Error in .::base : unused argument (head)
>>>>>>>>>
>>>>>>>>> won't work but
>>>>>>>>>
>>>>>>>>> mtcars %>% head
>>>>>>>>>
>>>>>>>>> works. I think this is a too harsh lesson for ordinary R users to
>>>>>>>>> learn `::` is a function. I've been wanting for magrittr to drop the
>>>>>>>>> support for a function name without () to avoid this confusion,
>>>>>>>>> so I would very much welcome the new pipe operator's behavior.
>>>>>>>>> Thank you all the developers who implemented this!
>>>>>>>>
>>>>>>>> I agree, it's an improvement on the corresponding magrittr error.
>>>>>>>>
>>>>>>>> I think the semantics of not evaluating the RHS, but treating the pipe
>>>>>>>> as purely syntactical is a good decision.
>>>>>>>>
>>>>>>>> I'm not sure I like the recommended way to pipe into a particular argument:
>>>>>>>>
>>>>>>>>      mtcars |> subset(cyl == 4) |> \(d) lm(mpg ~ disp, data = d)
>>>>>>>>
>>>>>>>> or
>>>>>>>>
>>>>>>>>      mtcars |> subset(cyl == 4) |> function(d) lm(mpg ~ disp, data = d)
>>>>>>>>
>>>>>>>> both of which are equivalent to
>>>>>>>>
>>>>>>>>      mtcars |> subset(cyl == 4) |> (function(d) lm(mpg ~ disp, data = d))()
>>>>>>>>
>>>>>>>> It's tempting to suggest it should allow something like
>>>>>>>>
>>>>>>>>      mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
>>>>>>>
>>>>>>> Which is really not that far off from
>>>>>>>
>>>>>>> mtcars |> subset(cyl == 4) |> \(.) lm(mpg ~ disp, data = .)
>>>>>>>
>>>>>>> once you get used to it.
>>>>>>>
>>>>>>> One consequence of the implementation is that it's not clear how
>>>>>>> multiple occurrences of the placeholder would be interpreted. With
>>>>>>> magrittr,
>>>>>>>
>>>>>>> sort(runif(10)) %>% ecdf(.)(.)
>>>>>>> ## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
>>>>>>>
>>>>>>> This is probably what you would expect, if you expect it to work at all, and not
>>>>>>>
>>>>>>> ecdf(sort(runif(10)))(sort(runif(10)))
>>>>>>>
>>>>>>> There would be no such ambiguity with anonymous functions
>>>>>>>
>>>>>>> sort(runif(10)) |> \(.) ecdf(.)(.)
>>>>>>>
>>>>>>> -Deepayan
>>>>>>>
>>>>>>>> which would be expanded to something equivalent to the other versions:
>>>>>>>> but that makes it quite a bit more complicated.  (Maybe _ or \. should
>>>>>>>> be used instead of ., since those are not legal variable names.)
>>>>>>>>
>>>>>>>> I don't think there should be an attempt to copy magrittr's special
>>>>>>>> casing of how . is used in determining whether to also include the
>>>>>>>> previous value as first argument.
>>>>>>>>
>>>>>>>> Duncan Murdoch
>>>>>>>>
>>>>>>>>
>>>>>>>>>
>>>>>>>>> Best,
>>>>>>>>> Hiroaki Yutani
>>>>>>>>>
>>>>>>>>> 2020?12?4?(?) 20:51 Duncan Murdoch <murdoch.duncan at gmail.com>:
>>>>>>>>>>
>>>>>>>>>> Just saw this on the R-devel news:
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> R now provides a simple native pipe syntax ?|>? as well as a shorthand
>>>>>>>>>> notation for creating functions, e.g. ?\(x) x + 1? is parsed as
>>>>>>>>>> ?function(x) x + 1?. The pipe implementation as a syntax transformation
>>>>>>>>>> was motivated by suggestions from Jim Hester and Lionel Henry. These
>>>>>>>>>> features are experimental and may change prior to release.
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> This is a good addition; by using "|>" instead of "%>%" there should be
>>>>>>>>>> a chance to get operator precedence right.  That said, the ?Syntax help
>>>>>>>>>> topic hasn't been updated, so I'm not sure where it fits in.
>>>>>>>>>>
>>>>>>>>>> There are some choices that take a little getting used to:
>>>>>>>>>>
>>>>>>>>>>     > mtcars |> head
>>>>>>>>>> Error: The pipe operator requires a function call or an anonymous
>>>>>>>>>> function expression as RHS
>>>>>>>>>>
>>>>>>>>>> (I need to say mtcars |> head() instead.)  This sometimes leads to error
>>>>>>>>>> messages that are somewhat confusing:
>>>>>>>>>>
>>>>>>>>>>     > mtcars |> magrittr::debug_pipe |> head
>>>>>>>>>> Error: function '::' not supported in RHS call of a pipe
>>>>>>>>>>
>>>>>>>>>> but
>>>>>>>>>>
>>>>>>>>>> mtcars |> magrittr::debug_pipe() |> head()
>>>>>>>>>>
>>>>>>>>>> works.
>>>>>>>>>>
>>>>>>>>>> Overall, I think this is a great addition, though it's going to be
>>>>>>>>>> disruptive for a while.
>>>>>>>>>>
>>>>>>>>>> Duncan Murdoch
>>>>>>>>>>
>>>>>>>>>> ______________________________________________
>>>>>>>>>> R-devel at r-project.org mailing list
>>>>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>>>>
>>>>>>>>> ______________________________________________
>>>>>>>>> R-devel at r-project.org mailing list
>>>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>>>>
>>>>>>>>
>>>>>>>> ______________________________________________
>>>>>>>> R-devel at r-project.org mailing list
>>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>>
>>>>>>> ______________________________________________
>>>>>>> R-devel at r-project.org mailing list
>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>
>>>>>> ______________________________________________
>>>>>> R-devel at r-project.org mailing list
>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>
>>>>>
>>>>>
>>>>> --
>>>>> Statistics & Software Consulting
>>>>> GKX Group, GKX Associates Inc.
>>>>> tel: 1-877-GKX-GROUP
>>>>> email: ggrothendieck at gmail.com
>>>>
>>>>
>>>>
>>>> --
>>>> Statistics & Software Consulting
>>>> GKX Group, GKX Associates Inc.
>>>> tel: 1-877-GKX-GROUP
>>>> email: ggrothendieck at gmail.com
>>>>
>>>> ______________________________________________
>>>> R-devel at r-project.org mailing list
>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>>
>>
>> --
>> Statistics & Software Consulting
>> GKX Group, GKX Associates Inc.
>> tel: 1-877-GKX-GROUP
>> email: ggrothendieck at gmail.com
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>


From d@tr7320 @end|ng |rom un|@@ydney@edu@@u  Wed Dec  9 00:00:04 2020
From: d@tr7320 @end|ng |rom un|@@ydney@edu@@u (Dario Strbenac)
Date: Tue, 8 Dec 2020 23:00:04 +0000
Subject: [Rd] Ignore Sites Option For libPaths
Message-ID: <SYBPR01MB4761B85D4678C2CCB95E9988CDCD0@SYBPR01MB4761.ausprd01.prod.outlook.com>

Good day,

Could .libPaths gain an option to ignore all values other than the user-specified new parameter? Currently, it takes the union of new and .Library and .Library.site and there is no way to turn it off. For quick and convenient troubleshooting that doesn't involve requiring the editing of configuration files, it would be nice to be able to run .libPaths(.libPaths()[1], ignoreSiteFiles = TRUE) to limit to only one folder of R packages.

> .libPaths()
[1] "/dskh/nobackup/biostat/Rpackages/v4" "/usr/users/course/splus/library/R"
[3] "/usr/lib/R/site-library"             "/usr/lib/R/library"
> .libPaths(.libPaths()[1]) # No option to ignore system-wide folders.
> .libPaths() # Paths are same as before.
[1] "/dskh/nobackup/biostat/Rpackages/v4" "/usr/users/course/splus/library/R"
[3] "/usr/lib/R/site-library"             "/usr/lib/R/library"

--------------------------------------
Dario Strbenac
University of Sydney
Camperdown NSW 2050
Australia

From g@bembecker @end|ng |rom gm@||@com  Wed Dec  9 00:37:44 2020
From: g@bembecker @end|ng |rom gm@||@com (Gabriel Becker)
Date: Tue, 8 Dec 2020 15:37:44 -0800
Subject: [Rd] Ignore Sites Option For libPaths
In-Reply-To: <SYBPR01MB4761B85D4678C2CCB95E9988CDCD0@SYBPR01MB4761.ausprd01.prod.outlook.com>
References: <SYBPR01MB4761B85D4678C2CCB95E9988CDCD0@SYBPR01MB4761.ausprd01.prod.outlook.com>
Message-ID: <CAD4oTHHgdjWnMsKHvXGUxcjumfdcgpNVpcdjqNWDvzGJN3uMxg@mail.gmail.com>

Hi Dario,

My switchr package is designed specifically to do what you're describing,
and does support excluding site libraries. So clearly I agree it would be
useful, but also, it does go against the "concept" of site libraries
somewhat.

I agree it would be a useful addition with the default to including them,
personally. And the patch would be pretty easy to put together. I can put
together a patch and add it to bugzilla as a wishlist item and we'll see
what thoughts are (unless I hear an emphatic no here, in which case I won't
bother, or unless you'd like to take a crack at it yourself).

~G

On Tue, Dec 8, 2020 at 3:00 PM Dario Strbenac <dstr7320 at uni.sydney.edu.au>
wrote:

> Good day,
>
> Could .libPaths gain an option to ignore all values other than the
> user-specified new parameter? Currently, it takes the union of new and
> .Library and .Library.site and there is no way to turn it off. For quick
> and convenient troubleshooting that doesn't involve requiring the editing
> of configuration files, it would be nice to be able to run
> .libPaths(.libPaths()[1], ignoreSiteFiles = TRUE) to limit to only one
> folder of R packages.
>
> > .libPaths()
> [1] "/dskh/nobackup/biostat/Rpackages/v4"
> "/usr/users/course/splus/library/R"
> [3] "/usr/lib/R/site-library"             "/usr/lib/R/library"
> > .libPaths(.libPaths()[1]) # No option to ignore system-wide folders.
> > .libPaths() # Paths are same as before.
> [1] "/dskh/nobackup/biostat/Rpackages/v4"
> "/usr/users/course/splus/library/R"
> [3] "/usr/lib/R/site-library"             "/usr/lib/R/library"
>
> --------------------------------------
> Dario Strbenac
> University of Sydney
> Camperdown NSW 2050
> Australia
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From edd @end|ng |rom deb|@n@org  Wed Dec  9 01:07:40 2020
From: edd @end|ng |rom deb|@n@org (Dirk Eddelbuettel)
Date: Tue, 8 Dec 2020 18:07:40 -0600
Subject: [Rd] Ignore Sites Option For libPaths
In-Reply-To: <SYBPR01MB4761B85D4678C2CCB95E9988CDCD0@SYBPR01MB4761.ausprd01.prod.outlook.com>
References: <SYBPR01MB4761B85D4678C2CCB95E9988CDCD0@SYBPR01MB4761.ausprd01.prod.outlook.com>
Message-ID: <24528.5452.10417.544814@rob.eddelbuettel.com>


On 8 December 2020 at 23:00, Dario Strbenac wrote:
| Could .libPaths gain an option to ignore all values other than the user-specified new parameter? Currently, it takes the union of new and .Library and .Library.site and there is no way to turn it off. 

Are you use? It is constructed from looking at environment variables you could set.

  edd at rob:~$ R_LIBS="/tmp" R_LIBS_SITE="/var" Rscript -e 'print(.libPaths())'
  [1] "/tmp"               "/var"               "/usr/lib/R/library"
  edd at rob:~$ 

Dirk

-- 
https://dirk.eddelbuettel.com | @eddelbuettel | edd at debian.org


From g@bembecker @end|ng |rom gm@||@com  Wed Dec  9 02:09:57 2020
From: g@bembecker @end|ng |rom gm@||@com (Gabriel Becker)
Date: Tue, 8 Dec 2020 17:09:57 -0800
Subject: [Rd] Ignore Sites Option For libPaths
In-Reply-To: <24528.5452.10417.544814@rob.eddelbuettel.com>
References: <SYBPR01MB4761B85D4678C2CCB95E9988CDCD0@SYBPR01MB4761.ausprd01.prod.outlook.com>
 <24528.5452.10417.544814@rob.eddelbuettel.com>
Message-ID: <CAD4oTHEYZiAs6eM=hprwGo+=5ut1fbqRETacE1OViOiBHw5A3Q@mail.gmail.com>

Of course you can, but the ability to do something via R code and the
ability to do them by wrapping the invocation of R are not similar terms of
convenience, IMO.

I say that as someone who routinely does both type of thing.

~G

On Tue, Dec 8, 2020 at 4:07 PM Dirk Eddelbuettel <edd at debian.org> wrote:

>
> On 8 December 2020 at 23:00, Dario Strbenac wrote:
> | Could .libPaths gain an option to ignore all values other than the
> user-specified new parameter? Currently, it takes the union of new and
> .Library and .Library.site and there is no way to turn it off.
>
> Are you use? It is constructed from looking at environment variables you
> could set.
>
>   edd at rob:~$ R_LIBS="/tmp" R_LIBS_SITE="/var" Rscript -e
> 'print(.libPaths())'
>   [1] "/tmp"               "/var"               "/usr/lib/R/library"
>   edd at rob:~$
>
> Dirk
>
> --
> https://dirk.eddelbuettel.com | @eddelbuettel | edd at debian.org
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From d@tr7320 @end|ng |rom un|@@ydney@edu@@u  Wed Dec  9 03:00:03 2020
From: d@tr7320 @end|ng |rom un|@@ydney@edu@@u (Dario Strbenac)
Date: Wed, 9 Dec 2020 02:00:03 +0000
Subject: [Rd] Ignore Sites Option For libPaths
In-Reply-To: <24528.5452.10417.544814@rob.eddelbuettel.com>
References: <SYBPR01MB4761B85D4678C2CCB95E9988CDCD0@SYBPR01MB4761.ausprd01.prod.outlook.com>,
 <24528.5452.10417.544814@rob.eddelbuettel.com>
Message-ID: <SYBPR01MB4761B1924B1D1F29B8A33F8FCDCC0@SYBPR01MB4761.ausprd01.prod.outlook.com>

Good day,

That seems like a straightforward and reasonable thing to do, but:

~$ R_LIBS="/tmp" R_LIBS_SITE="/var" Rscript -e 'print(.libPaths())'
[1] "/dora/nobackup/biostat/Rpackages/v4" "/dora/users/course/splus/library/R" 
[3] "/usr/lib/R/site-library"             "/usr/lib/R/library"

/tmp and /var exist of course.

--------------------------------------
Dario Strbenac
University of Sydney
Camperdown NSW 2050
Australia

From edd @end|ng |rom deb|@n@org  Wed Dec  9 03:14:18 2020
From: edd @end|ng |rom deb|@n@org (Dirk Eddelbuettel)
Date: Tue, 8 Dec 2020 20:14:18 -0600
Subject: [Rd] Ignore Sites Option For libPaths
In-Reply-To: <SYBPR01MB4761B1924B1D1F29B8A33F8FCDCC0@SYBPR01MB4761.ausprd01.prod.outlook.com>
References: <SYBPR01MB4761B85D4678C2CCB95E9988CDCD0@SYBPR01MB4761.ausprd01.prod.outlook.com>
 <24528.5452.10417.544814@rob.eddelbuettel.com>
 <SYBPR01MB4761B1924B1D1F29B8A33F8FCDCC0@SYBPR01MB4761.ausprd01.prod.outlook.com>
Message-ID: <24528.13050.93732.939622@rob.eddelbuettel.com>


On 9 December 2020 at 02:00, Dario Strbenac wrote:
| That seems like a straightforward and reasonable thing to do, but:
| 
| ~$ R_LIBS="/tmp" R_LIBS_SITE="/var" Rscript -e 'print(.libPaths())'
| [1] "/dora/nobackup/biostat/Rpackages/v4" "/dora/users/course/splus/library/R" 
| [3] "/usr/lib/R/site-library"             "/usr/lib/R/library"

Hm. Maybe you have code in RHOME/etc/* or in HOME to set some of these?

The (very detailed) description of what happens when is in help(Startup)
which is a great resource but as dense as they get. My example came from my
Ubuntu 20.04 box where I set nothing apart from not using a ~/R/ path.

Also try "R -q -e 'print(.libPaths())'" with these switches to narrow it down:

  --no-environ          Don't read the site and user environment files
  --no-site-file        Don't read the site-wide Rprofile                 
  --no-init-file        Don't read the user R profile

| /tmp and /var exist of course.

Right, I didn't stress that but the choice made it clear.  I still think you
should be able to tune this with just base R.

Cheers, Dirk

-- 
https://dirk.eddelbuettel.com | @eddelbuettel | edd at debian.org


From M@rk@Br@v|ngton @end|ng |rom d@t@61@c@|ro@@u  Wed Dec  9 07:01:05 2020
From: M@rk@Br@v|ngton @end|ng |rom d@t@61@c@|ro@@u (Bravington, Mark (Data61, Hobart))
Date: Wed, 9 Dec 2020 06:01:05 +0000
Subject: [Rd] New pipe operator
In-Reply-To: <34c419e1-7fea-61e1-2e5b-05f40b8c768a@gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
 <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
 <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>
 <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>
 <MEAPR01MB2407865F5622461515F409EDB4CE0@MEAPR01MB2407.ausprd01.prod.outlook.com>
 <5179b8d4-628e-ff73-fa53-92fe942e12ea@gmail.com>
 <MEAPR01MB240762B89E5DCF1CF23B09B5B4CD0@MEAPR01MB2407.ausprd01.prod.outlook.com>,
 <34c419e1-7fea-61e1-2e5b-05f40b8c768a@gmail.com>
Message-ID: <MEAPR01MB24074424174210310BE02B5FB4CC0@MEAPR01MB2407.ausprd01.prod.outlook.com>

> [Duncan Murdoch responding to...]
> [... Mark Bravington's proposals for placeholders and anonymous functions]
> > x |> foo( _PIPE_)                  # placeholder
> > x |> bah( otherarg, _PIPE_)        # placeholder
> > x |> { y <- _PIPE_+1; _PIPE_ / y } # anonymous function

> [DM] About your proposal [specifically, the anonymous function bit]:

> I don't find it attractive, but I can see that some people would.  But I
> don't think it's necessary to put it into the base parser.  Other than
> using an illegal name, there doesn't seem to be a reason you couldn't
> write a small function to convert your placeholder proposal to a call to
> a function.  So instead of typing

>   x |> { y <- _PIPE_+1; _PIPE_ / y }

> you would type

>   x |> forpipe({ y <- PIPE_+1; PIPE_ / y })

> I don't think "forpipe" is the right name here.  I proposed a generic
> "as.call" before, but I don't like that one either.  I'm still trying to
> think of a good name, and whether or not it makes sense for it to be
> generic.

Right, yes. Actually that was part of my first email: I had

x |> _ANON_({ y <- _PIPE_+1; _PIPE_ / y })

I deliberately picked otherwise-illegal names, to prevent extrapipular abuse, but that's not a big deal. Second email gives that option as well as curly-brace version.

It's true that there's no *need* to change the base parser in order to get the functionality of your 'forpipe' / my '_ANON_'--- but pipes are really about convenience, so "need" becomes quite subjective; perhaps the curly-brace version, or something else, is attractive enough to warrant it (I don't know). And it seems like the new pipe-aware parser is already having to deal differently with expressions inside a pipe vs outside.

However, I was also discussing non-anonymous function calls in pipes, and arguing that they should require (or at least be able to use) a reserved-word placeholder (PIPE_ or whatever)--- EG

x |> match( LETTERS, _PIPE_) # non-first arg

So that's a separate part of my proposal.

If I was king I actually wouldn't let people do

x |> head

and would force them instead to do 

x |> head( _PIPE_)

but, clearly, I am not.

> But the point is that we don't need to choose just one from all the
> proposed replacements for anonymous function syntax, we can try them out
> and see which ones we like.  We might end up with more than one (like we
> have at least 4 different high level graphics paradigms!), and that's
> not the end of the world.

Good point. Multiple options is no disaster, and experiments are excellent--- though once things get embedded in R, it's hard to pull them out... 

However, aren't we limited to experimenting within the confines of the current pipe-aware parser? Many of the suggestions on this topic seem to go beyond that (including mine). EG I *think*, subject to correction, that

 - you're right that 'forpipe'/'_ANON_' can be implemented to work with the current pipe-aware parser
 
 - But, the curly-brace version would require a parser change
 
 - and the use of a reserved-word placeholder also isn't possible as-is
 
If there's some way to try those things out, it would be great.

cheers
Mark


Mark Bravington
CSIRO Marine Lab
Hobart
Australia


________________________________________
From: Duncan Murdoch <murdoch.duncan at gmail.com>
Sent: Wednesday, 9 December 2020 09:28
To: Bravington, Mark (Data61, Hobart); Gabor Grothendieck; Gabriel Becker
Cc: r-devel at r-project.org
Subject: Re: [Rd] New pipe operator

First, one comment:

You're right about the illegality of _PIPE_ as a name, I had
misremembered the rule.

About your proposal:

I don't find it attractive, but I can see that some people would.  But I
don't think it's necessary to put it into the base parser.  Other than
using an illegal name, there doesn't seem to be a reason you couldn't
write a small function to convert your placeholder proposal to a call to
a function.  So instead of typing

  x |> { y <- _PIPE_+1; _PIPE_ / y }

you would type

  x |> forpipe({ y <- PIPE_+1; PIPE_ / y })

I don't think "forpipe" is the right name here.  I proposed a generic
"as.call" before, but I don't like that one either.  I'm still trying to
think of a good name, and whether or not it makes sense for it to be
generic.

But the point is that we don't need to choose just one from all the
proposed replacements for anonymous function syntax, we can try them out
and see which ones we like.  We might end up with more than one (like we
have at least 4 different high level graphics paradigms!), and that's
not the end of the world.

Duncan Murdoch

On 08/12/2020 4:26 p.m., Bravington, Mark (Data61, Hobart) wrote:
>>> On 06/12/2020 8:22 p.m., Bravington, Mark (Data61, Hobart) wrote:
>> (and Duncan Murdoch responded, as below)
>
> It still seems to me that placeholders are viable and unambiguous (only as things in RHS of pipes), and that something like
>
> x |> foo( _PIPE_)
> x |> bah( otherarg, _PIPE_)
> x |> { y <- _PIPE_+1; _PIPE_ / y } # anonymous function
>
> would be a viable solution that doesn't break syntax. This suggestion expands slightly on my previous post, to deal with anonymous functions without either ugly or cumbersome syntax. Specifically, the parser could expand curly-braces in a pipe RHS like this:
>
> x |> {expr}
>
> into
>
> _ANON_( _PIPE_, {expr})( x)
>
> where '_ANON_' itself  constructs-and-calls a function with one argument called '_PIPE_' whose body consists of 'expr' (which presumably refers to '_PIPE_')
>
> No new weird operators like \(, and the only break with normal syntax is the expansion of curly-braces--- plus treating one symbol, _PIPE_ or any other pre-agreed one perhaps even just _, as a legal name inside a pipe.
>
> Now back to my previous post and responding to Duncan's comments:
>
>>>    - I don't see the problem with a placeholder--- doesn't it remove all ambiguity? Sure there needs to be a standard unclashable name and people can argue about what that should be, but the following seems clear and flexible... to me, anyway:
>>>
>>>    thing |>
>>>      foo( _PIPE_) |>           # standard
>>>      bah( arg1, _PIPE_) |>   # multi-arg function
>>>      _ANON_({ x <- sum( _PIPE_); _PIPE_/x + x/_PIPE_ })   # anon function
>>>
>>> where '_PIPE_' is the ordained name of the placeholder, and '_ANON_' constructs-and-calls a function with single argument '_PIPE_'. There is just one rule (I think...): each pipe-stage must be a *call* involving the argument '_PIPE_'.
>
> and (see end) I think the line with _ANON_ above could in fact just be
>
>    ... |> { x <- sum( _PIPE_); _PIPE_/x + x/_PIPE_ }
>
>> I believe there's no ambiguity if the placeholder is *only* allowed in the RHS of a pipe expression.
>
> Yes--- that's my suggestion: there and only there. Hence an otherwise-illegal name like _PIPE_.
>
>> I think the ambiguity arises if you allow
>> the same syntax to be used to generate anonymous functions.
>
> Agreed; don't allow that outside of pipes.
>
>> We can't use _PIPE_ as the placeholder, because it's a legal name.
>
> Surely _PIPE_ is not a legal R name though? Not in my R4.1.0dev, anyway. Of course, the parser can _make_ it legal *only* in the context of RHS of pipe. Anyway, I'm not suggesting the names must be _PIPE_ and _ANON_--- the name is secondary to the concept.
>
>> But we could use _.
>
> Yes, any unclashable name would do--- though "_" is hard to read (as per complaints about "." as placeholder, which I use in my own code). And I remember back when R decided to disallow "_" as an assignment operator. Which forced me to change about 50000 lines of code that wasn't stored in text files, so I wasn't happy--- and the only reason that was ever given to me, was "it's ugly" ! Which is kinda true.
>
>> However, implementing this makes the parser pretty ugly: its handling of _ depends on the outer context.
>
> That context issue is already the case under the current proposal though; eg 'head(10)' in
>
> x |> head(10) # really head( <arg>, 10)
>
> or indeed 'head' in
>
> x |> head # actually a call to head(<arg>), not a symbol
>
>
>> I now agree that leaving out placeholder syntax was the right decision.
>
> Others are not so sure!
>
> Re operator precedence: thanks for pointing that out, I accept that R's current operator-precedence rules make it impossible for people to cleanly implement their own preferred homemade %my_pipe_op%.
>
> All the more reason to be careful with the pipe syntax choice for base-R, of course...
>
>
>> Then
>
>>     x |> (_ + 1) + mean(_)
>
>> could expand unambiguously to
>
>>     (function(_) (_  + 1) + mean(_))(x)
>
>> but
>
>>     (_ + 1) + mean(_)
>
>> shouldn't be taken to be an anonymous function declaration, otherwise
>> things like
>
>>     mean(_ |> _)
>
>> do become ambiguous:  is the second placeholder the argument to the anon
>> function, or is it the placeholder for the embedded pipe?
>
> That wouldn't be allowed in my proposal; the "_ |> _" is illegal because the RHS is not a call. For the whole thing, I'd require
>
> x |> _ANON_((_PIPE_ + 1) + mean( _PIPE_))
>
> or the just-curly version
>
> x |> { (_PIPE_ + 1) + mean( _PIPE_)}
>
> but with the implication that this would parse out to
>
> (`_ANON_`( { (_PIPE_ + 1) + mean( _PIPE_)}))( x)
>
>>> [*] Definition of _ANON_ could be something like this--- almost certainly won't work as-is, this is just to point out that it could be done in standard R.
>
>>> `_ANON_` <- function( expr) {
>>>    #1. Construct a function with arg '_PIPE_' and body 'expr'
>>>    #2. Construct a call() to that function
>>>    #3. Do the call
>
>>>    f <- function( `_PIPE_`) NULL
>>>    body( f) <- expr
>>>    environment( f) <- parent.frame() # or something... yes these details are almost certainly wrong
>>>    expr2 <- substitute( f( `_PIPE_`)) # or something...
>>>    eval.parent( expr2) # or something...
>>> }
>
>
> Mark Bravington
> CSIRO Marine Lab
> Hobart
> Australia
>
>
> ________________________________________
> From: Duncan Murdoch <murdoch.duncan at gmail.com>
> Sent: Monday, 7 December 2020 21:31
> To: Bravington, Mark (Data61, Hobart); Gabor Grothendieck; Gabriel Becker
> Cc: r-devel at r-project.org
> Subject: Re: [Rd] New pipe operator
>
> On 06/12/2020 8:22 p.m., Bravington, Mark (Data61, Hobart) wrote:
>> Seems like this *could* be a good thing, and thanks to R core for considering it. But, FWIW:
>>
>>    - I agree with Gabor G that consistency of "syntax" should be paramount here. Enough problems have been caused by earlier superficially-convenient non-standard features in R.  In particular:
>>
>>    -- there should not be any discrepancy between an in-place function-definition, and a predefined function attached to a symbol (as per Gabor's point).
>>
>>    -- Hence, the ability to say x |> foo  ie without parentheses, seems bound to lead to inconsistency, because x |> foo is allowed, x |> base::foo isn't allowed without tricks, but x |> function( y) foo( y) isn't... So, x |> foo is not worth keeping. Parentheses are a price well worth paying.
>>
>>    -- it is still inconsistent and confusing to (apparently) invoke a function in some places--- normally--- via 'foo(x)', yet in others--- pipily--- via 'foo()'. Especially if 'foo' already has a default value for its first argument.
>>
>>    - I don't see the problem with a placeholder--- doesn't it remove all ambiguity? Sure there needs to be a standard unclashable name and people can argue about what that should be, but the following seems clear and flexible... to me, anyway:
>>
>>    thing |>
>>      foo( _PIPE_) |>           # standard
>>      bah( arg1, _PIPE_) |>   # multi-arg function
>>      _ANON_({ x <- sum( _PIPE_); _PIPE_/x + x/_PIPE_ })   # anon function
>>
>> where '_PIPE_' is the ordained name of the placeholder, and '_ANON_' constructs-and-calls a function with single argument '_PIPE_'. There is just one rule (I think...): each pipe-stage must be a *call* involving the argument '_PIPE_'.
>
> I believe there's no ambiguity if the placeholder is *only* allowed in
> the RHS of a pipe expression.  I think the ambiguity arises if you allow
> the same syntax to be used to generate anonymous functions.  We can't
> use _PIPE_ as the placeholder, because it's a legal name.  But we could
> use _.  Then
>
>     x |> (_ + 1) + mean(_)
>
> could expand unambiguously to
>
>     (function(_) (_  + 1) + mean(_))(x)
>
> but
>
>     (_ + 1) + mean(_)
>
> shouldn't be taken to be an anonymous function declaration, otherwise
> things like
>
>     mean(_ |> _)
>
> do become ambiguous:  is the second placeholder the argument to the anon
> function, or is it the placeholder for the embedded pipe?
>
> However, implementing this makes the parser pretty ugly:  its handling
> of _ depends on the outer context.  I now agree that leaving out
> placeholder syntax was the right decision.
>
>
>>
>>
>>    - The proposed anonymous-function syntax looks quite ugly to me, diminishing readability and inviting errors. The new pipe symbol |> already looks scarily like quantum mechanics; adding \( just puts fishbones into the symbolic soup.
>>
>>    - IMO it's not worth going too far to try to lure magritter-etc fans to swap to the new; my experience is that many people keep using older inferior R syntax for years after better replacements become available (even if they are aware of replacements), for various reasons. Just provide a good framework, and let nature take its course.
>>
>>    - Disclaimer: personally I'm not much of a pipehead anyway, so maybe I'm not the audience. But if I was to consider piping, I wouldn't be very tempted by the current proposal. OTOH, I might even be tempted to write--- and use!--- my own version of '%|>%' as above (maybe someone already has). And if R did it for me, that'd be great :)
>
> Yours would suffer one of the same problems as magrittr's:  it has the
> wrong operator precedence.  The current precedence ordering (from
> ?Syntax) is, from highest to lowest:
>
>
> :: :::  access variables in a namespace
> $ @     component / slot extraction
> [ [[    indexing
> ^       exponentiation (right to left)
> - +     unary minus and plus
> :       sequence operator
> %any%   special operators (including %% and %/%)
> * /     multiply, divide
> + -     (binary) add, subtract
> < > <= >= == != ordering and comparison
> !       negation
> & &&    and
> | ||    or
> ~       as in formulae
> -> ->>  rightwards assignment
> <- <<-  assignment (right to left)
> =       assignment (right to left)
> ?       help (unary and binary)
>
>
> The %>% operator has higher precedence than the arithmetic operators, so
>
> x*y %>% f()
>
> is equivalent to x*f(y), not
>
> f(x*y)
>
> as it should "obviously" be.  I believe the new |> operator falls
> between "| ||" and "~", so
>
> x || y |> f()
>
> is the same as f(x || y), and
>
> x ~ y |> f()
>
> is x ~ f(y).   There could be arguments about where the new one appears
> (and there probably have been), but *clearly* magrittr's precedence is
> wrong, and yours would be too, because they are both fixed at the quite
> high precedence given to %any%.
>
> Duncan Murdoch
>
>>
>> [*] Definition of _ANON_ could be something like this--- almost certainly won't work as-is, this is just to point out that it could be done in standard R.
>>
>> `_ANON_` <- function( expr) {
>>     #1. Construct a function with arg '_PIPE_' and body 'expr'
>>     #2. Construct a call() to that function
>>     #3. Do the call
>>
>>     f <- function( `_PIPE_`) NULL
>>     body( f) <- expr
>>     environment( f) <- parent.frame() # or something... yes these details are almost certainly wrong
>>     expr2 <- substitute( f( `_PIPE_`)) # or something...
>>     eval.parent( expr2) # or something...
>> }
>>
>> cheers
>> Mark
>>
>> Mark Bravington
>> CSIRO Marine Lab
>> Hobart
>> Australia
>>
>>
>> ________________________________________
>> From: R-devel <r-devel-bounces at r-project.org> on behalf of Gabor Grothendieck <ggrothendieck at gmail.com>
>> Sent: Monday, 7 December 2020 10:21
>> To: Gabriel Becker
>> Cc: r-devel at r-project.org
>> Subject: Re: [Rd] New pipe operator
>>
>> I understand very well that it is implemented at the syntax level;
>> however, in any case the implementation is irrelevant to the principles.
>>
>> Here a similar example to the one I gave before but this time written out:
>>
>> This works:
>>
>>     3 |> function(x) x + 1
>>
>> but this does not:
>>
>>     foo <- function(x) x + 1
>>     3 |> foo
>>
>> so it breaks the principle of functions being first class objects.  foo and its
>> definition are not interchangeable.  You have
>> to write 3 |> foo() but don't have to write 3 |> (function(x) x + 1)().
>>
>> This isn't just a matter of notation, i.e. foo vs foo(), but is a
>> matter of breaking
>> the way R works as a functional language with first class functions.
>>
>> On Sun, Dec 6, 2020 at 4:06 PM Gabriel Becker <gabembecker at gmail.com> wrote:
>>>
>>> Hi Gabor,
>>>
>>> On Sun, Dec 6, 2020 at 12:52 PM Gabor Grothendieck <ggrothendieck at gmail.com> wrote:
>>>>
>>>> I think the real issue here is that functions are supposed to be
>>>> first class objects in R
>>>> or are supposed to be and |> would break that if if is possible
>>>> to write function(x) x + 1 on the RHS but not foo (assuming foo
>>>> was defined as that function).
>>>>
>>>> I don't think getting experience with using it can change that
>>>> inconsistency which seems serious to me and needs to
>>>> be addressed even if it complicates the implementation
>>>> since it drives to the heart of what R is.
>>>>
>>>
>>> With respect I think this is a misunderstanding of what is happening here.
>>>
>>> Functions are first class citizens. |> is, for all intents and purposes, a macro.
>>>
>>> LHS |> RHS(arg2=5)
>>>
>>> parses to
>>>
>>> RHS(LHS, arg2 = 5)
>>>
>>> There are no functions at the point in time when the pipe transformation happens, because no code has been evaluated. To know if a symbol is going to evaluate to a function requires evaluation which is a step entirely after the one where the |> pipe is implemented.
>>>
>>> Another way to think about it is that
>>>
>>> LHS |> RHS(arg2 = 5)
>>>
>>> is another way of writing RHS(LHS, arg2 = 5), NOT R code that is (or even can be) evaluated.
>>>
>>>
>>> Now this is a subtle point that only really has implications in as much as it is not the case for magrittr pipes, but its relevant for discussions like this, I think.
>>>
>>> ~G
>>>
>>>> On Sat, Dec 5, 2020 at 1:08 PM Gabor Grothendieck
>>>> <ggrothendieck at gmail.com> wrote:
>>>>>
>>>>> The construct utils::head  is not that common but bare functions are
>>>>> very common and to make it harder to use the common case so that
>>>>> the uncommon case is slightly easier is not desirable.
>>>>>
>>>>> Also it is trivial to write this which does work:
>>>>>
>>>>> mtcars %>% (utils::head)
>>>>>
>>>>> On Sat, Dec 5, 2020 at 11:59 AM Hugh Parsonage <hugh.parsonage at gmail.com> wrote:
>>>>>>
>>>>>> I'm surprised by the aversion to
>>>>>>
>>>>>> mtcars |> nrow
>>>>>>
>>>>>> over
>>>>>>
>>>>>> mtcars |> nrow()
>>>>>>
>>>>>> and I think the decision to disallow the former should be
>>>>>> reconsidered.  The pipe operator is only going to be used when the rhs
>>>>>> is a function, so there is no ambiguity with omitting the parentheses.
>>>>>> If it's disallowed, it becomes inconsistent with other treatments like
>>>>>> sapply(mtcars, typeof) where sapply(mtcars, typeof()) would just be
>>>>>> noise.  I'm not sure why this decision was taken
>>>>>>
>>>>>> If the only issue is with the double (and triple) colon operator, then
>>>>>> ideally `mtcars |> base::head` should resolve to `base::head(mtcars)`
>>>>>> -- in other words, demote the precedence of |>
>>>>>>
>>>>>> Obviously (looking at the R-Syntax branch) this decision was
>>>>>> considered, put into place, then dropped, but I can't see why
>>>>>> precisely.
>>>>>>
>>>>>> Best,
>>>>>>
>>>>>>
>>>>>> Hugh.
>>>>>>
>>>>>>
>>>>>>
>>>>>>
>>>>>>
>>>>>>
>>>>>>
>>>>>> On Sat, 5 Dec 2020 at 04:07, Deepayan Sarkar <deepayan.sarkar at gmail.com> wrote:
>>>>>>>
>>>>>>> On Fri, Dec 4, 2020 at 7:35 PM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>>>>>>>>
>>>>>>>> On 04/12/2020 8:13 a.m., Hiroaki Yutani wrote:
>>>>>>>>>>     Error: function '::' not supported in RHS call of a pipe
>>>>>>>>>
>>>>>>>>> To me, this error looks much more friendly than magrittr's error.
>>>>>>>>> Some of them got too used to specify functions without (). This
>>>>>>>>> is OK until they use `::`, but when they need to use it, it takes
>>>>>>>>> hours to figure out why
>>>>>>>>>
>>>>>>>>> mtcars %>% base::head
>>>>>>>>> #> Error in .::base : unused argument (head)
>>>>>>>>>
>>>>>>>>> won't work but
>>>>>>>>>
>>>>>>>>> mtcars %>% head
>>>>>>>>>
>>>>>>>>> works. I think this is a too harsh lesson for ordinary R users to
>>>>>>>>> learn `::` is a function. I've been wanting for magrittr to drop the
>>>>>>>>> support for a function name without () to avoid this confusion,
>>>>>>>>> so I would very much welcome the new pipe operator's behavior.
>>>>>>>>> Thank you all the developers who implemented this!
>>>>>>>>
>>>>>>>> I agree, it's an improvement on the corresponding magrittr error.
>>>>>>>>
>>>>>>>> I think the semantics of not evaluating the RHS, but treating the pipe
>>>>>>>> as purely syntactical is a good decision.
>>>>>>>>
>>>>>>>> I'm not sure I like the recommended way to pipe into a particular argument:
>>>>>>>>
>>>>>>>>      mtcars |> subset(cyl == 4) |> \(d) lm(mpg ~ disp, data = d)
>>>>>>>>
>>>>>>>> or
>>>>>>>>
>>>>>>>>      mtcars |> subset(cyl == 4) |> function(d) lm(mpg ~ disp, data = d)
>>>>>>>>
>>>>>>>> both of which are equivalent to
>>>>>>>>
>>>>>>>>      mtcars |> subset(cyl == 4) |> (function(d) lm(mpg ~ disp, data = d))()
>>>>>>>>
>>>>>>>> It's tempting to suggest it should allow something like
>>>>>>>>
>>>>>>>>      mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
>>>>>>>
>>>>>>> Which is really not that far off from
>>>>>>>
>>>>>>> mtcars |> subset(cyl == 4) |> \(.) lm(mpg ~ disp, data = .)
>>>>>>>
>>>>>>> once you get used to it.
>>>>>>>
>>>>>>> One consequence of the implementation is that it's not clear how
>>>>>>> multiple occurrences of the placeholder would be interpreted. With
>>>>>>> magrittr,
>>>>>>>
>>>>>>> sort(runif(10)) %>% ecdf(.)(.)
>>>>>>> ## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
>>>>>>>
>>>>>>> This is probably what you would expect, if you expect it to work at all, and not
>>>>>>>
>>>>>>> ecdf(sort(runif(10)))(sort(runif(10)))
>>>>>>>
>>>>>>> There would be no such ambiguity with anonymous functions
>>>>>>>
>>>>>>> sort(runif(10)) |> \(.) ecdf(.)(.)
>>>>>>>
>>>>>>> -Deepayan
>>>>>>>
>>>>>>>> which would be expanded to something equivalent to the other versions:
>>>>>>>> but that makes it quite a bit more complicated.  (Maybe _ or \. should
>>>>>>>> be used instead of ., since those are not legal variable names.)
>>>>>>>>
>>>>>>>> I don't think there should be an attempt to copy magrittr's special
>>>>>>>> casing of how . is used in determining whether to also include the
>>>>>>>> previous value as first argument.
>>>>>>>>
>>>>>>>> Duncan Murdoch
>>>>>>>>
>>>>>>>>
>>>>>>>>>
>>>>>>>>> Best,
>>>>>>>>> Hiroaki Yutani
>>>>>>>>>
>>>>>>>>> 2020?12?4?(?) 20:51 Duncan Murdoch <murdoch.duncan at gmail.com>:
>>>>>>>>>>
>>>>>>>>>> Just saw this on the R-devel news:
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> R now provides a simple native pipe syntax '|>' as well as a shorthand
>>>>>>>>>> notation for creating functions, e.g. '\(x) x + 1' is parsed as
>>>>>>>>>> 'function(x) x + 1'. The pipe implementation as a syntax transformation
>>>>>>>>>> was motivated by suggestions from Jim Hester and Lionel Henry. These
>>>>>>>>>> features are experimental and may change prior to release.
>>>>>>>>>>
>>>>>>>>>>
>>>>>>>>>> This is a good addition; by using "|>" instead of "%>%" there should be
>>>>>>>>>> a chance to get operator precedence right.  That said, the ?Syntax help
>>>>>>>>>> topic hasn't been updated, so I'm not sure where it fits in.
>>>>>>>>>>
>>>>>>>>>> There are some choices that take a little getting used to:
>>>>>>>>>>
>>>>>>>>>>     > mtcars |> head
>>>>>>>>>> Error: The pipe operator requires a function call or an anonymous
>>>>>>>>>> function expression as RHS
>>>>>>>>>>
>>>>>>>>>> (I need to say mtcars |> head() instead.)  This sometimes leads to error
>>>>>>>>>> messages that are somewhat confusing:
>>>>>>>>>>
>>>>>>>>>>     > mtcars |> magrittr::debug_pipe |> head
>>>>>>>>>> Error: function '::' not supported in RHS call of a pipe
>>>>>>>>>>
>>>>>>>>>> but
>>>>>>>>>>
>>>>>>>>>> mtcars |> magrittr::debug_pipe() |> head()
>>>>>>>>>>
>>>>>>>>>> works.
>>>>>>>>>>
>>>>>>>>>> Overall, I think this is a great addition, though it's going to be
>>>>>>>>>> disruptive for a while.
>>>>>>>>>>
>>>>>>>>>> Duncan Murdoch
>>>>>>>>>>
>>>>>>>>>> ______________________________________________
>>>>>>>>>> R-devel at r-project.org mailing list
>>>>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>>>>
>>>>>>>>> ______________________________________________
>>>>>>>>> R-devel at r-project.org mailing list
>>>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>>>>
>>>>>>>>
>>>>>>>> ______________________________________________
>>>>>>>> R-devel at r-project.org mailing list
>>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>>
>>>>>>> ______________________________________________
>>>>>>> R-devel at r-project.org mailing list
>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>
>>>>>> ______________________________________________
>>>>>> R-devel at r-project.org mailing list
>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>
>>>>>
>>>>>
>>>>> --
>>>>> Statistics & Software Consulting
>>>>> GKX Group, GKX Associates Inc.
>>>>> tel: 1-877-GKX-GROUP
>>>>> email: ggrothendieck at gmail.com
>>>>
>>>>
>>>>
>>>> --
>>>> Statistics & Software Consulting
>>>> GKX Group, GKX Associates Inc.
>>>> tel: 1-877-GKX-GROUP
>>>> email: ggrothendieck at gmail.com
>>>>
>>>> ______________________________________________
>>>> R-devel at r-project.org mailing list
>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>>
>>
>> --
>> Statistics & Software Consulting
>> GKX Group, GKX Associates Inc.
>> tel: 1-877-GKX-GROUP
>> email: ggrothendieck at gmail.com
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>



From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Wed Dec  9 09:49:46 2020
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Wed, 9 Dec 2020 09:49:46 +0100
Subject: [Rd] Ignore Sites Option For libPaths
In-Reply-To: <CAD4oTHEYZiAs6eM=hprwGo+=5ut1fbqRETacE1OViOiBHw5A3Q@mail.gmail.com>
References: <SYBPR01MB4761B85D4678C2CCB95E9988CDCD0@SYBPR01MB4761.ausprd01.prod.outlook.com>
 <24528.5452.10417.544814@rob.eddelbuettel.com>
 <CAD4oTHEYZiAs6eM=hprwGo+=5ut1fbqRETacE1OViOiBHw5A3Q@mail.gmail.com>
Message-ID: <24528.36778.578787.250945@stat.math.ethz.ch>

>>>>> Gabriel Becker 
>>>>>     on Tue, 8 Dec 2020 17:09:57 -0800 writes:

    > Of course you can, but the ability to do something via R
    > code and the ability to do them by wrapping the invocation
    > of R are not similar terms of convenience, IMO.

    > I say that as someone who routinely does both type of
    > thing.

    > ~G

I agree with Gabe here.
Also, R allows the user to remove their own home directory, it
should also allow to get a .libPaths() which contains nothing compulsory
but R's own .Library {as only that can contain 'base' !}

Martin


    > On Tue, Dec 8, 2020 at 4:07 PM Dirk Eddelbuettel
    > <edd at debian.org> wrote:

    >> 
    >> On 8 December 2020 at 23:00, Dario Strbenac wrote: |
    >> Could .libPaths gain an option to ignore all values other
    >> than the user-specified new parameter? Currently, it
    >> takes the union of new and .Library and .Library.site and
    >> there is no way to turn it off.
    >> 
    >> Are you use? It is constructed from looking at
    >> environment variables you could set.
    >> 
    >> edd at rob:~$ R_LIBS="/tmp" R_LIBS_SITE="/var" Rscript -e
    >> 'print(.libPaths())' [1] "/tmp" "/var"
    >> "/usr/lib/R/library" edd at rob:~$
    >> 
    >> Dirk


From t|m@goodm@n @end|ng |rom gm@||@com  Wed Dec  9 06:45:04 2020
From: t|m@goodm@n @end|ng |rom gm@||@com (Timothy Goodman)
Date: Tue, 8 Dec 2020 21:45:04 -0800
Subject: [Rd] the pipe |> and line breaks in pipelines
Message-ID: <CAGBtDS-ZS_35QnJnPqW_fHaJF-LaWo8iPhOaTssyVTCU=q7dSw@mail.gmail.com>

Hi,

I'm a data scientist who routinely uses R in my day-to-day work, for tasks
such as cleaning and transforming data, exploratory data analysis, etc.
This includes frequent use of the pipe operator from the magrittr and dplyr
libraries, %>%.  So, I was pleased to hear about the recent work on a
native pipe operator, |>.

This seems like a good time to bring up the main pain point I encounter
when using pipes in R, and some suggestions on what could be done about
it.  The issue is that the pipe operator can't be placed at the start of a
line of code (except in parentheses).  That's no different than any binary
operator in R, but I find it's a source of difficulty for the pipe because
of how pipes are often used.

[I'm assuming here that my usage is fairly typical of a lot of users; at
any rate, I don't think I'm *too* unusual.]

=== Why this is a problem ===

It's very common (for me, and I suspect for many users of dplyr) to write
multi-step pipelines and put each step on its own line for readability.
Something like this:

  ### Example 1 ###
  my_data_frame_1 %>%
    filter(some_conditions_1) %>%
    inner_join(my_data_frame_2, by = some_columns_1) %>%
    group_by(some_columns_2) %>%
    summarize(some_aggregate_functions_1) %>%
    filter(some_conditions_2) %>%
    left_join(my_data_frame_3, by = some_columns_3) %>%
    group_by(some_columns_4) %>%
    summarize(some_aggregate_functions_2) %>%
    arrange(some_columns_5)

[I guess some might consider this an overly long pipeline; for me it's
pretty typical.  I *could* split it up by assigning intermediate results to
variables, but much of the value I get from the pipe is that it lets my
code communicate which results are temporary, and which will be used again
later.  Assigning variables for single-use results would remove that
expressiveness.]

I would prefer (for reasons I'll explain) to be able to write the above
example like this, which isn't valid R:

  ### Example 2 (not valid R) ###
  my_data_frame_1
    %>% filter(some_conditions_1)
    %>% inner_join(my_data_frame_2, by = some_columns_1)
    %>% group_by(some_columns_2)
    %>% summarize(some_aggregate_functions_1)
    %>% filter(some_conditions_2)
    %>% left_join(my_data_frame_3, by = some_columns_3)
    %>% group_by(some_columns_4)
    %>% summarize(some_aggregate_functions_2)
    %>% arrange(some_columns_5)

One (minor) advantage is obvious: It lets you easily line up the pipes,
which means that you can see at a glance that the whole block is a single
pipeline, and you'd immediately notice if you inadvertently omitted a pipe,
which otherwise can lead to confusing output.  [It's also aesthetically
pleasing, especially when %>% is replaced with |>, but that's subjective.]

But the bigger issue happens when I want to re-run just *part* of the
pipeline.  I do this often when debugging: if the output of the pipeline
seems wrong, I re-run the first few steps and check the output, then
include a little more and re-run again, etc., until I locate my mistake.
Working in an interactive notebook environment, this involves using the
cursor to select just the part of the code I want to re-run.

It's fast and easy to select *entire* lines of code, but unfortunately with
the pipes placed at the end of the line I must instead select everything
*except* the last three characters of the line (the last two characters for
the new pipe).  Then when I want to re-run the same partial pipeline with
the next line of code included, I can't just press SHIFT+Down to select it
as I otherwise would, but instead must move the cursor horizontally to a
position three characters before the end of *that* line (which is generally
different due to varying line lengths).  And so forth each time I want to
include an additional line.

Moreover, with the staggered positions of the pipes at the end of each
line, it's very easy to accidentally select the final pipe on a line, and
then sit there for a moment wondering if the environment has stopped
responding before realizing it's just waiting for further input (i.e., for
the right-hand side).  These small delays and disruptions add up over the
course of a day.

This desire to select and re-run the first part of a pipeline is also the
reason why it doesn't suffice to achieve syntax like my "Example 2" by
wrapping the entire pipeline in parentheses.  That's of no use if I want to
re-run a selection that doesn't include the final close-paren.

=== Possible Solutions ===

I can think of two, but maybe there are others.  The first would make
"Example 2" into valid code, and the second would allow you to run a
selection that included a trailing pipe.

  Solution 1: Add a special case to how R is parsed, so if the first
(non-whitespace) token after an end-line is a pipe, that pipe gets moved to
before the end-line.
    - Argument for: This lets you write code like example 2, which
addresses the pain point around re-running part of a pipeline, and has
advantages for readability.  Also, since starting a line with a pipe
operator is currently invalid, the change wouldn't break any working code.
    - Argument against: It would make the behavior of %>% inconsistent with
that of other binary operators in R.  (However, this objection might not
apply to the new pipe, |>, which I understand is being implemented as a
syntax transformation rather than a binary operator.)

  Solution 2: Ignore the pipe operator if it occurs as the final token of
the code being executed.
    - Argument for: This would mean the user could select and re-run the
first few lines of a longer pipeline (selecting *entire* lines), avoiding
the difficulties described above.
    - Argument against: This means that %>% would be valid even if it
occurred without a right-hand side, which is inconsistent with other
operators in R.  (But, as above, this objection might not apply to |>.)
Also, this solution still doesn't enable the syntax of "Example 2", with
its readability benefit.

Thanks for reading this and considering it.

- Tim Goodman

	[[alternative HTML version deleted]]


From @te|@nML @end|ng |rom co||oc@t|on@@de  Wed Dec  9 12:08:31 2020
From: @te|@nML @end|ng |rom co||oc@t|on@@de (Stefan Evert)
Date: Wed, 9 Dec 2020 12:08:31 +0100
Subject: [Rd] the pipe |> and line breaks in pipelines
In-Reply-To: <CAGBtDS-ZS_35QnJnPqW_fHaJF-LaWo8iPhOaTssyVTCU=q7dSw@mail.gmail.com>
References: <CAGBtDS-ZS_35QnJnPqW_fHaJF-LaWo8iPhOaTssyVTCU=q7dSw@mail.gmail.com>
Message-ID: <08E9CCEC-9CA3-4003-8FA9-9ECD98B99AF9@collocations.de>

I'm not a pipe user, so I may be overlooking some issue, but wouldn't simply putting identity() on the last line solve your main problem?

### Example 1 ###
 my_data_frame_1 %>%
   filter(some_conditions_1) %>%
   inner_join(my_data_frame_2, by = some_columns_1) %>%
   group_by(some_columns_2) %>%
   summarize(some_aggregate_functions_1) %>%
   filter(some_conditions_2) %>%
   left_join(my_data_frame_3, by = some_columns_3) %>%
   group_by(some_columns_4) %>%
   summarize(some_aggregate_functions_2) %>%
   arrange(some_columns_5) %>%
   identity()

I agree that it would be visually more pleasing to have the pipe symbols lined up at the start of each line, but I don't think it's worth breaking R's principle of evaluating any line with a complete expression.

With your solution 1, R wouldn't be able to execute any complete command because it would have to wait and see if the next line happens to start with %>%.

With your solution 2, 
  
  my_data_frame_1 %>%

would be a complete expression (because an extra trailing %>% is allowed on the last line of a pipe) and hence execute immediately rather than wait for the next line.

Best,
Stefan


> On 9 Dec 2020, at 06:45, Timothy Goodman <timsgoodman at gmail.com> wrote:
> 
> Hi,
> 
> I'm a data scientist who routinely uses R in my day-to-day work, for tasks
> such as cleaning and transforming data, exploratory data analysis, etc.
> This includes frequent use of the pipe operator from the magrittr and dplyr
> libraries, %>%.  So, I was pleased to hear about the recent work on a
> native pipe operator, |>.
> 
> This seems like a good time to bring up the main pain point I encounter
> when using pipes in R, and some suggestions on what could be done about
> it.  The issue is that the pipe operator can't be placed at the start of a
> line of code (except in parentheses).  That's no different than any binary
> operator in R, but I find it's a source of difficulty for the pipe because
> of how pipes are often used.
> 
> [I'm assuming here that my usage is fairly typical of a lot of users; at
> any rate, I don't think I'm *too* unusual.]
> 
> === Why this is a problem ===
> 
> It's very common (for me, and I suspect for many users of dplyr) to write
> multi-step pipelines and put each step on its own line for readability.
> Something like this:
> 
>  ### Example 1 ###
>  my_data_frame_1 %>%
>    filter(some_conditions_1) %>%
>    inner_join(my_data_frame_2, by = some_columns_1) %>%
>    group_by(some_columns_2) %>%
>    summarize(some_aggregate_functions_1) %>%
>    filter(some_conditions_2) %>%
>    left_join(my_data_frame_3, by = some_columns_3) %>%
>    group_by(some_columns_4) %>%
>    summarize(some_aggregate_functions_2) %>%
>    arrange(some_columns_5)
> 
> [I guess some might consider this an overly long pipeline; for me it's
> pretty typical.  I *could* split it up by assigning intermediate results to
> variables, but much of the value I get from the pipe is that it lets my
> code communicate which results are temporary, and which will be used again
> later.  Assigning variables for single-use results would remove that
> expressiveness.]
> 
> I would prefer (for reasons I'll explain) to be able to write the above
> example like this, which isn't valid R:
> 
>  ### Example 2 (not valid R) ###
>  my_data_frame_1
>    %>% filter(some_conditions_1)
>    %>% inner_join(my_data_frame_2, by = some_columns_1)
>    %>% group_by(some_columns_2)
>    %>% summarize(some_aggregate_functions_1)
>    %>% filter(some_conditions_2)
>    %>% left_join(my_data_frame_3, by = some_columns_3)
>    %>% group_by(some_columns_4)
>    %>% summarize(some_aggregate_functions_2)
>    %>% arrange(some_columns_5)
> 
> One (minor) advantage is obvious: It lets you easily line up the pipes,
> which means that you can see at a glance that the whole block is a single
> pipeline, and you'd immediately notice if you inadvertently omitted a pipe,
> which otherwise can lead to confusing output.  [It's also aesthetically
> pleasing, especially when %>% is replaced with |>, but that's subjective.]
> 
> But the bigger issue happens when I want to re-run just *part* of the
> pipeline.  I do this often when debugging: if the output of the pipeline
> seems wrong, I re-run the first few steps and check the output, then
> include a little more and re-run again, etc., until I locate my mistake.
> Working in an interactive notebook environment, this involves using the
> cursor to select just the part of the code I want to re-run.
> 
> It's fast and easy to select *entire* lines of code, but unfortunately with
> the pipes placed at the end of the line I must instead select everything
> *except* the last three characters of the line (the last two characters for
> the new pipe).  Then when I want to re-run the same partial pipeline with
> the next line of code included, I can't just press SHIFT+Down to select it
> as I otherwise would, but instead must move the cursor horizontally to a
> position three characters before the end of *that* line (which is generally
> different due to varying line lengths).  And so forth each time I want to
> include an additional line.
> 
> Moreover, with the staggered positions of the pipes at the end of each
> line, it's very easy to accidentally select the final pipe on a line, and
> then sit there for a moment wondering if the environment has stopped
> responding before realizing it's just waiting for further input (i.e., for
> the right-hand side).  These small delays and disruptions add up over the
> course of a day.
> 
> This desire to select and re-run the first part of a pipeline is also the
> reason why it doesn't suffice to achieve syntax like my "Example 2" by
> wrapping the entire pipeline in parentheses.  That's of no use if I want to
> re-run a selection that doesn't include the final close-paren.
> 
> === Possible Solutions ===
> 
> I can think of two, but maybe there are others.  The first would make
> "Example 2" into valid code, and the second would allow you to run a
> selection that included a trailing pipe.
> 
>  Solution 1: Add a special case to how R is parsed, so if the first
> (non-whitespace) token after an end-line is a pipe, that pipe gets moved to
> before the end-line.
>    - Argument for: This lets you write code like example 2, which
> addresses the pain point around re-running part of a pipeline, and has
> advantages for readability.  Also, since starting a line with a pipe
> operator is currently invalid, the change wouldn't break any working code.
>    - Argument against: It would make the behavior of %>% inconsistent with
> that of other binary operators in R.  (However, this objection might not
> apply to the new pipe, |>, which I understand is being implemented as a
> syntax transformation rather than a binary operator.)
> 
>  Solution 2: Ignore the pipe operator if it occurs as the final token of
> the code being executed.
>    - Argument for: This would mean the user could select and re-run the
> first few lines of a longer pipeline (selecting *entire* lines), avoiding
> the difficulties described above.
>    - Argument against: This means that %>% would be valid even if it
> occurred without a right-hand side, which is inconsistent with other
> operators in R.  (But, as above, this objection might not apply to |>.)
> Also, this solution still doesn't enable the syntax of "Example 2", with
> its readability benefit.
> 
> Thanks for reading this and considering it.
> 
> - Tim Goodman
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From murdoch@dunc@n @end|ng |rom gm@||@com  Wed Dec  9 12:12:06 2020
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Wed, 9 Dec 2020 06:12:06 -0500
Subject: [Rd] the pipe |> and line breaks in pipelines
In-Reply-To: <CAGBtDS-ZS_35QnJnPqW_fHaJF-LaWo8iPhOaTssyVTCU=q7dSw@mail.gmail.com>
References: <CAGBtDS-ZS_35QnJnPqW_fHaJF-LaWo8iPhOaTssyVTCU=q7dSw@mail.gmail.com>
Message-ID: <408829af-758f-3dcb-5f5d-740d5064992f@gmail.com>

The requirement for operators at the end of the line comes from the 
interactive nature of R.  If you type

     my_data_frame_1

how could R know that you are not done, and are planning to type the 
rest of the expression

       %>% filter(some_conditions_1)
       ...

before it should consider the expression complete?  The way languages 
like C do this is by requiring a statement terminator at the end.  You 
can also do it by wrapping the entire thing in parentheses ().

However, be careful: Don't use braces:  they don't work.  And parens 
have the side effect of removing invisibility from the result (which is 
a design flaw or bonus, depending on your point of view).  So I actually 
wouldn't advise this workaround.

Duncan Murdoch


On 09/12/2020 12:45 a.m., Timothy Goodman wrote:
> Hi,
> 
> I'm a data scientist who routinely uses R in my day-to-day work, for tasks
> such as cleaning and transforming data, exploratory data analysis, etc.
> This includes frequent use of the pipe operator from the magrittr and dplyr
> libraries, %>%.  So, I was pleased to hear about the recent work on a
> native pipe operator, |>.
> 
> This seems like a good time to bring up the main pain point I encounter
> when using pipes in R, and some suggestions on what could be done about
> it.  The issue is that the pipe operator can't be placed at the start of a
> line of code (except in parentheses).  That's no different than any binary
> operator in R, but I find it's a source of difficulty for the pipe because
> of how pipes are often used.
> 
> [I'm assuming here that my usage is fairly typical of a lot of users; at
> any rate, I don't think I'm *too* unusual.]
> 
> === Why this is a problem ===
> 
> It's very common (for me, and I suspect for many users of dplyr) to write
> multi-step pipelines and put each step on its own line for readability.
> Something like this:
> 
>    ### Example 1 ###
>    my_data_frame_1 %>%
>      filter(some_conditions_1) %>%
>      inner_join(my_data_frame_2, by = some_columns_1) %>%
>      group_by(some_columns_2) %>%
>      summarize(some_aggregate_functions_1) %>%
>      filter(some_conditions_2) %>%
>      left_join(my_data_frame_3, by = some_columns_3) %>%
>      group_by(some_columns_4) %>%
>      summarize(some_aggregate_functions_2) %>%
>      arrange(some_columns_5)
> 
> [I guess some might consider this an overly long pipeline; for me it's
> pretty typical.  I *could* split it up by assigning intermediate results to
> variables, but much of the value I get from the pipe is that it lets my
> code communicate which results are temporary, and which will be used again
> later.  Assigning variables for single-use results would remove that
> expressiveness.]
> 
> I would prefer (for reasons I'll explain) to be able to write the above
> example like this, which isn't valid R:
> 
>    ### Example 2 (not valid R) ###
>    my_data_frame_1
>      %>% filter(some_conditions_1)
>      %>% inner_join(my_data_frame_2, by = some_columns_1)
>      %>% group_by(some_columns_2)
>      %>% summarize(some_aggregate_functions_1)
>      %>% filter(some_conditions_2)
>      %>% left_join(my_data_frame_3, by = some_columns_3)
>      %>% group_by(some_columns_4)
>      %>% summarize(some_aggregate_functions_2)
>      %>% arrange(some_columns_5)
> 
> One (minor) advantage is obvious: It lets you easily line up the pipes,
> which means that you can see at a glance that the whole block is a single
> pipeline, and you'd immediately notice if you inadvertently omitted a pipe,
> which otherwise can lead to confusing output.  [It's also aesthetically
> pleasing, especially when %>% is replaced with |>, but that's subjective.]
> 
> But the bigger issue happens when I want to re-run just *part* of the
> pipeline.  I do this often when debugging: if the output of the pipeline
> seems wrong, I re-run the first few steps and check the output, then
> include a little more and re-run again, etc., until I locate my mistake.
> Working in an interactive notebook environment, this involves using the
> cursor to select just the part of the code I want to re-run.
> 
> It's fast and easy to select *entire* lines of code, but unfortunately with
> the pipes placed at the end of the line I must instead select everything
> *except* the last three characters of the line (the last two characters for
> the new pipe).  Then when I want to re-run the same partial pipeline with
> the next line of code included, I can't just press SHIFT+Down to select it
> as I otherwise would, but instead must move the cursor horizontally to a
> position three characters before the end of *that* line (which is generally
> different due to varying line lengths).  And so forth each time I want to
> include an additional line.
> 
> Moreover, with the staggered positions of the pipes at the end of each
> line, it's very easy to accidentally select the final pipe on a line, and
> then sit there for a moment wondering if the environment has stopped
> responding before realizing it's just waiting for further input (i.e., for
> the right-hand side).  These small delays and disruptions add up over the
> course of a day.
> 
> This desire to select and re-run the first part of a pipeline is also the
> reason why it doesn't suffice to achieve syntax like my "Example 2" by
> wrapping the entire pipeline in parentheses.  That's of no use if I want to
> re-run a selection that doesn't include the final close-paren.
> 
> === Possible Solutions ===
> 
> I can think of two, but maybe there are others.  The first would make
> "Example 2" into valid code, and the second would allow you to run a
> selection that included a trailing pipe.
> 
>    Solution 1: Add a special case to how R is parsed, so if the first
> (non-whitespace) token after an end-line is a pipe, that pipe gets moved to
> before the end-line.
>      - Argument for: This lets you write code like example 2, which
> addresses the pain point around re-running part of a pipeline, and has
> advantages for readability.  Also, since starting a line with a pipe
> operator is currently invalid, the change wouldn't break any working code.
>      - Argument against: It would make the behavior of %>% inconsistent with
> that of other binary operators in R.  (However, this objection might not
> apply to the new pipe, |>, which I understand is being implemented as a
> syntax transformation rather than a binary operator.)
> 
>    Solution 2: Ignore the pipe operator if it occurs as the final token of
> the code being executed.
>      - Argument for: This would mean the user could select and re-run the
> first few lines of a longer pipeline (selecting *entire* lines), avoiding
> the difficulties described above.
>      - Argument against: This means that %>% would be valid even if it
> occurred without a right-hand side, which is inconsistent with other
> operators in R.  (But, as above, this objection might not apply to |>.)
> Also, this solution still doesn't enable the syntax of "Example 2", with
> its readability benefit.
> 
> Thanks for reading this and considering it.
> 
> - Tim Goodman
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


From ggrothend|eck @end|ng |rom gm@||@com  Wed Dec  9 12:22:53 2020
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Wed, 9 Dec 2020 06:22:53 -0500
Subject: [Rd] the pipe |> and line breaks in pipelines
In-Reply-To: <CAGBtDS-ZS_35QnJnPqW_fHaJF-LaWo8iPhOaTssyVTCU=q7dSw@mail.gmail.com>
References: <CAGBtDS-ZS_35QnJnPqW_fHaJF-LaWo8iPhOaTssyVTCU=q7dSw@mail.gmail.com>
Message-ID: <CAP01uRkvJ1bsoffCmSgZH2OG7kwefsmvP42-ad-UAfDtwfgEpg@mail.gmail.com>

On Wed, Dec 9, 2020 at 4:03 AM Timothy Goodman <timsgoodman at gmail.com> wrote:
> But the bigger issue happens when I want to re-run just *part* of the
> pipeline.

Insert one of the following into the pipeline. It does not require that you
edit any lines.   It only involves inserting a line.

  print %>%
  { str(.); . } %>%
  { . ->> .save } %>%


From rhe|p @end|ng |rom eoo@@dd@@n|  Wed Dec  9 15:55:52 2020
From: rhe|p @end|ng |rom eoo@@dd@@n| (Jan van der Laan)
Date: Wed, 9 Dec 2020 15:55:52 +0100
Subject: [Rd] New pipe operator
In-Reply-To: <CAP01uR=vTJ_uy+RURVZnA8vbnnPRTOUkn6a2AEkg4HG2Lu3kaQ@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
 <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
 <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>
 <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>
 <CAD4oTHHFWkiirncPRWngY+_k9HcB=8zo7VdXAONXQoXdNhKzDA@mail.gmail.com>
 <7e28d84a-f6d0-1e18-c131-163650e7cd75@gmail.com>
 <CAP01uR=vTJ_uy+RURVZnA8vbnnPRTOUkn6a2AEkg4HG2Lu3kaQ@mail.gmail.com>
Message-ID: <d5010e6f-f997-48f5-744c-2c9bc760d523@eoos.dds.nl>



On 08-12-2020 12:46, Gabor Grothendieck wrote:
> Duncan Murdoch:
>> I agree it's all about call expressions, but they aren't all being
>> treated equally:
>>
>> x |> f(...)
>>
>> expands to f(x, ...), while
>>
>> x |> `function`(...)
>>
>> expands to `function`(...)(x).  This is an exception to the rule for
> 
> Yes, this is the problem.  It is trying to handle two different sorts of right
> hand sides, calls and functions, using only syntax level operations and
> it really needs to either make use of deeper information or have some
> method that is available at the syntax level for identifying whether the
> right hand side is a call or function.  In the latter case having two
> operators would be one way to do it.
> 
>    f <- \(x) x + 1
>    x |> f()  # call
>    x |:> f  # function
>    x |:> \(x) x + 1  # function
> 
> In the other case where deeper information is used there would only be one
> operator and it would handle all cases but would use more than just syntax
> level knowledge.
> 
> R solved these sorts of problems long ago using S3 and other object oriented
> systems which dispatch different methods based on what the right hand side is.
> The attempt to avoid using the existing or equivalent mechanisms seems to have
> led to this problem.
> 



I think only allowing functions on the right hand side (e.g. only the |> 
operator and not the |:>) would be enough to handle most cases and seems 
easier to reason about. The limitations of that can easily be worked 
around using existing functionality in the language.

The problem with only allowing

x |> mean

and not

x |> mean()

is with additional arguments. However, this can be solved with a 
currying function, for example:

x |> curry(mean, na.rm = TRUE)

The cost is a few additional characters.

In the same way it is possible to write a function that accepts an 
expression and returns a function containing that expression. This can 
be used to have expressions on the right-hand side and reduces the need 
for anonymous functions.

x |> fexpr(. + 10)
dta |> fexpr(lm(y ~ x, data = .))

You could call this function .:

x |> .(. + 10)
dta |> .(lm(y ~ x, data = .))


Dummy example code (thanks to  a colleague of mine)


fexpr <- function(expr){
   expr <- substitute(expr)
   f <- function(.) {}
   body(f) <- expr
   f
}
. <- fexpr

curry <- function(fun,...){
   L <- list(...)
   function(...){
     do.call(fun, c(list(...),L))
   }
}

`%|>%` <- function(e1, e2) {
   e2(e1)
}


1:10 %>% mean
c(1,3,NA) %|>% curry(mean, na.rm = TRUE)
c(1,3,NA) %|>% .( mean(., na.rm = TRUE) ) %>% identity
c(1,3,NA) %|>% .( . + 4)
c(1,3,NA) %|>% fexpr( . + 4)
c(1,3,NA) %|>% function(x) mean(x, na.rm = TRUE) %>% fexpr(. + 1)

--
Jan


From murdoch@dunc@n @end|ng |rom gm@||@com  Wed Dec  9 16:08:34 2020
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Wed, 9 Dec 2020 10:08:34 -0500
Subject: [Rd] [External] Re: New pipe operator
In-Reply-To: <CAOO9MKU7LD9JkX3XK3NpqzzpiTirvRxdqJBbX0D=W3ik+Fw0bw@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <alpine.DEB.2.21.2012051203250.3003@luke-Latitude-7480>
 <CAOO9MKU7LD9JkX3XK3NpqzzpiTirvRxdqJBbX0D=W3ik+Fw0bw@mail.gmail.com>
Message-ID: <1e755fbb-f18f-227e-3477-6467fc255cbf@gmail.com>

You might be interested in this blog post by Michael Barrowman:

https://michaelbarrowman.co.uk/post/the-new-base-pipe/

He does some timing comparisons, and the current R-devel implementations 
of |> and \() do quite well.

Duncan Murdoch


On 06/12/2020 4:42 a.m., Jan Gorecki wrote:
> Luke,
> When writing a blog post on that, could you please describe
> performance implications that this new feature will carry?
> AFAIU, compared to a standard way of using temporary variables, pipes
> will allow to not increment REFCNT of objects being piped into.
> Therefore peak memory usage could be lower in some cases.
> 
> As for brackets required on RHS, I think it makes sense to be
> consistent and either require brackets for anonymous functions the
> same way we require for function name, or not require brackets for
> both of them.
> 
> Best,
> Jan
> 
> On Sat, Dec 5, 2020 at 8:10 PM <luke-tierney at uiowa.edu> wrote:
>>
>> We went back and forth on this several times. The key advantage of
>> requiring parentheses is to keep things simple and consistent.  Let's
>> get some experience with that. If experience shows requiring
>> parentheses creates too many issues then we can add the option of
>> dropping them later (with special handling of :: and :::). It's easier
>> to add flexibility and complexity than to restrict it after the fact.
>>
>> Best,
>>
>> luke
>>
>> On Sat, 5 Dec 2020, Hugh Parsonage wrote:
>>
>>> I'm surprised by the aversion to
>>>
>>> mtcars |> nrow
>>>
>>> over
>>>
>>> mtcars |> nrow()
>>>
>>> and I think the decision to disallow the former should be
>>> reconsidered.  The pipe operator is only going to be used when the rhs
>>> is a function, so there is no ambiguity with omitting the parentheses.
>>> If it's disallowed, it becomes inconsistent with other treatments like
>>> sapply(mtcars, typeof) where sapply(mtcars, typeof()) would just be
>>> noise.  I'm not sure why this decision was taken
>>>
>>> If the only issue is with the double (and triple) colon operator, then
>>> ideally `mtcars |> base::head` should resolve to `base::head(mtcars)`
>>> -- in other words, demote the precedence of |>
>>>
>>> Obviously (looking at the R-Syntax branch) this decision was
>>> considered, put into place, then dropped, but I can't see why
>>> precisely.
>>>
>>> Best,
>>>
>>>
>>> Hugh.
>>>
>>>
>>>
>>>
>>>
>>>
>>>
>>> On Sat, 5 Dec 2020 at 04:07, Deepayan Sarkar <deepayan.sarkar at gmail.com> wrote:
>>>>
>>>> On Fri, Dec 4, 2020 at 7:35 PM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>>>>>
>>>>> On 04/12/2020 8:13 a.m., Hiroaki Yutani wrote:
>>>>>>>    Error: function '::' not supported in RHS call of a pipe
>>>>>>
>>>>>> To me, this error looks much more friendly than magrittr's error.
>>>>>> Some of them got too used to specify functions without (). This
>>>>>> is OK until they use `::`, but when they need to use it, it takes
>>>>>> hours to figure out why
>>>>>>
>>>>>> mtcars %>% base::head
>>>>>> #> Error in .::base : unused argument (head)
>>>>>>
>>>>>> won't work but
>>>>>>
>>>>>> mtcars %>% head
>>>>>>
>>>>>> works. I think this is a too harsh lesson for ordinary R users to
>>>>>> learn `::` is a function. I've been wanting for magrittr to drop the
>>>>>> support for a function name without () to avoid this confusion,
>>>>>> so I would very much welcome the new pipe operator's behavior.
>>>>>> Thank you all the developers who implemented this!
>>>>>
>>>>> I agree, it's an improvement on the corresponding magrittr error.
>>>>>
>>>>> I think the semantics of not evaluating the RHS, but treating the pipe
>>>>> as purely syntactical is a good decision.
>>>>>
>>>>> I'm not sure I like the recommended way to pipe into a particular argument:
>>>>>
>>>>>     mtcars |> subset(cyl == 4) |> \(d) lm(mpg ~ disp, data = d)
>>>>>
>>>>> or
>>>>>
>>>>>     mtcars |> subset(cyl == 4) |> function(d) lm(mpg ~ disp, data = d)
>>>>>
>>>>> both of which are equivalent to
>>>>>
>>>>>     mtcars |> subset(cyl == 4) |> (function(d) lm(mpg ~ disp, data = d))()
>>>>>
>>>>> It's tempting to suggest it should allow something like
>>>>>
>>>>>     mtcars |> subset(cyl == 4) |> lm(mpg ~ disp, data = .)
>>>>
>>>> Which is really not that far off from
>>>>
>>>> mtcars |> subset(cyl == 4) |> \(.) lm(mpg ~ disp, data = .)
>>>>
>>>> once you get used to it.
>>>>
>>>> One consequence of the implementation is that it's not clear how
>>>> multiple occurrences of the placeholder would be interpreted. With
>>>> magrittr,
>>>>
>>>> sort(runif(10)) %>% ecdf(.)(.)
>>>> ## [1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
>>>>
>>>> This is probably what you would expect, if you expect it to work at all, and not
>>>>
>>>> ecdf(sort(runif(10)))(sort(runif(10)))
>>>>
>>>> There would be no such ambiguity with anonymous functions
>>>>
>>>> sort(runif(10)) |> \(.) ecdf(.)(.)
>>>>
>>>> -Deepayan
>>>>
>>>>> which would be expanded to something equivalent to the other versions:
>>>>> but that makes it quite a bit more complicated.  (Maybe _ or \. should
>>>>> be used instead of ., since those are not legal variable names.)
>>>>>
>>>>> I don't think there should be an attempt to copy magrittr's special
>>>>> casing of how . is used in determining whether to also include the
>>>>> previous value as first argument.
>>>>>
>>>>> Duncan Murdoch
>>>>>
>>>>>
>>>>>>
>>>>>> Best,
>>>>>> Hiroaki Yutani
>>>>>>
>>>>>> 2020?12?4?(?) 20:51 Duncan Murdoch <murdoch.duncan at gmail.com>:
>>>>>>>
>>>>>>> Just saw this on the R-devel news:
>>>>>>>
>>>>>>>
>>>>>>> R now provides a simple native pipe syntax ?|>? as well as a shorthand
>>>>>>> notation for creating functions, e.g. ?\(x) x + 1? is parsed as
>>>>>>> ?function(x) x + 1?. The pipe implementation as a syntax transformation
>>>>>>> was motivated by suggestions from Jim Hester and Lionel Henry. These
>>>>>>> features are experimental and may change prior to release.
>>>>>>>
>>>>>>>
>>>>>>> This is a good addition; by using "|>" instead of "%>%" there should be
>>>>>>> a chance to get operator precedence right.  That said, the ?Syntax help
>>>>>>> topic hasn't been updated, so I'm not sure where it fits in.
>>>>>>>
>>>>>>> There are some choices that take a little getting used to:
>>>>>>>
>>>>>>>   > mtcars |> head
>>>>>>> Error: The pipe operator requires a function call or an anonymous
>>>>>>> function expression as RHS
>>>>>>>
>>>>>>> (I need to say mtcars |> head() instead.)  This sometimes leads to error
>>>>>>> messages that are somewhat confusing:
>>>>>>>
>>>>>>>   > mtcars |> magrittr::debug_pipe |> head
>>>>>>> Error: function '::' not supported in RHS call of a pipe
>>>>>>>
>>>>>>> but
>>>>>>>
>>>>>>> mtcars |> magrittr::debug_pipe() |> head()
>>>>>>>
>>>>>>> works.
>>>>>>>
>>>>>>> Overall, I think this is a great addition, though it's going to be
>>>>>>> disruptive for a while.
>>>>>>>
>>>>>>> Duncan Murdoch
>>>>>>>
>>>>>>> ______________________________________________
>>>>>>> R-devel at r-project.org mailing list
>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>
>>>>>> ______________________________________________
>>>>>> R-devel at r-project.org mailing list
>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>
>>>>>
>>>>> ______________________________________________
>>>>> R-devel at r-project.org mailing list
>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>
>>>> ______________________________________________
>>>> R-devel at r-project.org mailing list
>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>
>>
>> --
>> Luke Tierney
>> Ralph E. Wareham Professor of Mathematical Sciences
>> University of Iowa                  Phone:             319-335-3386
>> Department of Statistics and        Fax:               319-335-3017
>>      Actuarial Science
>> 241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
>> Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


From murdoch@dunc@n @end|ng |rom gm@||@com  Wed Dec  9 16:20:11 2020
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Wed, 9 Dec 2020 10:20:11 -0500
Subject: [Rd] New pipe operator
In-Reply-To: <d5010e6f-f997-48f5-744c-2c9bc760d523@eoos.dds.nl>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
 <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
 <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>
 <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>
 <CAD4oTHHFWkiirncPRWngY+_k9HcB=8zo7VdXAONXQoXdNhKzDA@mail.gmail.com>
 <7e28d84a-f6d0-1e18-c131-163650e7cd75@gmail.com>
 <CAP01uR=vTJ_uy+RURVZnA8vbnnPRTOUkn6a2AEkg4HG2Lu3kaQ@mail.gmail.com>
 <d5010e6f-f997-48f5-744c-2c9bc760d523@eoos.dds.nl>
Message-ID: <d8a8296b-27d4-bbe3-f632-b10b3f308d00@gmail.com>

On 09/12/2020 9:55 a.m., Jan van der Laan wrote:

> 
> I think only allowing functions on the right hand side (e.g. only the |>
> operator and not the |:>) would be enough to handle most cases and seems
> easier to reason about. The limitations of that can easily be worked
> around using existing functionality in the language.

I agree that would be sufficient, but I don't see how it makes reasoning 
easier.  The transformation is trivial, so I'll assume that doesn't 
consume any mental energy compared to understanding what the final 
expression actually does.  Using your currying example, the choice is 
between

  x |> mean(na.rm = TRUE)

which transforms to mean(x, na.rm = TRUE), or your proposed

  x |> curry(mean, na.rm = TRUE)

which transforms to

  curry(mean, na.rm = TRUE)(x)

To me curry(mean, na.rm = TRUE)(x) looks a lot more complicated than 
mean(x, na.rm = TRUE), especially since it has the additional risk that 
users can define their own function called "curry".

Duncan Murdoch

> 
> The problem with only allowing
> 
> x |> mean
> 
> and not
> 
> x |> mean()
> 
> is with additional arguments. However, this can be solved with a
> currying function, for example:
> 
> x |> curry(mean, na.rm = TRUE)
> 
> The cost is a few additional characters.
> 
> In the same way it is possible to write a function that accepts an
> expression and returns a function containing that expression. This can
> be used to have expressions on the right-hand side and reduces the need
> for anonymous functions.
> 
> x |> fexpr(. + 10)
> dta |> fexpr(lm(y ~ x, data = .))
> 
> You could call this function .:
> 
> x |> .(. + 10)
> dta |> .(lm(y ~ x, data = .))
> 
> 
> Dummy example code (thanks to  a colleague of mine)
> 
> 
> fexpr <- function(expr){
>     expr <- substitute(expr)
>     f <- function(.) {}
>     body(f) <- expr
>     f
> }
> . <- fexpr
> 
> curry <- function(fun,...){
>     L <- list(...)
>     function(...){
>       do.call(fun, c(list(...),L))
>     }
> }
> 
> `%|>%` <- function(e1, e2) {
>     e2(e1)
> }
> 
> 
> 1:10 %>% mean
> c(1,3,NA) %|>% curry(mean, na.rm = TRUE)
> c(1,3,NA) %|>% .( mean(., na.rm = TRUE) ) %>% identity
> c(1,3,NA) %|>% .( . + 4)
> c(1,3,NA) %|>% fexpr( . + 4)
> c(1,3,NA) %|>% function(x) mean(x, na.rm = TRUE) %>% fexpr(. + 1)
> 
> --
> Jan
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


From rhe|p @end|ng |rom eoo@@dd@@n|  Wed Dec  9 16:42:43 2020
From: rhe|p @end|ng |rom eoo@@dd@@n| (Jan van der Laan)
Date: Wed, 9 Dec 2020 16:42:43 +0100
Subject: [Rd] New pipe operator
In-Reply-To: <d8a8296b-27d4-bbe3-f632-b10b3f308d00@gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
 <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
 <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>
 <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>
 <CAD4oTHHFWkiirncPRWngY+_k9HcB=8zo7VdXAONXQoXdNhKzDA@mail.gmail.com>
 <7e28d84a-f6d0-1e18-c131-163650e7cd75@gmail.com>
 <CAP01uR=vTJ_uy+RURVZnA8vbnnPRTOUkn6a2AEkg4HG2Lu3kaQ@mail.gmail.com>
 <d5010e6f-f997-48f5-744c-2c9bc760d523@eoos.dds.nl>
 <d8a8296b-27d4-bbe3-f632-b10b3f308d00@gmail.com>
Message-ID: <6d578354-bfd0-b253-e01e-87facfaa427c@eoos.dds.nl>





On 09-12-2020 16:20, Duncan Murdoch wrote:
> On 09/12/2020 9:55 a.m., Jan van der Laan wrote:
> 
>>
>> I think only allowing functions on the right hand side (e.g. only the |>
>> operator and not the |:>) would be enough to handle most cases and seems
>> easier to reason about. The limitations of that can easily be worked
>> around using existing functionality in the language.
> 
> I agree that would be sufficient, but I don't see how it makes reasoning 
> easier.? The transformation is trivial, so I'll assume that doesn't 
> consume any mental energy compared to understanding what the final 
> expression actually does.? Using your currying example, the choice is 
> between
> 
>  ?x |> mean(na.rm = TRUE)
> 
> which transforms to mean(x, na.rm = TRUE), or your proposed
> 
>  ?x |> curry(mean, na.rm = TRUE)
> 
> which transforms to
> 
>  ?curry(mean, na.rm = TRUE)(x)
> 
> To me curry(mean, na.rm = TRUE)(x) looks a lot more complicated than 
> mean(x, na.rm = TRUE), especially since it has the additional risk that 
> users can define their own function called "curry".


First, I do agree that

x |> mean(na.rm = TRUE)

is cleaner and this covers most of the use cases of users and many users 
are used to the syntax from the magritr pipes.

However, for programmers (there is not distinct line between users and 
programmers), it is simpler to reason in the sense that lhs |> rhs 
always mean rhs(lhs); this does not depend on whether rhs is call or 
(anonymous) function (not sure what is called what; which perhaps 
illustrates the difficulty).

As soon as you start to have functions returning functions, you have to 
think about how many brackets you have to place where. Being able to use 
functions returning functions does open up possibilities for 
programmers, as illustrated for example in my example using expressions. 
This would have been much less clear.

The argument of users begin able to redefine curry. Yes they can and 
this is perhaps a good thing. They can also redefine a lot of other 
stuff. And I am not suggesting that curry or fexpr or . are good names. 
You could even have a curry operator.

Best,
Jan





> 
> Duncan Murdoch
> 
>>
>> The problem with only allowing
>>
>> x |> mean
>>
>> and not
>>
>> x |> mean()
>>
>> is with additional arguments. However, this can be solved with a
>> currying function, for example:
>>
>> x |> curry(mean, na.rm = TRUE)
>>
>> The cost is a few additional characters.
>>
>> In the same way it is possible to write a function that accepts an
>> expression and returns a function containing that expression. This can
>> be used to have expressions on the right-hand side and reduces the need
>> for anonymous functions.
>>
>> x |> fexpr(. + 10)
>> dta |> fexpr(lm(y ~ x, data = .))
>>
>> You could call this function .:
>>
>> x |> .(. + 10)
>> dta |> .(lm(y ~ x, data = .))
>>
>>
>> Dummy example code (thanks to? a colleague of mine)
>>
>>
>> fexpr <- function(expr){
>> ??? expr <- substitute(expr)
>> ??? f <- function(.) {}
>> ??? body(f) <- expr
>> ??? f
>> }
>> . <- fexpr
>>
>> curry <- function(fun,...){
>> ??? L <- list(...)
>> ??? function(...){
>> ????? do.call(fun, c(list(...),L))
>> ??? }
>> }
>>
>> `%|>%` <- function(e1, e2) {
>> ??? e2(e1)
>> }
>>
>>
>> 1:10 %>% mean
>> c(1,3,NA) %|>% curry(mean, na.rm = TRUE)
>> c(1,3,NA) %|>% .( mean(., na.rm = TRUE) ) %>% identity
>> c(1,3,NA) %|>% .( . + 4)
>> c(1,3,NA) %|>% fexpr( . + 4)
>> c(1,3,NA) %|>% function(x) mean(x, na.rm = TRUE) %>% fexpr(. + 1)
>>
>> -- 
>> Jan
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>


From murdoch@dunc@n @end|ng |rom gm@||@com  Wed Dec  9 17:08:45 2020
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Wed, 9 Dec 2020 11:08:45 -0500
Subject: [Rd] New pipe operator
In-Reply-To: <6d578354-bfd0-b253-e01e-87facfaa427c@eoos.dds.nl>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
 <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
 <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>
 <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>
 <CAD4oTHHFWkiirncPRWngY+_k9HcB=8zo7VdXAONXQoXdNhKzDA@mail.gmail.com>
 <7e28d84a-f6d0-1e18-c131-163650e7cd75@gmail.com>
 <CAP01uR=vTJ_uy+RURVZnA8vbnnPRTOUkn6a2AEkg4HG2Lu3kaQ@mail.gmail.com>
 <d5010e6f-f997-48f5-744c-2c9bc760d523@eoos.dds.nl>
 <d8a8296b-27d4-bbe3-f632-b10b3f308d00@gmail.com>
 <6d578354-bfd0-b253-e01e-87facfaa427c@eoos.dds.nl>
Message-ID: <34326691-ec3a-3a70-4558-b67f596e8c70@gmail.com>

On 09/12/2020 10:42 a.m., Jan van der Laan wrote:
> 
> 
> 
> 
> On 09-12-2020 16:20, Duncan Murdoch wrote:
>> On 09/12/2020 9:55 a.m., Jan van der Laan wrote:
>>
>>>
>>> I think only allowing functions on the right hand side (e.g. only the |>
>>> operator and not the |:>) would be enough to handle most cases and seems
>>> easier to reason about. The limitations of that can easily be worked
>>> around using existing functionality in the language.
>>
>> I agree that would be sufficient, but I don't see how it makes reasoning
>> easier.? The transformation is trivial, so I'll assume that doesn't
>> consume any mental energy compared to understanding what the final
>> expression actually does.? Using your currying example, the choice is
>> between
>>
>>   ?x |> mean(na.rm = TRUE)
>>
>> which transforms to mean(x, na.rm = TRUE), or your proposed
>>
>>   ?x |> curry(mean, na.rm = TRUE)
>>
>> which transforms to
>>
>>   ?curry(mean, na.rm = TRUE)(x)
>>
>> To me curry(mean, na.rm = TRUE)(x) looks a lot more complicated than
>> mean(x, na.rm = TRUE), especially since it has the additional risk that
>> users can define their own function called "curry".
> 
> 
> First, I do agree that
> 
> x |> mean(na.rm = TRUE)
> 
> is cleaner and this covers most of the use cases of users and many users
> are used to the syntax from the magritr pipes.
> 
> However, for programmers (there is not distinct line between users and
> programmers), it is simpler to reason in the sense that lhs |> rhs
> always mean rhs(lhs); this does not depend on whether rhs is call or
> (anonymous) function (not sure what is called what; which perhaps
> illustrates the difficulty).

I think your proposed rule is pretty simple, with just one case:

lhs |> rhs

would transform to rhs(lhs).  Yes, that's simple.

The current rule is not as simple as yours, but it only has two cases 
instead of 1.  Both involve the rhs being a call, nothing else.

Case 1, the common one:  rhs is a call to a function using regular 
syntax, e.g. f(args) where args might be empty.  Then it is transformed 
to f(lhs, args).

Case 2:  rhs is a call to `function`, which we normally write as 
"function(args) body", which is transformed to (function(args) body)(lhs).

That's it!  Nothing else is allowed.  Not as simple as yours, but simple 
enough to be trivial to reason about.  Most of the effort would be spent 
in figuring out how the transformed expression would evaluate, and since 
your transformed expression is more complicated in the common case where 
currying is needed, I prefer the current proposal.


> 
> As soon as you start to have functions returning functions, you have to
> think about how many brackets you have to place where. Being able to use
> functions returning functions does open up possibilities for
> programmers, as illustrated for example in my example using expressions.
> This would have been much less clear.

I think your examples would work in the current system, too, with a 
small change to fexpr.  A corresponding change to curry could be made, 
but then it wouldn't be doing currying, so I won't do that.  Here's your 
example rewritten in the R-devel system:

fexpr <- function(x, expr){
   expr <- substitute(expr)
   f <- function(.) {}
   body(f) <- expr
   f(x)
}
. <- fexpr


1:10 |> mean()
c(1,3,NA) |> mean(na.rm = TRUE)
c(1,3,NA) |> .( mean(., na.rm = TRUE) ) |> identity()
c(1,3,NA) |> .( . + 4)
c(1,3,NA) |> fexpr( . + 4)
c(1,3,NA) |> function(x) mean(x, na.rm = TRUE) |> fexpr(. + 1)

That produces the same outputs as your code.

Duncan Murdoch


> The argument of users begin able to redefine curry. Yes they can and
> this is perhaps a good thing. They can also redefine a lot of other
> stuff. And I am not suggesting that curry or fexpr or . are good names.
> You could even have a curry operator.
> 
> Best,
> Jan
> 
> 
> 
> 
> 
>>
>> Duncan Murdoch
>>
>>>
>>> The problem with only allowing
>>>
>>> x |> mean
>>>
>>> and not
>>>
>>> x |> mean()
>>>
>>> is with additional arguments. However, this can be solved with a
>>> currying function, for example:
>>>
>>> x |> curry(mean, na.rm = TRUE)
>>>
>>> The cost is a few additional characters.
>>>
>>> In the same way it is possible to write a function that accepts an
>>> expression and returns a function containing that expression. This can
>>> be used to have expressions on the right-hand side and reduces the need
>>> for anonymous functions.
>>>
>>> x |> fexpr(. + 10)
>>> dta |> fexpr(lm(y ~ x, data = .))
>>>
>>> You could call this function .:
>>>
>>> x |> .(. + 10)
>>> dta |> .(lm(y ~ x, data = .))
>>>
>>>
>>> Dummy example code (thanks to? a colleague of mine)
>>>
>>>
>>> fexpr <- function(expr){
>>>  ??? expr <- substitute(expr)
>>>  ??? f <- function(.) {}
>>>  ??? body(f) <- expr
>>>  ??? f
>>> }
>>> . <- fexpr
>>>
>>> curry <- function(fun,...){
>>>  ??? L <- list(...)
>>>  ??? function(...){
>>>  ????? do.call(fun, c(list(...),L))
>>>  ??? }
>>> }
>>>
>>> `%|>%` <- function(e1, e2) {
>>>  ??? e2(e1)
>>> }
>>>
>>>
>>> 1:10 %>% mean
>>> c(1,3,NA) %|>% curry(mean, na.rm = TRUE)
>>> c(1,3,NA) %|>% .( mean(., na.rm = TRUE) ) %>% identity
>>> c(1,3,NA) %|>% .( . + 4)
>>> c(1,3,NA) %|>% fexpr( . + 4)
>>> c(1,3,NA) %|>% function(x) mean(x, na.rm = TRUE) %>% fexpr(. + 1)
>>>
>>> -- 
>>> Jan
>>>
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>
>>


From ggrothend|eck @end|ng |rom gm@||@com  Wed Dec  9 17:25:08 2020
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Wed, 9 Dec 2020 11:25:08 -0500
Subject: [Rd] [External] Re: New pipe operator
In-Reply-To: <1e755fbb-f18f-227e-3477-6467fc255cbf@gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <alpine.DEB.2.21.2012051203250.3003@luke-Latitude-7480>
 <CAOO9MKU7LD9JkX3XK3NpqzzpiTirvRxdqJBbX0D=W3ik+Fw0bw@mail.gmail.com>
 <1e755fbb-f18f-227e-3477-6467fc255cbf@gmail.com>
Message-ID: <CAP01uRnVnPws==rAAvumKeV0HMqMA3SRWvdyvTA6MXohbLuCXQ@mail.gmail.com>

On Wed, Dec 9, 2020 at 10:08 AM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>
> You might be interested in this blog post by Michael Barrowman:
>
> https://michaelbarrowman.co.uk/post/the-new-base-pipe/
>
> He does some timing comparisons, and the current R-devel implementations
> of |> and \() do quite well.

It does bring out that the requirement of using functions to get around the
lack of placeholders is not free but exacts a small penalty in
terms of performance (in addition to verbosity).

The bizarro pipe supports placeholders and so doesn't require functions
as a workaround and thus would presumably be even faster.  It is also
perfectly consistent with the rest of R and requires no new syntax.
You have to explicitly add a dot as the first argument but this seems a better
compromise to me than those involved with |> .


From g@bembecker @end|ng |rom gm@||@com  Wed Dec  9 18:36:22 2020
From: g@bembecker @end|ng |rom gm@||@com (Gabriel Becker)
Date: Wed, 9 Dec 2020 09:36:22 -0800
Subject: [Rd] [External] Re: New pipe operator
In-Reply-To: <CAP01uRnVnPws==rAAvumKeV0HMqMA3SRWvdyvTA6MXohbLuCXQ@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <alpine.DEB.2.21.2012051203250.3003@luke-Latitude-7480>
 <CAOO9MKU7LD9JkX3XK3NpqzzpiTirvRxdqJBbX0D=W3ik+Fw0bw@mail.gmail.com>
 <1e755fbb-f18f-227e-3477-6467fc255cbf@gmail.com>
 <CAP01uRnVnPws==rAAvumKeV0HMqMA3SRWvdyvTA6MXohbLuCXQ@mail.gmail.com>
Message-ID: <CAD4oTHE+6q5S11tJRvEiH1ZPjDFGwJ+s5WyyRCAsPrTxjLSwrw@mail.gmail.com>

On Wed, Dec 9, 2020 at 8:26 AM Gabor Grothendieck <ggrothendieck at gmail.com>
wrote:

> On Wed, Dec 9, 2020 at 10:08 AM Duncan Murdoch <murdoch.duncan at gmail.com>
> wrote:
> >
> > You might be interested in this blog post by Michael Barrowman:
> >
> > https://michaelbarrowman.co.uk/post/the-new-base-pipe/
> >
> > He does some timing comparisons, and the current R-devel implementations
> > of |> and \() do quite well.
>
> It does bring out that the requirement of using functions to get around the
> lack of placeholders is not free but exacts a small penalty in
> terms of performance (in addition to verbosity).
>

I mean, technically, yes, but even with that overhead it's 2 *orders of
magnitude* faster than the magrittr you're used to, and by the look of it
~3x faster than the new magrittr. And, those base pipe speeds are in
microseconds. You'd have to be running that pipeline thousands of times -
which people don't generally do with pipelines in the first place -  to see
a *5 millisecond* slowdown, which you would then happily fail to notice
completely because what your pipeline is actually doing takes so much
longer than those microseconds of the extra function call that its unlikely
to be detectable at all.



The bizarro pipe supports placeholders and so doesn't require functions
> as a workaround and thus would presumably be even faster.  It is also
> perfectly consistent with the rest of R and requires no new syntax.
> You have to explicitly add a dot as the first argument but this seems a
> better
> compromise to me than those involved with |> .
>

I mean, I think the bizarro pipe was a pretty clever piece of work. I was
impressed by what John did there, but I don't really know what you're
suggesting here. As you say, the bizarro pipe works now without any changes
and you're welcome to use it if you prefer it to base's (proposed/likely)
|> and magrittr's %>%.

~G

>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From ggrothend|eck @end|ng |rom gm@||@com  Wed Dec  9 18:46:57 2020
From: ggrothend|eck @end|ng |rom gm@||@com (Gabor Grothendieck)
Date: Wed, 9 Dec 2020 12:46:57 -0500
Subject: [Rd] [External] Re: New pipe operator
In-Reply-To: <CAD4oTHE+6q5S11tJRvEiH1ZPjDFGwJ+s5WyyRCAsPrTxjLSwrw@mail.gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <alpine.DEB.2.21.2012051203250.3003@luke-Latitude-7480>
 <CAOO9MKU7LD9JkX3XK3NpqzzpiTirvRxdqJBbX0D=W3ik+Fw0bw@mail.gmail.com>
 <1e755fbb-f18f-227e-3477-6467fc255cbf@gmail.com>
 <CAP01uRnVnPws==rAAvumKeV0HMqMA3SRWvdyvTA6MXohbLuCXQ@mail.gmail.com>
 <CAD4oTHE+6q5S11tJRvEiH1ZPjDFGwJ+s5WyyRCAsPrTxjLSwrw@mail.gmail.com>
Message-ID: <CAP01uRn=__=bM323e7_O0w_f444WczRc4=oxyaYBB3epeTAWcA@mail.gmail.com>

On Wed, Dec 9, 2020 at 12:36 PM Gabriel Becker <gabembecker at gmail.com> wrote:
> I mean, I think the bizarro pipe was a pretty clever piece of work. I was impressed by what John did there, but I don't really know what you're suggesting here. As you say, the bizarro pipe works now without any changes and you're welcome to use it if you prefer it to base's (proposed/likely) |> and magrittr's %>%.
>

If  |> exists then it will be impossible to avoid it unless the only
software you ever use is your own.
It's about the entire R ecosystem and what gets used because it is in the base.

It would still be possible to implement \(x)... without |>  so I would
go with that and rethink
the pipe situation.


From pd@|gd @end|ng |rom gm@||@com  Wed Dec  9 19:42:48 2020
From: pd@|gd @end|ng |rom gm@||@com (Peter Dalgaard)
Date: Wed, 9 Dec 2020 19:42:48 +0100
Subject: [Rd] New pipe operator
In-Reply-To: <d8a8296b-27d4-bbe3-f632-b10b3f308d00@gmail.com>
References: <e55c2093-0bb5-5f9b-5521-0ca8bdf35953@gmail.com>
 <CALyqOb8c1hHOSaMV+fqXTwpeOsP--KJ_t-oeqMYYafVXeNpqZg@mail.gmail.com>
 <7586e034-e287-0970-6480-f82d747b5445@gmail.com>
 <CADfFDC7bT58_+52uvmpHuMMQRNbbmqV3_7t_fc4sgJ_Esw=xag@mail.gmail.com>
 <CAJmOi+PO_8XDC23=rT=pQ76ENL=gx2V-41ax2fHSVs87xURcEA@mail.gmail.com>
 <CAP01uRkkd3jOjvaS9JgKYCD1KA83HfzCd+MQSv_2aYJPgcOmSQ@mail.gmail.com>
 <CAP01uRkPcbCBRGwAzKM=W19Ohh-zDGwZH8gM7=A-sK2rRaQxaQ@mail.gmail.com>
 <CAD4oTHFBY4rBhiRsJUkA6jwD2YWaxPMz2OZDOqSvHfv6A7DZPg@mail.gmail.com>
 <CAP01uRmTYna1nM+ugELHrCqLjfWuWwHSfE4cvqoaq2537sHpAw@mail.gmail.com>
 <CAD4oTHHFWkiirncPRWngY+_k9HcB=8zo7VdXAONXQoXdNhKzDA@mail.gmail.com>
 <7e28d84a-f6d0-1e18-c131-163650e7cd75@gmail.com>
 <CAP01uR=vTJ_uy+RURVZnA8vbnnPRTOUkn6a2AEkg4HG2Lu3kaQ@mail.gmail.com>
 <d5010e6f-f997-48f5-744c-2c9bc760d523@eoos.dds.nl>
 <d8a8296b-27d4-bbe3-f632-b10b3f308d00@gmail.com>
Message-ID: <8BBD5DDE-94D6-4298-9857-5CF51F916E8B@gmail.com>



> On 9 Dec 2020, at 16:20 , Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
> 
> To me curry(mean, na.rm = TRUE)(x) looks a lot more complicated than mean(x, na.rm = TRUE), especially since it has the additional risk that users can define their own function called "curry".

Not to mention that it would make people's data handling scripts look like the menu at an Indian restaurant.... ;-)

-pd

-- 
Peter Dalgaard, Professor,
Center for Statistics, Copenhagen Business School
Solbjerg Plads 3, 2000 Frederiksberg, Denmark
Phone: (+45)38153501
Office: A 4.23
Email: pd.mes at cbs.dk  Priv: PDalgd at gmail.com


From edd @end|ng |rom deb|@n@org  Wed Dec  9 19:47:50 2020
From: edd @end|ng |rom deb|@n@org (Dirk Eddelbuettel)
Date: Wed, 9 Dec 2020 12:47:50 -0600
Subject: [Rd] Ignore Sites Option For libPaths
In-Reply-To: <24528.36778.578787.250945@stat.math.ethz.ch>
References: <SYBPR01MB4761B85D4678C2CCB95E9988CDCD0@SYBPR01MB4761.ausprd01.prod.outlook.com>
 <24528.5452.10417.544814@rob.eddelbuettel.com>
 <CAD4oTHEYZiAs6eM=hprwGo+=5ut1fbqRETacE1OViOiBHw5A3Q@mail.gmail.com>
 <24528.36778.578787.250945@stat.math.ethz.ch>
Message-ID: <24529.7126.373929.721695@rob.eddelbuettel.com>


On 9 December 2020 at 09:49, Martin Maechler wrote:
| Also, R allows the user to remove their own home directory, it
| should also allow to get a .libPaths() which contains nothing compulsory
| but R's own .Library {as only that can contain 'base' !}

That would be a very nice-to-have feature! But right now, .libPaths() does
now allow this per my reading of the help page:

     ?.libPaths? is used for getting or setting the library trees that
     R knows about (and hence uses when looking for packages).  If
     called with argument ?new?, the library search path is set to the
     existing directories in ?unique(c(new, .Library.site, .Library))?
     and this is returned.  If given no argument, a character vector
     with the currently active library trees is returned.

Hence I was trying to help OP approximate the behaviour via the command-line
but count me in as in terms of supporting this in R itself if you want to
make such a change.

Dirk

-- 
https://dirk.eddelbuettel.com | @eddelbuettel | edd at debian.org


From 538280 @end|ng |rom gm@||@com  Wed Dec  9 20:16:52 2020
From: 538280 @end|ng |rom gm@||@com (Greg Snow)
Date: Wed, 9 Dec 2020 12:16:52 -0700
Subject: [Rd] New pipe operator and gg plotz
In-Reply-To: <034e01d6cc3f$3752af60$a5f80e20$@verizon.net>
References: <005a01d6cc06$c1192910$434b7b30$.ref@verizon.net>
 <005a01d6cc06$c1192910$434b7b30$@verizon.net>
 <342b718d-6616-3681-5302-d253c3041f14@gmail.com>
 <034e01d6cc3f$3752af60$a5f80e20$@verizon.net>
Message-ID: <CAFEqCdxE+bmSbi52v--ax_NwFr8NT5Cd8T2gDovmBpookPiRDA@mail.gmail.com>

Since `+` is already a function we could do regular piping to change this code:

mtcars %>%
  ggplot(aes(x=wt, y=mpg)) +
  geom_point()

to this:

mtcars %>%
  ggplot(aes(x=wt, y=mpg)) %>%
  `+`(geom_point())

Further we can write wrapper functions like:

p_geom_point <- function(x,...) {
  x + geom_point(...)
}

The run the code like:

mtcars %>%
  ggplot(aes(x=wt, y=mpg)) %>%
  p_geom_point()

All three of the above give the same plot from what I can see, but I
have not tested it with very many options beyond the above.

A really ambitious person could create a new package with wrappers for
all the ggplot2 functions that can come after the plus sign, then we
could use pipes for everything.  I don't know if there are any strange
circumstances that would make this cause problems (it probably will
slow things down slightly, but probably not enough for people to
notice).

On Sun, Dec 6, 2020 at 7:18 PM Avi Gross via R-devel
<r-devel at r-project.org> wrote:
>
> Thanks, Duncan. That answers my question fairly definitively.
>
> Although it can be DONE it likely won't be for the reasons Hadley mentioned until we get some other product that replaces it entirely. There are some interesting work-arounds mentioned.
>
> I was thinking of one that has overhead but might be a pain. Hadley mentioned a slight variant. The first argument to a function now is expected to be the data argument. The second might be the mapping. Now if the function is called with a new first argument that is a ggplot object, it could be possible to test the type and if it is a ggplot object than slide over carefully any additional matched arguments that were not explicitly named. Not sure that is at all easy to do.
>
> Alternately, you can ask that when used in such a pipeline that the user call all other arguments using names like data=whatever, mapping=aes(whatever) so no other args need to be adjusted by position.
>
> But all this is academic and I concede will likely not be done. I can live with the plus signs.
>
>
> -----Original Message-----
> From: Duncan Murdoch <murdoch.duncan at gmail.com>
> Sent: Sunday, December 6, 2020 2:50 PM
> To: Avi Gross <avigross at verizon.net>; 'r-devel' <r-devel at r-project.org>
> Subject: Re: [Rd] New pipe operator and gg plotz
>
> Hadley's answer (#7 here:
> https://community.rstudio.com/t/why-cant-ggplot2-use/4372) makes it pretty clear that he thinks it would have been nice now if he had made that choice when ggplot2 came out, but it's not worth the effort now to change it.
>
> Duncan Murdoch
>
> On 06/12/2020 2:34 p.m., Avi Gross via R-devel wrote:
> > As someone who switches back and forth between using standard R methods and those of the tidyverse, depending on the problem, my mood and whether Jupiter aligns with Saturn in the new age of Aquarius, I have a question about the forthcoming built-in pipe. Will it motivate anyone to eventually change or enhance the ggplot functionality to have a version that gets rid of the odd use of the addition symbol?
> >
> > I mean I now sometimes have a pipeline that looks like:
> >
> > Data %>%
> >       Do_this %>%
> >       Do_that(whatever) %>%
> >       ggplot(...) +
> >               geom_whatever(...) +
> >               ...
> >
> > My understanding is this is a bit of a historical anomaly that might someday be modified back.
> >
> > As I understand it, the call to ggplot() creates a partially filled-in object that holds all kinds of useful info. The additional calls to geom_point() and so on will add/change that hidden object. Nothing much happens till the object is implicitly or explicitly given to print() which switches to the print function for objects of that type and creates a graph based on the contents of the object at that time. So, in theory, you could have a pipelined version of ggplot where the first function accepts something like a  data.frame or tibble as the default first argument and at the end returns the object we have been describing. All additional functions would then accept such an object as the (hidden?) first argument and return the modified object. The final function in the pipe would either have the value captured in a variable for later use or print implicitly generating a graph.
> >
> > So the above silly example might become:
> >
> > Data %>%
> >       Do_this %>%
> >       Do_that(whatever) %>%
> >       ggplot(...) %>%
> >       geom_whatever(...) %>%
> >       ...
> >
> > Or, am I missing something here?
> >
> > The language and extensions such as are now in the tidyverse might be more streamlined and easier to read when using consistent notation. If we now build a reasonable version of the pipeline in, might we encourage other uses to gradually migrate back closer to the mainstream?
> >
> > -----Original Message-----
> > From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Rui
> > Barradas
> > Sent: Sunday, December 6, 2020 2:51 AM
> > To: Gregory Warnes <greg at warnes.net>; Abby Spurdle
> > <spurdle.a at gmail.com>
> > Cc: r-devel <r-devel at r-project.org>
> > Subject: Re: [Rd] New pipe operator
> >
> > Hello,
> >
> > If Hilbert liked beer, I like "pipe".
> >
> > More seriously, a new addition like this one is going to cause problems yet unknown. But it's a good idea to have a pipe operator available. As someone used to magrittr's data pipelines, I will play with this base one before making up my mind. I don't expect its behavior to be exactly like magrittr "%>%" (and it's not). For the moment all I can say is that it is something R users are used to and that it now avoids loading a package.
> > As for the new way to define anonymous functions, I am less sure. Too much syntatic sugar? Or am I finding the syntax ugly?
> >
> > Hope this helps,
> >
> > Rui Barradas
> >
> >
> > ?s 03:22 de 06/12/20, Gregory Warnes escreveu:
> >> If we?re being mathematically pedantic, the ?pipe? operator is
> >> actually function composition > That being said, pipes are a simple
> >> and well-known idiom. While being less
> >> than mathematically exact, it seems a reasonable   label for the (very
> >> useful) behavior.
> >>
> >> On Sat, Dec 5, 2020 at 9:43 PM Abby Spurdle <spurdle.a at gmail.com> wrote:
> >>
> >>>> This is a good addition
> >>>
> >>> I can't understand why so many people are calling this a "pipe".
> >>> Pipes connect processes, via their I/O streams.
> >>> Arguably, a more general interpretation would include sockets and files.
> >>>
> >>> https://en.wikipedia.org/wiki/Pipeline_(Unix)
> >>> https://en.wikipedia.org/wiki/Named_pipe
> >>> https://en.wikipedia.org/wiki/Anonymous_pipe
> >>>
> >>> As far as I can tell, the magrittr-like operators are functions (not
> >>> pipes), with nonstandard syntax.
> >>> This is not consistent with R's original design philosophy, building
> >>> on C, Lisp and S, along with lots of *important* math and stats.
> >>>
> >>> It's possible that some parties are interested in creating a kind of
> >>> "data pipeline".
> >>> I'm interested in this myself, and I think we could discuss this more.
> >>> But I'm not convinced the magrittr-like operators help to achieve
> >>> this goal.
> >>> Which, in my opinion, would require one to model programs as
> >>> directed graphs, along with some degree of asynchronous input.
> >>>
> >>> Presumably, these operators will be added to R anyway, and (almost)
> >>> no one will listen to me.
> >>>
> >>> So, I would like to make one suggestion:
> >>> Is it possible for these operators to *not* be named:
> >>>       The R Pipe
> >>>       The S Pipe
> >>>       Or anything with a similar meaning.
> >>>
> >>> Maybe tidy pipe, or something else that links it to its proponents?
> >>>
> >>> ______________________________________________
> >>> R-devel at r-project.org mailing list
> >>> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>>
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
> >
> >
> > Scanned by McAfee and confirmed virus-free.
> > Find out more here: https://bit.ly/2zCJMrO
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
> >
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel



-- 
Gregory (Greg) L. Snow Ph.D.
538280 at gmail.com


From murdoch@dunc@n @end|ng |rom gm@||@com  Wed Dec  9 20:23:40 2020
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Wed, 9 Dec 2020 14:23:40 -0500
Subject: [Rd] New pipe operator and gg plotz
In-Reply-To: <CAFEqCdxE+bmSbi52v--ax_NwFr8NT5Cd8T2gDovmBpookPiRDA@mail.gmail.com>
References: <005a01d6cc06$c1192910$434b7b30$.ref@verizon.net>
 <005a01d6cc06$c1192910$434b7b30$@verizon.net>
 <342b718d-6616-3681-5302-d253c3041f14@gmail.com>
 <034e01d6cc3f$3752af60$a5f80e20$@verizon.net>
 <CAFEqCdxE+bmSbi52v--ax_NwFr8NT5Cd8T2gDovmBpookPiRDA@mail.gmail.com>
Message-ID: <e50e3562-48c4-a078-c9f0-d0b701fdda88@gmail.com>

Looks like Sergio Oller took your ambitious approach: 
https://github.com/zeehio/ggpipe.  It hasn't been updated since 2017, so 
there may be some new things in ggplot2 that aren't there yet.

Duncan Murdoch

On 09/12/2020 2:16 p.m., Greg Snow wrote:
> Since `+` is already a function we could do regular piping to change this code:
> 
> mtcars %>%
>    ggplot(aes(x=wt, y=mpg)) +
>    geom_point()
> 
> to this:
> 
> mtcars %>%
>    ggplot(aes(x=wt, y=mpg)) %>%
>    `+`(geom_point())
> 
> Further we can write wrapper functions like:
> 
> p_geom_point <- function(x,...) {
>    x + geom_point(...)
> }
> 
> The run the code like:
> 
> mtcars %>%
>    ggplot(aes(x=wt, y=mpg)) %>%
>    p_geom_point()
> 
> All three of the above give the same plot from what I can see, but I
> have not tested it with very many options beyond the above.
> 
> A really ambitious person could create a new package with wrappers for
> all the ggplot2 functions that can come after the plus sign, then we
> could use pipes for everything.  I don't know if there are any strange
> circumstances that would make this cause problems (it probably will
> slow things down slightly, but probably not enough for people to
> notice).
> 
> On Sun, Dec 6, 2020 at 7:18 PM Avi Gross via R-devel
> <r-devel at r-project.org> wrote:
>>
>> Thanks, Duncan. That answers my question fairly definitively.
>>
>> Although it can be DONE it likely won't be for the reasons Hadley mentioned until we get some other product that replaces it entirely. There are some interesting work-arounds mentioned.
>>
>> I was thinking of one that has overhead but might be a pain. Hadley mentioned a slight variant. The first argument to a function now is expected to be the data argument. The second might be the mapping. Now if the function is called with a new first argument that is a ggplot object, it could be possible to test the type and if it is a ggplot object than slide over carefully any additional matched arguments that were not explicitly named. Not sure that is at all easy to do.
>>
>> Alternately, you can ask that when used in such a pipeline that the user call all other arguments using names like data=whatever, mapping=aes(whatever) so no other args need to be adjusted by position.
>>
>> But all this is academic and I concede will likely not be done. I can live with the plus signs.
>>
>>
>> -----Original Message-----
>> From: Duncan Murdoch <murdoch.duncan at gmail.com>
>> Sent: Sunday, December 6, 2020 2:50 PM
>> To: Avi Gross <avigross at verizon.net>; 'r-devel' <r-devel at r-project.org>
>> Subject: Re: [Rd] New pipe operator and gg plotz
>>
>> Hadley's answer (#7 here:
>> https://community.rstudio.com/t/why-cant-ggplot2-use/4372) makes it pretty clear that he thinks it would have been nice now if he had made that choice when ggplot2 came out, but it's not worth the effort now to change it.
>>
>> Duncan Murdoch
>>
>> On 06/12/2020 2:34 p.m., Avi Gross via R-devel wrote:
>>> As someone who switches back and forth between using standard R methods and those of the tidyverse, depending on the problem, my mood and whether Jupiter aligns with Saturn in the new age of Aquarius, I have a question about the forthcoming built-in pipe. Will it motivate anyone to eventually change or enhance the ggplot functionality to have a version that gets rid of the odd use of the addition symbol?
>>>
>>> I mean I now sometimes have a pipeline that looks like:
>>>
>>> Data %>%
>>>        Do_this %>%
>>>        Do_that(whatever) %>%
>>>        ggplot(...) +
>>>                geom_whatever(...) +
>>>                ...
>>>
>>> My understanding is this is a bit of a historical anomaly that might someday be modified back.
>>>
>>> As I understand it, the call to ggplot() creates a partially filled-in object that holds all kinds of useful info. The additional calls to geom_point() and so on will add/change that hidden object. Nothing much happens till the object is implicitly or explicitly given to print() which switches to the print function for objects of that type and creates a graph based on the contents of the object at that time. So, in theory, you could have a pipelined version of ggplot where the first function accepts something like a  data.frame or tibble as the default first argument and at the end returns the object we have been describing. All additional functions would then accept such an object as the (hidden?) first argument and return the modified object. The final function in the pipe would either have the value captured in a variable for later use or print implicitly generating a graph.
>>>
>>> So the above silly example might become:
>>>
>>> Data %>%
>>>        Do_this %>%
>>>        Do_that(whatever) %>%
>>>        ggplot(...) %>%
>>>        geom_whatever(...) %>%
>>>        ...
>>>
>>> Or, am I missing something here?
>>>
>>> The language and extensions such as are now in the tidyverse might be more streamlined and easier to read when using consistent notation. If we now build a reasonable version of the pipeline in, might we encourage other uses to gradually migrate back closer to the mainstream?
>>>
>>> -----Original Message-----
>>> From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Rui
>>> Barradas
>>> Sent: Sunday, December 6, 2020 2:51 AM
>>> To: Gregory Warnes <greg at warnes.net>; Abby Spurdle
>>> <spurdle.a at gmail.com>
>>> Cc: r-devel <r-devel at r-project.org>
>>> Subject: Re: [Rd] New pipe operator
>>>
>>> Hello,
>>>
>>> If Hilbert liked beer, I like "pipe".
>>>
>>> More seriously, a new addition like this one is going to cause problems yet unknown. But it's a good idea to have a pipe operator available. As someone used to magrittr's data pipelines, I will play with this base one before making up my mind. I don't expect its behavior to be exactly like magrittr "%>%" (and it's not). For the moment all I can say is that it is something R users are used to and that it now avoids loading a package.
>>> As for the new way to define anonymous functions, I am less sure. Too much syntatic sugar? Or am I finding the syntax ugly?
>>>
>>> Hope this helps,
>>>
>>> Rui Barradas
>>>
>>>
>>> ?s 03:22 de 06/12/20, Gregory Warnes escreveu:
>>>> If we?re being mathematically pedantic, the ?pipe? operator is
>>>> actually function composition > That being said, pipes are a simple
>>>> and well-known idiom. While being less
>>>> than mathematically exact, it seems a reasonable   label for the (very
>>>> useful) behavior.
>>>>
>>>> On Sat, Dec 5, 2020 at 9:43 PM Abby Spurdle <spurdle.a at gmail.com> wrote:
>>>>
>>>>>> This is a good addition
>>>>>
>>>>> I can't understand why so many people are calling this a "pipe".
>>>>> Pipes connect processes, via their I/O streams.
>>>>> Arguably, a more general interpretation would include sockets and files.
>>>>>
>>>>> https://en.wikipedia.org/wiki/Pipeline_(Unix)
>>>>> https://en.wikipedia.org/wiki/Named_pipe
>>>>> https://en.wikipedia.org/wiki/Anonymous_pipe
>>>>>
>>>>> As far as I can tell, the magrittr-like operators are functions (not
>>>>> pipes), with nonstandard syntax.
>>>>> This is not consistent with R's original design philosophy, building
>>>>> on C, Lisp and S, along with lots of *important* math and stats.
>>>>>
>>>>> It's possible that some parties are interested in creating a kind of
>>>>> "data pipeline".
>>>>> I'm interested in this myself, and I think we could discuss this more.
>>>>> But I'm not convinced the magrittr-like operators help to achieve
>>>>> this goal.
>>>>> Which, in my opinion, would require one to model programs as
>>>>> directed graphs, along with some degree of asynchronous input.
>>>>>
>>>>> Presumably, these operators will be added to R anyway, and (almost)
>>>>> no one will listen to me.
>>>>>
>>>>> So, I would like to make one suggestion:
>>>>> Is it possible for these operators to *not* be named:
>>>>>        The R Pipe
>>>>>        The S Pipe
>>>>>        Or anything with a similar meaning.
>>>>>
>>>>> Maybe tidy pipe, or something else that links it to its proponents?
>>>>>
>>>>> ______________________________________________
>>>>> R-devel at r-project.org mailing list
>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>
>>>
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>
>>>
>>> Scanned by McAfee and confirmed virus-free.
>>> Find out more here: https://bit.ly/2zCJMrO
>>>
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> 
>


From t|m@goodm@n @end|ng |rom gm@||@com  Wed Dec  9 20:33:26 2020
From: t|m@goodm@n @end|ng |rom gm@||@com (Timothy Goodman)
Date: Wed, 9 Dec 2020 11:33:26 -0800
Subject: [Rd] the pipe |> and line breaks in pipelines
In-Reply-To: <408829af-758f-3dcb-5f5d-740d5064992f@gmail.com>
References: <CAGBtDS-ZS_35QnJnPqW_fHaJF-LaWo8iPhOaTssyVTCU=q7dSw@mail.gmail.com>
 <408829af-758f-3dcb-5f5d-740d5064992f@gmail.com>
Message-ID: <CAGBtDS-KnJaNkzHVkui0wvdoFMDQ8QsRqknRyGkzULtBowtdwA@mail.gmail.com>

If I type my_data_frame_1 and press Enter (or Ctrl+Enter to execute the
command in the Notebook environment I'm using) I certainly *would* expect R
to treat it as a complete statement.

But what I'm talking about is a different case, where I highlight a
multi-line statement in my notebook:

    my_data_frame1
        |> filter(some_conditions_1)

and then press Ctrl+Enter.  Or, I suppose the equivalent would be to run an
R script containing those two lines of code, or to run a multi-line
statement like that from the console (which in RStudio I can do by pressing
Shift+Enter between the lines.)

In those cases, R could either (1) Give an error message [the current
behavior], or (2) understand that the first line is meant to be piped to
the second.  The second option would be significantly more useful, and is
almost certainly what the user intended.

(For what it's worth, there are some languages, such as Javascript, that
consider the first token of the next line when determining if the previous
line was complete.  JavaScript's rules around this are overly complicated,
but a rule like "a pipe following a line break is treated as continuing the
previous line" would be much simpler.  And while it might be objectionable
to treat the operator %>% different from other operators, the addition of
|>, which isn't truly an operator at all, seems like the right time to
consider it.)

-Tim

On Wed, Dec 9, 2020 at 3:12 AM Duncan Murdoch <murdoch.duncan at gmail.com>
wrote:

> The requirement for operators at the end of the line comes from the
> interactive nature of R.  If you type
>
>      my_data_frame_1
>
> how could R know that you are not done, and are planning to type the
> rest of the expression
>
>        %>% filter(some_conditions_1)
>        ...
>
> before it should consider the expression complete?  The way languages
> like C do this is by requiring a statement terminator at the end.  You
> can also do it by wrapping the entire thing in parentheses ().
>
> However, be careful: Don't use braces:  they don't work.  And parens
> have the side effect of removing invisibility from the result (which is
> a design flaw or bonus, depending on your point of view).  So I actually
> wouldn't advise this workaround.
>
> Duncan Murdoch
>
>
> On 09/12/2020 12:45 a.m., Timothy Goodman wrote:
> > Hi,
> >
> > I'm a data scientist who routinely uses R in my day-to-day work, for
> tasks
> > such as cleaning and transforming data, exploratory data analysis, etc.
> > This includes frequent use of the pipe operator from the magrittr and
> dplyr
> > libraries, %>%.  So, I was pleased to hear about the recent work on a
> > native pipe operator, |>.
> >
> > This seems like a good time to bring up the main pain point I encounter
> > when using pipes in R, and some suggestions on what could be done about
> > it.  The issue is that the pipe operator can't be placed at the start of
> a
> > line of code (except in parentheses).  That's no different than any
> binary
> > operator in R, but I find it's a source of difficulty for the pipe
> because
> > of how pipes are often used.
> >
> > [I'm assuming here that my usage is fairly typical of a lot of users; at
> > any rate, I don't think I'm *too* unusual.]
> >
> > === Why this is a problem ===
> >
> > It's very common (for me, and I suspect for many users of dplyr) to write
> > multi-step pipelines and put each step on its own line for readability.
> > Something like this:
> >
> >    ### Example 1 ###
> >    my_data_frame_1 %>%
> >      filter(some_conditions_1) %>%
> >      inner_join(my_data_frame_2, by = some_columns_1) %>%
> >      group_by(some_columns_2) %>%
> >      summarize(some_aggregate_functions_1) %>%
> >      filter(some_conditions_2) %>%
> >      left_join(my_data_frame_3, by = some_columns_3) %>%
> >      group_by(some_columns_4) %>%
> >      summarize(some_aggregate_functions_2) %>%
> >      arrange(some_columns_5)
> >
> > [I guess some might consider this an overly long pipeline; for me it's
> > pretty typical.  I *could* split it up by assigning intermediate results
> to
> > variables, but much of the value I get from the pipe is that it lets my
> > code communicate which results are temporary, and which will be used
> again
> > later.  Assigning variables for single-use results would remove that
> > expressiveness.]
> >
> > I would prefer (for reasons I'll explain) to be able to write the above
> > example like this, which isn't valid R:
> >
> >    ### Example 2 (not valid R) ###
> >    my_data_frame_1
> >      %>% filter(some_conditions_1)
> >      %>% inner_join(my_data_frame_2, by = some_columns_1)
> >      %>% group_by(some_columns_2)
> >      %>% summarize(some_aggregate_functions_1)
> >      %>% filter(some_conditions_2)
> >      %>% left_join(my_data_frame_3, by = some_columns_3)
> >      %>% group_by(some_columns_4)
> >      %>% summarize(some_aggregate_functions_2)
> >      %>% arrange(some_columns_5)
> >
> > One (minor) advantage is obvious: It lets you easily line up the pipes,
> > which means that you can see at a glance that the whole block is a single
> > pipeline, and you'd immediately notice if you inadvertently omitted a
> pipe,
> > which otherwise can lead to confusing output.  [It's also aesthetically
> > pleasing, especially when %>% is replaced with |>, but that's
> subjective.]
> >
> > But the bigger issue happens when I want to re-run just *part* of the
> > pipeline.  I do this often when debugging: if the output of the pipeline
> > seems wrong, I re-run the first few steps and check the output, then
> > include a little more and re-run again, etc., until I locate my mistake.
> > Working in an interactive notebook environment, this involves using the
> > cursor to select just the part of the code I want to re-run.
> >
> > It's fast and easy to select *entire* lines of code, but unfortunately
> with
> > the pipes placed at the end of the line I must instead select everything
> > *except* the last three characters of the line (the last two characters
> for
> > the new pipe).  Then when I want to re-run the same partial pipeline with
> > the next line of code included, I can't just press SHIFT+Down to select
> it
> > as I otherwise would, but instead must move the cursor horizontally to a
> > position three characters before the end of *that* line (which is
> generally
> > different due to varying line lengths).  And so forth each time I want to
> > include an additional line.
> >
> > Moreover, with the staggered positions of the pipes at the end of each
> > line, it's very easy to accidentally select the final pipe on a line, and
> > then sit there for a moment wondering if the environment has stopped
> > responding before realizing it's just waiting for further input (i.e.,
> for
> > the right-hand side).  These small delays and disruptions add up over the
> > course of a day.
> >
> > This desire to select and re-run the first part of a pipeline is also the
> > reason why it doesn't suffice to achieve syntax like my "Example 2" by
> > wrapping the entire pipeline in parentheses.  That's of no use if I want
> to
> > re-run a selection that doesn't include the final close-paren.
> >
> > === Possible Solutions ===
> >
> > I can think of two, but maybe there are others.  The first would make
> > "Example 2" into valid code, and the second would allow you to run a
> > selection that included a trailing pipe.
> >
> >    Solution 1: Add a special case to how R is parsed, so if the first
> > (non-whitespace) token after an end-line is a pipe, that pipe gets moved
> to
> > before the end-line.
> >      - Argument for: This lets you write code like example 2, which
> > addresses the pain point around re-running part of a pipeline, and has
> > advantages for readability.  Also, since starting a line with a pipe
> > operator is currently invalid, the change wouldn't break any working
> code.
> >      - Argument against: It would make the behavior of %>% inconsistent
> with
> > that of other binary operators in R.  (However, this objection might not
> > apply to the new pipe, |>, which I understand is being implemented as a
> > syntax transformation rather than a binary operator.)
> >
> >    Solution 2: Ignore the pipe operator if it occurs as the final token
> of
> > the code being executed.
> >      - Argument for: This would mean the user could select and re-run the
> > first few lines of a longer pipeline (selecting *entire* lines), avoiding
> > the difficulties described above.
> >      - Argument against: This means that %>% would be valid even if it
> > occurred without a right-hand side, which is inconsistent with other
> > operators in R.  (But, as above, this objection might not apply to |>.)
> > Also, this solution still doesn't enable the syntax of "Example 2", with
> > its readability benefit.
> >
> > Thanks for reading this and considering it.
> >
> > - Tim Goodman
> >
> >       [[alternative HTML version deleted]]
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
> >
>
>

	[[alternative HTML version deleted]]


From kev|nu@hey @end|ng |rom gm@||@com  Wed Dec  9 20:58:03 2020
From: kev|nu@hey @end|ng |rom gm@||@com (Kevin Ushey)
Date: Wed, 9 Dec 2020 11:58:03 -0800
Subject: [Rd] the pipe |> and line breaks in pipelines
In-Reply-To: <CAGBtDS-KnJaNkzHVkui0wvdoFMDQ8QsRqknRyGkzULtBowtdwA@mail.gmail.com>
References: <CAGBtDS-ZS_35QnJnPqW_fHaJF-LaWo8iPhOaTssyVTCU=q7dSw@mail.gmail.com>
 <408829af-758f-3dcb-5f5d-740d5064992f@gmail.com>
 <CAGBtDS-KnJaNkzHVkui0wvdoFMDQ8QsRqknRyGkzULtBowtdwA@mail.gmail.com>
Message-ID: <CAJXgQP0M6t2rUtQ+VuFacjKpBqnSR-oDHH_njbgpQP2tsxj5-Q@mail.gmail.com>

I agree with Duncan that the right solution is to wrap the pipe
expression with parentheses. Having the parser treat newlines
differently based on whether the session is interactive, or on what
type of operator happens to follow a newline, feels like a pretty big
can of worms.

I think this (or something similar) would accomplish what you want
while still retaining the nice aesthetics of the pipe expression, with
a minimal amount of syntax "noise":

result <- (
  data
    |> op1()
    |> op2()
)

For interactive sessions where you wanted to execute only parts of the
pipeline at a time, I could see that being accomplished by the editor
-- it could transform the expression so that it could be handled by R,
either by hoisting the pipe operator(s) up a line, or by wrapping the
to-be-executed expression in parentheses for you. If such a style of
coding became popular enough, I'm sure the developers of such editors
would be interested and willing to support this ...

Perhaps more importantly, it would be much easier to accomplish than a
change to the behavior of the R parser, and it would be work that
wouldn't have to be maintained by the R Core team.

Best,
Kevin

On Wed, Dec 9, 2020 at 11:34 AM Timothy Goodman <timsgoodman at gmail.com> wrote:
>
> If I type my_data_frame_1 and press Enter (or Ctrl+Enter to execute the
> command in the Notebook environment I'm using) I certainly *would* expect R
> to treat it as a complete statement.
>
> But what I'm talking about is a different case, where I highlight a
> multi-line statement in my notebook:
>
>     my_data_frame1
>         |> filter(some_conditions_1)
>
> and then press Ctrl+Enter.  Or, I suppose the equivalent would be to run an
> R script containing those two lines of code, or to run a multi-line
> statement like that from the console (which in RStudio I can do by pressing
> Shift+Enter between the lines.)
>
> In those cases, R could either (1) Give an error message [the current
> behavior], or (2) understand that the first line is meant to be piped to
> the second.  The second option would be significantly more useful, and is
> almost certainly what the user intended.
>
> (For what it's worth, there are some languages, such as Javascript, that
> consider the first token of the next line when determining if the previous
> line was complete.  JavaScript's rules around this are overly complicated,
> but a rule like "a pipe following a line break is treated as continuing the
> previous line" would be much simpler.  And while it might be objectionable
> to treat the operator %>% different from other operators, the addition of
> |>, which isn't truly an operator at all, seems like the right time to
> consider it.)
>
> -Tim
>
> On Wed, Dec 9, 2020 at 3:12 AM Duncan Murdoch <murdoch.duncan at gmail.com>
> wrote:
>
> > The requirement for operators at the end of the line comes from the
> > interactive nature of R.  If you type
> >
> >      my_data_frame_1
> >
> > how could R know that you are not done, and are planning to type the
> > rest of the expression
> >
> >        %>% filter(some_conditions_1)
> >        ...
> >
> > before it should consider the expression complete?  The way languages
> > like C do this is by requiring a statement terminator at the end.  You
> > can also do it by wrapping the entire thing in parentheses ().
> >
> > However, be careful: Don't use braces:  they don't work.  And parens
> > have the side effect of removing invisibility from the result (which is
> > a design flaw or bonus, depending on your point of view).  So I actually
> > wouldn't advise this workaround.
> >
> > Duncan Murdoch
> >
> >
> > On 09/12/2020 12:45 a.m., Timothy Goodman wrote:
> > > Hi,
> > >
> > > I'm a data scientist who routinely uses R in my day-to-day work, for
> > tasks
> > > such as cleaning and transforming data, exploratory data analysis, etc.
> > > This includes frequent use of the pipe operator from the magrittr and
> > dplyr
> > > libraries, %>%.  So, I was pleased to hear about the recent work on a
> > > native pipe operator, |>.
> > >
> > > This seems like a good time to bring up the main pain point I encounter
> > > when using pipes in R, and some suggestions on what could be done about
> > > it.  The issue is that the pipe operator can't be placed at the start of
> > a
> > > line of code (except in parentheses).  That's no different than any
> > binary
> > > operator in R, but I find it's a source of difficulty for the pipe
> > because
> > > of how pipes are often used.
> > >
> > > [I'm assuming here that my usage is fairly typical of a lot of users; at
> > > any rate, I don't think I'm *too* unusual.]
> > >
> > > === Why this is a problem ===
> > >
> > > It's very common (for me, and I suspect for many users of dplyr) to write
> > > multi-step pipelines and put each step on its own line for readability.
> > > Something like this:
> > >
> > >    ### Example 1 ###
> > >    my_data_frame_1 %>%
> > >      filter(some_conditions_1) %>%
> > >      inner_join(my_data_frame_2, by = some_columns_1) %>%
> > >      group_by(some_columns_2) %>%
> > >      summarize(some_aggregate_functions_1) %>%
> > >      filter(some_conditions_2) %>%
> > >      left_join(my_data_frame_3, by = some_columns_3) %>%
> > >      group_by(some_columns_4) %>%
> > >      summarize(some_aggregate_functions_2) %>%
> > >      arrange(some_columns_5)
> > >
> > > [I guess some might consider this an overly long pipeline; for me it's
> > > pretty typical.  I *could* split it up by assigning intermediate results
> > to
> > > variables, but much of the value I get from the pipe is that it lets my
> > > code communicate which results are temporary, and which will be used
> > again
> > > later.  Assigning variables for single-use results would remove that
> > > expressiveness.]
> > >
> > > I would prefer (for reasons I'll explain) to be able to write the above
> > > example like this, which isn't valid R:
> > >
> > >    ### Example 2 (not valid R) ###
> > >    my_data_frame_1
> > >      %>% filter(some_conditions_1)
> > >      %>% inner_join(my_data_frame_2, by = some_columns_1)
> > >      %>% group_by(some_columns_2)
> > >      %>% summarize(some_aggregate_functions_1)
> > >      %>% filter(some_conditions_2)
> > >      %>% left_join(my_data_frame_3, by = some_columns_3)
> > >      %>% group_by(some_columns_4)
> > >      %>% summarize(some_aggregate_functions_2)
> > >      %>% arrange(some_columns_5)
> > >
> > > One (minor) advantage is obvious: It lets you easily line up the pipes,
> > > which means that you can see at a glance that the whole block is a single
> > > pipeline, and you'd immediately notice if you inadvertently omitted a
> > pipe,
> > > which otherwise can lead to confusing output.  [It's also aesthetically
> > > pleasing, especially when %>% is replaced with |>, but that's
> > subjective.]
> > >
> > > But the bigger issue happens when I want to re-run just *part* of the
> > > pipeline.  I do this often when debugging: if the output of the pipeline
> > > seems wrong, I re-run the first few steps and check the output, then
> > > include a little more and re-run again, etc., until I locate my mistake.
> > > Working in an interactive notebook environment, this involves using the
> > > cursor to select just the part of the code I want to re-run.
> > >
> > > It's fast and easy to select *entire* lines of code, but unfortunately
> > with
> > > the pipes placed at the end of the line I must instead select everything
> > > *except* the last three characters of the line (the last two characters
> > for
> > > the new pipe).  Then when I want to re-run the same partial pipeline with
> > > the next line of code included, I can't just press SHIFT+Down to select
> > it
> > > as I otherwise would, but instead must move the cursor horizontally to a
> > > position three characters before the end of *that* line (which is
> > generally
> > > different due to varying line lengths).  And so forth each time I want to
> > > include an additional line.
> > >
> > > Moreover, with the staggered positions of the pipes at the end of each
> > > line, it's very easy to accidentally select the final pipe on a line, and
> > > then sit there for a moment wondering if the environment has stopped
> > > responding before realizing it's just waiting for further input (i.e.,
> > for
> > > the right-hand side).  These small delays and disruptions add up over the
> > > course of a day.
> > >
> > > This desire to select and re-run the first part of a pipeline is also the
> > > reason why it doesn't suffice to achieve syntax like my "Example 2" by
> > > wrapping the entire pipeline in parentheses.  That's of no use if I want
> > to
> > > re-run a selection that doesn't include the final close-paren.
> > >
> > > === Possible Solutions ===
> > >
> > > I can think of two, but maybe there are others.  The first would make
> > > "Example 2" into valid code, and the second would allow you to run a
> > > selection that included a trailing pipe.
> > >
> > >    Solution 1: Add a special case to how R is parsed, so if the first
> > > (non-whitespace) token after an end-line is a pipe, that pipe gets moved
> > to
> > > before the end-line.
> > >      - Argument for: This lets you write code like example 2, which
> > > addresses the pain point around re-running part of a pipeline, and has
> > > advantages for readability.  Also, since starting a line with a pipe
> > > operator is currently invalid, the change wouldn't break any working
> > code.
> > >      - Argument against: It would make the behavior of %>% inconsistent
> > with
> > > that of other binary operators in R.  (However, this objection might not
> > > apply to the new pipe, |>, which I understand is being implemented as a
> > > syntax transformation rather than a binary operator.)
> > >
> > >    Solution 2: Ignore the pipe operator if it occurs as the final token
> > of
> > > the code being executed.
> > >      - Argument for: This would mean the user could select and re-run the
> > > first few lines of a longer pipeline (selecting *entire* lines), avoiding
> > > the difficulties described above.
> > >      - Argument against: This means that %>% would be valid even if it
> > > occurred without a right-hand side, which is inconsistent with other
> > > operators in R.  (But, as above, this objection might not apply to |>.)
> > > Also, this solution still doesn't enable the syntax of "Example 2", with
> > > its readability benefit.
> > >
> > > Thanks for reading this and considering it.
> > >
> > > - Tim Goodman
> > >
> > >       [[alternative HTML version deleted]]
> > >
> > > ______________________________________________
> > > R-devel at r-project.org mailing list
> > > https://stat.ethz.ch/mailman/listinfo/r-devel
> > >
> >
> >
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From h@w|ckh@m @end|ng |rom gm@||@com  Wed Dec  9 21:12:06 2020
From: h@w|ckh@m @end|ng |rom gm@||@com (Hadley Wickham)
Date: Wed, 9 Dec 2020 14:12:06 -0600
Subject: [Rd] New pipe operator and gg plotz
In-Reply-To: <e50e3562-48c4-a078-c9f0-d0b701fdda88@gmail.com>
References: <005a01d6cc06$c1192910$434b7b30$.ref@verizon.net>
 <005a01d6cc06$c1192910$434b7b30$@verizon.net>
 <342b718d-6616-3681-5302-d253c3041f14@gmail.com>
 <034e01d6cc3f$3752af60$a5f80e20$@verizon.net>
 <CAFEqCdxE+bmSbi52v--ax_NwFr8NT5Cd8T2gDovmBpookPiRDA@mail.gmail.com>
 <e50e3562-48c4-a078-c9f0-d0b701fdda88@gmail.com>
Message-ID: <CABdHhvF4tLZELNt+39LD2VA6QTnSPBQ0r0M_QVP6EAcX5ec01Q@mail.gmail.com>

Another option is https://github.com/hadley/ggplot1 ?
Hadley

On Wed, Dec 9, 2020 at 1:24 PM Duncan Murdoch <murdoch.duncan at gmail.com> wrote:
>
> Looks like Sergio Oller took your ambitious approach:
> https://github.com/zeehio/ggpipe.  It hasn't been updated since 2017, so
> there may be some new things in ggplot2 that aren't there yet.
>
> Duncan Murdoch
>
> On 09/12/2020 2:16 p.m., Greg Snow wrote:
> > Since `+` is already a function we could do regular piping to change this code:
> >
> > mtcars %>%
> >    ggplot(aes(x=wt, y=mpg)) +
> >    geom_point()
> >
> > to this:
> >
> > mtcars %>%
> >    ggplot(aes(x=wt, y=mpg)) %>%
> >    `+`(geom_point())
> >
> > Further we can write wrapper functions like:
> >
> > p_geom_point <- function(x,...) {
> >    x + geom_point(...)
> > }
> >
> > The run the code like:
> >
> > mtcars %>%
> >    ggplot(aes(x=wt, y=mpg)) %>%
> >    p_geom_point()
> >
> > All three of the above give the same plot from what I can see, but I
> > have not tested it with very many options beyond the above.
> >
> > A really ambitious person could create a new package with wrappers for
> > all the ggplot2 functions that can come after the plus sign, then we
> > could use pipes for everything.  I don't know if there are any strange
> > circumstances that would make this cause problems (it probably will
> > slow things down slightly, but probably not enough for people to
> > notice).
> >
> > On Sun, Dec 6, 2020 at 7:18 PM Avi Gross via R-devel
> > <r-devel at r-project.org> wrote:
> >>
> >> Thanks, Duncan. That answers my question fairly definitively.
> >>
> >> Although it can be DONE it likely won't be for the reasons Hadley mentioned until we get some other product that replaces it entirely. There are some interesting work-arounds mentioned.
> >>
> >> I was thinking of one that has overhead but might be a pain. Hadley mentioned a slight variant. The first argument to a function now is expected to be the data argument. The second might be the mapping. Now if the function is called with a new first argument that is a ggplot object, it could be possible to test the type and if it is a ggplot object than slide over carefully any additional matched arguments that were not explicitly named. Not sure that is at all easy to do.
> >>
> >> Alternately, you can ask that when used in such a pipeline that the user call all other arguments using names like data=whatever, mapping=aes(whatever) so no other args need to be adjusted by position.
> >>
> >> But all this is academic and I concede will likely not be done. I can live with the plus signs.
> >>
> >>
> >> -----Original Message-----
> >> From: Duncan Murdoch <murdoch.duncan at gmail.com>
> >> Sent: Sunday, December 6, 2020 2:50 PM
> >> To: Avi Gross <avigross at verizon.net>; 'r-devel' <r-devel at r-project.org>
> >> Subject: Re: [Rd] New pipe operator and gg plotz
> >>
> >> Hadley's answer (#7 here:
> >> https://community.rstudio.com/t/why-cant-ggplot2-use/4372) makes it pretty clear that he thinks it would have been nice now if he had made that choice when ggplot2 came out, but it's not worth the effort now to change it.
> >>
> >> Duncan Murdoch
> >>
> >> On 06/12/2020 2:34 p.m., Avi Gross via R-devel wrote:
> >>> As someone who switches back and forth between using standard R methods and those of the tidyverse, depending on the problem, my mood and whether Jupiter aligns with Saturn in the new age of Aquarius, I have a question about the forthcoming built-in pipe. Will it motivate anyone to eventually change or enhance the ggplot functionality to have a version that gets rid of the odd use of the addition symbol?
> >>>
> >>> I mean I now sometimes have a pipeline that looks like:
> >>>
> >>> Data %>%
> >>>        Do_this %>%
> >>>        Do_that(whatever) %>%
> >>>        ggplot(...) +
> >>>                geom_whatever(...) +
> >>>                ...
> >>>
> >>> My understanding is this is a bit of a historical anomaly that might someday be modified back.
> >>>
> >>> As I understand it, the call to ggplot() creates a partially filled-in object that holds all kinds of useful info. The additional calls to geom_point() and so on will add/change that hidden object. Nothing much happens till the object is implicitly or explicitly given to print() which switches to the print function for objects of that type and creates a graph based on the contents of the object at that time. So, in theory, you could have a pipelined version of ggplot where the first function accepts something like a  data.frame or tibble as the default first argument and at the end returns the object we have been describing. All additional functions would then accept such an object as the (hidden?) first argument and return the modified object. The final function in the pipe would either have the value captured in a variable for later use or print implicitly generating a graph.
> >>>
> >>> So the above silly example might become:
> >>>
> >>> Data %>%
> >>>        Do_this %>%
> >>>        Do_that(whatever) %>%
> >>>        ggplot(...) %>%
> >>>        geom_whatever(...) %>%
> >>>        ...
> >>>
> >>> Or, am I missing something here?
> >>>
> >>> The language and extensions such as are now in the tidyverse might be more streamlined and easier to read when using consistent notation. If we now build a reasonable version of the pipeline in, might we encourage other uses to gradually migrate back closer to the mainstream?
> >>>
> >>> -----Original Message-----
> >>> From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Rui
> >>> Barradas
> >>> Sent: Sunday, December 6, 2020 2:51 AM
> >>> To: Gregory Warnes <greg at warnes.net>; Abby Spurdle
> >>> <spurdle.a at gmail.com>
> >>> Cc: r-devel <r-devel at r-project.org>
> >>> Subject: Re: [Rd] New pipe operator
> >>>
> >>> Hello,
> >>>
> >>> If Hilbert liked beer, I like "pipe".
> >>>
> >>> More seriously, a new addition like this one is going to cause problems yet unknown. But it's a good idea to have a pipe operator available. As someone used to magrittr's data pipelines, I will play with this base one before making up my mind. I don't expect its behavior to be exactly like magrittr "%>%" (and it's not). For the moment all I can say is that it is something R users are used to and that it now avoids loading a package.
> >>> As for the new way to define anonymous functions, I am less sure. Too much syntatic sugar? Or am I finding the syntax ugly?
> >>>
> >>> Hope this helps,
> >>>
> >>> Rui Barradas
> >>>
> >>>
> >>> ?s 03:22 de 06/12/20, Gregory Warnes escreveu:
> >>>> If we?re being mathematically pedantic, the ?pipe? operator is
> >>>> actually function composition > That being said, pipes are a simple
> >>>> and well-known idiom. While being less
> >>>> than mathematically exact, it seems a reasonable   label for the (very
> >>>> useful) behavior.
> >>>>
> >>>> On Sat, Dec 5, 2020 at 9:43 PM Abby Spurdle <spurdle.a at gmail.com> wrote:
> >>>>
> >>>>>> This is a good addition
> >>>>>
> >>>>> I can't understand why so many people are calling this a "pipe".
> >>>>> Pipes connect processes, via their I/O streams.
> >>>>> Arguably, a more general interpretation would include sockets and files.
> >>>>>
> >>>>> https://en.wikipedia.org/wiki/Pipeline_(Unix)
> >>>>> https://en.wikipedia.org/wiki/Named_pipe
> >>>>> https://en.wikipedia.org/wiki/Anonymous_pipe
> >>>>>
> >>>>> As far as I can tell, the magrittr-like operators are functions (not
> >>>>> pipes), with nonstandard syntax.
> >>>>> This is not consistent with R's original design philosophy, building
> >>>>> on C, Lisp and S, along with lots of *important* math and stats.
> >>>>>
> >>>>> It's possible that some parties are interested in creating a kind of
> >>>>> "data pipeline".
> >>>>> I'm interested in this myself, and I think we could discuss this more.
> >>>>> But I'm not convinced the magrittr-like operators help to achieve
> >>>>> this goal.
> >>>>> Which, in my opinion, would require one to model programs as
> >>>>> directed graphs, along with some degree of asynchronous input.
> >>>>>
> >>>>> Presumably, these operators will be added to R anyway, and (almost)
> >>>>> no one will listen to me.
> >>>>>
> >>>>> So, I would like to make one suggestion:
> >>>>> Is it possible for these operators to *not* be named:
> >>>>>        The R Pipe
> >>>>>        The S Pipe
> >>>>>        Or anything with a similar meaning.
> >>>>>
> >>>>> Maybe tidy pipe, or something else that links it to its proponents?
> >>>>>
> >>>>> ______________________________________________
> >>>>> R-devel at r-project.org mailing list
> >>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>>>>
> >>>
> >>> ______________________________________________
> >>> R-devel at r-project.org mailing list
> >>> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>>
> >>>
> >>> Scanned by McAfee and confirmed virus-free.
> >>> Find out more here: https://bit.ly/2zCJMrO
> >>>
> >>> ______________________________________________
> >>> R-devel at r-project.org mailing list
> >>> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>>
> >>
> >> ______________________________________________
> >> R-devel at r-project.org mailing list
> >> https://stat.ethz.ch/mailman/listinfo/r-devel
> >
> >
> >
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel



-- 
http://hadley.nz


From murdoch@dunc@n @end|ng |rom gm@||@com  Wed Dec  9 21:12:48 2020
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Wed, 9 Dec 2020 15:12:48 -0500
Subject: [Rd] the pipe |> and line breaks in pipelines
In-Reply-To: <CAGBtDS-KnJaNkzHVkui0wvdoFMDQ8QsRqknRyGkzULtBowtdwA@mail.gmail.com>
References: <CAGBtDS-ZS_35QnJnPqW_fHaJF-LaWo8iPhOaTssyVTCU=q7dSw@mail.gmail.com>
 <408829af-758f-3dcb-5f5d-740d5064992f@gmail.com>
 <CAGBtDS-KnJaNkzHVkui0wvdoFMDQ8QsRqknRyGkzULtBowtdwA@mail.gmail.com>
Message-ID: <219e797a-4ce9-2ad8-3553-5e6ef4a6c269@gmail.com>

On 09/12/2020 2:33 p.m., Timothy Goodman wrote:
> If I type my_data_frame_1 and press Enter (or Ctrl+Enter to execute the 
> command in the Notebook environment I'm using) I certainly *would* 
> expect R to treat it as a complete statement.
> 
> But what I'm talking about is a different case, where I highlight a 
> multi-line statement in my notebook:
> 
>  ? ? my_data_frame1
>  ? ? ? ? |> filter(some_conditions_1)
> 
> and then press Ctrl+Enter.

I don't think I'd like it if parsing changed between passing one line at 
a time and passing a block of lines.  I'd like to be able to highlight a 
few lines and pass those, then type one, then highlight some more and 
pass those:  and have it act as though I just passed the whole combined 
block, or typed everything one line at a time.


 ? Or, I suppose the equivalent would be to run
> an R script containing those two lines of code, or to run a multi-line 
> statement like that from the console (which in RStudio I can do by 
> pressing Shift+Enter between the lines.)
> 
> In those cases, R could either (1) Give an error message [the current 
> behavior], or (2) understand that the first line is meant to be piped to 
> the second.? The second option would be significantly more useful, and 
> is almost certainly what the user intended.
> 
> (For what it's worth, there are some languages, such as Javascript, that 
> consider the first token of the next line when determining if the 
> previous line was complete.? JavaScript's rules around this are overly 
> complicated, but a rule like "a pipe following a line break is treated 
> as continuing the previous line" would be much simpler.? And while it 
> might be objectionable to treat the operator %>% different from other 
> operators, the addition of |>, which isn't truly an operator at all, 
> seems like the right time to consider it.)

I think this would be hard to implement with R's current parser, but 
possible.  I think it could be done by distinguishing between EOL 
markers within a block of text and "end of block" marks.  If it applied 
only to the |> operator it would be *really* ugly.

My strongest objection to it is the one at the top, though.  If I have a 
block of lines sitting in my editor that I just finished executing, with 
the cursor pointing at the next line, I'd like to know that it didn't 
matter whether the lines were passed one at a time, as a block, or some 
combination of those.

Duncan Murdoch

> 
> -Tim
> 
> On Wed, Dec 9, 2020 at 3:12 AM Duncan Murdoch <murdoch.duncan at gmail.com 
> <mailto:murdoch.duncan at gmail.com>> wrote:
> 
>     The requirement for operators at the end of the line comes from the
>     interactive nature of R.? If you type
> 
>      ? ? ?my_data_frame_1
> 
>     how could R know that you are not done, and are planning to type the
>     rest of the expression
> 
>      ? ? ? ?%>% filter(some_conditions_1)
>      ? ? ? ?...
> 
>     before it should consider the expression complete?? The way languages
>     like C do this is by requiring a statement terminator at the end.? You
>     can also do it by wrapping the entire thing in parentheses ().
> 
>     However, be careful: Don't use braces:? they don't work.? And parens
>     have the side effect of removing invisibility from the result (which is
>     a design flaw or bonus, depending on your point of view).? So I
>     actually
>     wouldn't advise this workaround.
> 
>     Duncan Murdoch
> 
> 
>     On 09/12/2020 12:45 a.m., Timothy Goodman wrote:
>      > Hi,
>      >
>      > I'm a data scientist who routinely uses R in my day-to-day work,
>     for tasks
>      > such as cleaning and transforming data, exploratory data
>     analysis, etc.
>      > This includes frequent use of the pipe operator from the magrittr
>     and dplyr
>      > libraries, %>%.? So, I was pleased to hear about the recent work on a
>      > native pipe operator, |>.
>      >
>      > This seems like a good time to bring up the main pain point I
>     encounter
>      > when using pipes in R, and some suggestions on what could be done
>     about
>      > it.? The issue is that the pipe operator can't be placed at the
>     start of a
>      > line of code (except in parentheses).? That's no different than
>     any binary
>      > operator in R, but I find it's a source of difficulty for the
>     pipe because
>      > of how pipes are often used.
>      >
>      > [I'm assuming here that my usage is fairly typical of a lot of
>     users; at
>      > any rate, I don't think I'm *too* unusual.]
>      >
>      > === Why this is a problem ===
>      >
>      > It's very common (for me, and I suspect for many users of dplyr)
>     to write
>      > multi-step pipelines and put each step on its own line for
>     readability.
>      > Something like this:
>      >
>      >? ? ### Example 1 ###
>      >? ? my_data_frame_1 %>%
>      >? ? ? filter(some_conditions_1) %>%
>      >? ? ? inner_join(my_data_frame_2, by = some_columns_1) %>%
>      >? ? ? group_by(some_columns_2) %>%
>      >? ? ? summarize(some_aggregate_functions_1) %>%
>      >? ? ? filter(some_conditions_2) %>%
>      >? ? ? left_join(my_data_frame_3, by = some_columns_3) %>%
>      >? ? ? group_by(some_columns_4) %>%
>      >? ? ? summarize(some_aggregate_functions_2) %>%
>      >? ? ? arrange(some_columns_5)
>      >
>      > [I guess some might consider this an overly long pipeline; for me
>     it's
>      > pretty typical.? I *could* split it up by assigning intermediate
>     results to
>      > variables, but much of the value I get from the pipe is that it
>     lets my
>      > code communicate which results are temporary, and which will be
>     used again
>      > later.? Assigning variables for single-use results would remove that
>      > expressiveness.]
>      >
>      > I would prefer (for reasons I'll explain) to be able to write the
>     above
>      > example like this, which isn't valid R:
>      >
>      >? ? ### Example 2 (not valid R) ###
>      >? ? my_data_frame_1
>      >? ? ? %>% filter(some_conditions_1)
>      >? ? ? %>% inner_join(my_data_frame_2, by = some_columns_1)
>      >? ? ? %>% group_by(some_columns_2)
>      >? ? ? %>% summarize(some_aggregate_functions_1)
>      >? ? ? %>% filter(some_conditions_2)
>      >? ? ? %>% left_join(my_data_frame_3, by = some_columns_3)
>      >? ? ? %>% group_by(some_columns_4)
>      >? ? ? %>% summarize(some_aggregate_functions_2)
>      >? ? ? %>% arrange(some_columns_5)
>      >
>      > One (minor) advantage is obvious: It lets you easily line up the
>     pipes,
>      > which means that you can see at a glance that the whole block is
>     a single
>      > pipeline, and you'd immediately notice if you inadvertently
>     omitted a pipe,
>      > which otherwise can lead to confusing output.? [It's also
>     aesthetically
>      > pleasing, especially when %>% is replaced with |>, but that's
>     subjective.]
>      >
>      > But the bigger issue happens when I want to re-run just *part* of the
>      > pipeline.? I do this often when debugging: if the output of the
>     pipeline
>      > seems wrong, I re-run the first few steps and check the output, then
>      > include a little more and re-run again, etc., until I locate my
>     mistake.
>      > Working in an interactive notebook environment, this involves
>     using the
>      > cursor to select just the part of the code I want to re-run.
>      >
>      > It's fast and easy to select *entire* lines of code, but
>     unfortunately with
>      > the pipes placed at the end of the line I must instead select
>     everything
>      > *except* the last three characters of the line (the last two
>     characters for
>      > the new pipe).? Then when I want to re-run the same partial
>     pipeline with
>      > the next line of code included, I can't just press SHIFT+Down to
>     select it
>      > as I otherwise would, but instead must move the cursor
>     horizontally to a
>      > position three characters before the end of *that* line (which is
>     generally
>      > different due to varying line lengths).? And so forth each time I
>     want to
>      > include an additional line.
>      >
>      > Moreover, with the staggered positions of the pipes at the end of
>     each
>      > line, it's very easy to accidentally select the final pipe on a
>     line, and
>      > then sit there for a moment wondering if the environment has stopped
>      > responding before realizing it's just waiting for further input
>     (i.e., for
>      > the right-hand side).? These small delays and disruptions add up
>     over the
>      > course of a day.
>      >
>      > This desire to select and re-run the first part of a pipeline is
>     also the
>      > reason why it doesn't suffice to achieve syntax like my "Example
>     2" by
>      > wrapping the entire pipeline in parentheses.? That's of no use if
>     I want to
>      > re-run a selection that doesn't include the final close-paren.
>      >
>      > === Possible Solutions ===
>      >
>      > I can think of two, but maybe there are others.? The first would make
>      > "Example 2" into valid code, and the second would allow you to run a
>      > selection that included a trailing pipe.
>      >
>      >? ? Solution 1: Add a special case to how R is parsed, so if the first
>      > (non-whitespace) token after an end-line is a pipe, that pipe
>     gets moved to
>      > before the end-line.
>      >? ? ? - Argument for: This lets you write code like example 2, which
>      > addresses the pain point around re-running part of a pipeline,
>     and has
>      > advantages for readability.? Also, since starting a line with a pipe
>      > operator is currently invalid, the change wouldn't break any
>     working code.
>      >? ? ? - Argument against: It would make the behavior of %>%
>     inconsistent with
>      > that of other binary operators in R.? (However, this objection
>     might not
>      > apply to the new pipe, |>, which I understand is being
>     implemented as a
>      > syntax transformation rather than a binary operator.)
>      >
>      >? ? Solution 2: Ignore the pipe operator if it occurs as the final
>     token of
>      > the code being executed.
>      >? ? ? - Argument for: This would mean the user could select and
>     re-run the
>      > first few lines of a longer pipeline (selecting *entire* lines),
>     avoiding
>      > the difficulties described above.
>      >? ? ? - Argument against: This means that %>% would be valid even
>     if it
>      > occurred without a right-hand side, which is inconsistent with other
>      > operators in R.? (But, as above, this objection might not apply
>     to |>.)
>      > Also, this solution still doesn't enable the syntax of "Example
>     2", with
>      > its readability benefit.
>      >
>      > Thanks for reading this and considering it.
>      >
>      > - Tim Goodman
>      >
>      >? ? ? ?[[alternative HTML version deleted]]
>      >
>      > ______________________________________________
>      > R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
>      > https://stat.ethz.ch/mailman/listinfo/r-devel
>     <https://stat.ethz.ch/mailman/listinfo/r-devel>
>      >
>


From bbo|ker @end|ng |rom gm@||@com  Wed Dec  9 21:19:19 2020
From: bbo|ker @end|ng |rom gm@||@com (Ben Bolker)
Date: Wed, 9 Dec 2020 15:19:19 -0500
Subject: [Rd] the pipe |> and line breaks in pipelines
In-Reply-To: <CAJXgQP0M6t2rUtQ+VuFacjKpBqnSR-oDHH_njbgpQP2tsxj5-Q@mail.gmail.com>
References: <CAGBtDS-ZS_35QnJnPqW_fHaJF-LaWo8iPhOaTssyVTCU=q7dSw@mail.gmail.com>
 <408829af-758f-3dcb-5f5d-740d5064992f@gmail.com>
 <CAGBtDS-KnJaNkzHVkui0wvdoFMDQ8QsRqknRyGkzULtBowtdwA@mail.gmail.com>
 <CAJXgQP0M6t2rUtQ+VuFacjKpBqnSR-oDHH_njbgpQP2tsxj5-Q@mail.gmail.com>
Message-ID: <1bc181af-9380-e1b9-a894-861e03af4973@gmail.com>

   FWIW there is previous discussion of this in a twitter thread from May:

https://twitter.com/bolkerb/status/1258542150620332039

at the end I suggested defining something like .__END <- identity() as a 
pipe-ender.

On 12/9/20 2:58 PM, Kevin Ushey wrote:
> I agree with Duncan that the right solution is to wrap the pipe
> expression with parentheses. Having the parser treat newlines
> differently based on whether the session is interactive, or on what
> type of operator happens to follow a newline, feels like a pretty big
> can of worms.
> 
> I think this (or something similar) would accomplish what you want
> while still retaining the nice aesthetics of the pipe expression, with
> a minimal amount of syntax "noise":
> 
> result <- (
>    data
>      |> op1()
>      |> op2()
> )
> 
> For interactive sessions where you wanted to execute only parts of the
> pipeline at a time, I could see that being accomplished by the editor
> -- it could transform the expression so that it could be handled by R,
> either by hoisting the pipe operator(s) up a line, or by wrapping the
> to-be-executed expression in parentheses for you. If such a style of
> coding became popular enough, I'm sure the developers of such editors
> would be interested and willing to support this ...
> 
> Perhaps more importantly, it would be much easier to accomplish than a
> change to the behavior of the R parser, and it would be work that
> wouldn't have to be maintained by the R Core team.
> 
> Best,
> Kevin
> 
> On Wed, Dec 9, 2020 at 11:34 AM Timothy Goodman <timsgoodman at gmail.com> wrote:
>>
>> If I type my_data_frame_1 and press Enter (or Ctrl+Enter to execute the
>> command in the Notebook environment I'm using) I certainly *would* expect R
>> to treat it as a complete statement.
>>
>> But what I'm talking about is a different case, where I highlight a
>> multi-line statement in my notebook:
>>
>>      my_data_frame1
>>          |> filter(some_conditions_1)
>>
>> and then press Ctrl+Enter.  Or, I suppose the equivalent would be to run an
>> R script containing those two lines of code, or to run a multi-line
>> statement like that from the console (which in RStudio I can do by pressing
>> Shift+Enter between the lines.)
>>
>> In those cases, R could either (1) Give an error message [the current
>> behavior], or (2) understand that the first line is meant to be piped to
>> the second.  The second option would be significantly more useful, and is
>> almost certainly what the user intended.
>>
>> (For what it's worth, there are some languages, such as Javascript, that
>> consider the first token of the next line when determining if the previous
>> line was complete.  JavaScript's rules around this are overly complicated,
>> but a rule like "a pipe following a line break is treated as continuing the
>> previous line" would be much simpler.  And while it might be objectionable
>> to treat the operator %>% different from other operators, the addition of
>> |>, which isn't truly an operator at all, seems like the right time to
>> consider it.)
>>
>> -Tim
>>
>> On Wed, Dec 9, 2020 at 3:12 AM Duncan Murdoch <murdoch.duncan at gmail.com>
>> wrote:
>>
>>> The requirement for operators at the end of the line comes from the
>>> interactive nature of R.  If you type
>>>
>>>       my_data_frame_1
>>>
>>> how could R know that you are not done, and are planning to type the
>>> rest of the expression
>>>
>>>         %>% filter(some_conditions_1)
>>>         ...
>>>
>>> before it should consider the expression complete?  The way languages
>>> like C do this is by requiring a statement terminator at the end.  You
>>> can also do it by wrapping the entire thing in parentheses ().
>>>
>>> However, be careful: Don't use braces:  they don't work.  And parens
>>> have the side effect of removing invisibility from the result (which is
>>> a design flaw or bonus, depending on your point of view).  So I actually
>>> wouldn't advise this workaround.
>>>
>>> Duncan Murdoch
>>>
>>>
>>> On 09/12/2020 12:45 a.m., Timothy Goodman wrote:
>>>> Hi,
>>>>
>>>> I'm a data scientist who routinely uses R in my day-to-day work, for
>>> tasks
>>>> such as cleaning and transforming data, exploratory data analysis, etc.
>>>> This includes frequent use of the pipe operator from the magrittr and
>>> dplyr
>>>> libraries, %>%.  So, I was pleased to hear about the recent work on a
>>>> native pipe operator, |>.
>>>>
>>>> This seems like a good time to bring up the main pain point I encounter
>>>> when using pipes in R, and some suggestions on what could be done about
>>>> it.  The issue is that the pipe operator can't be placed at the start of
>>> a
>>>> line of code (except in parentheses).  That's no different than any
>>> binary
>>>> operator in R, but I find it's a source of difficulty for the pipe
>>> because
>>>> of how pipes are often used.
>>>>
>>>> [I'm assuming here that my usage is fairly typical of a lot of users; at
>>>> any rate, I don't think I'm *too* unusual.]
>>>>
>>>> === Why this is a problem ===
>>>>
>>>> It's very common (for me, and I suspect for many users of dplyr) to write
>>>> multi-step pipelines and put each step on its own line for readability.
>>>> Something like this:
>>>>
>>>>     ### Example 1 ###
>>>>     my_data_frame_1 %>%
>>>>       filter(some_conditions_1) %>%
>>>>       inner_join(my_data_frame_2, by = some_columns_1) %>%
>>>>       group_by(some_columns_2) %>%
>>>>       summarize(some_aggregate_functions_1) %>%
>>>>       filter(some_conditions_2) %>%
>>>>       left_join(my_data_frame_3, by = some_columns_3) %>%
>>>>       group_by(some_columns_4) %>%
>>>>       summarize(some_aggregate_functions_2) %>%
>>>>       arrange(some_columns_5)
>>>>
>>>> [I guess some might consider this an overly long pipeline; for me it's
>>>> pretty typical.  I *could* split it up by assigning intermediate results
>>> to
>>>> variables, but much of the value I get from the pipe is that it lets my
>>>> code communicate which results are temporary, and which will be used
>>> again
>>>> later.  Assigning variables for single-use results would remove that
>>>> expressiveness.]
>>>>
>>>> I would prefer (for reasons I'll explain) to be able to write the above
>>>> example like this, which isn't valid R:
>>>>
>>>>     ### Example 2 (not valid R) ###
>>>>     my_data_frame_1
>>>>       %>% filter(some_conditions_1)
>>>>       %>% inner_join(my_data_frame_2, by = some_columns_1)
>>>>       %>% group_by(some_columns_2)
>>>>       %>% summarize(some_aggregate_functions_1)
>>>>       %>% filter(some_conditions_2)
>>>>       %>% left_join(my_data_frame_3, by = some_columns_3)
>>>>       %>% group_by(some_columns_4)
>>>>       %>% summarize(some_aggregate_functions_2)
>>>>       %>% arrange(some_columns_5)
>>>>
>>>> One (minor) advantage is obvious: It lets you easily line up the pipes,
>>>> which means that you can see at a glance that the whole block is a single
>>>> pipeline, and you'd immediately notice if you inadvertently omitted a
>>> pipe,
>>>> which otherwise can lead to confusing output.  [It's also aesthetically
>>>> pleasing, especially when %>% is replaced with |>, but that's
>>> subjective.]
>>>>
>>>> But the bigger issue happens when I want to re-run just *part* of the
>>>> pipeline.  I do this often when debugging: if the output of the pipeline
>>>> seems wrong, I re-run the first few steps and check the output, then
>>>> include a little more and re-run again, etc., until I locate my mistake.
>>>> Working in an interactive notebook environment, this involves using the
>>>> cursor to select just the part of the code I want to re-run.
>>>>
>>>> It's fast and easy to select *entire* lines of code, but unfortunately
>>> with
>>>> the pipes placed at the end of the line I must instead select everything
>>>> *except* the last three characters of the line (the last two characters
>>> for
>>>> the new pipe).  Then when I want to re-run the same partial pipeline with
>>>> the next line of code included, I can't just press SHIFT+Down to select
>>> it
>>>> as I otherwise would, but instead must move the cursor horizontally to a
>>>> position three characters before the end of *that* line (which is
>>> generally
>>>> different due to varying line lengths).  And so forth each time I want to
>>>> include an additional line.
>>>>
>>>> Moreover, with the staggered positions of the pipes at the end of each
>>>> line, it's very easy to accidentally select the final pipe on a line, and
>>>> then sit there for a moment wondering if the environment has stopped
>>>> responding before realizing it's just waiting for further input (i.e.,
>>> for
>>>> the right-hand side).  These small delays and disruptions add up over the
>>>> course of a day.
>>>>
>>>> This desire to select and re-run the first part of a pipeline is also the
>>>> reason why it doesn't suffice to achieve syntax like my "Example 2" by
>>>> wrapping the entire pipeline in parentheses.  That's of no use if I want
>>> to
>>>> re-run a selection that doesn't include the final close-paren.
>>>>
>>>> === Possible Solutions ===
>>>>
>>>> I can think of two, but maybe there are others.  The first would make
>>>> "Example 2" into valid code, and the second would allow you to run a
>>>> selection that included a trailing pipe.
>>>>
>>>>     Solution 1: Add a special case to how R is parsed, so if the first
>>>> (non-whitespace) token after an end-line is a pipe, that pipe gets moved
>>> to
>>>> before the end-line.
>>>>       - Argument for: This lets you write code like example 2, which
>>>> addresses the pain point around re-running part of a pipeline, and has
>>>> advantages for readability.  Also, since starting a line with a pipe
>>>> operator is currently invalid, the change wouldn't break any working
>>> code.
>>>>       - Argument against: It would make the behavior of %>% inconsistent
>>> with
>>>> that of other binary operators in R.  (However, this objection might not
>>>> apply to the new pipe, |>, which I understand is being implemented as a
>>>> syntax transformation rather than a binary operator.)
>>>>
>>>>     Solution 2: Ignore the pipe operator if it occurs as the final token
>>> of
>>>> the code being executed.
>>>>       - Argument for: This would mean the user could select and re-run the
>>>> first few lines of a longer pipeline (selecting *entire* lines), avoiding
>>>> the difficulties described above.
>>>>       - Argument against: This means that %>% would be valid even if it
>>>> occurred without a right-hand side, which is inconsistent with other
>>>> operators in R.  (But, as above, this objection might not apply to |>.)
>>>> Also, this solution still doesn't enable the syntax of "Example 2", with
>>>> its readability benefit.
>>>>
>>>> Thanks for reading this and considering it.
>>>>
>>>> - Tim Goodman
>>>>
>>>>        [[alternative HTML version deleted]]
>>>>
>>>> ______________________________________________
>>>> R-devel at r-project.org mailing list
>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>
>>>
>>>
>>
>>          [[alternative HTML version deleted]]
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


From t|m@goodm@n @end|ng |rom gm@||@com  Wed Dec  9 21:45:51 2020
From: t|m@goodm@n @end|ng |rom gm@||@com (Timothy Goodman)
Date: Wed, 9 Dec 2020 12:45:51 -0800
Subject: [Rd] the pipe |> and line breaks in pipelines
In-Reply-To: <219e797a-4ce9-2ad8-3553-5e6ef4a6c269@gmail.com>
References: <CAGBtDS-ZS_35QnJnPqW_fHaJF-LaWo8iPhOaTssyVTCU=q7dSw@mail.gmail.com>
 <408829af-758f-3dcb-5f5d-740d5064992f@gmail.com>
 <CAGBtDS-KnJaNkzHVkui0wvdoFMDQ8QsRqknRyGkzULtBowtdwA@mail.gmail.com>
 <219e797a-4ce9-2ad8-3553-5e6ef4a6c269@gmail.com>
Message-ID: <CAGBtDS-m+CcM6ioRpo24C-q0Hjp=O6Y1SB2QJvVs+--pUCCa4A@mail.gmail.com>

Regarding special treatment for |>, isn't it getting special treatment
anyway, because it's implemented as a syntax transformation from x |> f(y)
to f(x, y), rather than as an operator?

That said, the point about wanting a block of code submitted line-by-line
to work the same as a block of code submitted all at once is a fair one.
Maybe the better solution would be if there were a way to say "Submit the
selected code as a single expression, ignoring line-breaks".  Then I could
run any number of lines with pipes at the start and no special character at
the end, and have it treated as a single pipeline.  I suppose that'd need
to be a feature offered by the environment (RStudio's RNotebooks in my
case).  I could wrap my pipelines in parentheses (to make the "pipes at
start of line" syntax valid R code), and then could use the hypothetical
"submit selected code ignoring line-breaks" feature when running just the
first part of the pipeline -- i.e., selecting full lines, but starting
after the opening paren so as not to need to insert a closing paren.

- Tim

On Wed, Dec 9, 2020 at 12:12 PM Duncan Murdoch <murdoch.duncan at gmail.com>
wrote:

> On 09/12/2020 2:33 p.m., Timothy Goodman wrote:
> > If I type my_data_frame_1 and press Enter (or Ctrl+Enter to execute the
> > command in the Notebook environment I'm using) I certainly *would*
> > expect R to treat it as a complete statement.
> >
> > But what I'm talking about is a different case, where I highlight a
> > multi-line statement in my notebook:
> >
> >      my_data_frame1
> >          |> filter(some_conditions_1)
> >
> > and then press Ctrl+Enter.
>
> I don't think I'd like it if parsing changed between passing one line at
> a time and passing a block of lines.  I'd like to be able to highlight a
> few lines and pass those, then type one, then highlight some more and
> pass those:  and have it act as though I just passed the whole combined
> block, or typed everything one line at a time.
>
>
>    Or, I suppose the equivalent would be to run
> > an R script containing those two lines of code, or to run a multi-line
> > statement like that from the console (which in RStudio I can do by
> > pressing Shift+Enter between the lines.)
> >
> > In those cases, R could either (1) Give an error message [the current
> > behavior], or (2) understand that the first line is meant to be piped to
> > the second.  The second option would be significantly more useful, and
> > is almost certainly what the user intended.
> >
> > (For what it's worth, there are some languages, such as Javascript, that
> > consider the first token of the next line when determining if the
> > previous line was complete.  JavaScript's rules around this are overly
> > complicated, but a rule like "a pipe following a line break is treated
> > as continuing the previous line" would be much simpler.  And while it
> > might be objectionable to treat the operator %>% different from other
> > operators, the addition of |>, which isn't truly an operator at all,
> > seems like the right time to consider it.)
>
> I think this would be hard to implement with R's current parser, but
> possible.  I think it could be done by distinguishing between EOL
> markers within a block of text and "end of block" marks.  If it applied
> only to the |> operator it would be *really* ugly.
>
> My strongest objection to it is the one at the top, though.  If I have a
> block of lines sitting in my editor that I just finished executing, with
> the cursor pointing at the next line, I'd like to know that it didn't
> matter whether the lines were passed one at a time, as a block, or some
> combination of those.
>
> Duncan Murdoch
>
> >
> > -Tim
> >
> > On Wed, Dec 9, 2020 at 3:12 AM Duncan Murdoch <murdoch.duncan at gmail.com
> > <mailto:murdoch.duncan at gmail.com>> wrote:
> >
> >     The requirement for operators at the end of the line comes from the
> >     interactive nature of R.  If you type
> >
> >           my_data_frame_1
> >
> >     how could R know that you are not done, and are planning to type the
> >     rest of the expression
> >
> >             %>% filter(some_conditions_1)
> >             ...
> >
> >     before it should consider the expression complete?  The way languages
> >     like C do this is by requiring a statement terminator at the end.
> You
> >     can also do it by wrapping the entire thing in parentheses ().
> >
> >     However, be careful: Don't use braces:  they don't work.  And parens
> >     have the side effect of removing invisibility from the result (which
> is
> >     a design flaw or bonus, depending on your point of view).  So I
> >     actually
> >     wouldn't advise this workaround.
> >
> >     Duncan Murdoch
> >
> >
> >     On 09/12/2020 12:45 a.m., Timothy Goodman wrote:
> >      > Hi,
> >      >
> >      > I'm a data scientist who routinely uses R in my day-to-day work,
> >     for tasks
> >      > such as cleaning and transforming data, exploratory data
> >     analysis, etc.
> >      > This includes frequent use of the pipe operator from the magrittr
> >     and dplyr
> >      > libraries, %>%.  So, I was pleased to hear about the recent work
> on a
> >      > native pipe operator, |>.
> >      >
> >      > This seems like a good time to bring up the main pain point I
> >     encounter
> >      > when using pipes in R, and some suggestions on what could be done
> >     about
> >      > it.  The issue is that the pipe operator can't be placed at the
> >     start of a
> >      > line of code (except in parentheses).  That's no different than
> >     any binary
> >      > operator in R, but I find it's a source of difficulty for the
> >     pipe because
> >      > of how pipes are often used.
> >      >
> >      > [I'm assuming here that my usage is fairly typical of a lot of
> >     users; at
> >      > any rate, I don't think I'm *too* unusual.]
> >      >
> >      > === Why this is a problem ===
> >      >
> >      > It's very common (for me, and I suspect for many users of dplyr)
> >     to write
> >      > multi-step pipelines and put each step on its own line for
> >     readability.
> >      > Something like this:
> >      >
> >      >    ### Example 1 ###
> >      >    my_data_frame_1 %>%
> >      >      filter(some_conditions_1) %>%
> >      >      inner_join(my_data_frame_2, by = some_columns_1) %>%
> >      >      group_by(some_columns_2) %>%
> >      >      summarize(some_aggregate_functions_1) %>%
> >      >      filter(some_conditions_2) %>%
> >      >      left_join(my_data_frame_3, by = some_columns_3) %>%
> >      >      group_by(some_columns_4) %>%
> >      >      summarize(some_aggregate_functions_2) %>%
> >      >      arrange(some_columns_5)
> >      >
> >      > [I guess some might consider this an overly long pipeline; for me
> >     it's
> >      > pretty typical.  I *could* split it up by assigning intermediate
> >     results to
> >      > variables, but much of the value I get from the pipe is that it
> >     lets my
> >      > code communicate which results are temporary, and which will be
> >     used again
> >      > later.  Assigning variables for single-use results would remove
> that
> >      > expressiveness.]
> >      >
> >      > I would prefer (for reasons I'll explain) to be able to write the
> >     above
> >      > example like this, which isn't valid R:
> >      >
> >      >    ### Example 2 (not valid R) ###
> >      >    my_data_frame_1
> >      >      %>% filter(some_conditions_1)
> >      >      %>% inner_join(my_data_frame_2, by = some_columns_1)
> >      >      %>% group_by(some_columns_2)
> >      >      %>% summarize(some_aggregate_functions_1)
> >      >      %>% filter(some_conditions_2)
> >      >      %>% left_join(my_data_frame_3, by = some_columns_3)
> >      >      %>% group_by(some_columns_4)
> >      >      %>% summarize(some_aggregate_functions_2)
> >      >      %>% arrange(some_columns_5)
> >      >
> >      > One (minor) advantage is obvious: It lets you easily line up the
> >     pipes,
> >      > which means that you can see at a glance that the whole block is
> >     a single
> >      > pipeline, and you'd immediately notice if you inadvertently
> >     omitted a pipe,
> >      > which otherwise can lead to confusing output.  [It's also
> >     aesthetically
> >      > pleasing, especially when %>% is replaced with |>, but that's
> >     subjective.]
> >      >
> >      > But the bigger issue happens when I want to re-run just *part* of
> the
> >      > pipeline.  I do this often when debugging: if the output of the
> >     pipeline
> >      > seems wrong, I re-run the first few steps and check the output,
> then
> >      > include a little more and re-run again, etc., until I locate my
> >     mistake.
> >      > Working in an interactive notebook environment, this involves
> >     using the
> >      > cursor to select just the part of the code I want to re-run.
> >      >
> >      > It's fast and easy to select *entire* lines of code, but
> >     unfortunately with
> >      > the pipes placed at the end of the line I must instead select
> >     everything
> >      > *except* the last three characters of the line (the last two
> >     characters for
> >      > the new pipe).  Then when I want to re-run the same partial
> >     pipeline with
> >      > the next line of code included, I can't just press SHIFT+Down to
> >     select it
> >      > as I otherwise would, but instead must move the cursor
> >     horizontally to a
> >      > position three characters before the end of *that* line (which is
> >     generally
> >      > different due to varying line lengths).  And so forth each time I
> >     want to
> >      > include an additional line.
> >      >
> >      > Moreover, with the staggered positions of the pipes at the end of
> >     each
> >      > line, it's very easy to accidentally select the final pipe on a
> >     line, and
> >      > then sit there for a moment wondering if the environment has
> stopped
> >      > responding before realizing it's just waiting for further input
> >     (i.e., for
> >      > the right-hand side).  These small delays and disruptions add up
> >     over the
> >      > course of a day.
> >      >
> >      > This desire to select and re-run the first part of a pipeline is
> >     also the
> >      > reason why it doesn't suffice to achieve syntax like my "Example
> >     2" by
> >      > wrapping the entire pipeline in parentheses.  That's of no use if
> >     I want to
> >      > re-run a selection that doesn't include the final close-paren.
> >      >
> >      > === Possible Solutions ===
> >      >
> >      > I can think of two, but maybe there are others.  The first would
> make
> >      > "Example 2" into valid code, and the second would allow you to
> run a
> >      > selection that included a trailing pipe.
> >      >
> >      >    Solution 1: Add a special case to how R is parsed, so if the
> first
> >      > (non-whitespace) token after an end-line is a pipe, that pipe
> >     gets moved to
> >      > before the end-line.
> >      >      - Argument for: This lets you write code like example 2,
> which
> >      > addresses the pain point around re-running part of a pipeline,
> >     and has
> >      > advantages for readability.  Also, since starting a line with a
> pipe
> >      > operator is currently invalid, the change wouldn't break any
> >     working code.
> >      >      - Argument against: It would make the behavior of %>%
> >     inconsistent with
> >      > that of other binary operators in R.  (However, this objection
> >     might not
> >      > apply to the new pipe, |>, which I understand is being
> >     implemented as a
> >      > syntax transformation rather than a binary operator.)
> >      >
> >      >    Solution 2: Ignore the pipe operator if it occurs as the final
> >     token of
> >      > the code being executed.
> >      >      - Argument for: This would mean the user could select and
> >     re-run the
> >      > first few lines of a longer pipeline (selecting *entire* lines),
> >     avoiding
> >      > the difficulties described above.
> >      >      - Argument against: This means that %>% would be valid even
> >     if it
> >      > occurred without a right-hand side, which is inconsistent with
> other
> >      > operators in R.  (But, as above, this objection might not apply
> >     to |>.)
> >      > Also, this solution still doesn't enable the syntax of "Example
> >     2", with
> >      > its readability benefit.
> >      >
> >      > Thanks for reading this and considering it.
> >      >
> >      > - Tim Goodman
> >      >
> >      >       [[alternative HTML version deleted]]
> >      >
> >      > ______________________________________________
> >      > R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
> >      > https://stat.ethz.ch/mailman/listinfo/r-devel
> >     <https://stat.ethz.ch/mailman/listinfo/r-devel>
> >      >
> >
>
>

	[[alternative HTML version deleted]]


From bbo|ker @end|ng |rom gm@||@com  Wed Dec  9 21:51:01 2020
From: bbo|ker @end|ng |rom gm@||@com (Ben Bolker)
Date: Wed, 9 Dec 2020 15:51:01 -0500
Subject: [Rd] the pipe |> and line breaks in pipelines
In-Reply-To: <CAGBtDS-m+CcM6ioRpo24C-q0Hjp=O6Y1SB2QJvVs+--pUCCa4A@mail.gmail.com>
References: <CAGBtDS-ZS_35QnJnPqW_fHaJF-LaWo8iPhOaTssyVTCU=q7dSw@mail.gmail.com>
 <408829af-758f-3dcb-5f5d-740d5064992f@gmail.com>
 <CAGBtDS-KnJaNkzHVkui0wvdoFMDQ8QsRqknRyGkzULtBowtdwA@mail.gmail.com>
 <219e797a-4ce9-2ad8-3553-5e6ef4a6c269@gmail.com>
 <CAGBtDS-m+CcM6ioRpo24C-q0Hjp=O6Y1SB2QJvVs+--pUCCa4A@mail.gmail.com>
Message-ID: <3f0d3e85-b122-aa45-cedb-d2c6789a9536@gmail.com>

   Definitely support the idea that if this kind of trickery is going to 
happen that it be confined to some particular IDE/environment or some 
particular submission protocol. I don't want it to happen in my ESS 
session please ... I'd rather deal with the parentheses.

On 12/9/20 3:45 PM, Timothy Goodman wrote:
> Regarding special treatment for |>, isn't it getting special treatment
> anyway, because it's implemented as a syntax transformation from x |> f(y)
> to f(x, y), rather than as an operator?
> 
> That said, the point about wanting a block of code submitted line-by-line
> to work the same as a block of code submitted all at once is a fair one.
> Maybe the better solution would be if there were a way to say "Submit the
> selected code as a single expression, ignoring line-breaks".  Then I could
> run any number of lines with pipes at the start and no special character at
> the end, and have it treated as a single pipeline.  I suppose that'd need
> to be a feature offered by the environment (RStudio's RNotebooks in my
> case).  I could wrap my pipelines in parentheses (to make the "pipes at
> start of line" syntax valid R code), and then could use the hypothetical
> "submit selected code ignoring line-breaks" feature when running just the
> first part of the pipeline -- i.e., selecting full lines, but starting
> after the opening paren so as not to need to insert a closing paren.
> 
> - Tim
> 
> On Wed, Dec 9, 2020 at 12:12 PM Duncan Murdoch <murdoch.duncan at gmail.com>
> wrote:
> 
>> On 09/12/2020 2:33 p.m., Timothy Goodman wrote:
>>> If I type my_data_frame_1 and press Enter (or Ctrl+Enter to execute the
>>> command in the Notebook environment I'm using) I certainly *would*
>>> expect R to treat it as a complete statement.
>>>
>>> But what I'm talking about is a different case, where I highlight a
>>> multi-line statement in my notebook:
>>>
>>>       my_data_frame1
>>>           |> filter(some_conditions_1)
>>>
>>> and then press Ctrl+Enter.
>>
>> I don't think I'd like it if parsing changed between passing one line at
>> a time and passing a block of lines.  I'd like to be able to highlight a
>> few lines and pass those, then type one, then highlight some more and
>> pass those:  and have it act as though I just passed the whole combined
>> block, or typed everything one line at a time.
>>
>>
>>     Or, I suppose the equivalent would be to run
>>> an R script containing those two lines of code, or to run a multi-line
>>> statement like that from the console (which in RStudio I can do by
>>> pressing Shift+Enter between the lines.)
>>>
>>> In those cases, R could either (1) Give an error message [the current
>>> behavior], or (2) understand that the first line is meant to be piped to
>>> the second.  The second option would be significantly more useful, and
>>> is almost certainly what the user intended.
>>>
>>> (For what it's worth, there are some languages, such as Javascript, that
>>> consider the first token of the next line when determining if the
>>> previous line was complete.  JavaScript's rules around this are overly
>>> complicated, but a rule like "a pipe following a line break is treated
>>> as continuing the previous line" would be much simpler.  And while it
>>> might be objectionable to treat the operator %>% different from other
>>> operators, the addition of |>, which isn't truly an operator at all,
>>> seems like the right time to consider it.)
>>
>> I think this would be hard to implement with R's current parser, but
>> possible.  I think it could be done by distinguishing between EOL
>> markers within a block of text and "end of block" marks.  If it applied
>> only to the |> operator it would be *really* ugly.
>>
>> My strongest objection to it is the one at the top, though.  If I have a
>> block of lines sitting in my editor that I just finished executing, with
>> the cursor pointing at the next line, I'd like to know that it didn't
>> matter whether the lines were passed one at a time, as a block, or some
>> combination of those.
>>
>> Duncan Murdoch
>>
>>>
>>> -Tim
>>>
>>> On Wed, Dec 9, 2020 at 3:12 AM Duncan Murdoch <murdoch.duncan at gmail.com
>>> <mailto:murdoch.duncan at gmail.com>> wrote:
>>>
>>>      The requirement for operators at the end of the line comes from the
>>>      interactive nature of R.  If you type
>>>
>>>            my_data_frame_1
>>>
>>>      how could R know that you are not done, and are planning to type the
>>>      rest of the expression
>>>
>>>              %>% filter(some_conditions_1)
>>>              ...
>>>
>>>      before it should consider the expression complete?  The way languages
>>>      like C do this is by requiring a statement terminator at the end.
>> You
>>>      can also do it by wrapping the entire thing in parentheses ().
>>>
>>>      However, be careful: Don't use braces:  they don't work.  And parens
>>>      have the side effect of removing invisibility from the result (which
>> is
>>>      a design flaw or bonus, depending on your point of view).  So I
>>>      actually
>>>      wouldn't advise this workaround.
>>>
>>>      Duncan Murdoch
>>>
>>>
>>>      On 09/12/2020 12:45 a.m., Timothy Goodman wrote:
>>>       > Hi,
>>>       >
>>>       > I'm a data scientist who routinely uses R in my day-to-day work,
>>>      for tasks
>>>       > such as cleaning and transforming data, exploratory data
>>>      analysis, etc.
>>>       > This includes frequent use of the pipe operator from the magrittr
>>>      and dplyr
>>>       > libraries, %>%.  So, I was pleased to hear about the recent work
>> on a
>>>       > native pipe operator, |>.
>>>       >
>>>       > This seems like a good time to bring up the main pain point I
>>>      encounter
>>>       > when using pipes in R, and some suggestions on what could be done
>>>      about
>>>       > it.  The issue is that the pipe operator can't be placed at the
>>>      start of a
>>>       > line of code (except in parentheses).  That's no different than
>>>      any binary
>>>       > operator in R, but I find it's a source of difficulty for the
>>>      pipe because
>>>       > of how pipes are often used.
>>>       >
>>>       > [I'm assuming here that my usage is fairly typical of a lot of
>>>      users; at
>>>       > any rate, I don't think I'm *too* unusual.]
>>>       >
>>>       > === Why this is a problem ===
>>>       >
>>>       > It's very common (for me, and I suspect for many users of dplyr)
>>>      to write
>>>       > multi-step pipelines and put each step on its own line for
>>>      readability.
>>>       > Something like this:
>>>       >
>>>       >    ### Example 1 ###
>>>       >    my_data_frame_1 %>%
>>>       >      filter(some_conditions_1) %>%
>>>       >      inner_join(my_data_frame_2, by = some_columns_1) %>%
>>>       >      group_by(some_columns_2) %>%
>>>       >      summarize(some_aggregate_functions_1) %>%
>>>       >      filter(some_conditions_2) %>%
>>>       >      left_join(my_data_frame_3, by = some_columns_3) %>%
>>>       >      group_by(some_columns_4) %>%
>>>       >      summarize(some_aggregate_functions_2) %>%
>>>       >      arrange(some_columns_5)
>>>       >
>>>       > [I guess some might consider this an overly long pipeline; for me
>>>      it's
>>>       > pretty typical.  I *could* split it up by assigning intermediate
>>>      results to
>>>       > variables, but much of the value I get from the pipe is that it
>>>      lets my
>>>       > code communicate which results are temporary, and which will be
>>>      used again
>>>       > later.  Assigning variables for single-use results would remove
>> that
>>>       > expressiveness.]
>>>       >
>>>       > I would prefer (for reasons I'll explain) to be able to write the
>>>      above
>>>       > example like this, which isn't valid R:
>>>       >
>>>       >    ### Example 2 (not valid R) ###
>>>       >    my_data_frame_1
>>>       >      %>% filter(some_conditions_1)
>>>       >      %>% inner_join(my_data_frame_2, by = some_columns_1)
>>>       >      %>% group_by(some_columns_2)
>>>       >      %>% summarize(some_aggregate_functions_1)
>>>       >      %>% filter(some_conditions_2)
>>>       >      %>% left_join(my_data_frame_3, by = some_columns_3)
>>>       >      %>% group_by(some_columns_4)
>>>       >      %>% summarize(some_aggregate_functions_2)
>>>       >      %>% arrange(some_columns_5)
>>>       >
>>>       > One (minor) advantage is obvious: It lets you easily line up the
>>>      pipes,
>>>       > which means that you can see at a glance that the whole block is
>>>      a single
>>>       > pipeline, and you'd immediately notice if you inadvertently
>>>      omitted a pipe,
>>>       > which otherwise can lead to confusing output.  [It's also
>>>      aesthetically
>>>       > pleasing, especially when %>% is replaced with |>, but that's
>>>      subjective.]
>>>       >
>>>       > But the bigger issue happens when I want to re-run just *part* of
>> the
>>>       > pipeline.  I do this often when debugging: if the output of the
>>>      pipeline
>>>       > seems wrong, I re-run the first few steps and check the output,
>> then
>>>       > include a little more and re-run again, etc., until I locate my
>>>      mistake.
>>>       > Working in an interactive notebook environment, this involves
>>>      using the
>>>       > cursor to select just the part of the code I want to re-run.
>>>       >
>>>       > It's fast and easy to select *entire* lines of code, but
>>>      unfortunately with
>>>       > the pipes placed at the end of the line I must instead select
>>>      everything
>>>       > *except* the last three characters of the line (the last two
>>>      characters for
>>>       > the new pipe).  Then when I want to re-run the same partial
>>>      pipeline with
>>>       > the next line of code included, I can't just press SHIFT+Down to
>>>      select it
>>>       > as I otherwise would, but instead must move the cursor
>>>      horizontally to a
>>>       > position three characters before the end of *that* line (which is
>>>      generally
>>>       > different due to varying line lengths).  And so forth each time I
>>>      want to
>>>       > include an additional line.
>>>       >
>>>       > Moreover, with the staggered positions of the pipes at the end of
>>>      each
>>>       > line, it's very easy to accidentally select the final pipe on a
>>>      line, and
>>>       > then sit there for a moment wondering if the environment has
>> stopped
>>>       > responding before realizing it's just waiting for further input
>>>      (i.e., for
>>>       > the right-hand side).  These small delays and disruptions add up
>>>      over the
>>>       > course of a day.
>>>       >
>>>       > This desire to select and re-run the first part of a pipeline is
>>>      also the
>>>       > reason why it doesn't suffice to achieve syntax like my "Example
>>>      2" by
>>>       > wrapping the entire pipeline in parentheses.  That's of no use if
>>>      I want to
>>>       > re-run a selection that doesn't include the final close-paren.
>>>       >
>>>       > === Possible Solutions ===
>>>       >
>>>       > I can think of two, but maybe there are others.  The first would
>> make
>>>       > "Example 2" into valid code, and the second would allow you to
>> run a
>>>       > selection that included a trailing pipe.
>>>       >
>>>       >    Solution 1: Add a special case to how R is parsed, so if the
>> first
>>>       > (non-whitespace) token after an end-line is a pipe, that pipe
>>>      gets moved to
>>>       > before the end-line.
>>>       >      - Argument for: This lets you write code like example 2,
>> which
>>>       > addresses the pain point around re-running part of a pipeline,
>>>      and has
>>>       > advantages for readability.  Also, since starting a line with a
>> pipe
>>>       > operator is currently invalid, the change wouldn't break any
>>>      working code.
>>>       >      - Argument against: It would make the behavior of %>%
>>>      inconsistent with
>>>       > that of other binary operators in R.  (However, this objection
>>>      might not
>>>       > apply to the new pipe, |>, which I understand is being
>>>      implemented as a
>>>       > syntax transformation rather than a binary operator.)
>>>       >
>>>       >    Solution 2: Ignore the pipe operator if it occurs as the final
>>>      token of
>>>       > the code being executed.
>>>       >      - Argument for: This would mean the user could select and
>>>      re-run the
>>>       > first few lines of a longer pipeline (selecting *entire* lines),
>>>      avoiding
>>>       > the difficulties described above.
>>>       >      - Argument against: This means that %>% would be valid even
>>>      if it
>>>       > occurred without a right-hand side, which is inconsistent with
>> other
>>>       > operators in R.  (But, as above, this objection might not apply
>>>      to |>.)
>>>       > Also, this solution still doesn't enable the syntax of "Example
>>>      2", with
>>>       > its readability benefit.
>>>       >
>>>       > Thanks for reading this and considering it.
>>>       >
>>>       > - Tim Goodman
>>>       >
>>>       >       [[alternative HTML version deleted]]
>>>       >
>>>       > ______________________________________________
>>>       > R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
>>>       > https://stat.ethz.ch/mailman/listinfo/r-devel
>>>      <https://stat.ethz.ch/mailman/listinfo/r-devel>
>>>       >
>>>
>>
>>
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


From murdoch@dunc@n @end|ng |rom gm@||@com  Wed Dec  9 22:03:45 2020
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Wed, 9 Dec 2020 16:03:45 -0500
Subject: [Rd] the pipe |> and line breaks in pipelines
In-Reply-To: <CAGBtDS-m+CcM6ioRpo24C-q0Hjp=O6Y1SB2QJvVs+--pUCCa4A@mail.gmail.com>
References: <CAGBtDS-ZS_35QnJnPqW_fHaJF-LaWo8iPhOaTssyVTCU=q7dSw@mail.gmail.com>
 <408829af-758f-3dcb-5f5d-740d5064992f@gmail.com>
 <CAGBtDS-KnJaNkzHVkui0wvdoFMDQ8QsRqknRyGkzULtBowtdwA@mail.gmail.com>
 <219e797a-4ce9-2ad8-3553-5e6ef4a6c269@gmail.com>
 <CAGBtDS-m+CcM6ioRpo24C-q0Hjp=O6Y1SB2QJvVs+--pUCCa4A@mail.gmail.com>
Message-ID: <7685a9a2-b91a-0a71-29be-0723d3c52570@gmail.com>

On 09/12/2020 3:45 p.m., Timothy Goodman wrote:
> Regarding special treatment for |>, isn't it getting special treatment 
> anyway, because it's implemented as a syntax transformation from x |> 
> f(y) to f(x, y), rather than as an operator?

That's different.  Currently |> is parsed just like any other binary 
operator, it's the code emitted after parsing that is different from 
most other cases.  I think your suggestion would need changes in the 
parsing itself.

It's a few years since I worked with Bison (the parser generator that R 
uses), but I recall that handling inconsistencies was always tricky.


> That said, the point about wanting a block of code submitted 
> line-by-line to work the same as a block of code submitted all at once 
> is a fair one.? Maybe the better solution would be if there were a way 
> to say "Submit the selected code as a single expression,?ignoring 
> line-breaks". 

The way to do that is to replace some of the line breaks with 
semicolons, which act as statement separators.  The tricky bit is to 
figure out which ones to replace.  So if your block is

   x +
   y
   z

you'd glue it together as "x + y; z".  RStudio appears to know enough 
about R parsing to do that, and presumably if it was allowed to look at 
the start of the next line could handle things like

   x
   |> f()
   z

and rewrite them as "x |> f(); z".  It would mess up debugging a little 
(z is now on line 1, not line 3), but maybe it could undo the 
transformation if R told it there was a problem at line 1, column 11.


  Then I could run any number of lines with pipes at the
> start and no special character at the end, and have it treated as a 
> single pipeline.? I suppose that'd need to be a feature offered by the 
> environment (RStudio's RNotebooks in my case).? I could wrap my 
> pipelines in parentheses (to make the "pipes at start of line" syntax 
> valid R code), and then could use the hypothetical "submit selected code 
> ignoring line-breaks" feature when running just the first part of the 
> pipeline -- i.e., selecting full lines, but starting after the opening 
> paren so as not to need to insert a closing paren.

I think I don't understand your workflow enough to comment on this.

Duncan


> 
> - Tim
> 
> On Wed, Dec 9, 2020 at 12:12 PM Duncan Murdoch <murdoch.duncan at gmail.com 
> <mailto:murdoch.duncan at gmail.com>> wrote:
> 
>     On 09/12/2020 2:33 p.m., Timothy Goodman wrote:
>      > If I type my_data_frame_1 and press Enter (or Ctrl+Enter to
>     execute the
>      > command in the Notebook environment I'm using) I certainly *would*
>      > expect R to treat it as a complete statement.
>      >
>      > But what I'm talking about is a different case, where I highlight a
>      > multi-line statement in my notebook:
>      >
>      >? ? ? my_data_frame1
>      >? ? ? ? ? |> filter(some_conditions_1)
>      >
>      > and then press Ctrl+Enter.
> 
>     I don't think I'd like it if parsing changed between passing one
>     line at
>     a time and passing a block of lines.? I'd like to be able to
>     highlight a
>     few lines and pass those, then type one, then highlight some more and
>     pass those:? and have it act as though I just passed the whole combined
>     block, or typed everything one line at a time.
> 
> 
>      ?? Or, I suppose the equivalent would be to run
>      > an R script containing those two lines of code, or to run a
>     multi-line
>      > statement like that from the console (which in RStudio I can do by
>      > pressing Shift+Enter between the lines.)
>      >
>      > In those cases, R could either (1) Give an error message [the
>     current
>      > behavior], or (2) understand that the first line is meant to be
>     piped to
>      > the second.? The second option would be significantly more
>     useful, and
>      > is almost certainly what the user intended.
>      >
>      > (For what it's worth, there are some languages, such as
>     Javascript, that
>      > consider the first token of the next line when determining if the
>      > previous line was complete.? JavaScript's rules around this are
>     overly
>      > complicated, but a rule like "a pipe following a line break is
>     treated
>      > as continuing the previous line" would be much simpler.? And
>     while it
>      > might be objectionable to treat the operator %>% different from
>     other
>      > operators, the addition of |>, which isn't truly an operator at all,
>      > seems like the right time to consider it.)
> 
>     I think this would be hard to implement with R's current parser, but
>     possible.? I think it could be done by distinguishing between EOL
>     markers within a block of text and "end of block" marks.? If it applied
>     only to the |> operator it would be *really* ugly.
> 
>     My strongest objection to it is the one at the top, though.? If I
>     have a
>     block of lines sitting in my editor that I just finished executing,
>     with
>     the cursor pointing at the next line, I'd like to know that it didn't
>     matter whether the lines were passed one at a time, as a block, or some
>     combination of those.
> 
>     Duncan Murdoch
> 
>      >
>      > -Tim
>      >
>      > On Wed, Dec 9, 2020 at 3:12 AM Duncan Murdoch
>     <murdoch.duncan at gmail.com <mailto:murdoch.duncan at gmail.com>
>      > <mailto:murdoch.duncan at gmail.com
>     <mailto:murdoch.duncan at gmail.com>>> wrote:
>      >
>      >? ? ?The requirement for operators at the end of the line comes
>     from the
>      >? ? ?interactive nature of R.? If you type
>      >
>      >? ? ? ? ? ?my_data_frame_1
>      >
>      >? ? ?how could R know that you are not done, and are planning to
>     type the
>      >? ? ?rest of the expression
>      >
>      >? ? ? ? ? ? ?%>% filter(some_conditions_1)
>      >? ? ? ? ? ? ?...
>      >
>      >? ? ?before it should consider the expression complete?? The way
>     languages
>      >? ? ?like C do this is by requiring a statement terminator at the
>     end.? You
>      >? ? ?can also do it by wrapping the entire thing in parentheses ().
>      >
>      >? ? ?However, be careful: Don't use braces:? they don't work.? And
>     parens
>      >? ? ?have the side effect of removing invisibility from the result
>     (which is
>      >? ? ?a design flaw or bonus, depending on your point of view).? So I
>      >? ? ?actually
>      >? ? ?wouldn't advise this workaround.
>      >
>      >? ? ?Duncan Murdoch
>      >
>      >
>      >? ? ?On 09/12/2020 12:45 a.m., Timothy Goodman wrote:
>      >? ? ? > Hi,
>      >? ? ? >
>      >? ? ? > I'm a data scientist who routinely uses R in my day-to-day
>     work,
>      >? ? ?for tasks
>      >? ? ? > such as cleaning and transforming data, exploratory data
>      >? ? ?analysis, etc.
>      >? ? ? > This includes frequent use of the pipe operator from the
>     magrittr
>      >? ? ?and dplyr
>      >? ? ? > libraries, %>%.? So, I was pleased to hear about the
>     recent work on a
>      >? ? ? > native pipe operator, |>.
>      >? ? ? >
>      >? ? ? > This seems like a good time to bring up the main pain point I
>      >? ? ?encounter
>      >? ? ? > when using pipes in R, and some suggestions on what could
>     be done
>      >? ? ?about
>      >? ? ? > it.? The issue is that the pipe operator can't be placed
>     at the
>      >? ? ?start of a
>      >? ? ? > line of code (except in parentheses).? That's no different
>     than
>      >? ? ?any binary
>      >? ? ? > operator in R, but I find it's a source of difficulty for the
>      >? ? ?pipe because
>      >? ? ? > of how pipes are often used.
>      >? ? ? >
>      >? ? ? > [I'm assuming here that my usage is fairly typical of a lot of
>      >? ? ?users; at
>      >? ? ? > any rate, I don't think I'm *too* unusual.]
>      >? ? ? >
>      >? ? ? > === Why this is a problem ===
>      >? ? ? >
>      >? ? ? > It's very common (for me, and I suspect for many users of
>     dplyr)
>      >? ? ?to write
>      >? ? ? > multi-step pipelines and put each step on its own line for
>      >? ? ?readability.
>      >? ? ? > Something like this:
>      >? ? ? >
>      >? ? ? >? ? ### Example 1 ###
>      >? ? ? >? ? my_data_frame_1 %>%
>      >? ? ? >? ? ? filter(some_conditions_1) %>%
>      >? ? ? >? ? ? inner_join(my_data_frame_2, by = some_columns_1) %>%
>      >? ? ? >? ? ? group_by(some_columns_2) %>%
>      >? ? ? >? ? ? summarize(some_aggregate_functions_1) %>%
>      >? ? ? >? ? ? filter(some_conditions_2) %>%
>      >? ? ? >? ? ? left_join(my_data_frame_3, by = some_columns_3) %>%
>      >? ? ? >? ? ? group_by(some_columns_4) %>%
>      >? ? ? >? ? ? summarize(some_aggregate_functions_2) %>%
>      >? ? ? >? ? ? arrange(some_columns_5)
>      >? ? ? >
>      >? ? ? > [I guess some might consider this an overly long pipeline;
>     for me
>      >? ? ?it's
>      >? ? ? > pretty typical.? I *could* split it up by assigning
>     intermediate
>      >? ? ?results to
>      >? ? ? > variables, but much of the value I get from the pipe is
>     that it
>      >? ? ?lets my
>      >? ? ? > code communicate which results are temporary, and which
>     will be
>      >? ? ?used again
>      >? ? ? > later.? Assigning variables for single-use results would
>     remove that
>      >? ? ? > expressiveness.]
>      >? ? ? >
>      >? ? ? > I would prefer (for reasons I'll explain) to be able to
>     write the
>      >? ? ?above
>      >? ? ? > example like this, which isn't valid R:
>      >? ? ? >
>      >? ? ? >? ? ### Example 2 (not valid R) ###
>      >? ? ? >? ? my_data_frame_1
>      >? ? ? >? ? ? %>% filter(some_conditions_1)
>      >? ? ? >? ? ? %>% inner_join(my_data_frame_2, by = some_columns_1)
>      >? ? ? >? ? ? %>% group_by(some_columns_2)
>      >? ? ? >? ? ? %>% summarize(some_aggregate_functions_1)
>      >? ? ? >? ? ? %>% filter(some_conditions_2)
>      >? ? ? >? ? ? %>% left_join(my_data_frame_3, by = some_columns_3)
>      >? ? ? >? ? ? %>% group_by(some_columns_4)
>      >? ? ? >? ? ? %>% summarize(some_aggregate_functions_2)
>      >? ? ? >? ? ? %>% arrange(some_columns_5)
>      >? ? ? >
>      >? ? ? > One (minor) advantage is obvious: It lets you easily line
>     up the
>      >? ? ?pipes,
>      >? ? ? > which means that you can see at a glance that the whole
>     block is
>      >? ? ?a single
>      >? ? ? > pipeline, and you'd immediately notice if you inadvertently
>      >? ? ?omitted a pipe,
>      >? ? ? > which otherwise can lead to confusing output.? [It's also
>      >? ? ?aesthetically
>      >? ? ? > pleasing, especially when %>% is replaced with |>, but that's
>      >? ? ?subjective.]
>      >? ? ? >
>      >? ? ? > But the bigger issue happens when I want to re-run just
>     *part* of the
>      >? ? ? > pipeline.? I do this often when debugging: if the output
>     of the
>      >? ? ?pipeline
>      >? ? ? > seems wrong, I re-run the first few steps and check the
>     output, then
>      >? ? ? > include a little more and re-run again, etc., until I
>     locate my
>      >? ? ?mistake.
>      >? ? ? > Working in an interactive notebook environment, this involves
>      >? ? ?using the
>      >? ? ? > cursor to select just the part of the code I want to re-run.
>      >? ? ? >
>      >? ? ? > It's fast and easy to select *entire* lines of code, but
>      >? ? ?unfortunately with
>      >? ? ? > the pipes placed at the end of the line I must instead select
>      >? ? ?everything
>      >? ? ? > *except* the last three characters of the line (the last two
>      >? ? ?characters for
>      >? ? ? > the new pipe).? Then when I want to re-run the same partial
>      >? ? ?pipeline with
>      >? ? ? > the next line of code included, I can't just press
>     SHIFT+Down to
>      >? ? ?select it
>      >? ? ? > as I otherwise would, but instead must move the cursor
>      >? ? ?horizontally to a
>      >? ? ? > position three characters before the end of *that* line
>     (which is
>      >? ? ?generally
>      >? ? ? > different due to varying line lengths).? And so forth each
>     time I
>      >? ? ?want to
>      >? ? ? > include an additional line.
>      >? ? ? >
>      >? ? ? > Moreover, with the staggered positions of the pipes at the
>     end of
>      >? ? ?each
>      >? ? ? > line, it's very easy to accidentally select the final pipe
>     on a
>      >? ? ?line, and
>      >? ? ? > then sit there for a moment wondering if the environment
>     has stopped
>      >? ? ? > responding before realizing it's just waiting for further
>     input
>      >? ? ?(i.e., for
>      >? ? ? > the right-hand side).? These small delays and disruptions
>     add up
>      >? ? ?over the
>      >? ? ? > course of a day.
>      >? ? ? >
>      >? ? ? > This desire to select and re-run the first part of a
>     pipeline is
>      >? ? ?also the
>      >? ? ? > reason why it doesn't suffice to achieve syntax like my
>     "Example
>      >? ? ?2" by
>      >? ? ? > wrapping the entire pipeline in parentheses.? That's of no
>     use if
>      >? ? ?I want to
>      >? ? ? > re-run a selection that doesn't include the final close-paren.
>      >? ? ? >
>      >? ? ? > === Possible Solutions ===
>      >? ? ? >
>      >? ? ? > I can think of two, but maybe there are others.? The first
>     would make
>      >? ? ? > "Example 2" into valid code, and the second would allow
>     you to run a
>      >? ? ? > selection that included a trailing pipe.
>      >? ? ? >
>      >? ? ? >? ? Solution 1: Add a special case to how R is parsed, so
>     if the first
>      >? ? ? > (non-whitespace) token after an end-line is a pipe, that pipe
>      >? ? ?gets moved to
>      >? ? ? > before the end-line.
>      >? ? ? >? ? ? - Argument for: This lets you write code like example
>     2, which
>      >? ? ? > addresses the pain point around re-running part of a pipeline,
>      >? ? ?and has
>      >? ? ? > advantages for readability.? Also, since starting a line
>     with a pipe
>      >? ? ? > operator is currently invalid, the change wouldn't break any
>      >? ? ?working code.
>      >? ? ? >? ? ? - Argument against: It would make the behavior of %>%
>      >? ? ?inconsistent with
>      >? ? ? > that of other binary operators in R.? (However, this objection
>      >? ? ?might not
>      >? ? ? > apply to the new pipe, |>, which I understand is being
>      >? ? ?implemented as a
>      >? ? ? > syntax transformation rather than a binary operator.)
>      >? ? ? >
>      >? ? ? >? ? Solution 2: Ignore the pipe operator if it occurs as
>     the final
>      >? ? ?token of
>      >? ? ? > the code being executed.
>      >? ? ? >? ? ? - Argument for: This would mean the user could select and
>      >? ? ?re-run the
>      >? ? ? > first few lines of a longer pipeline (selecting *entire*
>     lines),
>      >? ? ?avoiding
>      >? ? ? > the difficulties described above.
>      >? ? ? >? ? ? - Argument against: This means that %>% would be
>     valid even
>      >? ? ?if it
>      >? ? ? > occurred without a right-hand side, which is inconsistent
>     with other
>      >? ? ? > operators in R.? (But, as above, this objection might not
>     apply
>      >? ? ?to |>.)
>      >? ? ? > Also, this solution still doesn't enable the syntax of
>     "Example
>      >? ? ?2", with
>      >? ? ? > its readability benefit.
>      >? ? ? >
>      >? ? ? > Thanks for reading this and considering it.
>      >? ? ? >
>      >? ? ? > - Tim Goodman
>      >? ? ? >
>      >? ? ? >? ? ? ?[[alternative HTML version deleted]]
>      >? ? ? >
>      >? ? ? > ______________________________________________
>      >? ? ? > R-devel at r-project.org <mailto:R-devel at r-project.org>
>     <mailto:R-devel at r-project.org <mailto:R-devel at r-project.org>>
>     mailing list
>      >? ? ? > https://stat.ethz.ch/mailman/listinfo/r-devel
>     <https://stat.ethz.ch/mailman/listinfo/r-devel>
>      >? ? ?<https://stat.ethz.ch/mailman/listinfo/r-devel
>     <https://stat.ethz.ch/mailman/listinfo/r-devel>>
>      >? ? ? >
>      >
>


From greg @end|ng |rom w@rne@@net  Wed Dec  9 22:35:54 2020
From: greg @end|ng |rom w@rne@@net (Gregory Warnes)
Date: Wed, 9 Dec 2020 16:35:54 -0500
Subject: [Rd] the pipe |> and line breaks in pipelines
In-Reply-To: <3f0d3e85-b122-aa45-cedb-d2c6789a9536@gmail.com>
References: <CAGBtDS-ZS_35QnJnPqW_fHaJF-LaWo8iPhOaTssyVTCU=q7dSw@mail.gmail.com>
 <408829af-758f-3dcb-5f5d-740d5064992f@gmail.com>
 <CAGBtDS-KnJaNkzHVkui0wvdoFMDQ8QsRqknRyGkzULtBowtdwA@mail.gmail.com>
 <219e797a-4ce9-2ad8-3553-5e6ef4a6c269@gmail.com>
 <CAGBtDS-m+CcM6ioRpo24C-q0Hjp=O6Y1SB2QJvVs+--pUCCa4A@mail.gmail.com>
 <3f0d3e85-b122-aa45-cedb-d2c6789a9536@gmail.com>
Message-ID: <CAKorm_uU-PY2NbGJ+eikci=i+yaFFSXWMOe1uHWxSJTHt4vJvg@mail.gmail.com>

Many languages allow a final backslash (?\?) character to allow an
expression to span multiple lines, and I?ve often wished for this in R,
particularly to allow me to put  `else` on a separate line at the
top-level. It would also allow alignment of infix operators like the new
pipe operator `|>` at the start of a line, which I would heartily endorse.

On Wed, Dec 9, 2020 at 3:58 PM Ben Bolker <bbolker at gmail.com> wrote:

>    Definitely support the idea that if this kind of trickery is going to
> happen that it be confined to some particular IDE/environment or some
> particular submission protocol. I don't want it to happen in my ESS
> session please ... I'd rather deal with the parentheses.
>
> On 12/9/20 3:45 PM, Timothy Goodman wrote:
> > Regarding special treatment for |>, isn't it getting special treatment
> > anyway, because it's implemented as a syntax transformation from x |>
> f(y)
> > to f(x, y), rather than as an operator?
> >
> > That said, the point about wanting a block of code submitted line-by-line
> > to work the same as a block of code submittedr d all at once is a fair
> one.
> > Maybe the better solution would be if there were a way to say "Submit the
> > selected code as a single expression, ignoring line-breaks".  Then I
> could
> > run any number of lines with pipes at the start and no special character
> at
> > the end, and have it treated as a single pipeline.  I suppose that'd need
> > to be a feature offered by the erred environment (RStudio's RNotebooks
> in my
> > case).  I could wrap my pipelines in parentheses (to make the "pipes at
> > start of line" syntax valid R code), and then could use the hypothetical
> > "submit selected code ignoring line-breaks" feature when running just the
> > first part of the pipeline -- i.e., selecting full lines, but starting
> > after the opening paren so as not to need to insert a closing paren.
> >
> > - Tim
> >
> > On Wed, Dec 9, 2020 at 12:12 PM Duncan Murdoch <murdoch.duncan at gmail.com
> >
> > wrote:
> >
> >> On 09/12/2020 2:33 p.m., Timothy Goodman wrote:
> >>> If I type my_data_frame_1 and press Enter (or Ctrl+Enter to execute the
> >>> command in the Notebook environment I'm using) I certainly *would*
> >>> expect R to treat it as a complete statement.
> >>>
> >>> But what I'm talking about is a different case, where I highlight a
> >>> multi-line statement in my notebook:
> >>>
> >>>       my_data_frame1
> >>>           |> filter(some_conditions_1)
> >>>
> >>> and then press Ctrl+Enter.
> >>
> >> I don't think I'd like it if parsing changed between passing one line at
> >> a time and passing a block of lines.  I'd like to be able to highlight a
> >> few lines and pass those, then type one, then highlight some more and
> >> pass those:  and have it act as though I just passed the whole combined
> >> block, or typed everything one line at a time.
> >>
> >>
> >>     Or, I suppose the equivalent would be to run
> >>> an R script containing those two lines of code, or to run a multi-line
> >>> statement like that from the console (which in RStudio I can do by
> >>> pressing Shift+Enter between the lines.)
> >>>
> >>> In those cases, R could either (1) Give an error message [the current
> >>> behavior], or (2) understand that the first line is meant to be piped
> to
> >>> the second.  The second option would be significantly more useful, and
> >>> is almost certainly what the user intended.
> >>>
> >>> (For what it's worth, there are some languages, such as Javascript,
> that
> >>> consider the first token of the next line when determining if the
> >>> previous line was complete.  JavaScript's rules around this are overly
> >>> complicated, but a rule like "a pipe following a line break is treated
> >>> as continuing the previous line" would be much simpler.  And while it
> >>> might be objectionable to treat the operator %>% different from other
> >>> operators, the addition of |>, which isn't truly an operator at all,
> >>> seems like the right time to consider it.)
> >>
> >> I think this would be hard to implement with R's current parser, but
> >> possible.  I think it could be done by distinguishing between EOL
> >> markers within a block of text and "end of block" marks.  If it applied
> >> only to the |> operator it would be *really* ugly.
> >>
> >> My strongest objection to it is the one at the top, though.  If I have a
> >> block of lines sitting in my editor that I just finished executing, with
> >> the cursor pointing at the next line, I'd like to know that it didn't
> >> matter whether the lines were passed one at a time, as a block, or some
> >> combination of those.
> >>
> >> Duncan Murdoch
> >>
> >>>
> >>> -Tim
> >>>
> >>> On Wed, Dec 9, 2020 at 3:12 AM Duncan Murdoch <
> murdoch.duncan at gmail.com
> >>> <mailto:murdoch.duncan at gmail.com>> wrote:
> >>>
> >>>      The requirement for operators at the end of the line comes from
> the
> >>>      interactive nature of R.  If you type
> >>>
> >>>            my_data_frame_1
> >>>
> >>>      how could R know that you are not done, and are planning to type
> the
> >>>      rest of the expression
> >>>
> >>>              %>% filter(some_conditions_1)
> >>>              ...
> >>>
> >>>      before it should consider the expression complete?  The way
> languages
> >>>      like C do this is by requiring a statement terminator at the end.
> >> You
> >>>      can also do it by wrapping the entire thing in parentheses ().
> >>>
> >>>      However, be careful: Don't use braces:  they don't work.  And
> parens
> >>>      have the side effect of removing invisibility from the result
> (which
> >> is
> >>>      a design flaw or bonus, depending on your point of view).  So I
> >>>      actually
> >>>      wouldn't advise this workaround.
> >>>
> >>>      Duncan Murdoch
> >>>
> >>>
> >>>      On 09/12/2020 12:45 a.m., Timothy Goodman wrote:
> >>>       > Hi,
> >>>       >
> >>>       > I'm a data scientist who routinely uses R in my day-to-day
> work,
> >>>      for tasks
> >>>       > such as cleaning and transforming data, exploratory data
> >>>      analysis, etc.
> >>>       > This includes frequent use of the pipe operator from the
> magrittr
> >>>      and dplyr
> >>>       > libraries, %>%.  So, I was pleased to hear about the recent
> work
> >> on a
> >>>       > native pipe operator, |>.
> >>>       >
> >>>       > This seems like a good time to bring up the main pain point I
> >>>      encounter
> >>>       > when using pipes in R, and some suggestions on what could be
> done
> >>>      about
> >>>       > it.  The issue is that the pipe operator can't be placed at the
> >>>      start of a
> >>>       > line of code (except in parentheses).  That's no different than
> >>>      any binary
> >>>       > operator in R, but I find it's a source of difficulty for the
> >>>      pipe because
> >>>       > of how pipes are often used.
> >>>       >
> >>>       > [I'm assuming here that my usage is fairly typical of a lot of
> >>>      users; at
> >>>       > any rate, I don't think I'm *too* unusual.]
> >>>       >
> >>>       > === Why this is a problem ===
> >>>       >
> >>>       > It's very common (for me, and I suspect for many users of
> dplyr)
> >>>      to write
> >>>       > multi-step pipelines and put each step on its own line for
> >>>      readability.
> >>>       > Something like this:
> >>>       >
> >>>       >    ### Example 1 ###
> >>>       >    my_data_frame_1 %>%
> >>>       >      filter(some_conditions_1) %>%
> >>>       >      inner_join(my_data_frame_2, by = some_columns_1) %>%
> >>>       >      group_by(some_columns_2) %>%
> >>>       >      summarize(some_aggregate_functions_1) %>%
> >>>       >      filter(some_conditions_2) %>%
> >>>       >      left_join(my_data_frame_3, by = some_columns_3) %>%
> >>>       >      group_by(some_columns_4) %>%
> >>>       >      summarize(some_aggregate_functions_2) %>%
> >>>       >      arrange(some_columns_5)
> >>>       >
> >>>       > [I guess some might consider this an overly long pipeline; for
> me
> >>>      it's
> >>>       > pretty typical.  I *could* split it up by assigning
> intermediate
> >>>      results to
> >>>       > variables, but much of the value I get from the pipe is that it
> >>>      lets my
> >>>       > code communicate which results are temporary, and which will be
> >>>      used again
> >>>       > later.  Assigning variables for single-use results would remove
> >> that
> >>>       > expressiveness.]
> >>>       >
> >>>       > I would prefer (for reasons I'll explain) to be able to write
> the
> >>>      above
> >>>       > example like this, which isn't valid R:
> >>>       >
> >>>       >    ### Example 2 (not valid R) ###
> >>>       >    my_data_frame_1
> >>>       >      %>% filter(some_conditions_1)
> >>>       >      %>% inner_join(my_data_frame_2, by = some_columns_1)
> >>>       >      %>% group_by(some_columns_2)
> >>>       >      %>% summarize(some_aggregate_functions_1)
> >>>       >      %>% filter(some_conditions_2)
> >>>       >      %>% left_join(my_data_frame_3, by = some_columns_3)
> >>>       >      %>% group_by(some_columns_4)
> >>>       >      %>% summarize(some_aggregate_functions_2)
> >>>       >      %>% arrange(some_columns_5)
> >>>       >
> >>>       > One (minor) advantage is obvious: It lets you easily line up
> the
> >>>      pipes,
> >>>       > which means that you can see at a glance that the whole block
> is
> >>>      a single
> >>>       > pipeline, and you'd immediately notice if you inadvertently
> >>>      omitted a pipe,
> >>>       > which otherwise can lead to confusing output.  [It's also
> >>>      aesthetically
> >>>       > pleasing, especially when %>% is replaced with |>, but that's
> >>>      subjective.]
> >>>       >
> >>>       > But the bigger issue happens when I want to re-run just *part*
> of
> >> the
> >>>       > pipeline.  I do this often when debugging: if the output of the
> >>>      pipeline
> >>>       > seems wrong, I re-run the first few steps and check the output,
> >> then
> >>>       > include a little more and re-run again, etc., until I locate my
> >>>      mistake.
> >>>       > Working in an interactive notebook environment, this involves
> >>>      using the
> >>>       > cursor to select just the part of the code I want to re-run.
> >>>       >
> >>>       > It's fast and easy to select *entire* lines of code, but
> >>>      unfortunately with
> >>>       > the pipes placed at the end of the line I must instead select
> >>>      everything
> >>>       > *except* the last three characters of the line (the last two
> >>>      characters for
> >>>       > the new pipe).  Then when I want to re-run the same partial
> >>>      pipeline with
> >>>       > the next line of code included, I can't just press SHIFT+Down
> to
> >>>      select it
> >>>       > as I otherwise would, but instead must move the cursor
> >>>      horizontally to a
> >>>       > position three characters before the end of *that* line (which
> is
> >>>      generally
> >>>       > different due to varying line lengths).  And so forth each
> time I
> >>>      want to
> >>>       > include an additional line.
> >>>       >
> >>>       > Moreover, with the staggered positions of the pipes at the end
> of
> >>>      each
> >>>       > line, it's very easy to accidentally select the final pipe on a
> >>>      line, and
> >>>       > then sit there for a moment wondering if the environment has
> >> stopped
> >>>       > responding before realizing it's just waiting for further input
> >>>      (i.e., for
> >>>       > the right-hand side).  These small delays and disruptions add
> up
> >>>      over the
> >>>       > course of a day.
> >>>       >
> >>>       > This desire to select and re-run the first part of a pipeline
> is
> >>>      also the
> >>>       > reason why it doesn't suffice to achieve syntax like my
> "Example
> >>>      2" by
> >>>       > wrapping the entire pipeline in parentheses.  That's of no use
> if
> >>>      I want to
> >>>       > re-run a selection that doesn't include the final close-paren.
> >>>       >
> >>>       > === Possible Solutions ===
> >>>       >
> >>>       > I can think of two, but maybe there are others.  The first
> would
> >> make
> >>>       > "Example 2" into valid code, and the second would allow you to
> >> run a
> >>>       > selection that included a trailing pipe.
> >>>       >
> >>>       >    Solution 1: Add a special case to how R is parsed, so if the
> >> first
> >>>       > (non-whitespace) token after an end-line is a pipe, that pipe
> >>>      gets moved to
> >>>       > before the end-line.
> >>>       >      - Argument for: This lets you write code like example 2,
> >> which
> >>>       > addresses the pain point around re-running part of a pipeline,
> >>>      and has
> >>>       > advantages for readability.  Also, since starting a line with a
> >> pipe
> >>>       > operator is currently invalid, the change wouldn't break any
> >>>      working code.
> >>>       >      - Argument against: It would make the behavior of %>%
> >>>      inconsistent with
> >>>       > that of other binary operators in R.  (However, this objection
> >>>      might not
> >>>       > apply to the new pipe, |>, which I understand is being
> >>>      implemented as a
> >>>       > syntax transformation rather than a binary operator.)
> >>>       >
> >>>       >    Solution 2: Ignore the pipe operator if it occurs as the
> final
> >>>      token of
> >>>       > the code being executed.
> >>>       >      - Argument for: This would mean the user could select and
> >>>      re-run the
> >>>       > first few lines of a longer pipeline (selecting *entire*
> lines),
> >>>      avoiding
> >>>       > the difficulties described above.
> >>>       >      - Argument against: This means that %>% would be valid
> even
> >>>      if it
> >>>       > occurred without a right-hand side, which is inconsistent with
> >> other
> >>>       > operators in R.  (But, as above, this objection might not apply
> >>>      to |>.)
> >>>       > Also, this solution still doesn't enable the syntax of "Example
> >>>      2", with
> >>>       > its readability benefit.
> >>>       >
> >>>       > Thanks for reading this and considering it.
> >>>       >
> >>>       > - Tim Goodman
> >>>       >
> >>>       >       [[alternative HTML version deleted]]
> >>>       >
> >>>       > ______________________________________________
> >>>       > R-devel at r-project.org <mailto:R-devel at r-project.org> mailing
> list
> >>>       > https://stat.ethz.ch/mailman/listinfo/r-devel
> >>>      <https://stat.ethz.ch/mailman/listinfo/r-devel>
> >>>       >
> >>>
> >>
> >>
> >
> >       [[alternative HTML version deleted]]
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
> >
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>
-- 
"Whereas true religion and good morals are the only solid foundations of
public liberty and happiness . . . it is hereby earnestly recommended to
the several States to take the most effectual measures for the
encouragement thereof." Continental Congress, 1778

	[[alternative HTML version deleted]]


From t|m@goodm@n @end|ng |rom gm@||@com  Wed Dec  9 22:47:56 2020
From: t|m@goodm@n @end|ng |rom gm@||@com (Timothy Goodman)
Date: Wed, 9 Dec 2020 13:47:56 -0800
Subject: [Rd] the pipe |> and line breaks in pipelines
In-Reply-To: <7685a9a2-b91a-0a71-29be-0723d3c52570@gmail.com>
References: <CAGBtDS-ZS_35QnJnPqW_fHaJF-LaWo8iPhOaTssyVTCU=q7dSw@mail.gmail.com>
 <408829af-758f-3dcb-5f5d-740d5064992f@gmail.com>
 <CAGBtDS-KnJaNkzHVkui0wvdoFMDQ8QsRqknRyGkzULtBowtdwA@mail.gmail.com>
 <219e797a-4ce9-2ad8-3553-5e6ef4a6c269@gmail.com>
 <CAGBtDS-m+CcM6ioRpo24C-q0Hjp=O6Y1SB2QJvVs+--pUCCa4A@mail.gmail.com>
 <7685a9a2-b91a-0a71-29be-0723d3c52570@gmail.com>
Message-ID: <CAGBtDS-QJUtHcoJrMDzDAtPehOhT5=6jZe6d2_rc=e3Rm-XxcQ@mail.gmail.com>

On Wed, Dec 9, 2020 at 1:03 PM Duncan Murdoch <murdoch.duncan at gmail.com>
wrote:  Then I could run any number of lines with pipes at the

> > start and no special character at the end, and have it treated as a
> > single pipeline.  I suppose that'd need to be a feature offered by the
> > environment (RStudio's RNotebooks in my case).  I could wrap my
> > pipelines in parentheses (to make the "pipes at start of line" syntax
> > valid R code), and then could use the hypothetical "submit selected code
> > ignoring line-breaks" feature when running just the first part of the
> > pipeline -- i.e., selecting full lines, but starting after the opening
> > paren so as not to need to insert a closing paren.
>
> I think I don't understand your workflow enough to comment on this.
>
> Duncan
>
>
>
What I mean is, I could add parentheses as suggested to let me put the
pipes at the start of the line, like this:

    (                                  # Line 1
        my_data_frame                  # Line 2
        |> filter(some_condition)      # Line 3
        |> group_by(some_column)       # Line 4
        |> summarize(some_functions)   # Line 5
    )                                  # Line 6

If this gives me an unexpected result, I might want to re-run just up
through line 3 and check the output, to see if something is wrong with the
"filter" (e.g., my condition matched less data than expected).  Ideally, I
could do this without changing the code, by just selecting lines 2 and 3
and pressing Ctrl+Enter (my environment's shortcut for "run selected
code").  But it wouldn't work, because without including the parentheses
these lines would be treated as two separate expressions, the second of
which is invalid since it starts with a pipe.  Alternatively, I could
include line 1 in my selection (along with lines 2 and 3), but it wouldn't
work without having to type a new closing parenthesis after line 3, and
then delete it afterwards.  Or, I could select and comment out lines 4 and
5, and then select and run all 6 lines.  But none of those are as
convenient as just being able to select and run lines 2 and 3 (which is
what I'm used to being able to do in several other languages which support
pipelines).  And though it may seem a minor annoyance, when I'm working a
lot with dplyr code I find myself wanting to do something like this many
times per day.

What *would* work well would be if I could write the code as above, but
then when I want to select and re-run just lines 2 and 3, I would use some
keyboard shortcut that meant "pass this code to the parser as a single
line, with line breaks (and comments) removed".  Then it would be run like
    my_data_frame |> filter(some_condition)
instead of producing an error.  That'd require the environment I'm using --
RStudio -- to support this feature, but wouldn't require any change to how
R is parsed.  From the replies here, I'm coming around to thinking that'd
be the better option.

- Tim

	[[alternative HTML version deleted]]


From t|m@goodm@n @end|ng |rom gm@||@com  Wed Dec  9 22:56:58 2020
From: t|m@goodm@n @end|ng |rom gm@||@com (Timothy Goodman)
Date: Wed, 9 Dec 2020 13:56:58 -0800
Subject: [Rd] the pipe |> and line breaks in pipelines
In-Reply-To: <CAJXgQP1tyT1geV4s-2Jr5OcUjMptsyfP25QVgwbsO=pz+kNXcA@mail.gmail.com>
References: <CAGBtDS-ZS_35QnJnPqW_fHaJF-LaWo8iPhOaTssyVTCU=q7dSw@mail.gmail.com>
 <408829af-758f-3dcb-5f5d-740d5064992f@gmail.com>
 <CAGBtDS-KnJaNkzHVkui0wvdoFMDQ8QsRqknRyGkzULtBowtdwA@mail.gmail.com>
 <CAJXgQP0M6t2rUtQ+VuFacjKpBqnSR-oDHH_njbgpQP2tsxj5-Q@mail.gmail.com>
 <CAGBtDS-Fk4geCcLhM5ziRzvHoaf_1UyZOMgkBtUXJn3YQRJQKw@mail.gmail.com>
 <CAJXgQP1tyT1geV4s-2Jr5OcUjMptsyfP25QVgwbsO=pz+kNXcA@mail.gmail.com>
Message-ID: <CAGBtDS9=AQrq1tqc29irx3PxcWHFS3MAYCeJq3pieiapZZcBWw@mail.gmail.com>

I'm thrilled to hear it!  Thank you!

- Tim

P.S. I re-added the r-devel list, since Kevin's reply was sent just to me,
but I thought there might be others interested in knowing about those work
items.  (I hope that's OK, email-etiquette-wise.)

On Wed, Dec 9, 2020 at 1:10 PM Kevin Ushey <kevinushey at gmail.com> wrote:

> You might be surprised to learn that the RStudio IDE engineers might
> be receptive to such a feature request. :-)
>
> https://github.com/rstudio/rstudio/issues/8589
> https://github.com/rstudio/rstudio/issues/8590
>
> (Spoiler alert: I am one of the RStudio IDE engineers, and I think
> this would be worth doing.)
>
> Best,
> Kevin
>
> On Wed, Dec 9, 2020 at 12:16 PM Timothy Goodman <timsgoodman at gmail.com>
> wrote:
> >
> > Since my larger concern is being able to conveniently select and re-run
> part of a multiline pipeline, I don't think wrapping in parentheses will
> help.  I'd have to add a closing paren at the end of the selection, which
> is no more convenient than having to highlight all but the last pipe.
> (Admittedly, wrapping in parens would allow my preferred syntax of having
> pipes at the start of the line, but I don't think that's worth the cost of
> having to constantly move the trailing paren around.)
> >
> > My back-up plan if I fail to persuade you all is indeed to beg the
> developers of RStudio to add an option to do the transformation I would
> want when executing notebook code, but I'm anticipating the objection of "R
> Notebooks shouldn't transform invalid R code into valid R code."  I was
> hoping "Let's make this new pipe |> work differently in a case that's
> currently an error" would be an easier sell.
> >
> > Also, just to reiterate: Only one of my two suggestions really requires
> caring about newlines.  (That's my preferred solution, but I understand
> it'd be the bigger change.)  The other suggestion just amounts to ignoring
> a final |> when code is submitted for execution.
> >
> >  -Tim
> >
> > On Wed, Dec 9, 2020 at 11:58 AM Kevin Ushey <kevinushey at gmail.com>
> wrote:
> >>
> >> I agree with Duncan that the right solution is to wrap the pipe
> >> expression with parentheses. Having the parser treat newlines
> >> differently based on whether the session is interactive, or on what
> >> type of operator happens to follow a newline, feels like a pretty big
> >> can of worms.
> >>
> >> I think this (or something similar) would accomplish what you want
> >> while still retaining the nice aesthetics of the pipe expression, with
> >> a minimal amount of syntax "noise":
> >>
> >> result <- (
> >>   data
> >>     |> op1()
> >>     |> op2()
> >> )
> >>
> >> For interactive sessions where you wanted to execute only parts of the
> >> pipeline at a time, I could see that being accomplished by the editor
> >> -- it could transform the expression so that it could be handled by R,
> >> either by hoisting the pipe operator(s) up a line, or by wrapping the
> >> to-be-executed expression in parentheses for you. If such a style of
> >> coding became popular enough, I'm sure the developers of such editors
> >> would be interested and willing to support this ...
> >>
> >> Perhaps more importantly, it would be much easier to accomplish than a
> >> change to the behavior of the R parser, and it would be work that
> >> wouldn't have to be maintained by the R Core team.
> >>
> >> Best,
> >> Kevin
> >>
> >> On Wed, Dec 9, 2020 at 11:34 AM Timothy Goodman <timsgoodman at gmail.com>
> wrote:
> >> >
> >> > If I type my_data_frame_1 and press Enter (or Ctrl+Enter to execute
> the
> >> > command in the Notebook environment I'm using) I certainly *would*
> expect R
> >> > to treat it as a complete statement.
> >> >
> >> > But what I'm talking about is a different case, where I highlight a
> >> > multi-line statement in my notebook:
> >> >
> >> >     my_data_frame1
> >> >         |> filter(some_conditions_1)
> >> >
> >> > and then press Ctrl+Enter.  Or, I suppose the equivalent would be to
> run an
> >> > R script containing those two lines of code, or to run a multi-line
> >> > statement like that from the console (which in RStudio I can do by
> pressing
> >> > Shift+Enter between the lines.)
> >> >
> >> > In those cases, R could either (1) Give an error message [the current
> >> > behavior], or (2) understand that the first line is meant to be piped
> to
> >> > the second.  The second option would be significantly more useful,
> and is
> >> > almost certainly what the user intended.
> >> >
> >> > (For what it's worth, there are some languages, such as Javascript,
> that
> >> > consider the first token of the next line when determining if the
> previous
> >> > line was complete.  JavaScript's rules around this are overly
> complicated,
> >> > but a rule like "a pipe following a line break is treated as
> continuing the
> >> > previous line" would be much simpler.  And while it might be
> objectionable
> >> > to treat the operator %>% different from other operators, the
> addition of
> >> > |>, which isn't truly an operator at all, seems like the right time to
> >> > consider it.)
> >> >
> >> > -Tim
> >> >
> >> > On Wed, Dec 9, 2020 at 3:12 AM Duncan Murdoch <
> murdoch.duncan at gmail.com>
> >> > wrote:
> >> >
> >> > > The requirement for operators at the end of the line comes from the
> >> > > interactive nature of R.  If you type
> >> > >
> >> > >      my_data_frame_1
> >> > >
> >> > > how could R know that you are not done, and are planning to type the
> >> > > rest of the expression
> >> > >
> >> > >        %>% filter(some_conditions_1)
> >> > >        ...
> >> > >
> >> > > before it should consider the expression complete?  The way
> languages
> >> > > like C do this is by requiring a statement terminator at the end.
> You
> >> > > can also do it by wrapping the entire thing in parentheses ().
> >> > >
> >> > > However, be careful: Don't use braces:  they don't work.  And parens
> >> > > have the side effect of removing invisibility from the result
> (which is
> >> > > a design flaw or bonus, depending on your point of view).  So I
> actually
> >> > > wouldn't advise this workaround.
> >> > >
> >> > > Duncan Murdoch
> >> > >
> >> > >
> >> > > On 09/12/2020 12:45 a.m., Timothy Goodman wrote:
> >> > > > Hi,
> >> > > >
> >> > > > I'm a data scientist who routinely uses R in my day-to-day work,
> for
> >> > > tasks
> >> > > > such as cleaning and transforming data, exploratory data
> analysis, etc.
> >> > > > This includes frequent use of the pipe operator from the magrittr
> and
> >> > > dplyr
> >> > > > libraries, %>%.  So, I was pleased to hear about the recent work
> on a
> >> > > > native pipe operator, |>.
> >> > > >
> >> > > > This seems like a good time to bring up the main pain point I
> encounter
> >> > > > when using pipes in R, and some suggestions on what could be done
> about
> >> > > > it.  The issue is that the pipe operator can't be placed at the
> start of
> >> > > a
> >> > > > line of code (except in parentheses).  That's no different than
> any
> >> > > binary
> >> > > > operator in R, but I find it's a source of difficulty for the pipe
> >> > > because
> >> > > > of how pipes are often used.
> >> > > >
> >> > > > [I'm assuming here that my usage is fairly typical of a lot of
> users; at
> >> > > > any rate, I don't think I'm *too* unusual.]
> >> > > >
> >> > > > === Why this is a problem ===
> >> > > >
> >> > > > It's very common (for me, and I suspect for many users of dplyr)
> to write
> >> > > > multi-step pipelines and put each step on its own line for
> readability.
> >> > > > Something like this:
> >> > > >
> >> > > >    ### Example 1 ###
> >> > > >    my_data_frame_1 %>%
> >> > > >      filter(some_conditions_1) %>%
> >> > > >      inner_join(my_data_frame_2, by = some_columns_1) %>%
> >> > > >      group_by(some_columns_2) %>%
> >> > > >      summarize(some_aggregate_functions_1) %>%
> >> > > >      filter(some_conditions_2) %>%
> >> > > >      left_join(my_data_frame_3, by = some_columns_3) %>%
> >> > > >      group_by(some_columns_4) %>%
> >> > > >      summarize(some_aggregate_functions_2) %>%
> >> > > >      arrange(some_columns_5)
> >> > > >
> >> > > > [I guess some might consider this an overly long pipeline; for me
> it's
> >> > > > pretty typical.  I *could* split it up by assigning intermediate
> results
> >> > > to
> >> > > > variables, but much of the value I get from the pipe is that it
> lets my
> >> > > > code communicate which results are temporary, and which will be
> used
> >> > > again
> >> > > > later.  Assigning variables for single-use results would remove
> that
> >> > > > expressiveness.]
> >> > > >
> >> > > > I would prefer (for reasons I'll explain) to be able to write the
> above
> >> > > > example like this, which isn't valid R:
> >> > > >
> >> > > >    ### Example 2 (not valid R) ###
> >> > > >    my_data_frame_1
> >> > > >      %>% filter(some_conditions_1)
> >> > > >      %>% inner_join(my_data_frame_2, by = some_columns_1)
> >> > > >      %>% group_by(some_columns_2)
> >> > > >      %>% summarize(some_aggregate_functions_1)
> >> > > >      %>% filter(some_conditions_2)
> >> > > >      %>% left_join(my_data_frame_3, by = some_columns_3)
> >> > > >      %>% group_by(some_columns_4)
> >> > > >      %>% summarize(some_aggregate_functions_2)
> >> > > >      %>% arrange(some_columns_5)
> >> > > >
> >> > > > One (minor) advantage is obvious: It lets you easily line up the
> pipes,
> >> > > > which means that you can see at a glance that the whole block is
> a single
> >> > > > pipeline, and you'd immediately notice if you inadvertently
> omitted a
> >> > > pipe,
> >> > > > which otherwise can lead to confusing output.  [It's also
> aesthetically
> >> > > > pleasing, especially when %>% is replaced with |>, but that's
> >> > > subjective.]
> >> > > >
> >> > > > But the bigger issue happens when I want to re-run just *part* of
> the
> >> > > > pipeline.  I do this often when debugging: if the output of the
> pipeline
> >> > > > seems wrong, I re-run the first few steps and check the output,
> then
> >> > > > include a little more and re-run again, etc., until I locate my
> mistake.
> >> > > > Working in an interactive notebook environment, this involves
> using the
> >> > > > cursor to select just the part of the code I want to re-run.
> >> > > >
> >> > > > It's fast and easy to select *entire* lines of code, but
> unfortunately
> >> > > with
> >> > > > the pipes placed at the end of the line I must instead select
> everything
> >> > > > *except* the last three characters of the line (the last two
> characters
> >> > > for
> >> > > > the new pipe).  Then when I want to re-run the same partial
> pipeline with
> >> > > > the next line of code included, I can't just press SHIFT+Down to
> select
> >> > > it
> >> > > > as I otherwise would, but instead must move the cursor
> horizontally to a
> >> > > > position three characters before the end of *that* line (which is
> >> > > generally
> >> > > > different due to varying line lengths).  And so forth each time I
> want to
> >> > > > include an additional line.
> >> > > >
> >> > > > Moreover, with the staggered positions of the pipes at the end of
> each
> >> > > > line, it's very easy to accidentally select the final pipe on a
> line, and
> >> > > > then sit there for a moment wondering if the environment has
> stopped
> >> > > > responding before realizing it's just waiting for further input
> (i.e.,
> >> > > for
> >> > > > the right-hand side).  These small delays and disruptions add up
> over the
> >> > > > course of a day.
> >> > > >
> >> > > > This desire to select and re-run the first part of a pipeline is
> also the
> >> > > > reason why it doesn't suffice to achieve syntax like my "Example
> 2" by
> >> > > > wrapping the entire pipeline in parentheses.  That's of no use if
> I want
> >> > > to
> >> > > > re-run a selection that doesn't include the final close-paren.
> >> > > >
> >> > > > === Possible Solutions ===
> >> > > >
> >> > > > I can think of two, but maybe there are others.  The first would
> make
> >> > > > "Example 2" into valid code, and the second would allow you to
> run a
> >> > > > selection that included a trailing pipe.
> >> > > >
> >> > > >    Solution 1: Add a special case to how R is parsed, so if the
> first
> >> > > > (non-whitespace) token after an end-line is a pipe, that pipe
> gets moved
> >> > > to
> >> > > > before the end-line.
> >> > > >      - Argument for: This lets you write code like example 2,
> which
> >> > > > addresses the pain point around re-running part of a pipeline,
> and has
> >> > > > advantages for readability.  Also, since starting a line with a
> pipe
> >> > > > operator is currently invalid, the change wouldn't break any
> working
> >> > > code.
> >> > > >      - Argument against: It would make the behavior of %>%
> inconsistent
> >> > > with
> >> > > > that of other binary operators in R.  (However, this objection
> might not
> >> > > > apply to the new pipe, |>, which I understand is being
> implemented as a
> >> > > > syntax transformation rather than a binary operator.)
> >> > > >
> >> > > >    Solution 2: Ignore the pipe operator if it occurs as the final
> token
> >> > > of
> >> > > > the code being executed.
> >> > > >      - Argument for: This would mean the user could select and
> re-run the
> >> > > > first few lines of a longer pipeline (selecting *entire* lines),
> avoiding
> >> > > > the difficulties described above.
> >> > > >      - Argument against: This means that %>% would be valid even
> if it
> >> > > > occurred without a right-hand side, which is inconsistent with
> other
> >> > > > operators in R.  (But, as above, this objection might not apply
> to |>.)
> >> > > > Also, this solution still doesn't enable the syntax of "Example
> 2", with
> >> > > > its readability benefit.
> >> > > >
> >> > > > Thanks for reading this and considering it.
> >> > > >
> >> > > > - Tim Goodman
> >> > > >
> >> > > >       [[alternative HTML version deleted]]
> >> > > >
> >> > > > ______________________________________________
> >> > > > R-devel at r-project.org mailing list
> >> > > > https://stat.ethz.ch/mailman/listinfo/r-devel
> >> > > >
> >> > >
> >> > >
> >> >
> >> >         [[alternative HTML version deleted]]
> >> >
> >> > ______________________________________________
> >> > R-devel at r-project.org mailing list
> >> > https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From w||||@mwdun|@p @end|ng |rom gm@||@com  Wed Dec  9 23:42:43 2020
From: w||||@mwdun|@p @end|ng |rom gm@||@com (Bill Dunlap)
Date: Wed, 9 Dec 2020 14:42:43 -0800
Subject: [Rd] the pipe |> and line breaks in pipelines
In-Reply-To: <CAGBtDS-QJUtHcoJrMDzDAtPehOhT5=6jZe6d2_rc=e3Rm-XxcQ@mail.gmail.com>
References: <CAGBtDS-ZS_35QnJnPqW_fHaJF-LaWo8iPhOaTssyVTCU=q7dSw@mail.gmail.com>
 <408829af-758f-3dcb-5f5d-740d5064992f@gmail.com>
 <CAGBtDS-KnJaNkzHVkui0wvdoFMDQ8QsRqknRyGkzULtBowtdwA@mail.gmail.com>
 <219e797a-4ce9-2ad8-3553-5e6ef4a6c269@gmail.com>
 <CAGBtDS-m+CcM6ioRpo24C-q0Hjp=O6Y1SB2QJvVs+--pUCCa4A@mail.gmail.com>
 <7685a9a2-b91a-0a71-29be-0723d3c52570@gmail.com>
 <CAGBtDS-QJUtHcoJrMDzDAtPehOhT5=6jZe6d2_rc=e3Rm-XxcQ@mail.gmail.com>
Message-ID: <CAHqSRuSu5TPMrkeW8Q524=-r1UtZKDkp9RfF3PuOFTUU9Z2m9g@mail.gmail.com>

When I am debugging a function with code like
    x <- f1(x)
    x <- f2(x)
    result <- f3(x)
I will often slip a line like '.GlobalEnv$tmp1 <- x' between the first two
lines and '.GlobalEnv$tmp2 <- x' between the last two lines and look at the
intermediate results, 'tmp1' and 'tmp2' in the global environment, later to
see what is going on.

The equivalent expression using pipes is
    x |>
        f1() |>
        f2() \>
        f3() -> result
You can slip lines like 'print() \>' between the pipe parts because
print(x) returns x, but it is more tedious to add assignment lines.  One
could define a function like
   pipe_save <- function(x, name, envir=.GlobalEnv) {
       envir[[name]] <- x
        x
   }
and then puts lines like 'pipe_save("tmp1") |>' into the pipe sequence to
save intermediate results.

A function like
    pipe_eval <- function(x, expr) {
       eval(substitute(expr), list(x=x))
        x
   }
would make it easy to call plot() or summary(), etc., on the piped data
with lines like
   'pipe_eval(print(summary(x)) |>'
inserted into the pipe sequence.

E.g.,

> 1/(1:10) |>
+    pipe_eval(print(summary(x))) |>
+    range() |>
+    pipe_eval(print(x)) |>
+    sum()
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
 0.1000  0.1295  0.1833  0.2929  0.3125  1.0000
[1] 0.1 1.0
[1] 1.1

You could even add if(isTRUE(getOption("debug"))) before the eval() or
assignment to make these do nothing to make it easy to turn debugging on
and off with options(debug=TRUE/FALSE).

-Bill


On Wed, Dec 9, 2020 at 1:58 PM Timothy Goodman <timsgoodman at gmail.com>
wrote:
>
> On Wed, Dec 9, 2020 at 1:03 PM Duncan Murdoch <murdoch.duncan at gmail.com>
> wrote:  Then I could run any number of lines with pipes at the
>
> > > start and no special character at the end, and have it treated as a
> > > single pipeline.  I suppose that'd need to be a feature offered by the
> > > environment (RStudio's RNotebooks in my case).  I could wrap my
> > > pipelines in parentheses (to make the "pipes at start of line" syntax
> > > valid R code), and then could use the hypothetical "submit selected
code
> > > ignoring line-breaks" feature when running just the first part of the
> > > pipeline -- i.e., selecting full lines, but starting after the opening
> > > paren so as not to need to insert a closing paren.
> >
> > I think I don't understand your workflow enough to comment on this.
> >
> > Duncan
> >
> >
> >
> What I mean is, I could add parentheses as suggested to let me put the
> pipes at the start of the line, like this:
>
>     (                                  # Line 1
>         my_data_frame                  # Line 2
>         |> filter(some_condition)      # Line 3
>         |> group_by(some_column)       # Line 4
>         |> summarize(some_functions)   # Line 5
>     )                                  # Line 6
>
> If this gives me an unexpected result, I might want to re-run just up
> through line 3 and check the output, to see if something is wrong with the
> "filter" (e.g., my condition matched less data than expected).  Ideally, I
> could do this without changing the code, by just selecting lines 2 and 3
> and pressing Ctrl+Enter (my environment's shortcut for "run selected
> code").  But it wouldn't work, because without including the parentheses
> these lines would be treated as two separate expressions, the second of
> which is invalid since it starts with a pipe.  Alternatively, I could
> include line 1 in my selection (along with lines 2 and 3), but it wouldn't
> work without having to type a new closing parenthesis after line 3, and
> then delete it afterwards.  Or, I could select and comment out lines 4 and
> 5, and then select and run all 6 lines.  But none of those are as
> convenient as just being able to select and run lines 2 and 3 (which is
> what I'm used to being able to do in several other languages which support
> pipelines).  And though it may seem a minor annoyance, when I'm working a
> lot with dplyr code I find myself wanting to do something like this many
> times per day.
>
> What *would* work well would be if I could write the code as above, but
> then when I want to select and re-run just lines 2 and 3, I would use some
> keyboard shortcut that meant "pass this code to the parser as a single
> line, with line breaks (and comments) removed".  Then it would be run like
>     my_data_frame |> filter(some_condition)
> instead of producing an error.  That'd require the environment I'm using
--
> RStudio -- to support this feature, but wouldn't require any change to how
> R is parsed.  From the replies here, I'm coming around to thinking that'd
> be the better option.
>
> - Tim
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel

	[[alternative HTML version deleted]]


From @rne@henn|ng@en @end|ng |rom gm@||@com  Sun Dec 13 00:19:40 2020
From: @rne@henn|ng@en @end|ng |rom gm@||@com (Arne Henningsen)
Date: Sun, 13 Dec 2020 00:19:40 +0100
Subject: [Rd] R crashes when using huge data sets with character string
 variables
Message-ID: <CAMTWbJgN-GW9Zp21awbAmXpor9Rqd7H00gZa10K-dFVjrN-ysQ@mail.gmail.com>

When working with a huge data set with character string variables, I
experienced that various commands let R crash. When I run R in a
Linux/bash console, R terminates with the message "Killed". When I use
RStudio, I get the message "R Session Aborted. R encountered a fatal
error. The session was terminated. Start New Session". If an object in
the R workspace needs too much memory, I would expect that R would not
crash but issue an error message "Error: cannot allocate vector of
size ...".  A minimal reproducible example (at least on my computer)
is:

nObs <- 1e9

date <- paste( round( runif( nObs, 1981, 2015 ) ), round( runif( nObs,
1, 12 ) ), round( runif( nObs, 1, 31 ) ), sep = "-" )

Is this a bug or a feature of R?

Some information about my R version, OS, etc:

R> sessionInfo()
R version 4.0.3 (2020-10-10)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: Ubuntu 20.04.1 LTS

Matrix products: default
BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0
LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0

locale:
[1] LC_CTYPE=en_DK.UTF-8       LC_NUMERIC=C
[3] LC_TIME=en_DK.UTF-8        LC_COLLATE=en_DK.UTF-8
[5] LC_MONETARY=en_DK.UTF-8    LC_MESSAGES=en_DK.UTF-8
[7] LC_PAPER=en_DK.UTF-8       LC_NAME=C
[9] LC_ADDRESS=C               LC_TELEPHONE=C
[11] LC_MEASUREMENT=en_DK.UTF-8 LC_IDENTIFICATION=C

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base

loaded via a namespace (and not attached):
[1] compiler_4.0.3

/Arne

-- 
Arne Henningsen
http://www.arne-henningsen.name


From bbo|ker @end|ng |rom gm@||@com  Sun Dec 13 00:33:08 2020
From: bbo|ker @end|ng |rom gm@||@com (Ben Bolker)
Date: Sat, 12 Dec 2020 18:33:08 -0500
Subject: [Rd] R crashes when using huge data sets with character string
 variables
In-Reply-To: <CAMTWbJgN-GW9Zp21awbAmXpor9Rqd7H00gZa10K-dFVjrN-ysQ@mail.gmail.com>
References: <CAMTWbJgN-GW9Zp21awbAmXpor9Rqd7H00gZa10K-dFVjrN-ysQ@mail.gmail.com>
Message-ID: <56b2d17e-35e1-e5af-54e2-7bd8303c4436@gmail.com>

   On Windows you can use memory.limit.

https://stackoverflow.com/questions/12582793/limiting-memory-usage-in-r-under-linux

    Not sure how much that helps.

On 12/12/20 6:19 PM, Arne Henningsen wrote:
> When working with a huge data set with character string variables, I
> experienced that various commands let R crash. When I run R in a
> Linux/bash console, R terminates with the message "Killed". When I use
> RStudio, I get the message "R Session Aborted. R encountered a fatal
> error. The session was terminated. Start New Session". If an object in
> the R workspace needs too much memory, I would expect that R would not
> crash but issue an error message "Error: cannot allocate vector of
> size ...".  A minimal reproducible example (at least on my computer)
> is:
> 
> nObs <- 1e9
> 
> date <- paste( round( runif( nObs, 1981, 2015 ) ), round( runif( nObs,
> 1, 12 ) ), round( runif( nObs, 1, 31 ) ), sep = "-" )
> 
> Is this a bug or a feature of R?
> 
> Some information about my R version, OS, etc:
> 
> R> sessionInfo()
> R version 4.0.3 (2020-10-10)
> Platform: x86_64-pc-linux-gnu (64-bit)
> Running under: Ubuntu 20.04.1 LTS
> 
> Matrix products: default
> BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0
> LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0
> 
> locale:
> [1] LC_CTYPE=en_DK.UTF-8       LC_NUMERIC=C
> [3] LC_TIME=en_DK.UTF-8        LC_COLLATE=en_DK.UTF-8
> [5] LC_MONETARY=en_DK.UTF-8    LC_MESSAGES=en_DK.UTF-8
> [7] LC_PAPER=en_DK.UTF-8       LC_NAME=C
> [9] LC_ADDRESS=C               LC_TELEPHONE=C
> [11] LC_MEASUREMENT=en_DK.UTF-8 LC_IDENTIFICATION=C
> 
> attached base packages:
> [1] stats     graphics  grDevices utils     datasets  methods   base
> 
> loaded via a namespace (and not attached):
> [1] compiler_4.0.3
> 
> /Arne
>


From brod|e@g@@|@m @end|ng |rom y@hoo@com  Sun Dec 13 02:12:31 2020
From: brod|e@g@@|@m @end|ng |rom y@hoo@com (brodie gaslam)
Date: Sun, 13 Dec 2020 01:12:31 +0000 (UTC)
Subject: [Rd] R crashes when using huge data sets with character string
 variables
In-Reply-To: <56b2d17e-35e1-e5af-54e2-7bd8303c4436@gmail.com>
References: <CAMTWbJgN-GW9Zp21awbAmXpor9Rqd7H00gZa10K-dFVjrN-ysQ@mail.gmail.com>
 <56b2d17e-35e1-e5af-54e2-7bd8303c4436@gmail.com>
Message-ID: <1511796618.83974.1607821951891@mail.yahoo.com>

 > On Saturday, December 12, 2020, 6:33:33 PM EST, Ben Bolker <bbolker at gmail.com> wrote:
>
>? On Windows you can use memory.limit.
>
> https://stackoverflow.com/questions/12582793/limiting-memory-usage-in-r-under-linux
>
>??? Not sure how much that helps.
>
>On 12/12/20 6:19 PM, Arne Henningsen wrote:
>> When working with a huge data set with character string variables, I
>> experienced that various commands let R crash. When I run R in a
>> Linux/bash console, R terminates with the message "Killed". When I use
>> RStudio, I get the message "R Session Aborted. R encountered a fatal
>> error. The session was terminated. Start New Session". If an object in
>> the R workspace needs too much memory, I would expect that R would not
>> crash but issue an error message "Error: cannot allocate vector of
>> size ...".? A minimal reproducible example (at least on my computer)
>> is:
>>
>> nObs <- 1e9
>>
>> date <- paste( round( runif( nObs, 1981, 2015 ) ), round( runif( nObs,
>> 1, 12 ) ), round( runif( nObs, 1, 31 ) ), sep = "-" )
>>
>> Is this a bug or a feature of R?

On OS X I see:

??? > nObs <- 1e9
??? >? date <- paste( round( runif( nObs, 1981, 2015 ) ), round( runif( nObs,1, 12 ) ), round( runif( nObs, 1, 31 ) ), sep = "-" )
??? Error: vector memory exhausted (limit reached?)
??? > sessionInfo()
??? R version 4.0.3 (2020-10-10)
??? Platform: x86_64-apple-darwin17.0 (64-bit)
??? Running under: macOS Catalina 10.15.7

Which is what I would expect.? I don't doubt the error you've seen, just
providing a data point for whoever ends up looking into this further.

Best,

Brodie.


From iuke-tier@ey m@iii@g oii uiow@@edu  Sun Dec 13 04:26:50 2020
From: iuke-tier@ey m@iii@g oii uiow@@edu (iuke-tier@ey m@iii@g oii uiow@@edu)
Date: Sat, 12 Dec 2020 21:26:50 -0600 (CST)
Subject: [Rd] 
 [External] R crashes when using huge data sets with character
 string variables
In-Reply-To: <CAMTWbJgN-GW9Zp21awbAmXpor9Rqd7H00gZa10K-dFVjrN-ysQ@mail.gmail.com>
References: <CAMTWbJgN-GW9Zp21awbAmXpor9Rqd7H00gZa10K-dFVjrN-ysQ@mail.gmail.com>
Message-ID: <alpine.DEB.2.21.2012122115030.3377@luke-Latitude-7480>

If R is receiving a kill signal there is nothing it can do about it.

I am guessing you are running into a memory over-commit issue in your OS.
https://en.wikipedia.org/wiki/Memory_overcommitment
https://engineering.pivotal.io/post/virtual_memory_settings_in_linux_-_the_problem_with_overcommit/

If you have to run this close to your physical memory limits you might
try using your shell's facility (ulimit for bash, limit for some
others) to limit process memory/virtual memory use to your available
physical memory. You can also try setting the R_MAX_VSIZE environment
variable mentioned in ?Memory; that only affects the R heap, not
malloc() done elsewhere.

Best,

luke

On Sat, 12 Dec 2020, Arne Henningsen wrote:

> When working with a huge data set with character string variables, I
> experienced that various commands let R crash. When I run R in a
> Linux/bash console, R terminates with the message "Killed". When I use
> RStudio, I get the message "R Session Aborted. R encountered a fatal
> error. The session was terminated. Start New Session". If an object in
> the R workspace needs too much memory, I would expect that R would not
> crash but issue an error message "Error: cannot allocate vector of
> size ...".  A minimal reproducible example (at least on my computer)
> is:
>
> nObs <- 1e9
>
> date <- paste( round( runif( nObs, 1981, 2015 ) ), round( runif( nObs,
> 1, 12 ) ), round( runif( nObs, 1, 31 ) ), sep = "-" )
>
> Is this a bug or a feature of R?
>
> Some information about my R version, OS, etc:
>
> R> sessionInfo()
> R version 4.0.3 (2020-10-10)
> Platform: x86_64-pc-linux-gnu (64-bit)
> Running under: Ubuntu 20.04.1 LTS
>
> Matrix products: default
> BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0
> LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0
>
> locale:
> [1] LC_CTYPE=en_DK.UTF-8       LC_NUMERIC=C
> [3] LC_TIME=en_DK.UTF-8        LC_COLLATE=en_DK.UTF-8
> [5] LC_MONETARY=en_DK.UTF-8    LC_MESSAGES=en_DK.UTF-8
> [7] LC_PAPER=en_DK.UTF-8       LC_NAME=C
> [9] LC_ADDRESS=C               LC_TELEPHONE=C
> [11] LC_MEASUREMENT=en_DK.UTF-8 LC_IDENTIFICATION=C
>
> attached base packages:
> [1] stats     graphics  grDevices utils     datasets  methods   base
>
> loaded via a namespace (and not attached):
> [1] compiler_4.0.3
>
> /Arne
>
>

-- 
Luke Tierney
Ralph E. Wareham Professor of Mathematical Sciences
University of Iowa                  Phone:             319-335-3386
Department of Statistics and        Fax:               319-335-3017
    Actuarial Science
241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu


From edd @end|ng |rom deb|@n@org  Sun Dec 13 05:17:05 2020
From: edd @end|ng |rom deb|@n@org (Dirk Eddelbuettel)
Date: Sat, 12 Dec 2020 22:17:05 -0600
Subject: [Rd] 
 [External] R crashes when using huge data sets with character
 string variables
In-Reply-To: <alpine.DEB.2.21.2012122115030.3377@luke-Latitude-7480>
References: <CAMTWbJgN-GW9Zp21awbAmXpor9Rqd7H00gZa10K-dFVjrN-ysQ@mail.gmail.com>
 <alpine.DEB.2.21.2012122115030.3377@luke-Latitude-7480>
Message-ID: <24533.38337.45434.606263@rob.eddelbuettel.com>


On 12 December 2020 at 21:26, luke-tierney at uiowa.edu wrote:
| If R is receiving a kill signal there is nothing it can do about it.
| 
| I am guessing you are running into a memory over-commit issue in your OS.
| https://en.wikipedia.org/wiki/Memory_overcommitment
| https://engineering.pivotal.io/post/virtual_memory_settings_in_linux_-_the_problem_with_overcommit/
| 
| If you have to run this close to your physical memory limits you might
| try using your shell's facility (ulimit for bash, limit for some
| others) to limit process memory/virtual memory use to your available
| physical memory. You can also try setting the R_MAX_VSIZE environment
| variable mentioned in ?Memory; that only affects the R heap, not
| malloc() done elsewhere.

Similarly, as it is Linux, you could (easily) add virtual memory via a
swapfile (see 'man 8 swapfile' and 'man 8 swapon').  But even then, I expect
this to be slow -- 1e9 is a lot.

I have 32gb and ample swap (which is rarely used, but a safety net). When I
use your code with nObs <- 1e8 it ends up with about 6gb which poses poses no
problem, but already takes 3 1/2 minutes:

> nObs <- 1e8
> system.time(date <- paste( round( runif( nObs, 1981, 2015 ) ), round( runif( nObs, 1, 12 ) ), round( runif( nObs, 1, 31 ) ), sep = "-" ))
   user  system elapsed 
203.723   1.779 205.528 
> 

You may want to play with the nObs value to see exactly where it breaks on
your box.

Dirk

-- 
https://dirk.eddelbuettel.com | @eddelbuettel | edd at debian.org


From |uc@r @end|ng |rom |edor@project@org  Sun Dec 13 11:17:24 2020
From: |uc@r @end|ng |rom |edor@project@org (=?UTF-8?Q?I=C3=B1aki_Ucar?=)
Date: Sun, 13 Dec 2020 11:17:24 +0100
Subject: [Rd] 
 [External] R crashes when using huge data sets with character
 string variables
In-Reply-To: <alpine.DEB.2.21.2012122115030.3377@luke-Latitude-7480>
References: <CAMTWbJgN-GW9Zp21awbAmXpor9Rqd7H00gZa10K-dFVjrN-ysQ@mail.gmail.com>
 <alpine.DEB.2.21.2012122115030.3377@luke-Latitude-7480>
Message-ID: <CALEXWq2hWZqZ48EJ0XAgoOiEE90CvY6uF8jNbP06JhBtTuJ3tw@mail.gmail.com>

On Sun, 13 Dec 2020 at 04:27, <luke-tierney at uiowa.edu> wrote:
>
> If R is receiving a kill signal there is nothing it can do about it.
>
> I am guessing you are running into a memory over-commit issue in your OS.
> https://en.wikipedia.org/wiki/Memory_overcommitment
> https://engineering.pivotal.io/post/virtual_memory_settings_in_linux_-_the_problem_with_overcommit/

Correct. And in particular, this is most probably the earlyoom [1]
service in action, which, I believe, is installed and enabled by
default in Ubuntu 20.04. It is a simple daemon that monitors memory,
and when some conditions are reached (e.g., the system is about to
start swapping), it looks for offending processes and kills them.

[1] https://github.com/rfjakob/earlyoom

I?aki

> If you have to run this close to your physical memory limits you might
> try using your shell's facility (ulimit for bash, limit for some
> others) to limit process memory/virtual memory use to your available
> physical memory. You can also try setting the R_MAX_VSIZE environment
> variable mentioned in ?Memory; that only affects the R heap, not
> malloc() done elsewhere.
>
> Best,
>
> luke
>
> On Sat, 12 Dec 2020, Arne Henningsen wrote:
>
> > When working with a huge data set with character string variables, I
> > experienced that various commands let R crash. When I run R in a
> > Linux/bash console, R terminates with the message "Killed". When I use
> > RStudio, I get the message "R Session Aborted. R encountered a fatal
> > error. The session was terminated. Start New Session". If an object in
> > the R workspace needs too much memory, I would expect that R would not
> > crash but issue an error message "Error: cannot allocate vector of
> > size ...".  A minimal reproducible example (at least on my computer)
> > is:
> >
> > nObs <- 1e9
> >
> > date <- paste( round( runif( nObs, 1981, 2015 ) ), round( runif( nObs,
> > 1, 12 ) ), round( runif( nObs, 1, 31 ) ), sep = "-" )
> >
> > Is this a bug or a feature of R?
> >
> > Some information about my R version, OS, etc:
> >
> > R> sessionInfo()
> > R version 4.0.3 (2020-10-10)
> > Platform: x86_64-pc-linux-gnu (64-bit)
> > Running under: Ubuntu 20.04.1 LTS
> >
> > Matrix products: default
> > BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0
> > LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0
> >
> > locale:
> > [1] LC_CTYPE=en_DK.UTF-8       LC_NUMERIC=C
> > [3] LC_TIME=en_DK.UTF-8        LC_COLLATE=en_DK.UTF-8
> > [5] LC_MONETARY=en_DK.UTF-8    LC_MESSAGES=en_DK.UTF-8
> > [7] LC_PAPER=en_DK.UTF-8       LC_NAME=C
> > [9] LC_ADDRESS=C               LC_TELEPHONE=C
> > [11] LC_MEASUREMENT=en_DK.UTF-8 LC_IDENTIFICATION=C
> >
> > attached base packages:
> > [1] stats     graphics  grDevices utils     datasets  methods   base
> >
> > loaded via a namespace (and not attached):
> > [1] compiler_4.0.3
> >
> > /Arne
> >
> >
>
> --
> Luke Tierney
> Ralph E. Wareham Professor of Mathematical Sciences
> University of Iowa                  Phone:             319-335-3386
> Department of Statistics and        Fax:               319-335-3017
>     Actuarial Science
> 241 Schaeffer Hall                  email:   luke-tierney at uiowa.edu
> Iowa City, IA 52242                 WWW:  http://www.stat.uiowa.edu
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel



-- 
I?aki ?car


