From henr|k@bengt@@on @end|ng |rom gm@||@com  Wed Dec  1 07:10:34 2021
From: henr|k@bengt@@on @end|ng |rom gm@||@com (Henrik Bengtsson)
Date: Tue, 30 Nov 2021 22:10:34 -0800
Subject: [Rd] mapply(): Special case of USE.NAMES=TRUE with recent R-devel
 updates
Message-ID: <CAFDcVCRaGk8b3jeHQq5AL1LQkY1H7GjLRGTcrCPQ9UHye1FTgw@mail.gmail.com>

Hi,

in R-devel (4.2.0), we now get:

> mapply(paste, "A", character(), USE.NAMES = TRUE)
named list()

Now, in ?mapply we have:

USE.NAMES: logical; use the names of the first ... argument, or if
that is an unnamed character vector, use that vector as the names.

This basically says we should get:

> answer <- list()
> first <- "A"
> names(answer) <- first

which obviously is an error. The help is not explicit what should
happen when the length "of the first ... argument" is zero, but the
above behavior effectively does something like:

> answer <- list()
> first <- "A"
> names(answer) <- first[seq_along(answer)]
> answer
named list()

Is there a need for the docs to be updated, or should the result be an
unnamed empty list?

/Henrik


From hp@ge@@on@g|thub @end|ng |rom gm@||@com  Wed Dec  1 07:45:15 2021
From: hp@ge@@on@g|thub @end|ng |rom gm@||@com (=?UTF-8?B?SGVydsOpIFBhZ8Oocw==?=)
Date: Tue, 30 Nov 2021 22:45:15 -0800
Subject: [Rd] 
 mapply(): Special case of USE.NAMES=TRUE with recent R-devel updates
In-Reply-To: <CAFDcVCRaGk8b3jeHQq5AL1LQkY1H7GjLRGTcrCPQ9UHye1FTgw@mail.gmail.com>
References: <CAFDcVCRaGk8b3jeHQq5AL1LQkY1H7GjLRGTcrCPQ9UHye1FTgw@mail.gmail.com>
Message-ID: <842f72bb-53fa-1755-5480-1e351d9f56cb@gmail.com>

And also:

   > mapply(paste, c(a="A"), character(), USE.NAMES = TRUE)

   Error in names(answer) <- names1 :

     'names' attribute [1] must be the same length as the vector [0]


When the shortest arguments get recycled to the length of the longest, 
shouldn't their names also get recycled?

   > mapply(paste, c(a="A", b="B"), letters[1:6], USE.NAMES=TRUE)

       a     b  <NA>  <NA>  <NA>  <NA>

   "A a" "B b" "A c" "B d" "A e" "B f"

That's assuming that rep() accurately materializes recycling (I hope it 
does):

   > rep(c(a="A", b="B"), length.out=6)

     a   b   a   b   a   b

   "A" "B" "A" "B" "A" "B"


   > rep(c(a="A", b="B"), length.out=0)

   named character(0)


I always wished that the process of recycling which happens everywhere 
all the time in R was implemented in its own dedicated function 
recycle(). But that's another story.

Anyways, back to mapply(): Once what happens to the names during 
recycling is clarified, there should be no need to be explicit about 
what should happen when the length "of the first ... argument" is zero 
because it will no longer be a special case.

Cheers,
H.


On 30/11/2021 22:10, Henrik Bengtsson wrote:
> Hi,
> 
> in R-devel (4.2.0), we now get:
> 
>> mapply(paste, "A", character(), USE.NAMES = TRUE)
> named list()
> 
> Now, in ?mapply we have:
> 
> USE.NAMES: logical; use the names of the first ... argument, or if
> that is an unnamed character vector, use that vector as the names.
> 
> This basically says we should get:
> 
>> answer <- list()
>> first <- "A"
>> names(answer) <- first
> 
> which obviously is an error. The help is not explicit what should
> happen when the length "of the first ... argument" is zero, but the
> above behavior effectively does something like:
> 
>> answer <- list()
>> first <- "A"
>> names(answer) <- first[seq_along(answer)]
>> answer
> named list()
> 
> Is there a need for the docs to be updated, or should the result be an
> unnamed empty list?
> 
> /Henrik
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 

-- 
Herv? Pag?s

Bioconductor Core Team
hpages.on.github at gmail.com


From henr|k@bengt@@on @end|ng |rom gm@||@com  Wed Dec  1 18:59:13 2021
From: henr|k@bengt@@on @end|ng |rom gm@||@com (Henrik Bengtsson)
Date: Wed, 1 Dec 2021 09:59:13 -0800
Subject: [Rd] R-devel: as.vector(x,
 mode = "list") drops attributes despite documented not to
Message-ID: <CAFDcVCQJ2+X_jOEtyJaYb+YHuN4ohGber5pAJDWzCZXNS435Zw@mail.gmail.com>

Hi,

in R 4.1.2 we have:

> x <- structure(as.list(1:2), dim = c(1,2))
> x
     [,1] [,2]
[1,] 1    2
> as.vector(x, mode = "list")
     [,1] [,2]
[1,] 1    2

whereas in recent versions of R-devel (4.2.0) we have:

> x <- structure(as.list(1:2), dim = c(1,2))
> x
     [,1] [,2]
[1,] 1    2
> as.vector(x, mode = "list")
[[1]]
[1] 1

[[2]]
[1] 2

However, as I read ?as.vector, dropping of attributes should _not_
happen for non-atomic results such as lists.  Is the new behavior a
mistake?

Specifically, ?as.vector says:

'as.vector', a generic, attempts to coerce its argument into a vector
of mode 'mode' (the default is to coerce to whichever vector mode is
most convenient): if the result is atomic all attributes are removed.

[...]

Details:

The atomic modes are "logical", "integer", "numeric" (synonym
"double"), "complex", "character" and "raw".

[...] On the other hand, as.vector removes all attributes including
names for results of atomic mode (but not those of mode "list" nor
"expression").

Value:

[...]

For as.vector, a vector (atomic or of type list or expression). All
attributes are removed from the result if it is of an atomic mode, but
not in general for a list result. The default method handles 24 input
types and 12 values of type: the details of most coercions are
undocumented and subject to change.

/Henrik


From Thom@@@SOEIRO @end|ng |rom @p-hm@|r  Wed Dec  1 23:41:04 2021
From: Thom@@@SOEIRO @end|ng |rom @p-hm@|r (SOEIRO Thomas)
Date: Wed, 1 Dec 2021 22:41:04 +0000
Subject: [Rd] Add ... to Reduce?
Message-ID: <1638398464828.91211@ap-hm.fr>

Dear list,

Currently, it is needed to use anonymous functions to pass additional parameters to f in Reduce.

The following patch adds ... to pass additional arguments directly and seems to work in simple cases (see example below).

However, since this was not available (even though it is common for similar functions), I suspect that I am missing something...

Best,

Thomas


dfs <- list(x = warpbreaks)
dfs$x$id <- seq_along(dfs$x$breaks)
dfs$y <- dfs$x[1:15, ]
dfs$z <- dfs$x[20:35, ]

identical(
  Reduce(function(...) merge(..., by = "id", all = TRUE), dfs),
  Reduce(merge, dfs, by = "id", all = TRUE)
)


diff -u orig/funprog.R mod/funprog.R
--- orig/funprog.R	2021-12-01 23:02:09.710231318 +0100
+++ mod/funprog.R	2021-12-01 23:23:58.591120101 +0100
@@ -1,7 +1,7 @@
 #  File src/library/base/R/funprog.R
 #  Part of the R package, https://www.R-project.org
 #
-#  Copyright (C) 1995-2014 The R Core Team
+#  Copyright (C) 1995-2021 The R Core Team
 #
 #  This program is free software; you can redistribute it and/or modify
 #  it under the terms of the GNU General Public License as published by
@@ -17,7 +17,7 @@
 #  https://www.R-project.org/Licenses/
 
 Reduce <-
-function(f, x, init, right = FALSE, accumulate = FALSE)
+function(f, x, init, right = FALSE, accumulate = FALSE, ...)
 {
     mis <- missing(init)
     len <- length(x)
@@ -49,11 +49,11 @@
     if(!accumulate) {
         if(right) {
             for(i in rev(ind))
-                init <- forceAndCall(2, f, x[[i]], init)
+                init <- forceAndCall(2, f, x[[i]], init, ...)
         }
         else {
             for(i in ind)
-                init <- forceAndCall(2, f, init, x[[i]])
+                init <- forceAndCall(2, f, init, x[[i]], ...)
         }
         init
     }
@@ -66,13 +66,13 @@
             if(right) {
                 out[[len]] <- init
                 for(i in rev(ind)) {
-                    init <- forceAndCall(2, f, x[[i]], init)
+                    init <- forceAndCall(2, f, x[[i]], init, ...)
                     out[[i]] <- init
                 }
             } else {
                 out[[1L]] <- init
                 for(i in ind) {
-                    init <- forceAndCall(2, f, init, x[[i]])
+                    init <- forceAndCall(2, f, init, x[[i]], ...)
                     out[[i]] <- init
                 }
             }
@@ -80,14 +80,14 @@
             if(right) {
                 out[[len]] <- init
                 for(i in rev(ind)) {
-                    init <- forceAndCall(2, f, x[[i]], init)
+                    init <- forceAndCall(2, f, x[[i]], init, ...)
                     out[[i]] <- init
                 }
             }
             else {
                 for(i in ind) {
                     out[[i]] <- init
-                    init <- forceAndCall(2, f, init, x[[i]])
+                    init <- forceAndCall(2, f, init, x[[i]], ...)
                 }
                 out[[len]] <- init
             }
diff -u orig/funprog.Rd mod/funprog.Rd
--- orig/funprog.Rd	2021-12-01 23:02:38.400738386 +0100
+++ mod/funprog.Rd	2021-12-01 23:29:28.993976101 +0100
@@ -21,7 +21,7 @@
   given function.
 }
 \usage{
-Reduce(f, x, init, right = FALSE, accumulate = FALSE)
+Reduce(f, x, init, right = FALSE, accumulate = FALSE, ...)
 Filter(f, x)
 Find(f, x, right = FALSE, nomatch = NULL)
 Map(f, ...)
@@ -44,7 +44,7 @@
     combination is used.}
   \item{nomatch}{the value to be returned in the case when
     \dQuote{no match} (no element satisfying the predicate) is found.}
-  \item{\dots}{vectors.}
+  \item{\dots}{arguments to be passed to FUN.}
 }
 \details{
   If \code{init} is given, \code{Reduce} logically adds it to the start




From j|ox @end|ng |rom mcm@@ter@c@  Thu Dec  2 22:02:25 2021
From: j|ox @end|ng |rom mcm@@ter@c@ (Fox, John)
Date: Thu, 2 Dec 2021 21:02:25 +0000
Subject: [Rd] capturing multiple warnings in tryCatch()
Message-ID: <E3B708C1-8E1D-41A0-842A-9C05D229B3DB@mcmaster.ca>

Dear R-devel list members,

Is it possible to capture more than one warning message using tryCatch()? The answer may be in ?conditions, but, if it is, I can't locate it.

For example, in the following only the first warning message is captured and reported:

> foo <- function(){
+   warning("warning 1")
+   warning("warning 2")
+ }

> foo()
Warning messages:
1: In foo() : warning 1
2: In foo() : warning 2

> bar <- function(){
+   tryCatch(foo(), warning=function(w) print(w))
+ }

> bar()
<simpleWarning in foo(): warning 1>

Is there a way to capture "warning 2" as well?

Any help would be appreciated.

John

-- 
John Fox, Professor Emeritus
McMaster University
Hamilton, Ontario, Canada
Web: http://socserv.mcmaster.ca/jfox/
 
 


From @|mon@urb@nek @end|ng |rom R-project@org  Thu Dec  2 22:14:28 2021
From: @|mon@urb@nek @end|ng |rom R-project@org (Simon Urbanek)
Date: Fri, 3 Dec 2021 10:14:28 +1300
Subject: [Rd] capturing multiple warnings in tryCatch()
In-Reply-To: <E3B708C1-8E1D-41A0-842A-9C05D229B3DB@mcmaster.ca>
References: <E3B708C1-8E1D-41A0-842A-9C05D229B3DB@mcmaster.ca>
Message-ID: <516D77A0-7503-4695-A45F-1162ED816FCF@R-project.org>


Adapted from demo(error.catching):

> W=list()
> withCallingHandlers(foo(), warning=function(w) { W <<- c(W, list(w)); invokeRestart("muffleWarning") })
> str(W)
List of 2
 $ :List of 2
  ..$ message: chr "warning 1"
  ..$ call   : language foo()
  ..- attr(*, "class")= chr [1:3] "simpleWarning" "warning" "condition"
 $ :List of 2
  ..$ message: chr "warning 2"
  ..$ call   : language foo()
  ..- attr(*, "class")= chr [1:3] "simpleWarning" "warning" "condition"

Cheers,
Simon


> On Dec 3, 2021, at 10:02 AM, Fox, John <jfox at mcmaster.ca> wrote:
> 
> Dear R-devel list members,
> 
> Is it possible to capture more than one warning message using tryCatch()? The answer may be in ?conditions, but, if it is, I can't locate it.
> 
> For example, in the following only the first warning message is captured and reported:
> 
>> foo <- function(){
> +   warning("warning 1")
> +   warning("warning 2")
> + }
> 
>> foo()
> Warning messages:
> 1: In foo() : warning 1
> 2: In foo() : warning 2
> 
>> bar <- function(){
> +   tryCatch(foo(), warning=function(w) print(w))
> + }
> 
>> bar()
> <simpleWarning in foo(): warning 1>
> 
> Is there a way to capture "warning 2" as well?
> 
> Any help would be appreciated.
> 
> John
> 
> -- 
> John Fox, Professor Emeritus
> McMaster University
> Hamilton, Ontario, Canada
> Web: http://socserv.mcmaster.ca/jfox/
> 
> 
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 


From du@@@@dr|@n @end|ng |rom un|buc@ro  Thu Dec  2 22:52:36 2021
From: du@@@@dr|@n @end|ng |rom un|buc@ro (=?UTF-8?B?QWRyaWFuIER1yJlh?=)
Date: Thu, 2 Dec 2021 23:52:36 +0200
Subject: [Rd] capturing multiple warnings in tryCatch()
In-Reply-To: <E3B708C1-8E1D-41A0-842A-9C05D229B3DB@mcmaster.ca>
References: <E3B708C1-8E1D-41A0-842A-9C05D229B3DB@mcmaster.ca>
Message-ID: <CAJ=0CtCF3YAKkcUETBZHgCO6EaUxNkxDCWxYq7nq1Ua+f_5ubw@mail.gmail.com>

Dear John,

I have a function in package admisc called tryCatchWEM (catches warnings,
errors and messages):

> tryCatchWEM(foo())
$warning
[1] "warning1" "warning2"

Hope this helps,
Adrian

On Thu, 2 Dec 2021 at 23:04, Fox, John <jfox at mcmaster.ca> wrote:

> Dear R-devel list members,
>
> Is it possible to capture more than one warning message using tryCatch()?
> The answer may be in ?conditions, but, if it is, I can't locate it.
>
> For example, in the following only the first warning message is captured
> and reported:
>
> > foo <- function(){
> +   warning("warning 1")
> +   warning("warning 2")
> + }
>
> > foo()
> Warning messages:
> 1: In foo() : warning 1
> 2: In foo() : warning 2
>
> > bar <- function(){
> +   tryCatch(foo(), warning=function(w) print(w))
> + }
>
> > bar()
> <simpleWarning in foo(): warning 1>
>
> Is there a way to capture "warning 2" as well?
>
> Any help would be appreciated.
>
> John
>
> --
> John Fox, Professor Emeritus
> McMaster University
> Hamilton, Ontario, Canada
> Web: http://socserv.mcmaster.ca/jfox/
>
>
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


-- 
Adrian Dusa
University of Bucharest
Romanian Social Data Archive
Soseaua Panduri nr. 90-92
050663 Bucharest sector 5
Romania
https://adriandusa.eu

	[[alternative HTML version deleted]]


From henr|k@bengt@@on @end|ng |rom gm@||@com  Thu Dec  2 23:18:57 2021
From: henr|k@bengt@@on @end|ng |rom gm@||@com (Henrik Bengtsson)
Date: Thu, 2 Dec 2021 14:18:57 -0800
Subject: [Rd] capturing multiple warnings in tryCatch()
In-Reply-To: <516D77A0-7503-4695-A45F-1162ED816FCF@R-project.org>
References: <E3B708C1-8E1D-41A0-842A-9C05D229B3DB@mcmaster.ca>
 <516D77A0-7503-4695-A45F-1162ED816FCF@R-project.org>
Message-ID: <CAFDcVCQuFVXJFn812gbLcDcY=gBeKwwXm8AQsW5Pm+wqpTzRoQ@mail.gmail.com>

Simon's suggestion with withCallingHandlers() is the correct way.
Also, note that if you use tryCatch() to catch warnings, you're
*interrupting* the evaluation of the expression of interest, e.g.

> res <- tryCatch({ message("hey"); warning("boom"); message("there"); 42 }, warning = function(w) { message("Warning caught: ", conditionMessage(w)); 3.14 })
hey
Warning caught: boom
> res
[1] 3.14

Note how it never completes your expression.

/Henrik

On Thu, Dec 2, 2021 at 1:14 PM Simon Urbanek
<simon.urbanek at r-project.org> wrote:
>
>
> Adapted from demo(error.catching):
>
> > W=list()
> > withCallingHandlers(foo(), warning=function(w) { W <<- c(W, list(w)); invokeRestart("muffleWarning") })
> > str(W)
> List of 2
>  $ :List of 2
>   ..$ message: chr "warning 1"
>   ..$ call   : language foo()
>   ..- attr(*, "class")= chr [1:3] "simpleWarning" "warning" "condition"
>  $ :List of 2
>   ..$ message: chr "warning 2"
>   ..$ call   : language foo()
>   ..- attr(*, "class")= chr [1:3] "simpleWarning" "warning" "condition"
>
> Cheers,
> Simon
>
>
> > On Dec 3, 2021, at 10:02 AM, Fox, John <jfox at mcmaster.ca> wrote:
> >
> > Dear R-devel list members,
> >
> > Is it possible to capture more than one warning message using tryCatch()? The answer may be in ?conditions, but, if it is, I can't locate it.
> >
> > For example, in the following only the first warning message is captured and reported:
> >
> >> foo <- function(){
> > +   warning("warning 1")
> > +   warning("warning 2")
> > + }
> >
> >> foo()
> > Warning messages:
> > 1: In foo() : warning 1
> > 2: In foo() : warning 2
> >
> >> bar <- function(){
> > +   tryCatch(foo(), warning=function(w) print(w))
> > + }
> >
> >> bar()
> > <simpleWarning in foo(): warning 1>
> >
> > Is there a way to capture "warning 2" as well?
> >
> > Any help would be appreciated.
> >
> > John
> >
> > --
> > John Fox, Professor Emeritus
> > McMaster University
> > Hamilton, Ontario, Canada
> > Web: http://socserv.mcmaster.ca/jfox/
> >
> >
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
> >
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From j|ox @end|ng |rom mcm@@ter@c@  Thu Dec  2 23:37:52 2021
From: j|ox @end|ng |rom mcm@@ter@c@ (Fox, John)
Date: Thu, 2 Dec 2021 22:37:52 +0000
Subject: [Rd] capturing multiple warnings in tryCatch()
In-Reply-To: <CAFDcVCQuFVXJFn812gbLcDcY=gBeKwwXm8AQsW5Pm+wqpTzRoQ@mail.gmail.com>
References: <E3B708C1-8E1D-41A0-842A-9C05D229B3DB@mcmaster.ca>
 <516D77A0-7503-4695-A45F-1162ED816FCF@R-project.org>
 <CAFDcVCQuFVXJFn812gbLcDcY=gBeKwwXm8AQsW5Pm+wqpTzRoQ@mail.gmail.com>
Message-ID: <8B6460C6-78A9-414E-8353-A817CD7A5292@mcmaster.ca>

Dear Henrik, Simon, and Adrian,

As it turns out Adrian's admisc::tryCatchWEM() *almost* does what I want, which is both to capture all messages and the result of the expression (rather than the visible representation of the result). I was easily able to modify tryCatchWEM() to return the result.

Henrik: I was aware that tryCatch() doesn't return the final result of the expression, and I was previously re-executing the expression to capture the reult, but only getting the first warning message, along with the result. 

Thanks for responding to my question and providing viable solutions,
 John

?On 2021-12-02, 5:19 PM, "Henrik Bengtsson" <henrik.bengtsson at gmail.com> wrote:

    Simon's suggestion with withCallingHandlers() is the correct way.
    Also, note that if you use tryCatch() to catch warnings, you're
    *interrupting* the evaluation of the expression of interest, e.g.

    > res <- tryCatch({ message("hey"); warning("boom"); message("there"); 42 }, warning = function(w) { message("Warning caught: ", conditionMessage(w)); 3.14 })
    hey
    Warning caught: boom
    > res
    [1] 3.14

    Note how it never completes your expression.

    /Henrik

    On Thu, Dec 2, 2021 at 1:14 PM Simon Urbanek
    <simon.urbanek at r-project.org> wrote:
    >
    >
    > Adapted from demo(error.catching):
    >
    > > W=list()
    > > withCallingHandlers(foo(), warning=function(w) { W <<- c(W, list(w)); invokeRestart("muffleWarning") })
    > > str(W)
    > List of 2
    >  $ :List of 2
    >   ..$ message: chr "warning 1"
    >   ..$ call   : language foo()
    >   ..- attr(*, "class")= chr [1:3] "simpleWarning" "warning" "condition"
    >  $ :List of 2
    >   ..$ message: chr "warning 2"
    >   ..$ call   : language foo()
    >   ..- attr(*, "class")= chr [1:3] "simpleWarning" "warning" "condition"
    >
    > Cheers,
    > Simon
    >
    >
    > > On Dec 3, 2021, at 10:02 AM, Fox, John <jfox at mcmaster.ca> wrote:
    > >
    > > Dear R-devel list members,
    > >
    > > Is it possible to capture more than one warning message using tryCatch()? The answer may be in ?conditions, but, if it is, I can't locate it.
    > >
    > > For example, in the following only the first warning message is captured and reported:
    > >
    > >> foo <- function(){
    > > +   warning("warning 1")
    > > +   warning("warning 2")
    > > + }
    > >
    > >> foo()
    > > Warning messages:
    > > 1: In foo() : warning 1
    > > 2: In foo() : warning 2
    > >
    > >> bar <- function(){
    > > +   tryCatch(foo(), warning=function(w) print(w))
    > > + }
    > >
    > >> bar()
    > > <simpleWarning in foo(): warning 1>
    > >
    > > Is there a way to capture "warning 2" as well?
    > >
    > > Any help would be appreciated.
    > >
    > > John
    > >
    > > --
    > > John Fox, Professor Emeritus
    > > McMaster University
    > > Hamilton, Ontario, Canada
    > > Web: http://socserv.mcmaster.ca/jfox/
    > >
    > >
    > >
    > > ______________________________________________
    > > R-devel at r-project.org mailing list
    > > https://stat.ethz.ch/mailman/listinfo/r-devel
    > >
    >
    > ______________________________________________
    > R-devel at r-project.org mailing list
    > https://stat.ethz.ch/mailman/listinfo/r-devel


From dmedr| @end|ng |rom gm@||@com  Fri Dec  3 10:19:43 2021
From: dmedr| @end|ng |rom gm@||@com (Daniele Medri)
Date: Fri, 3 Dec 2021 10:19:43 +0100
Subject: [Rd] capturing multiple warnings in tryCatch()
In-Reply-To: <8B6460C6-78A9-414E-8353-A817CD7A5292@mcmaster.ca>
References: <E3B708C1-8E1D-41A0-842A-9C05D229B3DB@mcmaster.ca>
 <516D77A0-7503-4695-A45F-1162ED816FCF@R-project.org>
 <CAFDcVCQuFVXJFn812gbLcDcY=gBeKwwXm8AQsW5Pm+wqpTzRoQ@mail.gmail.com>
 <8B6460C6-78A9-414E-8353-A817CD7A5292@mcmaster.ca>
Message-ID: <CAOSBRp9UW-2jynwZtnNg5rjnD0XKoaXEkqtxVpB3tCCtVUi=cA@mail.gmail.com>

Interesting exchange of ideas.

A feature that should be included soon in the codebase to help in some
use-cases  -- eg. handling thousand database connections on {L,W}AN.



Il Gio 2 Dic 2021, 23:38 Fox, John <jfox at mcmaster.ca> ha scritto:

> Dear Henrik, Simon, and Adrian,
>
> As it turns out Adrian's admisc::tryCatchWEM() *almost* does what I want,
> which is both to capture all messages and the result of the expression
> (rather than the visible representation of the result). I was easily able
> to modify tryCatchWEM() to return the result.
>
> Henrik: I was aware that tryCatch() doesn't return the final result of the
> expression, and I was previously re-executing the expression to capture the
> reult, but only getting the first warning message, along with the result.
>
> Thanks for responding to my question and providing viable solutions,
>  John
>
> ?On 2021-12-02, 5:19 PM, "Henrik Bengtsson" <henrik.bengtsson at gmail.com>
> wrote:
>
>     Simon's suggestion with withCallingHandlers() is the correct way.
>     Also, note that if you use tryCatch() to catch warnings, you're
>     *interrupting* the evaluation of the expression of interest, e.g.
>
>     > res <- tryCatch({ message("hey"); warning("boom"); message("there");
> 42 }, warning = function(w) { message("Warning caught: ",
> conditionMessage(w)); 3.14 })
>     hey
>     Warning caught: boom
>     > res
>     [1] 3.14
>
>     Note how it never completes your expression.
>
>     /Henrik
>
>     On Thu, Dec 2, 2021 at 1:14 PM Simon Urbanek
>     <simon.urbanek at r-project.org> wrote:
>     >
>     >
>     > Adapted from demo(error.catching):
>     >
>     > > W=list()
>     > > withCallingHandlers(foo(), warning=function(w) { W <<- c(W,
> list(w)); invokeRestart("muffleWarning") })
>     > > str(W)
>     > List of 2
>     >  $ :List of 2
>     >   ..$ message: chr "warning 1"
>     >   ..$ call   : language foo()
>     >   ..- attr(*, "class")= chr [1:3] "simpleWarning" "warning"
> "condition"
>     >  $ :List of 2
>     >   ..$ message: chr "warning 2"
>     >   ..$ call   : language foo()
>     >   ..- attr(*, "class")= chr [1:3] "simpleWarning" "warning"
> "condition"
>     >
>     > Cheers,
>     > Simon
>     >
>     >
>     > > On Dec 3, 2021, at 10:02 AM, Fox, John <jfox at mcmaster.ca> wrote:
>     > >
>     > > Dear R-devel list members,
>     > >
>     > > Is it possible to capture more than one warning message using
> tryCatch()? The answer may be in ?conditions, but, if it is, I can't locate
> it.
>     > >
>     > > For example, in the following only the first warning message is
> captured and reported:
>     > >
>     > >> foo <- function(){
>     > > +   warning("warning 1")
>     > > +   warning("warning 2")
>     > > + }
>     > >
>     > >> foo()
>     > > Warning messages:
>     > > 1: In foo() : warning 1
>     > > 2: In foo() : warning 2
>     > >
>     > >> bar <- function(){
>     > > +   tryCatch(foo(), warning=function(w) print(w))
>     > > + }
>     > >
>     > >> bar()
>     > > <simpleWarning in foo(): warning 1>
>     > >
>     > > Is there a way to capture "warning 2" as well?
>     > >
>     > > Any help would be appreciated.
>     > >
>     > > John
>     > >
>     > > --
>     > > John Fox, Professor Emeritus
>     > > McMaster University
>     > > Hamilton, Ontario, Canada
>     > > Web: http://socserv.mcmaster.ca/jfox/
>     > >
>     > >
>     > >
>     > > ______________________________________________
>     > > R-devel at r-project.org mailing list
>     > > https://stat.ethz.ch/mailman/listinfo/r-devel
>     > >
>     >
>     > ______________________________________________
>     > R-devel at r-project.org mailing list
>     > https://stat.ethz.ch/mailman/listinfo/r-devel
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From ru|pb@rr@d@@ @end|ng |rom @@po@pt  Fri Dec  3 17:35:29 2021
From: ru|pb@rr@d@@ @end|ng |rom @@po@pt (Rui Barradas)
Date: Fri, 3 Dec 2021 16:35:29 +0000
Subject: [Rd] capturing multiple warnings in tryCatch()
In-Reply-To: <8B6460C6-78A9-414E-8353-A817CD7A5292@mcmaster.ca>
References: <E3B708C1-8E1D-41A0-842A-9C05D229B3DB@mcmaster.ca>
 <516D77A0-7503-4695-A45F-1162ED816FCF@R-project.org>
 <CAFDcVCQuFVXJFn812gbLcDcY=gBeKwwXm8AQsW5Pm+wqpTzRoQ@mail.gmail.com>
 <8B6460C6-78A9-414E-8353-A817CD7A5292@mcmaster.ca>
Message-ID: <c31cc520-d4dc-a8c4-ac94-40323e63c8cb@sapo.pt>

Hello,

I remembered having seen a function tryCatch.W.E and after an online 
search, found where.
It was in a R-Help post and in demo(error.catching). The question by 
Marius Hofert [1] was answered, among others, by Martin Maechler [2] 
which included the function tryCatch.W.E.

These posts refer to an old thread dated 2004 [3], with an answer by 
Luke Tierney [4]. The function withWarnings posted by Luke returns all 
warning messages in a list, as seen below.
I repost the function to have this self contained.



withWarnings <- function (expr) {
   warnings <- character()
   retval <- withCallingHandlers(expr, warning = function(ex) {
     warnings <<- c(warnings, conditionMessage(ex))
     invokeRestart("muffleWarning")
   })
   list(Value = retval, Warnings = warnings)
}
withWarnings(foo())
#$Value
#[1] "warning 2"
#
#$Warnings
#[1] "warning 1" "warning 2"



Function tryCatch.W.E is now part of contributed package simsalapar [5], 
with credits to Marius and Martin given in its documentation.


[1] https://stat.ethz.ch/pipermail/r-help/2010-December/262185.html
[2] https://stat.ethz.ch/pipermail/r-help/2010-December/262626.html
[3] https://stat.ethz.ch/pipermail/r-help/2004-June/052092.html
[4] https://stat.ethz.ch/pipermail/r-help/2004-June/052132.html
[5] https://CRAN.R-project.org/package=simsalapar


Hope this helps,

Rui Barradas



?s 22:37 de 02/12/21, Fox, John escreveu:
> Dear Henrik, Simon, and Adrian,
> 
> As it turns out Adrian's admisc::tryCatchWEM() *almost* does what I want, which is both to capture all messages and the result of the expression (rather than the visible representation of the result). I was easily able to modify tryCatchWEM() to return the result.
> 
> Henrik: I was aware that tryCatch() doesn't return the final result of the expression, and I was previously re-executing the expression to capture the reult, but only getting the first warning message, along with the result.
> 
> Thanks for responding to my question and providing viable solutions,
>   John
> 
> ?On 2021-12-02, 5:19 PM, "Henrik Bengtsson" <henrik.bengtsson at gmail.com> wrote:
> 
>      Simon's suggestion with withCallingHandlers() is the correct way.
>      Also, note that if you use tryCatch() to catch warnings, you're
>      *interrupting* the evaluation of the expression of interest, e.g.
> 
>      > res <- tryCatch({ message("hey"); warning("boom"); message("there"); 42 }, warning = function(w) { message("Warning caught: ", conditionMessage(w)); 3.14 })
>      hey
>      Warning caught: boom
>      > res
>      [1] 3.14
> 
>      Note how it never completes your expression.
> 
>      /Henrik
> 
>      On Thu, Dec 2, 2021 at 1:14 PM Simon Urbanek
>      <simon.urbanek at r-project.org> wrote:
>      >
>      >
>      > Adapted from demo(error.catching):
>      >
>      > > W=list()
>      > > withCallingHandlers(foo(), warning=function(w) { W <<- c(W, list(w)); invokeRestart("muffleWarning") })
>      > > str(W)
>      > List of 2
>      >  $ :List of 2
>      >   ..$ message: chr "warning 1"
>      >   ..$ call   : language foo()
>      >   ..- attr(*, "class")= chr [1:3] "simpleWarning" "warning" "condition"
>      >  $ :List of 2
>      >   ..$ message: chr "warning 2"
>      >   ..$ call   : language foo()
>      >   ..- attr(*, "class")= chr [1:3] "simpleWarning" "warning" "condition"
>      >
>      > Cheers,
>      > Simon
>      >
>      >
>      > > On Dec 3, 2021, at 10:02 AM, Fox, John <jfox at mcmaster.ca> wrote:
>      > >
>      > > Dear R-devel list members,
>      > >
>      > > Is it possible to capture more than one warning message using tryCatch()? The answer may be in ?conditions, but, if it is, I can't locate it.
>      > >
>      > > For example, in the following only the first warning message is captured and reported:
>      > >
>      > >> foo <- function(){
>      > > +   warning("warning 1")
>      > > +   warning("warning 2")
>      > > + }
>      > >
>      > >> foo()
>      > > Warning messages:
>      > > 1: In foo() : warning 1
>      > > 2: In foo() : warning 2
>      > >
>      > >> bar <- function(){
>      > > +   tryCatch(foo(), warning=function(w) print(w))
>      > > + }
>      > >
>      > >> bar()
>      > > <simpleWarning in foo(): warning 1>
>      > >
>      > > Is there a way to capture "warning 2" as well?
>      > >
>      > > Any help would be appreciated.
>      > >
>      > > John
>      > >
>      > > --
>      > > John Fox, Professor Emeritus
>      > > McMaster University
>      > > Hamilton, Ontario, Canada
>      > > Web: http://socserv.mcmaster.ca/jfox/
>      > >
>      > >
>      > >
>      > > ______________________________________________
>      > > R-devel at r-project.org mailing list
>      > > https://stat.ethz.ch/mailman/listinfo/r-devel
>      > >
>      >
>      > ______________________________________________
>      > R-devel at r-project.org mailing list
>      > https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


From du@@@@dr|@n @end|ng |rom gm@||@com  Fri Dec  3 19:55:53 2021
From: du@@@@dr|@n @end|ng |rom gm@||@com (=?UTF-8?B?QWRyaWFuIER1yJlh?=)
Date: Fri, 3 Dec 2021 20:55:53 +0200
Subject: [Rd] capturing multiple warnings in tryCatch()
In-Reply-To: <8B6460C6-78A9-414E-8353-A817CD7A5292@mcmaster.ca>
References: <E3B708C1-8E1D-41A0-842A-9C05D229B3DB@mcmaster.ca>
 <516D77A0-7503-4695-A45F-1162ED816FCF@R-project.org>
 <CAFDcVCQuFVXJFn812gbLcDcY=gBeKwwXm8AQsW5Pm+wqpTzRoQ@mail.gmail.com>
 <8B6460C6-78A9-414E-8353-A817CD7A5292@mcmaster.ca>
Message-ID: <CAJ=0CtAVpv6QKAZwWxEB3fsjUD8PA6+-nBYnok=Kffa_SfNF3Q@mail.gmail.com>

On Fri, 3 Dec 2021 at 00:37, Fox, John <jfox at mcmaster.ca> wrote:

> Dear Henrik, Simon, and Adrian,
>
> As it turns out Adrian's admisc::tryCatchWEM() *almost* does what I want,
> which is both to capture all messages and the result of the expression
> (rather than the visible representation of the result). I was easily able
> to modify tryCatchWEM() to return the result.
>

Glad it helps.
I would be happy to improve the function, should you send a reprex with the
desired final result.

Best wishes,
Adrian

	[[alternative HTML version deleted]]


From j|ox @end|ng |rom mcm@@ter@c@  Fri Dec  3 20:27:48 2021
From: j|ox @end|ng |rom mcm@@ter@c@ (Fox, John)
Date: Fri, 3 Dec 2021 19:27:48 +0000
Subject: [Rd] capturing multiple warnings in tryCatch()
In-Reply-To: <c31cc520-d4dc-a8c4-ac94-40323e63c8cb@sapo.pt>
References: <E3B708C1-8E1D-41A0-842A-9C05D229B3DB@mcmaster.ca>
 <516D77A0-7503-4695-A45F-1162ED816FCF@R-project.org>
 <CAFDcVCQuFVXJFn812gbLcDcY=gBeKwwXm8AQsW5Pm+wqpTzRoQ@mail.gmail.com>
 <8B6460C6-78A9-414E-8353-A817CD7A5292@mcmaster.ca>
 <c31cc520-d4dc-a8c4-ac94-40323e63c8cb@sapo.pt>
Message-ID: <97C656F9-F4BF-4EC1-8874-74E2B69B5E90@mcmaster.ca>

Dear Rui,

Thanks for this. Simon referred to demo(error.catching), and Adrian's version returns the printed representation of the result along with messages.

Best,
 John

?On 2021-12-03, 11:35 AM, "Rui Barradas" <ruipbarradas at sapo.pt> wrote:

    Hello,

    I remembered having seen a function tryCatch.W.E and after an online 
    search, found where.
    It was in a R-Help post and in demo(error.catching). The question by 
    Marius Hofert [1] was answered, among others, by Martin Maechler [2] 
    which included the function tryCatch.W.E.

    These posts refer to an old thread dated 2004 [3], with an answer by 
    Luke Tierney [4]. The function withWarnings posted by Luke returns all 
    warning messages in a list, as seen below.
    I repost the function to have this self contained.



    withWarnings <- function (expr) {
       warnings <- character()
       retval <- withCallingHandlers(expr, warning = function(ex) {
         warnings <<- c(warnings, conditionMessage(ex))
         invokeRestart("muffleWarning")
       })
       list(Value = retval, Warnings = warnings)
    }
    withWarnings(foo())
    #$Value
    #[1] "warning 2"
    #
    #$Warnings
    #[1] "warning 1" "warning 2"



    Function tryCatch.W.E is now part of contributed package simsalapar [5], 
    with credits to Marius and Martin given in its documentation.


    [1] https://stat.ethz.ch/pipermail/r-help/2010-December/262185.html
    [2] https://stat.ethz.ch/pipermail/r-help/2010-December/262626.html
    [3] https://stat.ethz.ch/pipermail/r-help/2004-June/052092.html
    [4] https://stat.ethz.ch/pipermail/r-help/2004-June/052132.html
    [5] https://CRAN.R-project.org/package=simsalapar


    Hope this helps,

    Rui Barradas



    ?s 22:37 de 02/12/21, Fox, John escreveu:
    > Dear Henrik, Simon, and Adrian,
    > 
    > As it turns out Adrian's admisc::tryCatchWEM() *almost* does what I want, which is both to capture all messages and the result of the expression (rather than the visible representation of the result). I was easily able to modify tryCatchWEM() to return the result.
    > 
    > Henrik: I was aware that tryCatch() doesn't return the final result of the expression, and I was previously re-executing the expression to capture the reult, but only getting the first warning message, along with the result.
    > 
    > Thanks for responding to my question and providing viable solutions,
    >   John
    > 
    > On 2021-12-02, 5:19 PM, "Henrik Bengtsson" <henrik.bengtsson at gmail.com> wrote:
    > 
    >      Simon's suggestion with withCallingHandlers() is the correct way.
    >      Also, note that if you use tryCatch() to catch warnings, you're
    >      *interrupting* the evaluation of the expression of interest, e.g.
    > 
    >      > res <- tryCatch({ message("hey"); warning("boom"); message("there"); 42 }, warning = function(w) { message("Warning caught: ", conditionMessage(w)); 3.14 })
    >      hey
    >      Warning caught: boom
    >      > res
    >      [1] 3.14
    > 
    >      Note how it never completes your expression.
    > 
    >      /Henrik
    > 
    >      On Thu, Dec 2, 2021 at 1:14 PM Simon Urbanek
    >      <simon.urbanek at r-project.org> wrote:
    >      >
    >      >
    >      > Adapted from demo(error.catching):
    >      >
    >      > > W=list()
    >      > > withCallingHandlers(foo(), warning=function(w) { W <<- c(W, list(w)); invokeRestart("muffleWarning") })
    >      > > str(W)
    >      > List of 2
    >      >  $ :List of 2
    >      >   ..$ message: chr "warning 1"
    >      >   ..$ call   : language foo()
    >      >   ..- attr(*, "class")= chr [1:3] "simpleWarning" "warning" "condition"
    >      >  $ :List of 2
    >      >   ..$ message: chr "warning 2"
    >      >   ..$ call   : language foo()
    >      >   ..- attr(*, "class")= chr [1:3] "simpleWarning" "warning" "condition"
    >      >
    >      > Cheers,
    >      > Simon
    >      >
    >      >
    >      > > On Dec 3, 2021, at 10:02 AM, Fox, John <jfox at mcmaster.ca> wrote:
    >      > >
    >      > > Dear R-devel list members,
    >      > >
    >      > > Is it possible to capture more than one warning message using tryCatch()? The answer may be in ?conditions, but, if it is, I can't locate it.
    >      > >
    >      > > For example, in the following only the first warning message is captured and reported:
    >      > >
    >      > >> foo <- function(){
    >      > > +   warning("warning 1")
    >      > > +   warning("warning 2")
    >      > > + }
    >      > >
    >      > >> foo()
    >      > > Warning messages:
    >      > > 1: In foo() : warning 1
    >      > > 2: In foo() : warning 2
    >      > >
    >      > >> bar <- function(){
    >      > > +   tryCatch(foo(), warning=function(w) print(w))
    >      > > + }
    >      > >
    >      > >> bar()
    >      > > <simpleWarning in foo(): warning 1>
    >      > >
    >      > > Is there a way to capture "warning 2" as well?
    >      > >
    >      > > Any help would be appreciated.
    >      > >
    >      > > John
    >      > >
    >      > > --
    >      > > John Fox, Professor Emeritus
    >      > > McMaster University
    >      > > Hamilton, Ontario, Canada
    >      > > Web: http://socserv.mcmaster.ca/jfox/
    >      > >
    >      > >
    >      > >
    >      > > ______________________________________________
    >      > > R-devel at r-project.org mailing list
    >      > > https://stat.ethz.ch/mailman/listinfo/r-devel
    >      > >
    >      >
    >      > ______________________________________________
    >      > R-devel at r-project.org mailing list
    >      > https://stat.ethz.ch/mailman/listinfo/r-devel
    > 
    > ______________________________________________
    > R-devel at r-project.org mailing list
    > https://stat.ethz.ch/mailman/listinfo/r-devel
    > 


From j|ox @end|ng |rom mcm@@ter@c@  Fri Dec  3 20:42:34 2021
From: j|ox @end|ng |rom mcm@@ter@c@ (Fox, John)
Date: Fri, 3 Dec 2021 19:42:34 +0000
Subject: [Rd] capturing multiple warnings in tryCatch()
In-Reply-To: <20482_1638557779_1B3IuJTH009857_CAJ=0CtAVpv6QKAZwWxEB3fsjUD8PA6+-nBYnok=Kffa_SfNF3Q@mail.gmail.com>
References: <E3B708C1-8E1D-41A0-842A-9C05D229B3DB@mcmaster.ca>
 <516D77A0-7503-4695-A45F-1162ED816FCF@R-project.org>
 <CAFDcVCQuFVXJFn812gbLcDcY=gBeKwwXm8AQsW5Pm+wqpTzRoQ@mail.gmail.com>
 <8B6460C6-78A9-414E-8353-A817CD7A5292@mcmaster.ca>
 <20482_1638557779_1B3IuJTH009857_CAJ=0CtAVpv6QKAZwWxEB3fsjUD8PA6+-nBYnok=Kffa_SfNF3Q@mail.gmail.com>
Message-ID: <D3316D5B-283C-4FE0-ADF5-07C7F821872A@mcmaster.ca>

Dear Adrian,

Here's my slightly modified version of your function, which serves my purpose:

------- snip -------

tryCatchWEM <- function (expr, capture = TRUE) {
    toreturn <- list()
    output <- withVisible(withCallingHandlers(
        tryCatch(expr, 
                 error = function(e) {
                     toreturn$error <<- e$message
                     NULL
                 }), warning = function(w) {
                     toreturn$warning <<- c(toreturn$warning, w$message)
                     invokeRestart("muffleWarning")
                 }, message = function(m) {
                     toreturn$message <<- paste(toreturn$message, m$message, 
                                                sep = "")
                     invokeRestart("muffleMessage")
                 }))
    if (capture & output$visible) {
        if (!is.null(output$value)) {
            toreturn$result <- output$value
        }
    }
    if (length(toreturn) > 0) {
        return(toreturn)
    }
}

------- snip -------

The two small modifications are to change the default of capture to TRUE and to return output$value rather than capture.output(output$value). So a suggestion would be to modify the capture argument to, say, capture=c("no", "output", "value") and then something like

	. . .
	capture <- match.arg(capture)
	. . .
	if (capture == "output"){
      	toreturn$output <- capture.output(output$value)
	} else if (capture == "value"){
		toreturn$value <- output$value
	}
	. . .

Best,
 John

?On 2021-12-03, 1:56 PM, "R-devel on behalf of Adrian Du?a" <r-devel-bounces at r-project.org on behalf of dusa.adrian at gmail.com> wrote:

    On Fri, 3 Dec 2021 at 00:37, Fox, John <jfox at mcmaster.ca> wrote:

    > Dear Henrik, Simon, and Adrian,
    >
    > As it turns out Adrian's admisc::tryCatchWEM() *almost* does what I want,
    > which is both to capture all messages and the result of the expression
    > (rather than the visible representation of the result). I was easily able
    > to modify tryCatchWEM() to return the result.
    >

    Glad it helps.
    I would be happy to improve the function, should you send a reprex with the
    desired final result.

    Best wishes,
    Adrian

    	[[alternative HTML version deleted]]

    ______________________________________________
    R-devel at r-project.org mailing list
    https://stat.ethz.ch/mailman/listinfo/r-devel


From du@@@@dr|@n @end|ng |rom gm@||@com  Sat Dec  4 00:26:44 2021
From: du@@@@dr|@n @end|ng |rom gm@||@com (=?UTF-8?B?QWRyaWFuIER1yJlh?=)
Date: Sat, 4 Dec 2021 01:26:44 +0200
Subject: [Rd] capturing multiple warnings in tryCatch()
In-Reply-To: <D3316D5B-283C-4FE0-ADF5-07C7F821872A@mcmaster.ca>
References: <E3B708C1-8E1D-41A0-842A-9C05D229B3DB@mcmaster.ca>
 <516D77A0-7503-4695-A45F-1162ED816FCF@R-project.org>
 <CAFDcVCQuFVXJFn812gbLcDcY=gBeKwwXm8AQsW5Pm+wqpTzRoQ@mail.gmail.com>
 <8B6460C6-78A9-414E-8353-A817CD7A5292@mcmaster.ca>
 <20482_1638557779_1B3IuJTH009857_CAJ=0CtAVpv6QKAZwWxEB3fsjUD8PA6+-nBYnok=Kffa_SfNF3Q@mail.gmail.com>
 <D3316D5B-283C-4FE0-ADF5-07C7F821872A@mcmaster.ca>
Message-ID: <CAJ=0CtC6ZOpbxTBKhgWmovQ9L1f4LKir-z92ru-XtrxgFV5X2Q@mail.gmail.com>

Dear John,

The logical argument capture is already in production use by other
packages, but I think this is easily solved by:

if (!is.null(output$value) & output$visible) {
    if (capture) {
        toreturn$output <- capture.output(output$value)
    }
    toreturn$value <- output$value
}

so that value is always part of the return list, if visible.

This is a very good suggestion, and I've already incorporated it into this
function.

All the best,
Adrian

On Fri, 3 Dec 2021 at 21:42, Fox, John <jfox at mcmaster.ca> wrote:

> Dear Adrian,
>
> Here's my slightly modified version of your function, which serves my
> purpose:
>
> ------- snip -------
>
> tryCatchWEM <- function (expr, capture = TRUE) {
>     toreturn <- list()
>     output <- withVisible(withCallingHandlers(
>         tryCatch(expr,
>                  error = function(e) {
>                      toreturn$error <<- e$message
>                      NULL
>                  }), warning = function(w) {
>                      toreturn$warning <<- c(toreturn$warning, w$message)
>                      invokeRestart("muffleWarning")
>                  }, message = function(m) {
>                      toreturn$message <<- paste(toreturn$message,
> m$message,
>                                                 sep = "")
>                      invokeRestart("muffleMessage")
>                  }))
>     if (capture & output$visible) {
>         if (!is.null(output$value)) {
>             toreturn$result <- output$value
>         }
>     }
>     if (length(toreturn) > 0) {
>         return(toreturn)
>     }
> }
>
> ------- snip -------
>
> The two small modifications are to change the default of capture to TRUE
> and to return output$value rather than capture.output(output$value). So a
> suggestion would be to modify the capture argument to, say, capture=c("no",
> "output", "value") and then something like
>
>         . . .
>         capture <- match.arg(capture)
>         . . .
>         if (capture == "output"){
>         toreturn$output <- capture.output(output$value)
>         } else if (capture == "value"){
>                 toreturn$value <- output$value
>         }
>         . . .
>
> Best,
>  John
>
> ?On 2021-12-03, 1:56 PM, "R-devel on behalf of Adrian Du?a" <
> r-devel-bounces at r-project.org on behalf of dusa.adrian at gmail.com> wrote:
>
>     On Fri, 3 Dec 2021 at 00:37, Fox, John <jfox at mcmaster.ca> wrote:
>
>     > Dear Henrik, Simon, and Adrian,
>     >
>     > As it turns out Adrian's admisc::tryCatchWEM() *almost* does what I
> want,
>     > which is both to capture all messages and the result of the
> expression
>     > (rather than the visible representation of the result). I was easily
> able
>     > to modify tryCatchWEM() to return the result.
>     >
>
>     Glad it helps.
>     I would be happy to improve the function, should you send a reprex
> with the
>     desired final result.
>
>     Best wishes,
>     Adrian
>
>         [[alternative HTML version deleted]]
>
>     ______________________________________________
>     R-devel at r-project.org mailing list
>     https://stat.ethz.ch/mailman/listinfo/r-devel
>
>

	[[alternative HTML version deleted]]


From j|ox @end|ng |rom mcm@@ter@c@  Sat Dec  4 02:40:39 2021
From: j|ox @end|ng |rom mcm@@ter@c@ (Fox, John)
Date: Sat, 4 Dec 2021 01:40:39 +0000
Subject: [Rd] capturing multiple warnings in tryCatch()
In-Reply-To: <8582_1638574041_1B3NRK7r032693_CAJ=0CtC6ZOpbxTBKhgWmovQ9L1f4LKir-z92ru-XtrxgFV5X2Q@mail.gmail.com>
References: <E3B708C1-8E1D-41A0-842A-9C05D229B3DB@mcmaster.ca>
 <516D77A0-7503-4695-A45F-1162ED816FCF@R-project.org>
 <CAFDcVCQuFVXJFn812gbLcDcY=gBeKwwXm8AQsW5Pm+wqpTzRoQ@mail.gmail.com>
 <8B6460C6-78A9-414E-8353-A817CD7A5292@mcmaster.ca>
 <20482_1638557779_1B3IuJTH009857_CAJ=0CtAVpv6QKAZwWxEB3fsjUD8PA6+-nBYnok=Kffa_SfNF3Q@mail.gmail.com>
 <D3316D5B-283C-4FE0-ADF5-07C7F821872A@mcmaster.ca>
 <8582_1638574041_1B3NRK7r032693_CAJ=0CtC6ZOpbxTBKhgWmovQ9L1f4LKir-z92ru-XtrxgFV5X2Q@mail.gmail.com>
Message-ID: <4E0E55D8-250E-4781-BA8C-FBCEEFAD59BA@mcmaster.ca>

Dear Adrian,

For consistency, you might want to put toreturn$value <- output$value inside of if (capture) {}. In any event, it makes sense for me to wait for the modified admisc::tryCatchWEM to find its way to CRAN rather than to maintain my own version of the function.

Thanks for this,
 John

?On 2021-12-03, 6:27 PM, "R-devel on behalf of Adrian Du?a" <r-devel-bounces at r-project.org on behalf of dusa.adrian at gmail.com> wrote:

    Dear John,

    The logical argument capture is already in production use by other
    packages, but I think this is easily solved by:

    if (!is.null(output$value) & output$visible) {
        if (capture) {
            toreturn$output <- capture.output(output$value)
        }
        toreturn$value <- output$value
    }

    so that value is always part of the return list, if visible.

    This is a very good suggestion, and I've already incorporated it into this
    function.

    All the best,
    Adrian

    On Fri, 3 Dec 2021 at 21:42, Fox, John <jfox at mcmaster.ca> wrote:

    > Dear Adrian,
    >
    > Here's my slightly modified version of your function, which serves my
    > purpose:
    >
    > ------- snip -------
    >
    > tryCatchWEM <- function (expr, capture = TRUE) {
    >     toreturn <- list()
    >     output <- withVisible(withCallingHandlers(
    >         tryCatch(expr,
    >                  error = function(e) {
    >                      toreturn$error <<- e$message
    >                      NULL
    >                  }), warning = function(w) {
    >                      toreturn$warning <<- c(toreturn$warning, w$message)
    >                      invokeRestart("muffleWarning")
    >                  }, message = function(m) {
    >                      toreturn$message <<- paste(toreturn$message,
    > m$message,
    >                                                 sep = "")
    >                      invokeRestart("muffleMessage")
    >                  }))
    >     if (capture & output$visible) {
    >         if (!is.null(output$value)) {
    >             toreturn$result <- output$value
    >         }
    >     }
    >     if (length(toreturn) > 0) {
    >         return(toreturn)
    >     }
    > }
    >
    > ------- snip -------
    >
    > The two small modifications are to change the default of capture to TRUE
    > and to return output$value rather than capture.output(output$value). So a
    > suggestion would be to modify the capture argument to, say, capture=c("no",
    > "output", "value") and then something like
    >
    >         . . .
    >         capture <- match.arg(capture)
    >         . . .
    >         if (capture == "output"){
    >         toreturn$output <- capture.output(output$value)
    >         } else if (capture == "value"){
    >                 toreturn$value <- output$value
    >         }
    >         . . .
    >
    > Best,
    >  John
    >
    > On 2021-12-03, 1:56 PM, "R-devel on behalf of Adrian Du?a" <
    > r-devel-bounces at r-project.org on behalf of dusa.adrian at gmail.com> wrote:
    >
    >     On Fri, 3 Dec 2021 at 00:37, Fox, John <jfox at mcmaster.ca> wrote:
    >
    >     > Dear Henrik, Simon, and Adrian,
    >     >
    >     > As it turns out Adrian's admisc::tryCatchWEM() *almost* does what I
    > want,
    >     > which is both to capture all messages and the result of the
    > expression
    >     > (rather than the visible representation of the result). I was easily
    > able
    >     > to modify tryCatchWEM() to return the result.
    >     >
    >
    >     Glad it helps.
    >     I would be happy to improve the function, should you send a reprex
    > with the
    >     desired final result.
    >
    >     Best wishes,
    >     Adrian
    >
    >         [[alternative HTML version deleted]]
    >
    >     ______________________________________________
    >     R-devel at r-project.org mailing list
    >     https://stat.ethz.ch/mailman/listinfo/r-devel
    >
    >

    	[[alternative HTML version deleted]]

    ______________________________________________
    R-devel at r-project.org mailing list
    https://stat.ethz.ch/mailman/listinfo/r-devel


From gr@ntmcd @end|ng |rom uoregon@edu  Sat Dec  4 23:36:44 2021
From: gr@ntmcd @end|ng |rom uoregon@edu (Grant McDermott)
Date: Sat, 4 Dec 2021 22:36:44 +0000
Subject: [Rd] string concatenation operator (revisited)
Message-ID: <MWHPR1001MB2384CD0939331AF4B4DE9C41CF6B9@MWHPR1001MB2384.namprd10.prod.outlook.com>

Hi all,

I wonder if the R Core team might reconsider an old feature request, as detailed in this 2005 thread: https://stat.ethz.ch/pipermail/r-help/2005-February/thread.html#66698

The TL;DR version is base R support for a `+.character` method. This would essentially provide a shortcut to `paste?0`, in much the same way that `\(x)` now provides a shortcut to `function(x)`.

> a = "hello "; b = "world"
> a + b
> [1] "hello world"

I appreciate some of the original concerns raised against a native "string1 + string2" implementation. The above thread also provides several use-at-your-own-risk workarounds. But sixteen years is a long time in software development and R now stands as something of an exception on this score. Python, Julia, Stata, and SQL (among various others) all support native string concatenation/interpolation using binary/arithmetic operators. It's been a surprising source of frustration for students in some of the classes I teach, particularly those coming from another language.

Many thanks for considering.

PS. I hope I didn't miss any additional discussion of this issue beyond the original 2005 thread. My search efforts didn't turn anything else up, except this popular Stackoverflow question: https://stackoverflow.com/questions/4730551/making-a-string-concatenation-operator-in-r

Grant McDermott
Assistant Professor
Department of Economics
University of Oregon
www.grantmcdermott.com


	[[alternative HTML version deleted]]


From @v|gro@@ @end|ng |rom ver|zon@net  Sun Dec  5 03:26:05 2021
From: @v|gro@@ @end|ng |rom ver|zon@net (Avi Gross)
Date: Sat, 4 Dec 2021 21:26:05 -0500
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <MWHPR1001MB2384CD0939331AF4B4DE9C41CF6B9@MWHPR1001MB2384.namprd10.prod.outlook.com>
References: <MWHPR1001MB2384CD0939331AF4B4DE9C41CF6B9@MWHPR1001MB2384.namprd10.prod.outlook.com>
Message-ID: <00df01d7e97f$74cc8d80$5e65a880$@verizon.net>

Grant,

One nit to consider is that the default behavior of pasteo() to include a space as a separator would not be a perfect choice for the usual meaning of plus. 

I would prefer a+b to be "helloworld" in your example and to get what you say would be 

a + " " + b

Which I assume would put in a space where you want it and not where you don't.

As I am sure you have been told, you already can make an operator like this:

`%+%` <- function(x, y) paste0(x, y)

And then use:

a %+% b

And to do it this way, you might have two such functions where %+% does NOT add a space but the odd version with a space in it, % +% or %++% does add a space!

`%+%` <- function(x, y) paste0(x, y, sep="")
`%++%` <- function(x, y) paste0(x, " ",  y)
`% +%` <- function(x, y) paste0(x, " ",  y)

Now testing it with:

a = "hello"; b = "world" # NOTE I removed the trailing space you had in "a".

> a %+% b
[1] "helloworld"
> a %++% b
[1] "hello world"
> a % +% b
[1] "hello world"

It also seems to work with multiple units mixed in a row as shown below:

> a %+% b % +% a %++% b
[1] "helloworld hello world"

And it sort of works with vectors of strings or numbers using string concatenation:

> a <- letters[1:3]
> b <- seq(from=101, to = 301, by = 100)
> a %+% b %+% a
[1] "a101a" "b201b" "c301c"

But are you asking for a naked "+" sign to be vectorized like that?

And what if someone accidentally types something like:

a = "text"
a = a + 1

The addition now looks like adding an integer to a text string. In many languages, like PERL, this results in implicated conversion to make "text1" the result. My work-around does that:

> a = a %+% 1
> a
[1] "text1"

BUT what you are asking for is for R to do normal addition if a and b are both numeric and presumably do (as languages like Python do) text concatenation when they are both text. What do you suggest happen if one is numeric and the other is text or perhaps some arbitrary data type? 

I checked to see what Python version 3.9 does:

>>> 5 + 4
9
>>> "5" + "4"
'54'
>>> "5" + 4
Traceback (most recent call last):
  File "<pyshell#6>", line 1, in <module>
    "5" + 4
TypeError: can only concatenate str (not "int") to str

It is clear it does not normally support such mixed methods, albeit I can probably easily create an object sub-class where I create a dunder method that perhaps checks if one of the two things being added can be coerced into a string or into a number as needed to convert so the two types match.

But this is about R.

As others have said, the underlying early philosophy of R being created as a language did not head the same way as some other languages and R is mainly not the same kind of object-oriented as some others and thus some things are not trivially done but can be done using other ways like the %+% technique above.

But R also allows weird things like this: 
# VERY CAREFULLY as overwriting "+" means you cannot use it in your other ...
# So not a suggested idea but if done you must preserve the original meaning of plus elsewhere like I do.

flexible_plus <- function(first, second) {
  if (all(is.numeric(first), is.numeric(second))) return(first + second)
  if (all(is.character(first), is.character(second))) return(paste0(first, second))
  # If you reach here, there is an error
  print("ERROR: both arguments must be numeric or both character")
  return(NULL)
}

Now define things carefully to use something like the function flexible_plus I created becoming the MEANING of a naked plus sign.  But note it will now be used in other ways and places in any code that does addition so it is not an ideal solution. It does sort of work, FWIW.

`%+++%` <- `+`
`+` <- flexible_plus

Finally some testing:

> 5 %+++% 3
[1] 8
> flexible_plus(5, 3)
[1] 8
> 5 + 3
[1] 8
> "hello" + "world"
[1] "helloworld"
> "hello" + 5
[1] "ERROR: both arguments must be numeric or both character"
NULL

It does seem to do approximately what I said it would do but also does some vectorized things as well as long as all are the same type:

> c(1,2,3) + 4
[1] 5 6 7
> c(1,2,3) + c(4,5,6)
[1] 5 7 9
> c("word1", "word2", "word3") + "more"
[1] "word1more" "word2more" "word3more"
> c("word1", "word2", "word3") + c("more", "snore")
[1] "word1more"  "word2snore" "word3more"

Again, the above code is for illustration purposes only. I would be beyond shocked if the above did not break something somewhere and it certainly is not as efficient as the built-in adder. As an exercise, it looks reasonable. LOL!


-----Original Message-----
From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Grant McDermott
Sent: Saturday, December 4, 2021 5:37 PM
To: r-devel at r-project.org
Subject: [Rd] string concatenation operator (revisited)

Hi all,

I wonder if the R Core team might reconsider an old feature request, as detailed in this 2005 thread: https://stat.ethz.ch/pipermail/r-help/2005-February/thread.html#66698

The TL;DR version is base R support for a `+.character` method. This would essentially provide a shortcut to `paste?0`, in much the same way that `\(x)` now provides a shortcut to `function(x)`.

> a = "hello "; b = "world"
> a + b
> [1] "hello world"

I appreciate some of the original concerns raised against a native "string1 + string2" implementation. The above thread also provides several use-at-your-own-risk workarounds. But sixteen years is a long time in software development and R now stands as something of an exception on this score. Python, Julia, Stata, and SQL (among various others) all support native string concatenation/interpolation using binary/arithmetic operators. It's been a surprising source of frustration for students in some of the classes I teach, particularly those coming from another language.

Many thanks for considering.

PS. I hope I didn't miss any additional discussion of this issue beyond the original 2005 thread. My search efforts didn't turn anything else up, except this popular Stackoverflow question: https://stackoverflow.com/questions/4730551/making-a-string-concatenation-operator-in-r

Grant McDermott
Assistant Professor
Department of Economics
University of Oregon
www.grantmcdermott.com


	[[alternative HTML version deleted]]

______________________________________________
R-devel at r-project.org mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


From ru|pb@rr@d@@ @end|ng |rom @@po@pt  Sun Dec  5 08:41:05 2021
From: ru|pb@rr@d@@ @end|ng |rom @@po@pt (Rui Barradas)
Date: Sun, 5 Dec 2021 07:41:05 +0000
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <MWHPR1001MB2384CD0939331AF4B4DE9C41CF6B9@MWHPR1001MB2384.namprd10.prod.outlook.com>
References: <MWHPR1001MB2384CD0939331AF4B4DE9C41CF6B9@MWHPR1001MB2384.namprd10.prod.outlook.com>
Message-ID: <5aa24f01-b224-c19c-c3a4-3b96c27f0413@sapo.pt>

Hello,

Bert Gunter started a very recent R-Help thread [1] about the following 
method not working.

`+.character` <- function(x, y) paste0(x, y)


The discussion is worth reading and at least partly answers to the 
reason why the feature request has never made it to base R.

It goes without saying that I do not speak for the R Core team.


[1] https://stat.ethz.ch/pipermail/r-help/2021-December/473163.html


Hope this helps,

Rui Barradas

?s 22:36 de 04/12/21, Grant McDermott escreveu:
> Hi all,
> 
> I wonder if the R Core team might reconsider an old feature request, as detailed in this 2005 thread: https://stat.ethz.ch/pipermail/r-help/2005-February/thread.html#66698
> 
> The TL;DR version is base R support for a `+.character` method. This would essentially provide a shortcut to `paste?0`, in much the same way that `\(x)` now provides a shortcut to `function(x)`.
> 
>> a = "hello "; b = "world"
>> a + b
>> [1] "hello world"
> 
> I appreciate some of the original concerns raised against a native "string1 + string2" implementation. The above thread also provides several use-at-your-own-risk workarounds. But sixteen years is a long time in software development and R now stands as something of an exception on this score. Python, Julia, Stata, and SQL (among various others) all support native string concatenation/interpolation using binary/arithmetic operators. It's been a surprising source of frustration for students in some of the classes I teach, particularly those coming from another language.
> 
> Many thanks for considering.
> 
> PS. I hope I didn't miss any additional discussion of this issue beyond the original 2005 thread. My search efforts didn't turn anything else up, except this popular Stackoverflow question: https://stackoverflow.com/questions/4730551/making-a-string-concatenation-operator-in-r
> 
> Grant McDermott
> Assistant Professor
> Department of Economics
> University of Oregon
> www.grantmcdermott.com
> 
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


From kry|ov@r00t @end|ng |rom gm@||@com  Sun Dec  5 13:22:12 2021
From: kry|ov@r00t @end|ng |rom gm@||@com (Ivan Krylov)
Date: Sun, 5 Dec 2021 15:22:12 +0300
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <00df01d7e97f$74cc8d80$5e65a880$@verizon.net>
References: <MWHPR1001MB2384CD0939331AF4B4DE9C41CF6B9@MWHPR1001MB2384.namprd10.prod.outlook.com>
 <00df01d7e97f$74cc8d80$5e65a880$@verizon.net>
Message-ID: <20211205152212.3b7a6806@Tarkus>

On Sat, 4 Dec 2021 21:26:05 -0500
Avi Gross via R-devel <r-devel at r-project.org> wrote:

> In many languages, like PERL, this results in implicated conversion
> to make "text1" the result.

FWIW, Perl5 has a separate string concatenation operator (".") in order
to avoid potential confusion with addition. So do Lua (".."), SQL
("||", only some of the dialects) and Raku ("~", former Perl6). Some of
the potential concerns with string concatenation as an operator in R
could be alleviated by introducing a separate operator, just like matrix
multiplication ("%*%") is separate from elementwise multiplication
("*"), nowadays even in Python ("@" and "*", respectively).

-- 
Best regards,
Ivan


From Andre@G||||bert @end|ng |rom chu-rouen@|r  Sun Dec  5 14:56:27 2021
From: Andre@G||||bert @end|ng |rom chu-rouen@|r (GILLIBERT, Andre)
Date: Sun, 5 Dec 2021 13:56:27 +0000
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <20211205152212.3b7a6806@Tarkus>
References: <MWHPR1001MB2384CD0939331AF4B4DE9C41CF6B9@MWHPR1001MB2384.namprd10.prod.outlook.com>
 <00df01d7e97f$74cc8d80$5e65a880$@verizon.net>, <20211205152212.3b7a6806@Tarkus>
Message-ID: <a6c3a2ab3af8492b8ef6a2670f833e9f@chu-rouen.fr>

Ivan Krylov <krylov.r00t at gmail.com> wrote:
> FWIW, Perl5 has a separate string concatenation operator (".") in order
> to avoid potential confusion with addition. So do Lua (".."), SQL
> ("||", only some of the dialects) and Raku ("~", former Perl6).


Indeed, using the same operator '+' for addition and string concatenation is not a great idea in my opinion.
Accidental character arguments to a '+' that meant to be a numerical addition would go undetected. Bug tracking would be harder in that case.

R is already too permissive: it finds some interpretation of most probably buggy code, such as ifelse() on vectors of unequal length or '[' operator with only one argument to index a matrix. I would not want to add new permissive behaviors.

A new operator, dedicated to string concatenation, such as %+% or %.%, would be better, in my opinion.

--
Sincerely
Andr? GILLIBERT

	[[alternative HTML version deleted]]


From murdoch@dunc@n @end|ng |rom gm@||@com  Sun Dec  5 17:50:23 2021
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Sun, 5 Dec 2021 11:50:23 -0500
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <20211205152212.3b7a6806@Tarkus>
References: <MWHPR1001MB2384CD0939331AF4B4DE9C41CF6B9@MWHPR1001MB2384.namprd10.prod.outlook.com>
 <00df01d7e97f$74cc8d80$5e65a880$@verizon.net>
 <20211205152212.3b7a6806@Tarkus>
Message-ID: <a499c740-940d-7ef0-b80c-70b968983a65@gmail.com>

On 05/12/2021 7:22 a.m., Ivan Krylov wrote:
> On Sat, 4 Dec 2021 21:26:05 -0500
> Avi Gross via R-devel <r-devel at r-project.org> wrote:
> 
>> In many languages, like PERL, this results in implicated conversion
>> to make "text1" the result.
> 
> FWIW, Perl5 has a separate string concatenation operator (".") in order
> to avoid potential confusion with addition. So do Lua (".."), SQL
> ("||", only some of the dialects) and Raku ("~", former Perl6). Some of
> the potential concerns with string concatenation as an operator in R
> could be alleviated by introducing a separate operator, just like matrix
> multiplication ("%*%") is separate from elementwise multiplication
> ("*"), nowadays even in Python ("@" and "*", respectively).
> 

People seem to handle the automatic conversion of comparison operators. 
  Occasionally someone is surprised that

   123 < "5"

is TRUE, but mostly people muddle along.

One possible issue is that for some things (e.g. S3 Arith group 
generic), "+" is grouped with the other arithmetic operators, "-", "*", 
"^", "%%", "%/%", "/".  I don't think it would make sense for any of 
them to work on strings.  But there are exceptions listed for number of 
arguments among the Math group, so an exception in the Arith group 
wouldn't be the end of the world.

Duncan Murdoch


From r@d|ord @end|ng |rom c@@toronto@edu  Mon Dec  6 07:14:02 2021
From: r@d|ord @end|ng |rom c@@toronto@edu (Radford Neal)
Date: Mon, 6 Dec 2021 01:14:02 -0500
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
Message-ID: <20211206061402.GA3810@mail.cs.toronto.edu>

> The TL;DR version is base R support for a `+.character` method. This
> would essentially provide a shortcut to `paste0`...

In pqR (see pqR-project.org), I have implemented ! and !! as binary
string concatenation operators, equivalent to paste0 and paste,
respectively.  

For instance,

    > "hello" ! "world"
    [1] "helloworld"
    > "hello" !! "world"
    [1] "hello world"
    > "hello" !! 1:4
    [1] "hello 1" "hello 2" "hello 3" "hello 4"
    
This seems preferable to overloading the + operator, which would lead
to people reading code wondering whether a+b is doing an addition or a
string concatenation.  There are very few circumstances in which one
would want to write code where a+b might be either of these.  So it's
better to make clear what is going on by having a different operator
for string concatenation.  

Plus ! and !! semm natural for representing paste0 and paste, whereas
using ++ for paste (with + for paste0) would look rather strange.

   Radford Neal


From murdoch@dunc@n @end|ng |rom gm@||@com  Mon Dec  6 11:06:42 2021
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Mon, 6 Dec 2021 05:06:42 -0500
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <20211206061402.GA3810@mail.cs.toronto.edu>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
Message-ID: <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>

On 06/12/2021 1:14 a.m., Radford Neal wrote:
>> The TL;DR version is base R support for a `+.character` method. This
>> would essentially provide a shortcut to `paste0`...
> 
> In pqR (see pqR-project.org), I have implemented ! and !! as binary
> string concatenation operators, equivalent to paste0 and paste,
> respectively.
> 
> For instance,
> 
>      > "hello" ! "world"
>      [1] "helloworld"
>      > "hello" !! "world"
>      [1] "hello world"
>      > "hello" !! 1:4
>      [1] "hello 1" "hello 2" "hello 3" "hello 4"

I'm curious about the details:

Would `1 ! 2` convert both to strings?

Where does the binary ! fit in the operator priority?  E.g. how is

   a ! b > c

parsed?

Duncan Murdoch


>      
> This seems preferable to overloading the + operator, which would lead
> to people reading code wondering whether a+b is doing an addition or a
> string concatenation.  There are very few circumstances in which one
> would want to write code where a+b might be either of these.  So it's
> better to make clear what is going on by having a different operator
> for string concatenation.
> 
> Plus ! and !! semm natural for representing paste0 and paste, whereas
> using ++ for paste (with + for paste0) would look rather strange.
> 
>     Radford Neal
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


From th|erry@onke||nx @end|ng |rom |nbo@be  Mon Dec  6 13:02:45 2021
From: th|erry@onke||nx @end|ng |rom |nbo@be (Thierry Onkelinx)
Date: Mon, 6 Dec 2021 13:02:45 +0100
Subject: [Rd] install.packages() and Additional_repositories
Message-ID: <CAJuCY5zvTbKbMX3T8Rwu3tkDcOGv1z=hHo5rYN78SQkUeuEppA@mail.gmail.com>

Dear R core team,

Writing R extensions mentions an optional 'Additional_repositories' field
in the DESCRIPTION. (
https://cran.r-project.org/doc/manuals/R-exts.html#Package-Dependencies).
Currently, install.packages() does not use that information when installing
a package. Would you accept a patch to amend this?

If so, should install.packages() use the `Additional_repositories` when
listed? Or should that be based on an extra argument? E.g. additional_repos
= FALSE (default).

Best regards,

Thierry

ir. Thierry Onkelinx
Statisticus / Statistician

Vlaamse Overheid / Government of Flanders
INSTITUUT VOOR NATUUR- EN BOSONDERZOEK / RESEARCH INSTITUTE FOR NATURE AND
FOREST
Team Biometrie & Kwaliteitszorg / Team Biometrics & Quality Assurance
thierry.onkelinx at inbo.be
Havenlaan 88 bus 73, 1000 Brussel
www.inbo.be

///////////////////////////////////////////////////////////////////////////////////////////
To call in the statistician after the experiment is done may be no more
than asking him to perform a post-mortem examination: he may be able to say
what the experiment died of. ~ Sir Ronald Aylmer Fisher
The plural of anecdote is not data. ~ Roger Brinner
The combination of some data and an aching desire for an answer does not
ensure that a reasonable answer can be extracted from a given body of data.
~ John Tukey
///////////////////////////////////////////////////////////////////////////////////////////

<https://www.inbo.be>

	[[alternative HTML version deleted]]


From @zwj|08 @end|ng |rom gm@||@com  Mon Dec  6 18:23:26 2021
From: @zwj|08 @end|ng |rom gm@||@com (Jiefei Wang)
Date: Mon, 6 Dec 2021 12:23:26 -0500
Subject: [Rd] Great overhead for setTimeLimit?
Message-ID: <CAGiFhPNCBG_iieiNmo6+4a0cMnO-0Arfkj2zuUDO=+2MdZONow@mail.gmail.com>

Hi all,

>From the document of 'setTimeLimit', it states "Setting any limit has
a small overhead ? well under 1% on the systems measured.", but
something is wrong with my benchmark code, enabling the time limit
makes my benchmark 1x slower than the benchmark without the limit.
Below is an example

```
benchFunc <- function(x, data) {
    value <- 0
    for(i in 1:5000){
        for(j in seq_along(data))
            value <- value + data[j]
    }
    value
}
data <- sample(1:10, 10)

setTimeLimit(Inf, Inf, FALSE)
system.time(lapply(1:5000, benchFunc, data = data))

setTimeLimit(999, 999, FALSE)
system.time(lapply(1:5000, benchFunc, data = data))
```

Here are the test results

> setTimeLimit(Inf, Inf, FALSE)
> system.time(lapply(1:5000, benchFunc, data = data))
   user  system elapsed
 10.809   0.006  10.812
> setTimeLimit(999, 999, FALSE)
> system.time(lapply(1:5000, benchFunc, data = data))
   user  system elapsed
 13.634   6.478  20.106


As a side note, it looks like the GC consumes the most CPU time. The
GC costs 10 secs without the time limit, but 19 secs with the limit.
Any thoughts?

Best,
Jiefei


From r@d|ord @end|ng |rom c@@toronto@edu  Mon Dec  6 19:03:02 2021
From: r@d|ord @end|ng |rom c@@toronto@edu (Radford Neal)
Date: Mon, 6 Dec 2021 13:03:02 -0500
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
Message-ID: <20211206180302.GA6850@mail.cs.toronto.edu>

> > In pqR (see pqR-project.org), I have implemented ! and !! as binary
> > string concatenation operators, equivalent to paste0 and paste,
> > respectively.
> > 
> > For instance,
> > 
> >      > "hello" ! "world"
> >      [1] "helloworld"
> >      > "hello" !! "world"
> >      [1] "hello world"
> >      > "hello" !! 1:4
> >      [1] "hello 1" "hello 2" "hello 3" "hello 4"
> 
> I'm curious about the details:
> 
> Would `1 ! 2` convert both to strings?

They're equivalent to paste0 and paste, so 1 ! 2 produces "12", just
like paste0(1,2) does.  Of course, they wouldn't have to be exactly
equivalent to paste0 and paste - one could impose stricter
requirements if that seemed better for error detection.  Off hand,
though, I think automatically converting is more in keeping with the
rest of R.  Explicitly converting with as.character could be tedious.

I suppose disallowing logical arguments might make sense to guard
against typos where ! was meant to be the unary-not operator, but
ended up being a binary operator, after some sort of typo.  I doubt
that this would be a common error, though.

(Note that there's no ambiguity when there are no typos, except that
when negation is involved a space may be needed - so, for example, 
"x" !  !TRUE is "xFALSE", but "x"!!TRUE is "x TRUE".  Existing uses of
double negation are still fine - eg, a <- !!TRUE still sets a to TRUE.
Parsing of operators is greedy, so "x"!!!TRUE is "x FALSE", not "xTRUE".)

> Where does the binary ! fit in the operator priority?  E.g. how is
> 
>   a ! b > c
> 
> parsed?

As (a ! b) > c.

Their precedence is between that of + and - and that of < and >.
So "x" ! 1+2 evalates to "x3" and "x" ! 1+2 < "x4" is TRUE.  

(Actually, pqR also has a .. operator that fixes the problems with
generating sequences with the : operator, and it has precedence lower
than + and - and higher than ! and !!, but that's not relevant if you
don't have the .. operator.)

   Radford Neal


From g@bembecker @end|ng |rom gm@||@com  Mon Dec  6 21:34:40 2021
From: g@bembecker @end|ng |rom gm@||@com (Gabriel Becker)
Date: Mon, 6 Dec 2021 12:34:40 -0800
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <20211206180302.GA6850@mail.cs.toronto.edu>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
Message-ID: <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>

Hi All,

Seeing this and the other thread (and admittedly not having clicked through
to the linked r-help thread), I wonder about NAs.

Should NA <concat> "hi there"  not result in NA_character_? This is not
what any of the paste functions do, but in my opinoin, NA + <non_na_value>
seems like it should be NA  (not "NA"), particularly if we are talking
about `+` overloading, but potentially even in the case of a distinct
concatenation operator?

I guess what I'm saying is that in my head missingness propagation rules
should take priority in such an operator (ie NA + <anything> should
*always * be NA).

Is that something others disagree with, or has it just not come up yet in
(the parts I have read) of this discussion?

Best,
~G

On Mon, Dec 6, 2021 at 10:03 AM Radford Neal <radford at cs.toronto.edu> wrote:

> > > In pqR (see pqR-project.org), I have implemented ! and !! as binary
> > > string concatenation operators, equivalent to paste0 and paste,
> > > respectively.
> > >
> > > For instance,
> > >
> > >      > "hello" ! "world"
> > >      [1] "helloworld"
> > >      > "hello" !! "world"
> > >      [1] "hello world"
> > >      > "hello" !! 1:4
> > >      [1] "hello 1" "hello 2" "hello 3" "hello 4"
> >
> > I'm curious about the details:
> >
> > Would `1 ! 2` convert both to strings?
>
> They're equivalent to paste0 and paste, so 1 ! 2 produces "12", just
> like paste0(1,2) does.  Of course, they wouldn't have to be exactly
> equivalent to paste0 and paste - one could impose stricter
> requirements if that seemed better for error detection.  Off hand,
> though, I think automatically converting is more in keeping with the
> rest of R.  Explicitly converting with as.character could be tedious.
>
> I suppose disallowing logical arguments might make sense to guard
> against typos where ! was meant to be the unary-not operator, but
> ended up being a binary operator, after some sort of typo.  I doubt
> that this would be a common error, though.
>
> (Note that there's no ambiguity when there are no typos, except that
> when negation is involved a space may be needed - so, for example,
> "x" !  !TRUE is "xFALSE", but "x"!!TRUE is "x TRUE".  Existing uses of
> double negation are still fine - eg, a <- !!TRUE still sets a to TRUE.
> Parsing of operators is greedy, so "x"!!!TRUE is "x FALSE", not "xTRUE".)
>
> > Where does the binary ! fit in the operator priority?  E.g. how is
> >
> >   a ! b > c
> >
> > parsed?
>
> As (a ! b) > c.
>
> Their precedence is between that of + and - and that of < and >.
> So "x" ! 1+2 evalates to "x3" and "x" ! 1+2 < "x4" is TRUE.
>
> (Actually, pqR also has a .. operator that fixes the problems with
> generating sequences with the : operator, and it has precedence lower
> than + and - and higher than ! and !!, but that's not relevant if you
> don't have the .. operator.)
>
>    Radford Neal
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From @vr@h@m@@d|er @end|ng |rom gm@||@com  Mon Dec  6 22:21:37 2021
From: @vr@h@m@@d|er @end|ng |rom gm@||@com (Avraham Adler)
Date: Mon, 6 Dec 2021 16:21:37 -0500
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
Message-ID: <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>

Gabe, I agree that missingness is important to factor in. To somewhat abuse
the terminology, NA is often used to represent missingness. Perhaps
concatenating character something with character something missing should
result in the original character?

Avi

On Mon, Dec 6, 2021 at 3:35 PM Gabriel Becker <gabembecker at gmail.com> wrote:

> Hi All,
>
> Seeing this and the other thread (and admittedly not having clicked through
> to the linked r-help thread), I wonder about NAs.
>
> Should NA <concat> "hi there"  not result in NA_character_? This is not
> what any of the paste functions do, but in my opinoin, NA + <non_na_value>
> seems like it should be NA  (not "NA"), particularly if we are talking
> about `+` overloading, but potentially even in the case of a distinct
> concatenation operator?
>
> I guess what I'm saying is that in my head missingness propagation rules
> should take priority in such an operator (ie NA + <anything> should
> *always * be NA).
>
> Is that something others disagree with, or has it just not come up yet in
> (the parts I have read) of this discussion?
>
> Best,
> ~G
>
> On Mon, Dec 6, 2021 at 10:03 AM Radford Neal <radford at cs.toronto.edu>
> wrote:
>
> > > > In pqR (see pqR-project.org), I have implemented ! and !! as binary
> > > > string concatenation operators, equivalent to paste0 and paste,
> > > > respectively.
> > > >
> > > > For instance,
> > > >
> > > >      > "hello" ! "world"
> > > >      [1] "helloworld"
> > > >      > "hello" !! "world"
> > > >      [1] "hello world"
> > > >      > "hello" !! 1:4
> > > >      [1] "hello 1" "hello 2" "hello 3" "hello 4"
> > >
> > > I'm curious about the details:
> > >
> > > Would `1 ! 2` convert both to strings?
> >
> > They're equivalent to paste0 and paste, so 1 ! 2 produces "12", just
> > like paste0(1,2) does.  Of course, they wouldn't have to be exactly
> > equivalent to paste0 and paste - one could impose stricter
> > requirements if that seemed better for error detection.  Off hand,
> > though, I think automatically converting is more in keeping with the
> > rest of R.  Explicitly converting with as.character could be tedious.
> >
> > I suppose disallowing logical arguments might make sense to guard
> > against typos where ! was meant to be the unary-not operator, but
> > ended up being a binary operator, after some sort of typo.  I doubt
> > that this would be a common error, though.
> >
> > (Note that there's no ambiguity when there are no typos, except that
> > when negation is involved a space may be needed - so, for example,
> > "x" !  !TRUE is "xFALSE", but "x"!!TRUE is "x TRUE".  Existing uses of
> > double negation are still fine - eg, a <- !!TRUE still sets a to TRUE.
> > Parsing of operators is greedy, so "x"!!!TRUE is "x FALSE", not "xTRUE".)
> >
> > > Where does the binary ! fit in the operator priority?  E.g. how is
> > >
> > >   a ! b > c
> > >
> > > parsed?
> >
> > As (a ! b) > c.
> >
> > Their precedence is between that of + and - and that of < and >.
> > So "x" ! 1+2 evalates to "x3" and "x" ! 1+2 < "x4" is TRUE.
> >
> > (Actually, pqR also has a .. operator that fixes the problems with
> > generating sequences with the : operator, and it has precedence lower
> > than + and - and higher than ! and !!, but that's not relevant if you
> > don't have the .. operator.)
> >
> >    Radford Neal
> >
> > ______________________________________________
> > R-devel at r-project.org mailing list
> > https://stat.ethz.ch/mailman/listinfo/r-devel
> >
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>
-- 
Sent from Gmail Mobile

	[[alternative HTML version deleted]]


From murdoch@dunc@n @end|ng |rom gm@||@com  Mon Dec  6 22:28:01 2021
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Mon, 6 Dec 2021 16:28:01 -0500
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
Message-ID: <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>

On 06/12/2021 4:21 p.m., Avraham Adler wrote:
> Gabe, I agree that missingness is important to factor in. To somewhat abuse
> the terminology, NA is often used to represent missingness. Perhaps
> concatenating character something with character something missing should
> result in the original character?

I think that's a bad idea.  If you wanted to represent an empty string, 
you should use "" or NULL, not NA.

I'd agree with Gabe, paste0("abc", NA) shouldn't give "abcNA", it should 
give NA.

Duncan Murdoch

> 
> Avi
> 
> On Mon, Dec 6, 2021 at 3:35 PM Gabriel Becker <gabembecker at gmail.com> wrote:
> 
>> Hi All,
>>
>> Seeing this and the other thread (and admittedly not having clicked through
>> to the linked r-help thread), I wonder about NAs.
>>
>> Should NA <concat> "hi there"  not result in NA_character_? This is not
>> what any of the paste functions do, but in my opinoin, NA + <non_na_value>
>> seems like it should be NA  (not "NA"), particularly if we are talking
>> about `+` overloading, but potentially even in the case of a distinct
>> concatenation operator?
>>
>> I guess what I'm saying is that in my head missingness propagation rules
>> should take priority in such an operator (ie NA + <anything> should
>> *always * be NA).
>>
>> Is that something others disagree with, or has it just not come up yet in
>> (the parts I have read) of this discussion?
>>
>> Best,
>> ~G
>>
>> On Mon, Dec 6, 2021 at 10:03 AM Radford Neal <radford at cs.toronto.edu>
>> wrote:
>>
>>>>> In pqR (see pqR-project.org), I have implemented ! and !! as binary
>>>>> string concatenation operators, equivalent to paste0 and paste,
>>>>> respectively.
>>>>>
>>>>> For instance,
>>>>>
>>>>>       > "hello" ! "world"
>>>>>       [1] "helloworld"
>>>>>       > "hello" !! "world"
>>>>>       [1] "hello world"
>>>>>       > "hello" !! 1:4
>>>>>       [1] "hello 1" "hello 2" "hello 3" "hello 4"
>>>>
>>>> I'm curious about the details:
>>>>
>>>> Would `1 ! 2` convert both to strings?
>>>
>>> They're equivalent to paste0 and paste, so 1 ! 2 produces "12", just
>>> like paste0(1,2) does.  Of course, they wouldn't have to be exactly
>>> equivalent to paste0 and paste - one could impose stricter
>>> requirements if that seemed better for error detection.  Off hand,
>>> though, I think automatically converting is more in keeping with the
>>> rest of R.  Explicitly converting with as.character could be tedious.
>>>
>>> I suppose disallowing logical arguments might make sense to guard
>>> against typos where ! was meant to be the unary-not operator, but
>>> ended up being a binary operator, after some sort of typo.  I doubt
>>> that this would be a common error, though.
>>>
>>> (Note that there's no ambiguity when there are no typos, except that
>>> when negation is involved a space may be needed - so, for example,
>>> "x" !  !TRUE is "xFALSE", but "x"!!TRUE is "x TRUE".  Existing uses of
>>> double negation are still fine - eg, a <- !!TRUE still sets a to TRUE.
>>> Parsing of operators is greedy, so "x"!!!TRUE is "x FALSE", not "xTRUE".)
>>>
>>>> Where does the binary ! fit in the operator priority?  E.g. how is
>>>>
>>>>    a ! b > c
>>>>
>>>> parsed?
>>>
>>> As (a ! b) > c.
>>>
>>> Their precedence is between that of + and - and that of < and >.
>>> So "x" ! 1+2 evalates to "x3" and "x" ! 1+2 < "x4" is TRUE.
>>>
>>> (Actually, pqR also has a .. operator that fixes the problems with
>>> generating sequences with the : operator, and it has precedence lower
>>> than + and - and higher than ! and !!, but that's not relevant if you
>>> don't have the .. operator.)
>>>
>>>     Radford Neal
>>>
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>
>>
>>          [[alternative HTML version deleted]]
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>


From w||||@mwdun|@p @end|ng |rom gm@||@com  Tue Dec  7 01:11:29 2021
From: w||||@mwdun|@p @end|ng |rom gm@||@com (Bill Dunlap)
Date: Mon, 6 Dec 2021 16:11:29 -0800
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
Message-ID: <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>

Should paste0(character(0), c("a","b")) give character(0)?
There is a fair bit of code that assumes that paste("X",NULL) gives "X" but
c(1,2)+NULL gives numeric(0).

-Bill

On Mon, Dec 6, 2021 at 1:32 PM Duncan Murdoch <murdoch.duncan at gmail.com>
wrote:

> On 06/12/2021 4:21 p.m., Avraham Adler wrote:
> > Gabe, I agree that missingness is important to factor in. To somewhat
> abuse
> > the terminology, NA is often used to represent missingness. Perhaps
> > concatenating character something with character something missing should
> > result in the original character?
>
> I think that's a bad idea.  If you wanted to represent an empty string,
> you should use "" or NULL, not NA.
>
> I'd agree with Gabe, paste0("abc", NA) shouldn't give "abcNA", it should
> give NA.
>
> Duncan Murdoch
>
> >
> > Avi
> >
> > On Mon, Dec 6, 2021 at 3:35 PM Gabriel Becker <gabembecker at gmail.com>
> wrote:
> >
> >> Hi All,
> >>
> >> Seeing this and the other thread (and admittedly not having clicked
> through
> >> to the linked r-help thread), I wonder about NAs.
> >>
> >> Should NA <concat> "hi there"  not result in NA_character_? This is not
> >> what any of the paste functions do, but in my opinoin, NA +
> <non_na_value>
> >> seems like it should be NA  (not "NA"), particularly if we are talking
> >> about `+` overloading, but potentially even in the case of a distinct
> >> concatenation operator?
> >>
> >> I guess what I'm saying is that in my head missingness propagation rules
> >> should take priority in such an operator (ie NA + <anything> should
> >> *always * be NA).
> >>
> >> Is that something others disagree with, or has it just not come up yet
> in
> >> (the parts I have read) of this discussion?
> >>
> >> Best,
> >> ~G
> >>
> >> On Mon, Dec 6, 2021 at 10:03 AM Radford Neal <radford at cs.toronto.edu>
> >> wrote:
> >>
> >>>>> In pqR (see pqR-project.org), I have implemented ! and !! as binary
> >>>>> string concatenation operators, equivalent to paste0 and paste,
> >>>>> respectively.
> >>>>>
> >>>>> For instance,
> >>>>>
> >>>>>       > "hello" ! "world"
> >>>>>       [1] "helloworld"
> >>>>>       > "hello" !! "world"
> >>>>>       [1] "hello world"
> >>>>>       > "hello" !! 1:4
> >>>>>       [1] "hello 1" "hello 2" "hello 3" "hello 4"
> >>>>
> >>>> I'm curious about the details:
> >>>>
> >>>> Would `1 ! 2` convert both to strings?
> >>>
> >>> They're equivalent to paste0 and paste, so 1 ! 2 produces "12", just
> >>> like paste0(1,2) does.  Of course, they wouldn't have to be exactly
> >>> equivalent to paste0 and paste - one could impose stricter
> >>> requirements if that seemed better for error detection.  Off hand,
> >>> though, I think automatically converting is more in keeping with the
> >>> rest of R.  Explicitly converting with as.character could be tedious.
> >>>
> >>> I suppose disallowing logical arguments might make sense to guard
> >>> against typos where ! was meant to be the unary-not operator, but
> >>> ended up being a binary operator, after some sort of typo.  I doubt
> >>> that this would be a common error, though.
> >>>
> >>> (Note that there's no ambiguity when there are no typos, except that
> >>> when negation is involved a space may be needed - so, for example,
> >>> "x" !  !TRUE is "xFALSE", but "x"!!TRUE is "x TRUE".  Existing uses of
> >>> double negation are still fine - eg, a <- !!TRUE still sets a to TRUE.
> >>> Parsing of operators is greedy, so "x"!!!TRUE is "x FALSE", not
> "xTRUE".)
> >>>
> >>>> Where does the binary ! fit in the operator priority?  E.g. how is
> >>>>
> >>>>    a ! b > c
> >>>>
> >>>> parsed?
> >>>
> >>> As (a ! b) > c.
> >>>
> >>> Their precedence is between that of + and - and that of < and >.
> >>> So "x" ! 1+2 evalates to "x3" and "x" ! 1+2 < "x4" is TRUE.
> >>>
> >>> (Actually, pqR also has a .. operator that fixes the problems with
> >>> generating sequences with the : operator, and it has precedence lower
> >>> than + and - and higher than ! and !!, but that's not relevant if you
> >>> don't have the .. operator.)
> >>>
> >>>     Radford Neal
> >>>
> >>> ______________________________________________
> >>> R-devel at r-project.org mailing list
> >>> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>>
> >>
> >>          [[alternative HTML version deleted]]
> >>
> >> ______________________________________________
> >> R-devel at r-project.org mailing list
> >> https://stat.ethz.ch/mailman/listinfo/r-devel
> >>
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>

	[[alternative HTML version deleted]]


From g@bembecker @end|ng |rom gm@||@com  Tue Dec  7 01:20:51 2021
From: g@bembecker @end|ng |rom gm@||@com (Gabriel Becker)
Date: Mon, 6 Dec 2021 16:20:51 -0800
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
 <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
Message-ID: <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>

As I recall, there was a large discussion related to that which resulted in
the recycle0 argument being added (but defaulting to FALSE) for
paste/paste0.

I think a lot of these things ultimately mean that if there were to be a
string concatenation operator, it probably shouldn't have behavior
identical to paste0. Was that what you were getting at as well, Bill?

~G

On Mon, Dec 6, 2021 at 4:11 PM Bill Dunlap <williamwdunlap at gmail.com> wrote:

> Should paste0(character(0), c("a","b")) give character(0)?
> There is a fair bit of code that assumes that paste("X",NULL) gives "X"
> but c(1,2)+NULL gives numeric(0).
>
> -Bill
>
> On Mon, Dec 6, 2021 at 1:32 PM Duncan Murdoch <murdoch.duncan at gmail.com>
> wrote:
>
>> On 06/12/2021 4:21 p.m., Avraham Adler wrote:
>> > Gabe, I agree that missingness is important to factor in. To somewhat
>> abuse
>> > the terminology, NA is often used to represent missingness. Perhaps
>> > concatenating character something with character something missing
>> should
>> > result in the original character?
>>
>> I think that's a bad idea.  If you wanted to represent an empty string,
>> you should use "" or NULL, not NA.
>>
>> I'd agree with Gabe, paste0("abc", NA) shouldn't give "abcNA", it should
>> give NA.
>>
>> Duncan Murdoch
>>
>> >
>> > Avi
>> >
>> > On Mon, Dec 6, 2021 at 3:35 PM Gabriel Becker <gabembecker at gmail.com>
>> wrote:
>> >
>> >> Hi All,
>> >>
>> >> Seeing this and the other thread (and admittedly not having clicked
>> through
>> >> to the linked r-help thread), I wonder about NAs.
>> >>
>> >> Should NA <concat> "hi there"  not result in NA_character_? This is not
>> >> what any of the paste functions do, but in my opinoin, NA +
>> <non_na_value>
>> >> seems like it should be NA  (not "NA"), particularly if we are talking
>> >> about `+` overloading, but potentially even in the case of a distinct
>> >> concatenation operator?
>> >>
>> >> I guess what I'm saying is that in my head missingness propagation
>> rules
>> >> should take priority in such an operator (ie NA + <anything> should
>> >> *always * be NA).
>> >>
>> >> Is that something others disagree with, or has it just not come up yet
>> in
>> >> (the parts I have read) of this discussion?
>> >>
>> >> Best,
>> >> ~G
>> >>
>> >> On Mon, Dec 6, 2021 at 10:03 AM Radford Neal <radford at cs.toronto.edu>
>> >> wrote:
>> >>
>> >>>>> In pqR (see pqR-project.org), I have implemented ! and !! as binary
>> >>>>> string concatenation operators, equivalent to paste0 and paste,
>> >>>>> respectively.
>> >>>>>
>> >>>>> For instance,
>> >>>>>
>> >>>>>       > "hello" ! "world"
>> >>>>>       [1] "helloworld"
>> >>>>>       > "hello" !! "world"
>> >>>>>       [1] "hello world"
>> >>>>>       > "hello" !! 1:4
>> >>>>>       [1] "hello 1" "hello 2" "hello 3" "hello 4"
>> >>>>
>> >>>> I'm curious about the details:
>> >>>>
>> >>>> Would `1 ! 2` convert both to strings?
>> >>>
>> >>> They're equivalent to paste0 and paste, so 1 ! 2 produces "12", just
>> >>> like paste0(1,2) does.  Of course, they wouldn't have to be exactly
>> >>> equivalent to paste0 and paste - one could impose stricter
>> >>> requirements if that seemed better for error detection.  Off hand,
>> >>> though, I think automatically converting is more in keeping with the
>> >>> rest of R.  Explicitly converting with as.character could be tedious.
>> >>>
>> >>> I suppose disallowing logical arguments might make sense to guard
>> >>> against typos where ! was meant to be the unary-not operator, but
>> >>> ended up being a binary operator, after some sort of typo.  I doubt
>> >>> that this would be a common error, though.
>> >>>
>> >>> (Note that there's no ambiguity when there are no typos, except that
>> >>> when negation is involved a space may be needed - so, for example,
>> >>> "x" !  !TRUE is "xFALSE", but "x"!!TRUE is "x TRUE".  Existing uses of
>> >>> double negation are still fine - eg, a <- !!TRUE still sets a to TRUE.
>> >>> Parsing of operators is greedy, so "x"!!!TRUE is "x FALSE", not
>> "xTRUE".)
>> >>>
>> >>>> Where does the binary ! fit in the operator priority?  E.g. how is
>> >>>>
>> >>>>    a ! b > c
>> >>>>
>> >>>> parsed?
>> >>>
>> >>> As (a ! b) > c.
>> >>>
>> >>> Their precedence is between that of + and - and that of < and >.
>> >>> So "x" ! 1+2 evalates to "x3" and "x" ! 1+2 < "x4" is TRUE.
>> >>>
>> >>> (Actually, pqR also has a .. operator that fixes the problems with
>> >>> generating sequences with the : operator, and it has precedence lower
>> >>> than + and - and higher than ! and !!, but that's not relevant if you
>> >>> don't have the .. operator.)
>> >>>
>> >>>     Radford Neal
>> >>>
>> >>> ______________________________________________
>> >>> R-devel at r-project.org mailing list
>> >>> https://stat.ethz.ch/mailman/listinfo/r-devel
>> >>>
>> >>
>> >>          [[alternative HTML version deleted]]
>> >>
>> >> ______________________________________________
>> >> R-devel at r-project.org mailing list
>> >> https://stat.ethz.ch/mailman/listinfo/r-devel
>> >>
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>

	[[alternative HTML version deleted]]


From d@@cott @end|ng |rom @uck|@nd@@c@nz  Tue Dec  7 01:35:15 2021
From: d@@cott @end|ng |rom @uck|@nd@@c@nz (David Scott)
Date: Tue, 7 Dec 2021 13:35:15 +1300
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
 <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
 <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
Message-ID: <30e5215a-1dd8-fbd4-75e5-6190640a36f2@auckland.ac.nz>

I am surprised nobody so far has mentioned glue which is an 
implementation in R of a python idiom.

It is a reverse import in a great number of R packages on CRAN. It 
specifies how some of the special cases so far considered are treated 
which seems an advantage:

 > library(glue)
 > glue(NA, 2)
NA2
 > glue(NA, 2, .sep = " ")
NA 2
 > glue(NA, 2, .na = NULL)
NA

David Scott

On 7/12/2021 1:20 pm, Gabriel Becker wrote:
> As I recall, there was a large discussion related to that which 
> resulted in
> the recycle0 argument being added (but defaulting to FALSE) for
> paste/paste0.
>
> I think a lot of these things ultimately mean that if there were to be a
> string concatenation operator, it probably shouldn't have behavior
> identical to paste0. Was that what you were getting at as well, Bill?
>
> ~G
>
> On Mon, Dec 6, 2021 at 4:11 PM Bill Dunlap <williamwdunlap at gmail.com> 
> wrote:
>
> > Should paste0(character(0), c("a","b")) give character(0)?
> > There is a fair bit of code that assumes that paste("X",NULL) gives "X"
> > but c(1,2)+NULL gives numeric(0).
> >
> > -Bill
> >
> > On Mon, Dec 6, 2021 at 1:32 PM Duncan Murdoch <murdoch.duncan at gmail.com>
> > wrote:
> >
> >> On 06/12/2021 4:21 p.m., Avraham Adler wrote:
> >> > Gabe, I agree that missingness is important to factor in. To somewhat
> >> abuse
> >> > the terminology, NA is often used to represent missingness. Perhaps
> >> > concatenating character something with character something missing
> >> should
> >> > result in the original character?
> >>
> >> I think that's a bad idea. If you wanted to represent an empty string,
> >> you should use "" or NULL, not NA.
> >>
> >> I'd agree with Gabe, paste0("abc", NA) shouldn't give "abcNA", it 
> should
> >> give NA.
> >>
> >> Duncan Murdoch
> >>
> >> >
> >> > Avi
> >> >
> >> > On Mon, Dec 6, 2021 at 3:35 PM Gabriel Becker <gabembecker at gmail.com>
> >> wrote:
> >> >
> >> >> Hi All,
> >> >>
> >> >> Seeing this and the other thread (and admittedly not having clicked
> >> through
> >> >> to the linked r-help thread), I wonder about NAs.
> >> >>
> >> >> Should NA <concat> "hi there" not result in NA_character_? This 
> is not
> >> >> what any of the paste functions do, but in my opinoin, NA +
> >> <non_na_value>
> >> >> seems like it should be NA (not "NA"), particularly if we are 
> talking
> >> >> about `+` overloading, but potentially even in the case of a 
> distinct
> >> >> concatenation operator?
> >> >>
> >> >> I guess what I'm saying is that in my head missingness propagation
> >> rules
> >> >> should take priority in such an operator (ie NA + <anything> should
> >> >> *always * be NA).
> >> >>
> >> >> Is that something others disagree with, or has it just not come 
> up yet
> >> in
> >> >> (the parts I have read) of this discussion?
> >> >>
> >> >> Best,
> >> >> ~G
> >> >>
> >> >> On Mon, Dec 6, 2021 at 10:03 AM Radford Neal 
> <radford at cs.toronto.edu>
> >> >> wrote:
> >> >>
> >> >>>>> In pqR (see pqR-project.org), I have implemented ! and !! as 
> binary
> >> >>>>> string concatenation operators, equivalent to paste0 and paste,
> >> >>>>> respectively.
> >> >>>>>
> >> >>>>> For instance,
> >> >>>>>
> >> >>>>> > "hello" ! "world"
> >> >>>>> [1] "helloworld"
> >> >>>>> > "hello" !! "world"
> >> >>>>> [1] "hello world"
> >> >>>>> > "hello" !! 1:4
> >> >>>>> [1] "hello 1" "hello 2" "hello 3" "hello 4"
> >> >>>>
> >> >>>> I'm curious about the details:
> >> >>>>
> >> >>>> Would `1 ! 2` convert both to strings?
> >> >>>
> >> >>> They're equivalent to paste0 and paste, so 1 ! 2 produces "12", 
> just
> >> >>> like paste0(1,2) does. Of course, they wouldn't have to be exactly
> >> >>> equivalent to paste0 and paste - one could impose stricter
> >> >>> requirements if that seemed better for error detection. Off hand,
> >> >>> though, I think automatically converting is more in keeping 
> with the
> >> >>> rest of R. Explicitly converting with as.character could be 
> tedious.
> >> >>>
> >> >>> I suppose disallowing logical arguments might make sense to guard
> >> >>> against typos where ! was meant to be the unary-not operator, but
> >> >>> ended up being a binary operator, after some sort of typo. I doubt
> >> >>> that this would be a common error, though.
> >> >>>
> >> >>> (Note that there's no ambiguity when there are no typos, except 
> that
> >> >>> when negation is involved a space may be needed - so, for example,
> >> >>> "x" ! !TRUE is "xFALSE", but "x"!!TRUE is "x TRUE". Existing 
> uses of
> >> >>> double negation are still fine - eg, a <- !!TRUE still sets a 
> to TRUE.
> >> >>> Parsing of operators is greedy, so "x"!!!TRUE is "x FALSE", not
> >> "xTRUE".)
> >> >>>
> >> >>>> Where does the binary ! fit in the operator priority? E.g. how is
> >> >>>>
> >> >>>> a ! b > c
> >> >>>>
> >> >>>> parsed?
> >> >>>
> >> >>> As (a ! b) > c.
> >> >>>
> >> >>> Their precedence is between that of + and - and that of < and >.
> >> >>> So "x" ! 1+2 evalates to "x3" and "x" ! 1+2 < "x4" is TRUE.
> >> >>>
> >> >>> (Actually, pqR also has a .. operator that fixes the problems with
> >> >>> generating sequences with the : operator, and it has precedence 
> lower
> >> >>> than + and - and higher than ! and !!, but that's not relevant 
> if you
> >> >>> don't have the .. operator.)
> >> >>>
> >> >>> Radford Neal
> >> >>>
> >> >>> ______________________________________________
> >> >>> R-devel at r-project.org mailing list
> >> >>> https://stat.ethz.ch/mailman/listinfo/r-devel 
> <https://stat.ethz.ch/mailman/listinfo/r-devel>
> >> >>>
> >> >>
> >> >> [[alternative HTML version deleted]]
> >> >>
> >> >> ______________________________________________
> >> >> R-devel at r-project.org mailing list
> >> >> https://stat.ethz.ch/mailman/listinfo/r-devel 
> <https://stat.ethz.ch/mailman/listinfo/r-devel>
> >> >>
> >>
> >> ______________________________________________
> >> R-devel at r-project.org mailing list
> >> https://stat.ethz.ch/mailman/listinfo/r-devel 
> <https://stat.ethz.ch/mailman/listinfo/r-devel>
> >>
> >
>
> [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel 
> <https://stat.ethz.ch/mailman/listinfo/r-devel>

-- 
_________________________________________________________________
David Scott
Department of Statistics
The University of Auckland, PB 92019
Auckland 1142,    NEW ZEALAND
Email:d.scott at auckland.ac.nz


	[[alternative HTML version deleted]]


From w||||@mwdun|@p @end|ng |rom gm@||@com  Tue Dec  7 02:18:08 2021
From: w||||@mwdun|@p @end|ng |rom gm@||@com (Bill Dunlap)
Date: Mon, 6 Dec 2021 17:18:08 -0800
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
 <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
 <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
Message-ID: <CAHqSRuRDKLbyVGDQezGkkOLYRJwOqD6ARFbRPvNVxBpDutYHGg@mail.gmail.com>

>I think a lot of these things ultimately mean that if there were to be a
string >concatenation operator, it probably shouldn't have behavior
identical to >paste0. Was that what you were getting at as well, Bill?

Yes.

On Mon, Dec 6, 2021 at 4:21 PM Gabriel Becker <gabembecker at gmail.com> wrote:

> As I recall, there was a large discussion related to that which resulted
> in the recycle0 argument being added (but defaulting to FALSE) for
> paste/paste0.
>
> I think a lot of these things ultimately mean that if there were to be a
> string concatenation operator, it probably shouldn't have behavior
> identical to paste0. Was that what you were getting at as well, Bill?
>
> ~G
>
> On Mon, Dec 6, 2021 at 4:11 PM Bill Dunlap <williamwdunlap at gmail.com>
> wrote:
>
>> Should paste0(character(0), c("a","b")) give character(0)?
>> There is a fair bit of code that assumes that paste("X",NULL) gives "X"
>> but c(1,2)+NULL gives numeric(0).
>>
>> -Bill
>>
>> On Mon, Dec 6, 2021 at 1:32 PM Duncan Murdoch <murdoch.duncan at gmail.com>
>> wrote:
>>
>>> On 06/12/2021 4:21 p.m., Avraham Adler wrote:
>>> > Gabe, I agree that missingness is important to factor in. To somewhat
>>> abuse
>>> > the terminology, NA is often used to represent missingness. Perhaps
>>> > concatenating character something with character something missing
>>> should
>>> > result in the original character?
>>>
>>> I think that's a bad idea.  If you wanted to represent an empty string,
>>> you should use "" or NULL, not NA.
>>>
>>> I'd agree with Gabe, paste0("abc", NA) shouldn't give "abcNA", it should
>>> give NA.
>>>
>>> Duncan Murdoch
>>>
>>> >
>>> > Avi
>>> >
>>> > On Mon, Dec 6, 2021 at 3:35 PM Gabriel Becker <gabembecker at gmail.com>
>>> wrote:
>>> >
>>> >> Hi All,
>>> >>
>>> >> Seeing this and the other thread (and admittedly not having clicked
>>> through
>>> >> to the linked r-help thread), I wonder about NAs.
>>> >>
>>> >> Should NA <concat> "hi there"  not result in NA_character_? This is
>>> not
>>> >> what any of the paste functions do, but in my opinoin, NA +
>>> <non_na_value>
>>> >> seems like it should be NA  (not "NA"), particularly if we are talking
>>> >> about `+` overloading, but potentially even in the case of a distinct
>>> >> concatenation operator?
>>> >>
>>> >> I guess what I'm saying is that in my head missingness propagation
>>> rules
>>> >> should take priority in such an operator (ie NA + <anything> should
>>> >> *always * be NA).
>>> >>
>>> >> Is that something others disagree with, or has it just not come up
>>> yet in
>>> >> (the parts I have read) of this discussion?
>>> >>
>>> >> Best,
>>> >> ~G
>>> >>
>>> >> On Mon, Dec 6, 2021 at 10:03 AM Radford Neal <radford at cs.toronto.edu>
>>> >> wrote:
>>> >>
>>> >>>>> In pqR (see pqR-project.org), I have implemented ! and !! as binary
>>> >>>>> string concatenation operators, equivalent to paste0 and paste,
>>> >>>>> respectively.
>>> >>>>>
>>> >>>>> For instance,
>>> >>>>>
>>> >>>>>       > "hello" ! "world"
>>> >>>>>       [1] "helloworld"
>>> >>>>>       > "hello" !! "world"
>>> >>>>>       [1] "hello world"
>>> >>>>>       > "hello" !! 1:4
>>> >>>>>       [1] "hello 1" "hello 2" "hello 3" "hello 4"
>>> >>>>
>>> >>>> I'm curious about the details:
>>> >>>>
>>> >>>> Would `1 ! 2` convert both to strings?
>>> >>>
>>> >>> They're equivalent to paste0 and paste, so 1 ! 2 produces "12", just
>>> >>> like paste0(1,2) does.  Of course, they wouldn't have to be exactly
>>> >>> equivalent to paste0 and paste - one could impose stricter
>>> >>> requirements if that seemed better for error detection.  Off hand,
>>> >>> though, I think automatically converting is more in keeping with the
>>> >>> rest of R.  Explicitly converting with as.character could be tedious.
>>> >>>
>>> >>> I suppose disallowing logical arguments might make sense to guard
>>> >>> against typos where ! was meant to be the unary-not operator, but
>>> >>> ended up being a binary operator, after some sort of typo.  I doubt
>>> >>> that this would be a common error, though.
>>> >>>
>>> >>> (Note that there's no ambiguity when there are no typos, except that
>>> >>> when negation is involved a space may be needed - so, for example,
>>> >>> "x" !  !TRUE is "xFALSE", but "x"!!TRUE is "x TRUE".  Existing uses
>>> of
>>> >>> double negation are still fine - eg, a <- !!TRUE still sets a to
>>> TRUE.
>>> >>> Parsing of operators is greedy, so "x"!!!TRUE is "x FALSE", not
>>> "xTRUE".)
>>> >>>
>>> >>>> Where does the binary ! fit in the operator priority?  E.g. how is
>>> >>>>
>>> >>>>    a ! b > c
>>> >>>>
>>> >>>> parsed?
>>> >>>
>>> >>> As (a ! b) > c.
>>> >>>
>>> >>> Their precedence is between that of + and - and that of < and >.
>>> >>> So "x" ! 1+2 evalates to "x3" and "x" ! 1+2 < "x4" is TRUE.
>>> >>>
>>> >>> (Actually, pqR also has a .. operator that fixes the problems with
>>> >>> generating sequences with the : operator, and it has precedence lower
>>> >>> than + and - and higher than ! and !!, but that's not relevant if you
>>> >>> don't have the .. operator.)
>>> >>>
>>> >>>     Radford Neal
>>> >>>
>>> >>> ______________________________________________
>>> >>> R-devel at r-project.org mailing list
>>> >>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>> >>>
>>> >>
>>> >>          [[alternative HTML version deleted]]
>>> >>
>>> >> ______________________________________________
>>> >> R-devel at r-project.org mailing list
>>> >> https://stat.ethz.ch/mailman/listinfo/r-devel
>>> >>
>>>
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>
>>

	[[alternative HTML version deleted]]


From @v|gro@@ @end|ng |rom ver|zon@net  Tue Dec  7 02:27:06 2021
From: @v|gro@@ @end|ng |rom ver|zon@net (Avi Gross)
Date: Mon, 6 Dec 2021 20:27:06 -0500
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
 <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
 <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
Message-ID: <010101d7eb09$8c0156d0$a4040470$@verizon.net>

After seeing what others are saying, it is clear that you need to carefully
think things out before designing any implementation of a more native
concatenation operator whether it is called "+' or anything else. There may
not be any ONE right solution but unlike a function version like paste()
there is nowhere to place any options that specify what you mean.

You can obviously expand paste() to accept arguments like replace.NA="" or
replace.NA="<NA>" and similar arguments on what to do if you see a NaN, and
Inf or -Inf, a NULL or even an NA.character_ and so on. Heck, you might tell
to make other substitutions as in substitute=list(100=99, D=F) or any other
nonsense you can come up with.

But you have nowhere to put options when saying:

c <- a + b

Sure, you could set various global options before the addition and maybe
rest them after, but that is not a way I like to go for something this
basic.

And enough such tinkering makes me wonder if it is easier to ask a user to
use a slightly different function like this:

paste.no.na <- function(...) do.call(paste, Filter(Negate(is.na),
list(...)))

The above one-line function removes any NA from the argument list to make a
potentially shorter list before calling the real paste() using it.

Variations can, of course, be made that allow functionality as above. 

If R was a true object-oriented language in the same sense as others like
Python, operator overloading of "+" might be doable in more complex ways but
we can only work with what we have. I tend to agree with others that in some
places R is so lenient that all kinds of errors can happen because it makes
a guess on how to correct it. Generally, if you really want to mix numeric
and character, many languages require you to transform any arguments to make
all of compatible types. The paste() function is clearly stated to coerce
all arguments to be of type character for you. Whereas a+b makes no such
promises and also is not properly defined even if a and b are both of type
character. Sure, we can expand the language but it may still do things some
find not to be quite what they wanted as in "2"+"3" becoming "23" rather
than 5. Right now, I can use as.numeric("2")+as.numeric("3") and get the
intended result after making very clear to anyone reading the code that I
wanted strings converted to floating point before the addition.

As has been pointed out, the plus operator if used to concatenate does not
have a cognate for other operations like -*/ and R has used most other
special symbols for other purposes. So, sure, we can use something like ....
(4 periods) if it is not already being used for something but using + here
is a tad confusing. Having said that, the makers of Python did make that
choice.

-----Original Message-----
From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Gabriel Becker
Sent: Monday, December 6, 2021 7:21 PM
To: Bill Dunlap <williamwdunlap at gmail.com>
Cc: Radford Neal <radford at cs.toronto.edu>; r-devel <r-devel at r-project.org>
Subject: Re: [Rd] string concatenation operator (revisited)

As I recall, there was a large discussion related to that which resulted in
the recycle0 argument being added (but defaulting to FALSE) for
paste/paste0.

I think a lot of these things ultimately mean that if there were to be a
string concatenation operator, it probably shouldn't have behavior identical
to paste0. Was that what you were getting at as well, Bill?

~G

On Mon, Dec 6, 2021 at 4:11 PM Bill Dunlap <williamwdunlap at gmail.com> wrote:

> Should paste0(character(0), c("a","b")) give character(0)?
> There is a fair bit of code that assumes that paste("X",NULL) gives "X"
> but c(1,2)+NULL gives numeric(0).
>
> -Bill
>
> On Mon, Dec 6, 2021 at 1:32 PM Duncan Murdoch 
> <murdoch.duncan at gmail.com>
> wrote:
>
>> On 06/12/2021 4:21 p.m., Avraham Adler wrote:
>> > Gabe, I agree that missingness is important to factor in. To 
>> > somewhat
>> abuse
>> > the terminology, NA is often used to represent missingness. Perhaps 
>> > concatenating character something with character something missing
>> should
>> > result in the original character?
>>
>> I think that's a bad idea.  If you wanted to represent an empty 
>> string, you should use "" or NULL, not NA.
>>
>> I'd agree with Gabe, paste0("abc", NA) shouldn't give "abcNA", it 
>> should give NA.
>>
>> Duncan Murdoch
>>
>> >
>> > Avi
>> >
>> > On Mon, Dec 6, 2021 at 3:35 PM Gabriel Becker 
>> > <gabembecker at gmail.com>
>> wrote:
>> >
>> >> Hi All,
>> >>
>> >> Seeing this and the other thread (and admittedly not having 
>> >> clicked
>> through
>> >> to the linked r-help thread), I wonder about NAs.
>> >>
>> >> Should NA <concat> "hi there"  not result in NA_character_? This 
>> >> is not what any of the paste functions do, but in my opinoin, NA +
>> <non_na_value>
>> >> seems like it should be NA  (not "NA"), particularly if we are 
>> >> talking about `+` overloading, but potentially even in the case of 
>> >> a distinct concatenation operator?
>> >>
>> >> I guess what I'm saying is that in my head missingness propagation
>> rules
>> >> should take priority in such an operator (ie NA + <anything> 
>> >> should *always * be NA).
>> >>
>> >> Is that something others disagree with, or has it just not come up 
>> >> yet
>> in
>> >> (the parts I have read) of this discussion?
>> >>
>> >> Best,
>> >> ~G
>> >>
>> >> On Mon, Dec 6, 2021 at 10:03 AM Radford Neal 
>> >> <radford at cs.toronto.edu>
>> >> wrote:
>> >>
>> >>>>> In pqR (see pqR-project.org), I have implemented ! and !! as 
>> >>>>> binary string concatenation operators, equivalent to paste0 and 
>> >>>>> paste, respectively.
>> >>>>>
>> >>>>> For instance,
>> >>>>>
>> >>>>>       > "hello" ! "world"
>> >>>>>       [1] "helloworld"
>> >>>>>       > "hello" !! "world"
>> >>>>>       [1] "hello world"
>> >>>>>       > "hello" !! 1:4
>> >>>>>       [1] "hello 1" "hello 2" "hello 3" "hello 4"
>> >>>>
>> >>>> I'm curious about the details:
>> >>>>
>> >>>> Would `1 ! 2` convert both to strings?
>> >>>
>> >>> They're equivalent to paste0 and paste, so 1 ! 2 produces "12", 
>> >>> just like paste0(1,2) does.  Of course, they wouldn't have to be 
>> >>> exactly equivalent to paste0 and paste - one could impose 
>> >>> stricter requirements if that seemed better for error detection.  
>> >>> Off hand, though, I think automatically converting is more in 
>> >>> keeping with the rest of R.  Explicitly converting with as.character
could be tedious.
>> >>>
>> >>> I suppose disallowing logical arguments might make sense to guard 
>> >>> against typos where ! was meant to be the unary-not operator, but 
>> >>> ended up being a binary operator, after some sort of typo.  I 
>> >>> doubt that this would be a common error, though.
>> >>>
>> >>> (Note that there's no ambiguity when there are no typos, except 
>> >>> that when negation is involved a space may be needed - so, for 
>> >>> example, "x" !  !TRUE is "xFALSE", but "x"!!TRUE is "x TRUE".  
>> >>> Existing uses of double negation are still fine - eg, a <- !!TRUE
still sets a to TRUE.
>> >>> Parsing of operators is greedy, so "x"!!!TRUE is "x FALSE", not
>> "xTRUE".)
>> >>>
>> >>>> Where does the binary ! fit in the operator priority?  E.g. how 
>> >>>> is
>> >>>>
>> >>>>    a ! b > c
>> >>>>
>> >>>> parsed?
>> >>>
>> >>> As (a ! b) > c.
>> >>>
>> >>> Their precedence is between that of + and - and that of < and >.
>> >>> So "x" ! 1+2 evalates to "x3" and "x" ! 1+2 < "x4" is TRUE.
>> >>>
>> >>> (Actually, pqR also has a .. operator that fixes the problems 
>> >>> with generating sequences with the : operator, and it has 
>> >>> precedence lower than + and - and higher than ! and !!, but 
>> >>> that's not relevant if you don't have the .. operator.)
>> >>>
>> >>>     Radford Neal
>> >>>
>> >>> ______________________________________________
>> >>> R-devel at r-project.org mailing list 
>> >>> https://stat.ethz.ch/mailman/listinfo/r-devel
>> >>>
>> >>
>> >>          [[alternative HTML version deleted]]
>> >>
>> >> ______________________________________________
>> >> R-devel at r-project.org mailing list 
>> >> https://stat.ethz.ch/mailman/listinfo/r-devel
>> >>
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>

	[[alternative HTML version deleted]]

______________________________________________
R-devel at r-project.org mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


From t@r@@@z@kh@rko @end|ng |rom uzh@ch  Tue Dec  7 10:09:08 2021
From: t@r@@@z@kh@rko @end|ng |rom uzh@ch (Taras Zakharko)
Date: Tue, 7 Dec 2021 10:09:08 +0100
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <010101d7eb09$8c0156d0$a4040470$@verizon.net>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
 <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
 <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
 <010101d7eb09$8c0156d0$a4040470$@verizon.net>
Message-ID: <7CA551D8-3636-4E03-AF4C-0BDD4F5FB9F4@uzh.ch>

Great summary, Avi. 

String concatenation cold be trivially added to R, but it probably should not be. You will notice that modern languages tend not to use ?+? to do string concatenation (they either have 
a custom operator or a special kind of pattern to do it) due to practical issues such an approach brings (implicit type casting, lack of commutativity, performance etc.). These issues will be felt even more so in R with it?s weak typing, idiosyncratic casting behavior and NAs. 

As other?s have pointed out, any kind of behavior one wants from string concatenation can be implemented by custom operators as needed. This is not something that needs to be in the base R. I would rather like the efforts to be directed on improving string formatting (such as glue-style built-in string interpolation).

? Taras


> On 7 Dec 2021, at 02:27, Avi Gross via R-devel <r-devel at r-project.org> wrote:
> 
> After seeing what others are saying, it is clear that you need to carefully
> think things out before designing any implementation of a more native
> concatenation operator whether it is called "+' or anything else. There may
> not be any ONE right solution but unlike a function version like paste()
> there is nowhere to place any options that specify what you mean.
> 
> You can obviously expand paste() to accept arguments like replace.NA="" or
> replace.NA="<NA>" and similar arguments on what to do if you see a NaN, and
> Inf or -Inf, a NULL or even an NA.character_ and so on. Heck, you might tell
> to make other substitutions as in substitute=list(100=99, D=F) or any other
> nonsense you can come up with.
> 
> But you have nowhere to put options when saying:
> 
> c <- a + b
> 
> Sure, you could set various global options before the addition and maybe
> rest them after, but that is not a way I like to go for something this
> basic.
> 
> And enough such tinkering makes me wonder if it is easier to ask a user to
> use a slightly different function like this:
> 
> paste.no.na <- function(...) do.call(paste, Filter(Negate(is.na),
> list(...)))
> 
> The above one-line function removes any NA from the argument list to make a
> potentially shorter list before calling the real paste() using it.
> 
> Variations can, of course, be made that allow functionality as above. 
> 
> If R was a true object-oriented language in the same sense as others like
> Python, operator overloading of "+" might be doable in more complex ways but
> we can only work with what we have. I tend to agree with others that in some
> places R is so lenient that all kinds of errors can happen because it makes
> a guess on how to correct it. Generally, if you really want to mix numeric
> and character, many languages require you to transform any arguments to make
> all of compatible types. The paste() function is clearly stated to coerce
> all arguments to be of type character for you. Whereas a+b makes no such
> promises and also is not properly defined even if a and b are both of type
> character. Sure, we can expand the language but it may still do things some
> find not to be quite what they wanted as in "2"+"3" becoming "23" rather
> than 5. Right now, I can use as.numeric("2")+as.numeric("3") and get the
> intended result after making very clear to anyone reading the code that I
> wanted strings converted to floating point before the addition.
> 
> As has been pointed out, the plus operator if used to concatenate does not
> have a cognate for other operations like -*/ and R has used most other
> special symbols for other purposes. So, sure, we can use something like ....
> (4 periods) if it is not already being used for something but using + here
> is a tad confusing. Having said that, the makers of Python did make that
> choice.
> 
> -----Original Message-----
> From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Gabriel Becker
> Sent: Monday, December 6, 2021 7:21 PM
> To: Bill Dunlap <williamwdunlap at gmail.com>
> Cc: Radford Neal <radford at cs.toronto.edu>; r-devel <r-devel at r-project.org>
> Subject: Re: [Rd] string concatenation operator (revisited)
> 
> As I recall, there was a large discussion related to that which resulted in
> the recycle0 argument being added (but defaulting to FALSE) for
> paste/paste0.
> 
> I think a lot of these things ultimately mean that if there were to be a
> string concatenation operator, it probably shouldn't have behavior identical
> to paste0. Was that what you were getting at as well, Bill?
> 
> ~G
> 
> On Mon, Dec 6, 2021 at 4:11 PM Bill Dunlap <williamwdunlap at gmail.com> wrote:
> 
>> Should paste0(character(0), c("a","b")) give character(0)?
>> There is a fair bit of code that assumes that paste("X",NULL) gives "X"
>> but c(1,2)+NULL gives numeric(0).
>> 
>> -Bill
>> 
>> On Mon, Dec 6, 2021 at 1:32 PM Duncan Murdoch 
>> <murdoch.duncan at gmail.com>
>> wrote:
>> 
>>> On 06/12/2021 4:21 p.m., Avraham Adler wrote:
>>>> Gabe, I agree that missingness is important to factor in. To 
>>>> somewhat
>>> abuse
>>>> the terminology, NA is often used to represent missingness. Perhaps 
>>>> concatenating character something with character something missing
>>> should
>>>> result in the original character?
>>> 
>>> I think that's a bad idea.  If you wanted to represent an empty 
>>> string, you should use "" or NULL, not NA.
>>> 
>>> I'd agree with Gabe, paste0("abc", NA) shouldn't give "abcNA", it 
>>> should give NA.
>>> 
>>> Duncan Murdoch
>>> 
>>>> 
>>>> Avi
>>>> 
>>>> On Mon, Dec 6, 2021 at 3:35 PM Gabriel Becker 
>>>> <gabembecker at gmail.com>
>>> wrote:
>>>> 
>>>>> Hi All,
>>>>> 
>>>>> Seeing this and the other thread (and admittedly not having 
>>>>> clicked
>>> through
>>>>> to the linked r-help thread), I wonder about NAs.
>>>>> 
>>>>> Should NA <concat> "hi there"  not result in NA_character_? This 
>>>>> is not what any of the paste functions do, but in my opinoin, NA +
>>> <non_na_value>
>>>>> seems like it should be NA  (not "NA"), particularly if we are 
>>>>> talking about `+` overloading, but potentially even in the case of 
>>>>> a distinct concatenation operator?
>>>>> 
>>>>> I guess what I'm saying is that in my head missingness propagation
>>> rules
>>>>> should take priority in such an operator (ie NA + <anything> 
>>>>> should *always * be NA).
>>>>> 
>>>>> Is that something others disagree with, or has it just not come up 
>>>>> yet
>>> in
>>>>> (the parts I have read) of this discussion?
>>>>> 
>>>>> Best,
>>>>> ~G
>>>>> 
>>>>> On Mon, Dec 6, 2021 at 10:03 AM Radford Neal 
>>>>> <radford at cs.toronto.edu>
>>>>> wrote:
>>>>> 
>>>>>>>> In pqR (see pqR-project.org), I have implemented ! and !! as 
>>>>>>>> binary string concatenation operators, equivalent to paste0 and 
>>>>>>>> paste, respectively.
>>>>>>>> 
>>>>>>>> For instance,
>>>>>>>> 
>>>>>>>>> "hello" ! "world"
>>>>>>>>      [1] "helloworld"
>>>>>>>>> "hello" !! "world"
>>>>>>>>      [1] "hello world"
>>>>>>>>> "hello" !! 1:4
>>>>>>>>      [1] "hello 1" "hello 2" "hello 3" "hello 4"
>>>>>>> 
>>>>>>> I'm curious about the details:
>>>>>>> 
>>>>>>> Would `1 ! 2` convert both to strings?
>>>>>> 
>>>>>> They're equivalent to paste0 and paste, so 1 ! 2 produces "12", 
>>>>>> just like paste0(1,2) does.  Of course, they wouldn't have to be 
>>>>>> exactly equivalent to paste0 and paste - one could impose 
>>>>>> stricter requirements if that seemed better for error detection.  
>>>>>> Off hand, though, I think automatically converting is more in 
>>>>>> keeping with the rest of R.  Explicitly converting with as.character
> could be tedious.
>>>>>> 
>>>>>> I suppose disallowing logical arguments might make sense to guard 
>>>>>> against typos where ! was meant to be the unary-not operator, but 
>>>>>> ended up being a binary operator, after some sort of typo.  I 
>>>>>> doubt that this would be a common error, though.
>>>>>> 
>>>>>> (Note that there's no ambiguity when there are no typos, except 
>>>>>> that when negation is involved a space may be needed - so, for 
>>>>>> example, "x" !  !TRUE is "xFALSE", but "x"!!TRUE is "x TRUE".  
>>>>>> Existing uses of double negation are still fine - eg, a <- !!TRUE
> still sets a to TRUE.
>>>>>> Parsing of operators is greedy, so "x"!!!TRUE is "x FALSE", not
>>> "xTRUE".)
>>>>>> 
>>>>>>> Where does the binary ! fit in the operator priority?  E.g. how 
>>>>>>> is
>>>>>>> 
>>>>>>>   a ! b > c
>>>>>>> 
>>>>>>> parsed?
>>>>>> 
>>>>>> As (a ! b) > c.
>>>>>> 
>>>>>> Their precedence is between that of + and - and that of < and >.
>>>>>> So "x" ! 1+2 evalates to "x3" and "x" ! 1+2 < "x4" is TRUE.
>>>>>> 
>>>>>> (Actually, pqR also has a .. operator that fixes the problems 
>>>>>> with generating sequences with the : operator, and it has 
>>>>>> precedence lower than + and - and higher than ! and !!, but 
>>>>>> that's not relevant if you don't have the .. operator.)
>>>>>> 
>>>>>>    Radford Neal
>>>>>> 
>>>>>> ______________________________________________
>>>>>> R-devel at r-project.org mailing list 
>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>> 
>>>>> 
>>>>>         [[alternative HTML version deleted]]
>>>>> 
>>>>> ______________________________________________
>>>>> R-devel at r-project.org mailing list 
>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>> 
>>> 
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>> 
>> 
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From murdoch@dunc@n @end|ng |rom gm@||@com  Tue Dec  7 11:05:45 2021
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Tue, 7 Dec 2021 05:05:45 -0500
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <7CA551D8-3636-4E03-AF4C-0BDD4F5FB9F4@uzh.ch>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
 <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
 <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
 <010101d7eb09$8c0156d0$a4040470$@verizon.net>
 <7CA551D8-3636-4E03-AF4C-0BDD4F5FB9F4@uzh.ch>
Message-ID: <4a29fe16-1828-c545-2744-1a4ad5993033@gmail.com>

On 07/12/2021 4:09 a.m., Taras Zakharko wrote:
> Great summary, Avi.
> 
> String concatenation cold be trivially added to R, but it probably should not be. You will notice that modern languages tend not to use ?+? to do string concatenation (they either have
> a custom operator or a special kind of pattern to do it) due to practical issues such an approach brings (implicit type casting, lack of commutativity, performance etc.). These issues will be felt even more so in R with it?s weak typing, idiosyncratic casting behavior and NAs.
> 
> As other?s have pointed out, any kind of behavior one wants from string concatenation can be implemented by custom operators as needed. 

> This is not something that needs to be in the base R. I would rather like the efforts to be directed on improving string formatting (such as glue-style built-in string interpolation).

R already has that in the glue package and elsewhere in other packages 
(e.g. I wrote a simple version for rgl). What would be the benefit of 
having it built in?

Duncan Murdoch

> 
> ? Taras
> 
> 
>> On 7 Dec 2021, at 02:27, Avi Gross via R-devel <r-devel at r-project.org> wrote:
>>
>> After seeing what others are saying, it is clear that you need to carefully
>> think things out before designing any implementation of a more native
>> concatenation operator whether it is called "+' or anything else. There may
>> not be any ONE right solution but unlike a function version like paste()
>> there is nowhere to place any options that specify what you mean.
>>
>> You can obviously expand paste() to accept arguments like replace.NA="" or
>> replace.NA="<NA>" and similar arguments on what to do if you see a NaN, and
>> Inf or -Inf, a NULL or even an NA.character_ and so on. Heck, you might tell
>> to make other substitutions as in substitute=list(100=99, D=F) or any other
>> nonsense you can come up with.
>>
>> But you have nowhere to put options when saying:
>>
>> c <- a + b
>>
>> Sure, you could set various global options before the addition and maybe
>> rest them after, but that is not a way I like to go for something this
>> basic.
>>
>> And enough such tinkering makes me wonder if it is easier to ask a user to
>> use a slightly different function like this:
>>
>> paste.no.na <- function(...) do.call(paste, Filter(Negate(is.na),
>> list(...)))
>>
>> The above one-line function removes any NA from the argument list to make a
>> potentially shorter list before calling the real paste() using it.
>>
>> Variations can, of course, be made that allow functionality as above.
>>
>> If R was a true object-oriented language in the same sense as others like
>> Python, operator overloading of "+" might be doable in more complex ways but
>> we can only work with what we have. I tend to agree with others that in some
>> places R is so lenient that all kinds of errors can happen because it makes
>> a guess on how to correct it. Generally, if you really want to mix numeric
>> and character, many languages require you to transform any arguments to make
>> all of compatible types. The paste() function is clearly stated to coerce
>> all arguments to be of type character for you. Whereas a+b makes no such
>> promises and also is not properly defined even if a and b are both of type
>> character. Sure, we can expand the language but it may still do things some
>> find not to be quite what they wanted as in "2"+"3" becoming "23" rather
>> than 5. Right now, I can use as.numeric("2")+as.numeric("3") and get the
>> intended result after making very clear to anyone reading the code that I
>> wanted strings converted to floating point before the addition.
>>
>> As has been pointed out, the plus operator if used to concatenate does not
>> have a cognate for other operations like -*/ and R has used most other
>> special symbols for other purposes. So, sure, we can use something like ....
>> (4 periods) if it is not already being used for something but using + here
>> is a tad confusing. Having said that, the makers of Python did make that
>> choice.
>>
>> -----Original Message-----
>> From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Gabriel Becker
>> Sent: Monday, December 6, 2021 7:21 PM
>> To: Bill Dunlap <williamwdunlap at gmail.com>
>> Cc: Radford Neal <radford at cs.toronto.edu>; r-devel <r-devel at r-project.org>
>> Subject: Re: [Rd] string concatenation operator (revisited)
>>
>> As I recall, there was a large discussion related to that which resulted in
>> the recycle0 argument being added (but defaulting to FALSE) for
>> paste/paste0.
>>
>> I think a lot of these things ultimately mean that if there were to be a
>> string concatenation operator, it probably shouldn't have behavior identical
>> to paste0. Was that what you were getting at as well, Bill?
>>
>> ~G
>>
>> On Mon, Dec 6, 2021 at 4:11 PM Bill Dunlap <williamwdunlap at gmail.com> wrote:
>>
>>> Should paste0(character(0), c("a","b")) give character(0)?
>>> There is a fair bit of code that assumes that paste("X",NULL) gives "X"
>>> but c(1,2)+NULL gives numeric(0).
>>>
>>> -Bill
>>>
>>> On Mon, Dec 6, 2021 at 1:32 PM Duncan Murdoch
>>> <murdoch.duncan at gmail.com>
>>> wrote:
>>>
>>>> On 06/12/2021 4:21 p.m., Avraham Adler wrote:
>>>>> Gabe, I agree that missingness is important to factor in. To
>>>>> somewhat
>>>> abuse
>>>>> the terminology, NA is often used to represent missingness. Perhaps
>>>>> concatenating character something with character something missing
>>>> should
>>>>> result in the original character?
>>>>
>>>> I think that's a bad idea.  If you wanted to represent an empty
>>>> string, you should use "" or NULL, not NA.
>>>>
>>>> I'd agree with Gabe, paste0("abc", NA) shouldn't give "abcNA", it
>>>> should give NA.
>>>>
>>>> Duncan Murdoch
>>>>
>>>>>
>>>>> Avi
>>>>>
>>>>> On Mon, Dec 6, 2021 at 3:35 PM Gabriel Becker
>>>>> <gabembecker at gmail.com>
>>>> wrote:
>>>>>
>>>>>> Hi All,
>>>>>>
>>>>>> Seeing this and the other thread (and admittedly not having
>>>>>> clicked
>>>> through
>>>>>> to the linked r-help thread), I wonder about NAs.
>>>>>>
>>>>>> Should NA <concat> "hi there"  not result in NA_character_? This
>>>>>> is not what any of the paste functions do, but in my opinoin, NA +
>>>> <non_na_value>
>>>>>> seems like it should be NA  (not "NA"), particularly if we are
>>>>>> talking about `+` overloading, but potentially even in the case of
>>>>>> a distinct concatenation operator?
>>>>>>
>>>>>> I guess what I'm saying is that in my head missingness propagation
>>>> rules
>>>>>> should take priority in such an operator (ie NA + <anything>
>>>>>> should *always * be NA).
>>>>>>
>>>>>> Is that something others disagree with, or has it just not come up
>>>>>> yet
>>>> in
>>>>>> (the parts I have read) of this discussion?
>>>>>>
>>>>>> Best,
>>>>>> ~G
>>>>>>
>>>>>> On Mon, Dec 6, 2021 at 10:03 AM Radford Neal
>>>>>> <radford at cs.toronto.edu>
>>>>>> wrote:
>>>>>>
>>>>>>>>> In pqR (see pqR-project.org), I have implemented ! and !! as
>>>>>>>>> binary string concatenation operators, equivalent to paste0 and
>>>>>>>>> paste, respectively.
>>>>>>>>>
>>>>>>>>> For instance,
>>>>>>>>>
>>>>>>>>>> "hello" ! "world"
>>>>>>>>>       [1] "helloworld"
>>>>>>>>>> "hello" !! "world"
>>>>>>>>>       [1] "hello world"
>>>>>>>>>> "hello" !! 1:4
>>>>>>>>>       [1] "hello 1" "hello 2" "hello 3" "hello 4"
>>>>>>>>
>>>>>>>> I'm curious about the details:
>>>>>>>>
>>>>>>>> Would `1 ! 2` convert both to strings?
>>>>>>>
>>>>>>> They're equivalent to paste0 and paste, so 1 ! 2 produces "12",
>>>>>>> just like paste0(1,2) does.  Of course, they wouldn't have to be
>>>>>>> exactly equivalent to paste0 and paste - one could impose
>>>>>>> stricter requirements if that seemed better for error detection.
>>>>>>> Off hand, though, I think automatically converting is more in
>>>>>>> keeping with the rest of R.  Explicitly converting with as.character
>> could be tedious.
>>>>>>>
>>>>>>> I suppose disallowing logical arguments might make sense to guard
>>>>>>> against typos where ! was meant to be the unary-not operator, but
>>>>>>> ended up being a binary operator, after some sort of typo.  I
>>>>>>> doubt that this would be a common error, though.
>>>>>>>
>>>>>>> (Note that there's no ambiguity when there are no typos, except
>>>>>>> that when negation is involved a space may be needed - so, for
>>>>>>> example, "x" !  !TRUE is "xFALSE", but "x"!!TRUE is "x TRUE".
>>>>>>> Existing uses of double negation are still fine - eg, a <- !!TRUE
>> still sets a to TRUE.
>>>>>>> Parsing of operators is greedy, so "x"!!!TRUE is "x FALSE", not
>>>> "xTRUE".)
>>>>>>>
>>>>>>>> Where does the binary ! fit in the operator priority?  E.g. how
>>>>>>>> is
>>>>>>>>
>>>>>>>>    a ! b > c
>>>>>>>>
>>>>>>>> parsed?
>>>>>>>
>>>>>>> As (a ! b) > c.
>>>>>>>
>>>>>>> Their precedence is between that of + and - and that of < and >.
>>>>>>> So "x" ! 1+2 evalates to "x3" and "x" ! 1+2 < "x4" is TRUE.
>>>>>>>
>>>>>>> (Actually, pqR also has a .. operator that fixes the problems
>>>>>>> with generating sequences with the : operator, and it has
>>>>>>> precedence lower than + and - and higher than ! and !!, but
>>>>>>> that's not relevant if you don't have the .. operator.)
>>>>>>>
>>>>>>>     Radford Neal
>>>>>>>
>>>>>>> ______________________________________________
>>>>>>> R-devel at r-project.org mailing list
>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>>
>>>>>>
>>>>>>          [[alternative HTML version deleted]]
>>>>>>
>>>>>> ______________________________________________
>>>>>> R-devel at r-project.org mailing list
>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>
>>>>
>>>> ______________________________________________
>>>> R-devel at r-project.org mailing list
>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>
>>>
>>
>> 	[[alternative HTML version deleted]]
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
>


From @|mon@urb@nek @end|ng |rom R-project@org  Tue Dec  7 12:06:13 2021
From: @|mon@urb@nek @end|ng |rom R-project@org (Simon Urbanek)
Date: Wed, 8 Dec 2021 00:06:13 +1300
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <7CA551D8-3636-4E03-AF4C-0BDD4F5FB9F4@uzh.ch>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
 <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
 <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
 <010101d7eb09$8c0156d0$a4040470$@verizon.net>
 <7CA551D8-3636-4E03-AF4C-0BDD4F5FB9F4@uzh.ch>
Message-ID: <921415D6-E68C-41EE-A836-25B30668A00C@R-project.org>



> On Dec 7, 2021, at 22:09, Taras Zakharko <taras.zakharko at uzh.ch> wrote:
> 
> Great summary, Avi. 
> 
> String concatenation cold be trivially added to R, but it probably should not be. You will notice that modern languages tend not to use ?+? to do string concatenation (they either have 
> a custom operator or a special kind of pattern to do it) due to practical issues such an approach brings (implicit type casting, lack of commutativity, performance etc.). These issues will be felt even more so in R with it?s weak typing, idiosyncratic casting behavior and NAs. 
> 
> As other?s have pointed out, any kind of behavior one wants from string concatenation can be implemented by custom operators as needed. This is not something that needs to be in the base R. I would rather like the efforts to be directed on improving string formatting (such as glue-style built-in string interpolation).
> 

This is getting OT, but there is a very good reason why string interpolation is not in core R. As I recall it has been considered some time ago, but it is very dangerous as it implies evaluation on constants which opens a huge security hole and has questionable semantics (where you evaluate etc). Hence it's much easier to ban a package than to hack it out of R ;).

Cheers,
Simon


> ? Taras
> 
> 
>> On 7 Dec 2021, at 02:27, Avi Gross via R-devel <r-devel at r-project.org> wrote:
>> 
>> After seeing what others are saying, it is clear that you need to carefully
>> think things out before designing any implementation of a more native
>> concatenation operator whether it is called "+' or anything else. There may
>> not be any ONE right solution but unlike a function version like paste()
>> there is nowhere to place any options that specify what you mean.
>> 
>> You can obviously expand paste() to accept arguments like replace.NA="" or
>> replace.NA="<NA>" and similar arguments on what to do if you see a NaN, and
>> Inf or -Inf, a NULL or even an NA.character_ and so on. Heck, you might tell
>> to make other substitutions as in substitute=list(100=99, D=F) or any other
>> nonsense you can come up with.
>> 
>> But you have nowhere to put options when saying:
>> 
>> c <- a + b
>> 
>> Sure, you could set various global options before the addition and maybe
>> rest them after, but that is not a way I like to go for something this
>> basic.
>> 
>> And enough such tinkering makes me wonder if it is easier to ask a user to
>> use a slightly different function like this:
>> 
>> paste.no.na <- function(...) do.call(paste, Filter(Negate(is.na),
>> list(...)))
>> 
>> The above one-line function removes any NA from the argument list to make a
>> potentially shorter list before calling the real paste() using it.
>> 
>> Variations can, of course, be made that allow functionality as above. 
>> 
>> If R was a true object-oriented language in the same sense as others like
>> Python, operator overloading of "+" might be doable in more complex ways but
>> we can only work with what we have. I tend to agree with others that in some
>> places R is so lenient that all kinds of errors can happen because it makes
>> a guess on how to correct it. Generally, if you really want to mix numeric
>> and character, many languages require you to transform any arguments to make
>> all of compatible types. The paste() function is clearly stated to coerce
>> all arguments to be of type character for you. Whereas a+b makes no such
>> promises and also is not properly defined even if a and b are both of type
>> character. Sure, we can expand the language but it may still do things some
>> find not to be quite what they wanted as in "2"+"3" becoming "23" rather
>> than 5. Right now, I can use as.numeric("2")+as.numeric("3") and get the
>> intended result after making very clear to anyone reading the code that I
>> wanted strings converted to floating point before the addition.
>> 
>> As has been pointed out, the plus operator if used to concatenate does not
>> have a cognate for other operations like -*/ and R has used most other
>> special symbols for other purposes. So, sure, we can use something like ....
>> (4 periods) if it is not already being used for something but using + here
>> is a tad confusing. Having said that, the makers of Python did make that
>> choice.
>> 
>> -----Original Message-----
>> From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Gabriel Becker
>> Sent: Monday, December 6, 2021 7:21 PM
>> To: Bill Dunlap <williamwdunlap at gmail.com>
>> Cc: Radford Neal <radford at cs.toronto.edu>; r-devel <r-devel at r-project.org>
>> Subject: Re: [Rd] string concatenation operator (revisited)
>> 
>> As I recall, there was a large discussion related to that which resulted in
>> the recycle0 argument being added (but defaulting to FALSE) for
>> paste/paste0.
>> 
>> I think a lot of these things ultimately mean that if there were to be a
>> string concatenation operator, it probably shouldn't have behavior identical
>> to paste0. Was that what you were getting at as well, Bill?
>> 
>> ~G
>> 
>> On Mon, Dec 6, 2021 at 4:11 PM Bill Dunlap <williamwdunlap at gmail.com> wrote:
>> 
>>> Should paste0(character(0), c("a","b")) give character(0)?
>>> There is a fair bit of code that assumes that paste("X",NULL) gives "X"
>>> but c(1,2)+NULL gives numeric(0).
>>> 
>>> -Bill
>>> 
>>> On Mon, Dec 6, 2021 at 1:32 PM Duncan Murdoch 
>>> <murdoch.duncan at gmail.com>
>>> wrote:
>>> 
>>>> On 06/12/2021 4:21 p.m., Avraham Adler wrote:
>>>>> Gabe, I agree that missingness is important to factor in. To 
>>>>> somewhat
>>>> abuse
>>>>> the terminology, NA is often used to represent missingness. Perhaps 
>>>>> concatenating character something with character something missing
>>>> should
>>>>> result in the original character?
>>>> 
>>>> I think that's a bad idea.  If you wanted to represent an empty 
>>>> string, you should use "" or NULL, not NA.
>>>> 
>>>> I'd agree with Gabe, paste0("abc", NA) shouldn't give "abcNA", it 
>>>> should give NA.
>>>> 
>>>> Duncan Murdoch
>>>> 
>>>>> 
>>>>> Avi
>>>>> 
>>>>> On Mon, Dec 6, 2021 at 3:35 PM Gabriel Becker 
>>>>> <gabembecker at gmail.com>
>>>> wrote:
>>>>> 
>>>>>> Hi All,
>>>>>> 
>>>>>> Seeing this and the other thread (and admittedly not having 
>>>>>> clicked
>>>> through
>>>>>> to the linked r-help thread), I wonder about NAs.
>>>>>> 
>>>>>> Should NA <concat> "hi there"  not result in NA_character_? This 
>>>>>> is not what any of the paste functions do, but in my opinoin, NA +
>>>> <non_na_value>
>>>>>> seems like it should be NA  (not "NA"), particularly if we are 
>>>>>> talking about `+` overloading, but potentially even in the case of 
>>>>>> a distinct concatenation operator?
>>>>>> 
>>>>>> I guess what I'm saying is that in my head missingness propagation
>>>> rules
>>>>>> should take priority in such an operator (ie NA + <anything> 
>>>>>> should *always * be NA).
>>>>>> 
>>>>>> Is that something others disagree with, or has it just not come up 
>>>>>> yet
>>>> in
>>>>>> (the parts I have read) of this discussion?
>>>>>> 
>>>>>> Best,
>>>>>> ~G
>>>>>> 
>>>>>> On Mon, Dec 6, 2021 at 10:03 AM Radford Neal 
>>>>>> <radford at cs.toronto.edu>
>>>>>> wrote:
>>>>>> 
>>>>>>>>> In pqR (see pqR-project.org), I have implemented ! and !! as 
>>>>>>>>> binary string concatenation operators, equivalent to paste0 and 
>>>>>>>>> paste, respectively.
>>>>>>>>> 
>>>>>>>>> For instance,
>>>>>>>>> 
>>>>>>>>>> "hello" ! "world"
>>>>>>>>>     [1] "helloworld"
>>>>>>>>>> "hello" !! "world"
>>>>>>>>>     [1] "hello world"
>>>>>>>>>> "hello" !! 1:4
>>>>>>>>>     [1] "hello 1" "hello 2" "hello 3" "hello 4"
>>>>>>>> 
>>>>>>>> I'm curious about the details:
>>>>>>>> 
>>>>>>>> Would `1 ! 2` convert both to strings?
>>>>>>> 
>>>>>>> They're equivalent to paste0 and paste, so 1 ! 2 produces "12", 
>>>>>>> just like paste0(1,2) does.  Of course, they wouldn't have to be 
>>>>>>> exactly equivalent to paste0 and paste - one could impose 
>>>>>>> stricter requirements if that seemed better for error detection.  
>>>>>>> Off hand, though, I think automatically converting is more in 
>>>>>>> keeping with the rest of R.  Explicitly converting with as.character
>> could be tedious.
>>>>>>> 
>>>>>>> I suppose disallowing logical arguments might make sense to guard 
>>>>>>> against typos where ! was meant to be the unary-not operator, but 
>>>>>>> ended up being a binary operator, after some sort of typo.  I 
>>>>>>> doubt that this would be a common error, though.
>>>>>>> 
>>>>>>> (Note that there's no ambiguity when there are no typos, except 
>>>>>>> that when negation is involved a space may be needed - so, for 
>>>>>>> example, "x" !  !TRUE is "xFALSE", but "x"!!TRUE is "x TRUE".  
>>>>>>> Existing uses of double negation are still fine - eg, a <- !!TRUE
>> still sets a to TRUE.
>>>>>>> Parsing of operators is greedy, so "x"!!!TRUE is "x FALSE", not
>>>> "xTRUE".)
>>>>>>> 
>>>>>>>> Where does the binary ! fit in the operator priority?  E.g. how 
>>>>>>>> is
>>>>>>>> 
>>>>>>>>  a ! b > c
>>>>>>>> 
>>>>>>>> parsed?
>>>>>>> 
>>>>>>> As (a ! b) > c.
>>>>>>> 
>>>>>>> Their precedence is between that of + and - and that of < and >.
>>>>>>> So "x" ! 1+2 evalates to "x3" and "x" ! 1+2 < "x4" is TRUE.
>>>>>>> 
>>>>>>> (Actually, pqR also has a .. operator that fixes the problems 
>>>>>>> with generating sequences with the : operator, and it has 
>>>>>>> precedence lower than + and - and higher than ! and !!, but 
>>>>>>> that's not relevant if you don't have the .. operator.)
>>>>>>> 
>>>>>>>   Radford Neal
>>>>>>> 
>>>>>>> ______________________________________________
>>>>>>> R-devel at r-project.org mailing list 
>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>> 
>>>>>> 
>>>>>>        [[alternative HTML version deleted]]
>>>>>> 
>>>>>> ______________________________________________
>>>>>> R-devel at r-project.org mailing list 
>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>> 
>>>> 
>>>> ______________________________________________
>>>> R-devel at r-project.org mailing list
>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>> 
>>> 
>> 
>> 	[[alternative HTML version deleted]]
>> 
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>> 
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 


From t@r@@@z@kh@rko @end|ng |rom uzh@ch  Tue Dec  7 12:56:30 2021
From: t@r@@@z@kh@rko @end|ng |rom uzh@ch (Taras Zakharko)
Date: Tue, 7 Dec 2021 12:56:30 +0100
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <921415D6-E68C-41EE-A836-25B30668A00C@R-project.org>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
 <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
 <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
 <010101d7eb09$8c0156d0$a4040470$@verizon.net>
 <7CA551D8-3636-4E03-AF4C-0BDD4F5FB9F4@uzh.ch>
 <921415D6-E68C-41EE-A836-25B30668A00C@R-project.org>
Message-ID: <F8A25DDA-EB48-46EB-8D4E-04783E7F5731@uzh.ch>

I fully agree! General string interpolation opens a gaping security hole and is accompanied by all kinds of problems and decisions. What I envision instead is something like this:

   f?hello {name}? 

Which gets parsed by R to this:

   (STRINTERPSXP (CHARSXP (PROMISE nil)))

Basically, a new type of R language construct that still can be processed by packages (for customized interpolation like in cli etc.), with a default eval which is basically paste0(). The benefit here would be that this is eagerly parsed and syntactically checked, and that the promise code could carry a srcref. And of course, that you could pass an interpolated string expression lazily between frames without losing the environment etc? For more advanced applications, a low level string interpolation expression constructor could be provided (that could either parse a general string ? at the user?s risk, or build it directly from expressions). 

? Taras


> On 7 Dec 2021, at 12:06, Simon Urbanek <simon.urbanek at R-project.org> wrote:
> 
> 
> 
>> On Dec 7, 2021, at 22:09, Taras Zakharko <taras.zakharko at uzh.ch <mailto:taras.zakharko at uzh.ch>> wrote:
>> 
>> Great summary, Avi. 
>> 
>> String concatenation cold be trivially added to R, but it probably should not be. You will notice that modern languages tend not to use ?+? to do string concatenation (they either have 
>> a custom operator or a special kind of pattern to do it) due to practical issues such an approach brings (implicit type casting, lack of commutativity, performance etc.). These issues will be felt even more so in R with it?s weak typing, idiosyncratic casting behavior and NAs. 
>> 
>> As other?s have pointed out, any kind of behavior one wants from string concatenation can be implemented by custom operators as needed. This is not something that needs to be in the base R. I would rather like the efforts to be directed on improving string formatting (such as glue-style built-in string interpolation).
>> 
> 
> This is getting OT, but there is a very good reason why string interpolation is not in core R. As I recall it has been considered some time ago, but it is very dangerous as it implies evaluation on constants which opens a huge security hole and has questionable semantics (where you evaluate etc). Hence it's much easier to ban a package than to hack it out of R ;).
> 
> Cheers,
> Simon
> 
> 
>> ? Taras
>> 
>> 
>>> On 7 Dec 2021, at 02:27, Avi Gross via R-devel <r-devel at r-project.org> wrote:
>>> 
>>> After seeing what others are saying, it is clear that you need to carefully
>>> think things out before designing any implementation of a more native
>>> concatenation operator whether it is called "+' or anything else. There may
>>> not be any ONE right solution but unlike a function version like paste()
>>> there is nowhere to place any options that specify what you mean.
>>> 
>>> You can obviously expand paste() to accept arguments like replace.NA="" or
>>> replace.NA="<NA>" and similar arguments on what to do if you see a NaN, and
>>> Inf or -Inf, a NULL or even an NA.character_ and so on. Heck, you might tell
>>> to make other substitutions as in substitute=list(100=99, D=F) or any other
>>> nonsense you can come up with.
>>> 
>>> But you have nowhere to put options when saying:
>>> 
>>> c <- a + b
>>> 
>>> Sure, you could set various global options before the addition and maybe
>>> rest them after, but that is not a way I like to go for something this
>>> basic.
>>> 
>>> And enough such tinkering makes me wonder if it is easier to ask a user to
>>> use a slightly different function like this:
>>> 
>>> paste.no.na <- function(...) do.call(paste, Filter(Negate(is.na),
>>> list(...)))
>>> 
>>> The above one-line function removes any NA from the argument list to make a
>>> potentially shorter list before calling the real paste() using it.
>>> 
>>> Variations can, of course, be made that allow functionality as above. 
>>> 
>>> If R was a true object-oriented language in the same sense as others like
>>> Python, operator overloading of "+" might be doable in more complex ways but
>>> we can only work with what we have. I tend to agree with others that in some
>>> places R is so lenient that all kinds of errors can happen because it makes
>>> a guess on how to correct it. Generally, if you really want to mix numeric
>>> and character, many languages require you to transform any arguments to make
>>> all of compatible types. The paste() function is clearly stated to coerce
>>> all arguments to be of type character for you. Whereas a+b makes no such
>>> promises and also is not properly defined even if a and b are both of type
>>> character. Sure, we can expand the language but it may still do things some
>>> find not to be quite what they wanted as in "2"+"3" becoming "23" rather
>>> than 5. Right now, I can use as.numeric("2")+as.numeric("3") and get the
>>> intended result after making very clear to anyone reading the code that I
>>> wanted strings converted to floating point before the addition.
>>> 
>>> As has been pointed out, the plus operator if used to concatenate does not
>>> have a cognate for other operations like -*/ and R has used most other
>>> special symbols for other purposes. So, sure, we can use something like ....
>>> (4 periods) if it is not already being used for something but using + here
>>> is a tad confusing. Having said that, the makers of Python did make that
>>> choice.
>>> 
>>> -----Original Message-----
>>> From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Gabriel Becker
>>> Sent: Monday, December 6, 2021 7:21 PM
>>> To: Bill Dunlap <williamwdunlap at gmail.com>
>>> Cc: Radford Neal <radford at cs.toronto.edu>; r-devel <r-devel at r-project.org>
>>> Subject: Re: [Rd] string concatenation operator (revisited)
>>> 
>>> As I recall, there was a large discussion related to that which resulted in
>>> the recycle0 argument being added (but defaulting to FALSE) for
>>> paste/paste0.
>>> 
>>> I think a lot of these things ultimately mean that if there were to be a
>>> string concatenation operator, it probably shouldn't have behavior identical
>>> to paste0. Was that what you were getting at as well, Bill?
>>> 
>>> ~G
>>> 
>>> On Mon, Dec 6, 2021 at 4:11 PM Bill Dunlap <williamwdunlap at gmail.com> wrote:
>>> 
>>>> Should paste0(character(0), c("a","b")) give character(0)?
>>>> There is a fair bit of code that assumes that paste("X",NULL) gives "X"
>>>> but c(1,2)+NULL gives numeric(0).
>>>> 
>>>> -Bill
>>>> 
>>>> On Mon, Dec 6, 2021 at 1:32 PM Duncan Murdoch 
>>>> <murdoch.duncan at gmail.com>
>>>> wrote:
>>>> 
>>>>> On 06/12/2021 4:21 p.m., Avraham Adler wrote:
>>>>>> Gabe, I agree that missingness is important to factor in. To 
>>>>>> somewhat
>>>>> abuse
>>>>>> the terminology, NA is often used to represent missingness. Perhaps 
>>>>>> concatenating character something with character something missing
>>>>> should
>>>>>> result in the original character?
>>>>> 
>>>>> I think that's a bad idea.  If you wanted to represent an empty 
>>>>> string, you should use "" or NULL, not NA.
>>>>> 
>>>>> I'd agree with Gabe, paste0("abc", NA) shouldn't give "abcNA", it 
>>>>> should give NA.
>>>>> 
>>>>> Duncan Murdoch
>>>>> 
>>>>>> 
>>>>>> Avi
>>>>>> 
>>>>>> On Mon, Dec 6, 2021 at 3:35 PM Gabriel Becker 
>>>>>> <gabembecker at gmail.com>
>>>>> wrote:
>>>>>> 
>>>>>>> Hi All,
>>>>>>> 
>>>>>>> Seeing this and the other thread (and admittedly not having 
>>>>>>> clicked
>>>>> through
>>>>>>> to the linked r-help thread), I wonder about NAs.
>>>>>>> 
>>>>>>> Should NA <concat> "hi there"  not result in NA_character_? This 
>>>>>>> is not what any of the paste functions do, but in my opinoin, NA +
>>>>> <non_na_value>
>>>>>>> seems like it should be NA  (not "NA"), particularly if we are 
>>>>>>> talking about `+` overloading, but potentially even in the case of 
>>>>>>> a distinct concatenation operator?
>>>>>>> 
>>>>>>> I guess what I'm saying is that in my head missingness propagation
>>>>> rules
>>>>>>> should take priority in such an operator (ie NA + <anything> 
>>>>>>> should *always * be NA).
>>>>>>> 
>>>>>>> Is that something others disagree with, or has it just not come up 
>>>>>>> yet
>>>>> in
>>>>>>> (the parts I have read) of this discussion?
>>>>>>> 
>>>>>>> Best,
>>>>>>> ~G
>>>>>>> 
>>>>>>> On Mon, Dec 6, 2021 at 10:03 AM Radford Neal 
>>>>>>> <radford at cs.toronto.edu>
>>>>>>> wrote:
>>>>>>> 
>>>>>>>>>> In pqR (see pqR-project.org), I have implemented ! and !! as 
>>>>>>>>>> binary string concatenation operators, equivalent to paste0 and 
>>>>>>>>>> paste, respectively.
>>>>>>>>>> 
>>>>>>>>>> For instance,
>>>>>>>>>> 
>>>>>>>>>>> "hello" ! "world"
>>>>>>>>>>    [1] "helloworld"
>>>>>>>>>>> "hello" !! "world"
>>>>>>>>>>    [1] "hello world"
>>>>>>>>>>> "hello" !! 1:4
>>>>>>>>>>    [1] "hello 1" "hello 2" "hello 3" "hello 4"
>>>>>>>>> 
>>>>>>>>> I'm curious about the details:
>>>>>>>>> 
>>>>>>>>> Would `1 ! 2` convert both to strings?
>>>>>>>> 
>>>>>>>> They're equivalent to paste0 and paste, so 1 ! 2 produces "12", 
>>>>>>>> just like paste0(1,2) does.  Of course, they wouldn't have to be 
>>>>>>>> exactly equivalent to paste0 and paste - one could impose 
>>>>>>>> stricter requirements if that seemed better for error detection.  
>>>>>>>> Off hand, though, I think automatically converting is more in 
>>>>>>>> keeping with the rest of R.  Explicitly converting with as.character
>>> could be tedious.
>>>>>>>> 
>>>>>>>> I suppose disallowing logical arguments might make sense to guard 
>>>>>>>> against typos where ! was meant to be the unary-not operator, but 
>>>>>>>> ended up being a binary operator, after some sort of typo.  I 
>>>>>>>> doubt that this would be a common error, though.
>>>>>>>> 
>>>>>>>> (Note that there's no ambiguity when there are no typos, except 
>>>>>>>> that when negation is involved a space may be needed - so, for 
>>>>>>>> example, "x" !  !TRUE is "xFALSE", but "x"!!TRUE is "x TRUE".  
>>>>>>>> Existing uses of double negation are still fine - eg, a <- !!TRUE
>>> still sets a to TRUE.
>>>>>>>> Parsing of operators is greedy, so "x"!!!TRUE is "x FALSE", not
>>>>> "xTRUE".)
>>>>>>>> 
>>>>>>>>> Where does the binary ! fit in the operator priority?  E.g. how 
>>>>>>>>> is
>>>>>>>>> 
>>>>>>>>> a ! b > c
>>>>>>>>> 
>>>>>>>>> parsed?
>>>>>>>> 
>>>>>>>> As (a ! b) > c.
>>>>>>>> 
>>>>>>>> Their precedence is between that of + and - and that of < and >.
>>>>>>>> So "x" ! 1+2 evalates to "x3" and "x" ! 1+2 < "x4" is TRUE.
>>>>>>>> 
>>>>>>>> (Actually, pqR also has a .. operator that fixes the problems 
>>>>>>>> with generating sequences with the : operator, and it has 
>>>>>>>> precedence lower than + and - and higher than ! and !!, but 
>>>>>>>> that's not relevant if you don't have the .. operator.)
>>>>>>>> 
>>>>>>>>  Radford Neal
>>>>>>>> 
>>>>>>>> ______________________________________________
>>>>>>>> R-devel at r-project.org mailing list 
>>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>>> 
>>>>>>> 
>>>>>>>       [[alternative HTML version deleted]]
>>>>>>> 
>>>>>>> ______________________________________________
>>>>>>> R-devel at r-project.org mailing list 
>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>> 
>>>>> 
>>>>> ______________________________________________
>>>>> R-devel at r-project.org mailing list
>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>> 
>>>> 
>>> 
>>> 	[[alternative HTML version deleted]]
>>> 
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>> 
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>> 
>> ______________________________________________
>> R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel <https://stat.ethz.ch/mailman/listinfo/r-devel>

	[[alternative HTML version deleted]]


From Thom@@@SOEIRO @end|ng |rom @p-hm@|r  Tue Dec  7 14:21:04 2021
From: Thom@@@SOEIRO @end|ng |rom @p-hm@|r (SOEIRO Thomas)
Date: Tue, 7 Dec 2021 13:21:04 +0000
Subject: [Rd] Documentation of addmargins
Message-ID: <5fc9ba4689ea495786a23d5b51781002@SCWPR-EXDAG1-6A.aphm.ap-hm.fr>

Dear list,

There is a minor typo in addmargins (section Details):

- If the functions used to form margins are not commutative the result depends on the order in which margins are computed. Annotation of margins is done via naming the FUN list.
+ If the functions used to form margins are not commutative**add ':' or ', i.e.' here** the result depends on the order in which margins are computed. Annotation of margins is done via naming the FUN list.


I'm not sure if such minor things really need to be reported when they are noticed... Please let me know if not. Of course this is minor, but imho one of the strengths of R is also its documentation!

Best,

Thomas


From Andre@G||||bert @end|ng |rom chu-rouen@|r  Tue Dec  7 16:59:08 2021
From: Andre@G||||bert @end|ng |rom chu-rouen@|r (GILLIBERT, Andre)
Date: Tue, 7 Dec 2021 15:59:08 +0000
Subject: [Rd] Documentation of addmargins
In-Reply-To: <5fc9ba4689ea495786a23d5b51781002@SCWPR-EXDAG1-6A.aphm.ap-hm.fr>
References: <5fc9ba4689ea495786a23d5b51781002@SCWPR-EXDAG1-6A.aphm.ap-hm.fr>
Message-ID: <588ee29d2a0047b8807a9f0451aeae0b@chu-rouen.fr>


Thomas SOEIRO wrote:
> Dear list,

> There is a minor typo in addmargins (section Details):

> - If the functions used to form margins are not commutative the result depends on the order in which margins are computed. Annotation of margins is done via naming the FUN list.
> + If the functions used to form margins are not commutative**add ':' or ', i.e.' here** the result depends on the order in which margins are computed. Annotation of margins is done via naming the FUN list.
>
>
> I'm not sure if such minor things really need to be reported when they are noticed... Please let me know if not. Of course this is minor, but imho one of the strengths of R is also its documentation!
>

The documentation looks correct to me.
If the function FUN is not commutative (i.e. the result depends on the order of the vector passed to it), then the result of addmargins() will depend on the order of the 'margin' argument to the addmargins() function.

For instance:
mat <- rbind(c(1,10),c(100,1000))
fun <- function(x) {x[1]-x[2]-x[1]*x[2]} # non-commutative function
a <- addmargins(mat ,margin=c(1,2), FUN=fun)
b <- addmargins(mat ,margin=c(2,1), FUN=fun)

a and b are different, because the fun function is not commutative.

-- 
Sincerely
Andr? GILLIBERT

From Thom@@@SOEIRO @end|ng |rom @p-hm@|r  Tue Dec  7 17:01:18 2021
From: Thom@@@SOEIRO @end|ng |rom @p-hm@|r (SOEIRO Thomas)
Date: Tue, 7 Dec 2021 16:01:18 +0000
Subject: [Rd] Documentation of addmargins
In-Reply-To: <588ee29d2a0047b8807a9f0451aeae0b@chu-rouen.fr>
References: <5fc9ba4689ea495786a23d5b51781002@SCWPR-EXDAG1-6A.aphm.ap-hm.fr>
 <588ee29d2a0047b8807a9f0451aeae0b@chu-rouen.fr>
Message-ID: <768a3b50cc2442939fbd381cf2779ec6@SCWPR-EXDAG1-6A.aphm.ap-hm.fr>

Yes, it is!

There is only a small typo (missing punctuation for easier reading)

Sorry for the misunderstanding, it may not be clear enough in my previous mail.

-----Message d'origine-----
De?: GILLIBERT, Andre [mailto:Andre.Gillibert at chu-rouen.fr] 
Envoy??: mardi 7 d?cembre 2021 16:59
??: SOEIRO Thomas; R Development List
Objet?: RE: Documentation of addmargins

EMAIL EXTERNE - TRAITER AVEC PR?CAUTION LIENS ET FICHIERS

Thomas SOEIRO wrote:
> Dear list,

> There is a minor typo in addmargins (section Details):

> - If the functions used to form margins are not commutative the result depends on the order in which margins are computed. Annotation of margins is done via naming the FUN list.
> + If the functions used to form margins are not commutative**add ':' or ', i.e.' here** the result depends on the order in which margins are computed. Annotation of margins is done via naming the FUN list.
>
>
> I'm not sure if such minor things really need to be reported when they are noticed... Please let me know if not. Of course this is minor, but imho one of the strengths of R is also its documentation!
>

The documentation looks correct to me.
If the function FUN is not commutative (i.e. the result depends on the order of the vector passed to it), then the result of addmargins() will depend on the order of the 'margin' argument to the addmargins() function.

For instance:
mat <- rbind(c(1,10),c(100,1000))
fun <- function(x) {x[1]-x[2]-x[1]*x[2]} # non-commutative function a <- addmargins(mat ,margin=c(1,2), FUN=fun) b <- addmargins(mat ,margin=c(2,1), FUN=fun)

a and b are different, because the fun function is not commutative.

--
Sincerely
Andr? GILLIBERT

From edd @end|ng |rom deb|@n@org  Tue Dec  7 17:48:59 2021
From: edd @end|ng |rom deb|@n@org (Dirk Eddelbuettel)
Date: Tue, 7 Dec 2021 10:48:59 -0600
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <921415D6-E68C-41EE-A836-25B30668A00C@R-project.org>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
 <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
 <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
 <010101d7eb09$8c0156d0$a4040470$@verizon.net>
 <7CA551D8-3636-4E03-AF4C-0BDD4F5FB9F4@uzh.ch>
 <921415D6-E68C-41EE-A836-25B30668A00C@R-project.org>
Message-ID: <25007.36987.625028.288350@rob.eddelbuettel.com>


On 8 December 2021 at 00:06, Simon Urbanek wrote:
| Hence it's much easier to ban a package than to hack it out of R ;).

Paging Achim for suggested `fortunes` inclusion.

Dirk

-- 
https://dirk.eddelbuettel.com | @eddelbuettel | edd at debian.org


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Tue Dec  7 18:35:00 2021
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Tue, 7 Dec 2021 18:35:00 +0100
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <F8A25DDA-EB48-46EB-8D4E-04783E7F5731@uzh.ch>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
 <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
 <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
 <010101d7eb09$8c0156d0$a4040470$@verizon.net>
 <7CA551D8-3636-4E03-AF4C-0BDD4F5FB9F4@uzh.ch>
 <921415D6-E68C-41EE-A836-25B30668A00C@R-project.org>
 <F8A25DDA-EB48-46EB-8D4E-04783E7F5731@uzh.ch>
Message-ID: <25007.39748.476241.17592@stat.math.ethz.ch>

>>>>> Taras Zakharko 
>>>>>     on Tue, 7 Dec 2021 12:56:30 +0100 writes:

    > I fully agree! General string interpolation opens a gaping security hole and is accompanied by all kinds of problems and decisions. What I envision instead is something like this:
    > f?hello {name}? 

    > Which gets parsed by R to this:

    > (STRINTERPSXP (CHARSXP (PROMISE nil)))

    > Basically, a new type of R language construct that still can be processed by packages (for customized interpolation like in cli etc.), with a default eval which is basically paste0(). The benefit here would be that this is eagerly parsed and syntactically checked, and that the promise code could carry a srcref. And of course, that you could pass an interpolated string expression lazily between frames without losing the environment etc? For more advanced applications, a low level string interpolation expression constructor could be provided (that could either parse a general string ? at the user?s risk, or build it directly from expressions). 

    > ? Taras

Well, many months ago, R's  NEWS (for R-devel, then became R 4.0.0)
contained

    * There is a new syntax for specifying _raw_ character constants
      similar to the one used in C++: r"(...)" with ... any character
      sequence not containing the sequence )".  This makes it easier to
      write strings that contain backslashes or both single and double
      quotes.  For more details see ?Quotes.

This should be pretty close to what you propose above
(well, you need to replace your UTF-8 forward double quotes by
ASCII ones),
no ?

    >> On 7 Dec 2021, at 12:06, Simon Urbanek <simon.urbanek at R-project.org> wrote:
    >> 
    >> 
    >> 
    >>> On Dec 7, 2021, at 22:09, Taras Zakharko <taras.zakharko at uzh.ch <mailto:taras.zakharko at uzh.ch>> wrote:
    >>> 
    >>> Great summary, Avi. 
    >>> 
    >>> String concatenation cold be trivially added to R, but it probably should not be. You will notice that modern languages tend not to use ?+? to do string concatenation (they either have 
    >>> a custom operator or a special kind of pattern to do it) due to practical issues such an approach brings (implicit type casting, lack of commutativity, performance etc.). These issues will be felt even more so in R with it?s weak typing, idiosyncratic casting behavior and NAs. 
    >>> 
    >>> As other?s have pointed out, any kind of behavior one wants from string concatenation can be implemented by custom operators as needed. This is not something that needs to be in the base R. I would rather like the efforts to be directed on improving string formatting (such as glue-style built-in string interpolation).
    >>> 
    >> 
    >> This is getting OT, but there is a very good reason why string interpolation is not in core R. As I recall it has been considered some time ago, but it is very dangerous as it implies evaluation on constants which opens a huge security hole and has questionable semantics (where you evaluate etc). Hence it's much easier to ban a package than to hack it out of R ;).
    >> 
    >> Cheers,
    >> Simon
    >> 
    >>> ? Taras

 [............]


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Tue Dec  7 18:37:40 2021
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Tue, 7 Dec 2021 18:37:40 +0100
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <25007.39748.476241.17592@stat.math.ethz.ch>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
 <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
 <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
 <010101d7eb09$8c0156d0$a4040470$@verizon.net>
 <7CA551D8-3636-4E03-AF4C-0BDD4F5FB9F4@uzh.ch>
 <921415D6-E68C-41EE-A836-25B30668A00C@R-project.org>
 <F8A25DDA-EB48-46EB-8D4E-04783E7F5731@uzh.ch>
 <25007.39748.476241.17592@stat.math.ethz.ch>
Message-ID: <25007.39908.493984.292262@stat.math.ethz.ch>

>>>>> Martin Maechler 
>>>>>     on Tue, 7 Dec 2021 18:35:00 +0100 writes:

>>>>> Taras Zakharko 
>>>>>     on Tue, 7 Dec 2021 12:56:30 +0100 writes:

    >> I fully agree! General string interpolation opens a gaping security hole and is accompanied by all kinds of problems and decisions. What I envision instead is something like this:
    >> f?hello {name}? 

    >> Which gets parsed by R to this:

    >> (STRINTERPSXP (CHARSXP (PROMISE nil)))

    >> Basically, a new type of R language construct that still can be processed by packages (for customized interpolation like in cli etc.), with a default eval which is basically paste0(). The benefit here would be that this is eagerly parsed and syntactically checked, and that the promise code could carry a srcref. And of course, that you could pass an interpolated string expression lazily between frames without losing the environment etc? For more advanced applications, a low level string interpolation expression constructor could be provided (that could either parse a general string ? at the user?s risk, or build it directly from expressions). 

    >> ? Taras

    > Well, many months ago, R's  NEWS (for R-devel, then became R 4.0.0)
    > contained

    > * There is a new syntax for specifying _raw_ character constants
    > similar to the one used in C++: r"(...)" with ... any character
    > sequence not containing the sequence )".  This makes it easier to
    > write strings that contain backslashes or both single and double
    > quotes.  For more details see ?Quotes.

    > This should be pretty close to what you propose above
    > (well, you need to replace your UTF-8 forward double quotes by
    > ASCII ones),
    > no ?

No it is not; sorry I'm not at full strength..
Martin


    >>> On 7 Dec 2021, at 12:06, Simon Urbanek <simon.urbanek at R-project.org> wrote:
    >>> 
    >>> 
    >>> 
    >>>> On Dec 7, 2021, at 22:09, Taras Zakharko <taras.zakharko at uzh.ch <mailto:taras.zakharko at uzh.ch>> wrote:
    >>>> 
    >>>> Great summary, Avi. 
    >>>> 
    >>>> String concatenation cold be trivially added to R, but it probably should not be. You will notice that modern languages tend not to use ?+? to do string concatenation (they either have 
    >>>> a custom operator or a special kind of pattern to do it) due to practical issues such an approach brings (implicit type casting, lack of commutativity, performance etc.). These issues will be felt even more so in R with it?s weak typing, idiosyncratic casting behavior and NAs. 
    >>>> 
    >>>> As other?s have pointed out, any kind of behavior one wants from string concatenation can be implemented by custom operators as needed. This is not something that needs to be in the base R. I would rather like the efforts to be directed on improving string formatting (such as glue-style built-in string interpolation).
    >>>> 
    >>> 
    >>> This is getting OT, but there is a very good reason why string interpolation is not in core R. As I recall it has been considered some time ago, but it is very dangerous as it implies evaluation on constants which opens a huge security hole and has questionable semantics (where you evaluate etc). Hence it's much easier to ban a package than to hack it out of R ;).
    >>> 
    >>> Cheers,
    >>> Simon
    >>> 
    >>>> ? Taras

    > [............]

    > ______________________________________________
    > R-devel at r-project.org mailing list
    > https://stat.ethz.ch/mailman/listinfo/r-devel


From @|mon@urb@nek @end|ng |rom R-project@org  Tue Dec  7 23:05:52 2021
From: @|mon@urb@nek @end|ng |rom R-project@org (Simon Urbanek)
Date: Wed, 8 Dec 2021 11:05:52 +1300
Subject: [Rd] String interpolation [Was: string concatenation operator
 (revisited)]
In-Reply-To: <F8A25DDA-EB48-46EB-8D4E-04783E7F5731@uzh.ch>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
 <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
 <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
 <010101d7eb09$8c0156d0$a4040470$@verizon.net>
 <7CA551D8-3636-4E03-AF4C-0BDD4F5FB9F4@uzh.ch>
 <921415D6-E68C-41EE-A836-25B30668A00C@R-project.org>
 <F8A25DDA-EB48-46EB-8D4E-04783E7F5731@uzh.ch>
Message-ID: <98866BE8-AA8B-45DC-85CB-D51AEE625533@R-project.org>

I don't think a custom type alone would work, because users would expect to use such string anywhere a regular string can be used, and that's where the problems start - the evaluation would have to happen at a point where it is not expected since we can assume today that CHAR() doesn't evaluate. If it's just construct that needs some function call to turn it into a real string, then that's (from user's perspective) no different than glue() so I don't think the users would see the benefit (admittedly, you could do a lot more with such internal type, but not sure if the complexity is worth it).

Cheers,
Simon



> On Dec 8, 2021, at 12:56 AM, Taras Zakharko <taras.zakharko at uzh.ch> wrote:
> 
> I fully agree! General string interpolation opens a gaping security hole and is accompanied by all kinds of problems and decisions. What I envision instead is something like this:
> 
>   f?hello {name}? 
> 
> Which gets parsed by R to this:
> 
>   (STRINTERPSXP (CHARSXP (PROMISE nil)))
> 
> Basically, a new type of R language construct that still can be processed by packages (for customized interpolation like in cli etc.), with a default eval which is basically paste0(). The benefit here would be that this is eagerly parsed and syntactically checked, and that the promise code could carry a srcref. And of course, that you could pass an interpolated string expression lazily between frames without losing the environment etc? For more advanced applications, a low level string interpolation expression constructor could be provided (that could either parse a general string ? at the user?s risk, or build it directly from expressions). 
> 
> ? Taras
> 
> 
>> On 7 Dec 2021, at 12:06, Simon Urbanek <simon.urbanek at R-project.org> wrote:
>> 
>> 
>> 
>>> On Dec 7, 2021, at 22:09, Taras Zakharko <taras.zakharko at uzh.ch <mailto:taras.zakharko at uzh.ch>> wrote:
>>> 
>>> Great summary, Avi. 
>>> 
>>> String concatenation cold be trivially added to R, but it probably should not be. You will notice that modern languages tend not to use ?+? to do string concatenation (they either have 
>>> a custom operator or a special kind of pattern to do it) due to practical issues such an approach brings (implicit type casting, lack of commutativity, performance etc.). These issues will be felt even more so in R with it?s weak typing, idiosyncratic casting behavior and NAs. 
>>> 
>>> As other?s have pointed out, any kind of behavior one wants from string concatenation can be implemented by custom operators as needed. This is not something that needs to be in the base R. I would rather like the efforts to be directed on improving string formatting (such as glue-style built-in string interpolation).
>>> 
>> 
>> This is getting OT, but there is a very good reason why string interpolation is not in core R. As I recall it has been considered some time ago, but it is very dangerous as it implies evaluation on constants which opens a huge security hole and has questionable semantics (where you evaluate etc). Hence it's much easier to ban a package than to hack it out of R ;).
>> 
>> Cheers,
>> Simon
>> 
>> 
>>> ? Taras
>>> 
>>> 
>>>> On 7 Dec 2021, at 02:27, Avi Gross via R-devel <r-devel at r-project.org> wrote:
>>>> 
>>>> After seeing what others are saying, it is clear that you need to carefully
>>>> think things out before designing any implementation of a more native
>>>> concatenation operator whether it is called "+' or anything else. There may
>>>> not be any ONE right solution but unlike a function version like paste()
>>>> there is nowhere to place any options that specify what you mean.
>>>> 
>>>> You can obviously expand paste() to accept arguments like replace.NA="" or
>>>> replace.NA="<NA>" and similar arguments on what to do if you see a NaN, and
>>>> Inf or -Inf, a NULL or even an NA.character_ and so on. Heck, you might tell
>>>> to make other substitutions as in substitute=list(100=99, D=F) or any other
>>>> nonsense you can come up with.
>>>> 
>>>> But you have nowhere to put options when saying:
>>>> 
>>>> c <- a + b
>>>> 
>>>> Sure, you could set various global options before the addition and maybe
>>>> rest them after, but that is not a way I like to go for something this
>>>> basic.
>>>> 
>>>> And enough such tinkering makes me wonder if it is easier to ask a user to
>>>> use a slightly different function like this:
>>>> 
>>>> paste.no.na <- function(...) do.call(paste, Filter(Negate(is.na),
>>>> list(...)))
>>>> 
>>>> The above one-line function removes any NA from the argument list to make a
>>>> potentially shorter list before calling the real paste() using it.
>>>> 
>>>> Variations can, of course, be made that allow functionality as above. 
>>>> 
>>>> If R was a true object-oriented language in the same sense as others like
>>>> Python, operator overloading of "+" might be doable in more complex ways but
>>>> we can only work with what we have. I tend to agree with others that in some
>>>> places R is so lenient that all kinds of errors can happen because it makes
>>>> a guess on how to correct it. Generally, if you really want to mix numeric
>>>> and character, many languages require you to transform any arguments to make
>>>> all of compatible types. The paste() function is clearly stated to coerce
>>>> all arguments to be of type character for you. Whereas a+b makes no such
>>>> promises and also is not properly defined even if a and b are both of type
>>>> character. Sure, we can expand the language but it may still do things some
>>>> find not to be quite what they wanted as in "2"+"3" becoming "23" rather
>>>> than 5. Right now, I can use as.numeric("2")+as.numeric("3") and get the
>>>> intended result after making very clear to anyone reading the code that I
>>>> wanted strings converted to floating point before the addition.
>>>> 
>>>> As has been pointed out, the plus operator if used to concatenate does not
>>>> have a cognate for other operations like -*/ and R has used most other
>>>> special symbols for other purposes. So, sure, we can use something like ....
>>>> (4 periods) if it is not already being used for something but using + here
>>>> is a tad confusing. Having said that, the makers of Python did make that
>>>> choice.
>>>> 
>>>> -----Original Message-----
>>>> From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Gabriel Becker
>>>> Sent: Monday, December 6, 2021 7:21 PM
>>>> To: Bill Dunlap <williamwdunlap at gmail.com>
>>>> Cc: Radford Neal <radford at cs.toronto.edu>; r-devel <r-devel at r-project.org>
>>>> Subject: Re: [Rd] string concatenation operator (revisited)
>>>> 
>>>> As I recall, there was a large discussion related to that which resulted in
>>>> the recycle0 argument being added (but defaulting to FALSE) for
>>>> paste/paste0.
>>>> 
>>>> I think a lot of these things ultimately mean that if there were to be a
>>>> string concatenation operator, it probably shouldn't have behavior identical
>>>> to paste0. Was that what you were getting at as well, Bill?
>>>> 
>>>> ~G
>>>> 
>>>> On Mon, Dec 6, 2021 at 4:11 PM Bill Dunlap <williamwdunlap at gmail.com> wrote:
>>>> 
>>>>> Should paste0(character(0), c("a","b")) give character(0)?
>>>>> There is a fair bit of code that assumes that paste("X",NULL) gives "X"
>>>>> but c(1,2)+NULL gives numeric(0).
>>>>> 
>>>>> -Bill
>>>>> 
>>>>> On Mon, Dec 6, 2021 at 1:32 PM Duncan Murdoch 
>>>>> <murdoch.duncan at gmail.com>
>>>>> wrote:
>>>>> 
>>>>>> On 06/12/2021 4:21 p.m., Avraham Adler wrote:
>>>>>>> Gabe, I agree that missingness is important to factor in. To 
>>>>>>> somewhat
>>>>>> abuse
>>>>>>> the terminology, NA is often used to represent missingness. Perhaps 
>>>>>>> concatenating character something with character something missing
>>>>>> should
>>>>>>> result in the original character?
>>>>>> 
>>>>>> I think that's a bad idea.  If you wanted to represent an empty 
>>>>>> string, you should use "" or NULL, not NA.
>>>>>> 
>>>>>> I'd agree with Gabe, paste0("abc", NA) shouldn't give "abcNA", it 
>>>>>> should give NA.
>>>>>> 
>>>>>> Duncan Murdoch
>>>>>> 
>>>>>>> 
>>>>>>> Avi
>>>>>>> 
>>>>>>> On Mon, Dec 6, 2021 at 3:35 PM Gabriel Becker 
>>>>>>> <gabembecker at gmail.com>
>>>>>> wrote:
>>>>>>> 
>>>>>>>> Hi All,
>>>>>>>> 
>>>>>>>> Seeing this and the other thread (and admittedly not having 
>>>>>>>> clicked
>>>>>> through
>>>>>>>> to the linked r-help thread), I wonder about NAs.
>>>>>>>> 
>>>>>>>> Should NA <concat> "hi there"  not result in NA_character_? This 
>>>>>>>> is not what any of the paste functions do, but in my opinoin, NA +
>>>>>> <non_na_value>
>>>>>>>> seems like it should be NA  (not "NA"), particularly if we are 
>>>>>>>> talking about `+` overloading, but potentially even in the case of 
>>>>>>>> a distinct concatenation operator?
>>>>>>>> 
>>>>>>>> I guess what I'm saying is that in my head missingness propagation
>>>>>> rules
>>>>>>>> should take priority in such an operator (ie NA + <anything> 
>>>>>>>> should *always * be NA).
>>>>>>>> 
>>>>>>>> Is that something others disagree with, or has it just not come up 
>>>>>>>> yet
>>>>>> in
>>>>>>>> (the parts I have read) of this discussion?
>>>>>>>> 
>>>>>>>> Best,
>>>>>>>> ~G
>>>>>>>> 
>>>>>>>> On Mon, Dec 6, 2021 at 10:03 AM Radford Neal 
>>>>>>>> <radford at cs.toronto.edu>
>>>>>>>> wrote:
>>>>>>>> 
>>>>>>>>>>> In pqR (see pqR-project.org), I have implemented ! and !! as 
>>>>>>>>>>> binary string concatenation operators, equivalent to paste0 and 
>>>>>>>>>>> paste, respectively.
>>>>>>>>>>> 
>>>>>>>>>>> For instance,
>>>>>>>>>>> 
>>>>>>>>>>>> "hello" ! "world"
>>>>>>>>>>>   [1] "helloworld"
>>>>>>>>>>>> "hello" !! "world"
>>>>>>>>>>>   [1] "hello world"
>>>>>>>>>>>> "hello" !! 1:4
>>>>>>>>>>>   [1] "hello 1" "hello 2" "hello 3" "hello 4"
>>>>>>>>>> 
>>>>>>>>>> I'm curious about the details:
>>>>>>>>>> 
>>>>>>>>>> Would `1 ! 2` convert both to strings?
>>>>>>>>> 
>>>>>>>>> They're equivalent to paste0 and paste, so 1 ! 2 produces "12", 
>>>>>>>>> just like paste0(1,2) does.  Of course, they wouldn't have to be 
>>>>>>>>> exactly equivalent to paste0 and paste - one could impose 
>>>>>>>>> stricter requirements if that seemed better for error detection.  
>>>>>>>>> Off hand, though, I think automatically converting is more in 
>>>>>>>>> keeping with the rest of R.  Explicitly converting with as.character
>>>> could be tedious.
>>>>>>>>> 
>>>>>>>>> I suppose disallowing logical arguments might make sense to guard 
>>>>>>>>> against typos where ! was meant to be the unary-not operator, but 
>>>>>>>>> ended up being a binary operator, after some sort of typo.  I 
>>>>>>>>> doubt that this would be a common error, though.
>>>>>>>>> 
>>>>>>>>> (Note that there's no ambiguity when there are no typos, except 
>>>>>>>>> that when negation is involved a space may be needed - so, for 
>>>>>>>>> example, "x" !  !TRUE is "xFALSE", but "x"!!TRUE is "x TRUE".  
>>>>>>>>> Existing uses of double negation are still fine - eg, a <- !!TRUE
>>>> still sets a to TRUE.
>>>>>>>>> Parsing of operators is greedy, so "x"!!!TRUE is "x FALSE", not
>>>>>> "xTRUE".)
>>>>>>>>> 
>>>>>>>>>> Where does the binary ! fit in the operator priority?  E.g. how 
>>>>>>>>>> is
>>>>>>>>>> 
>>>>>>>>>> a ! b > c
>>>>>>>>>> 
>>>>>>>>>> parsed?
>>>>>>>>> 
>>>>>>>>> As (a ! b) > c.
>>>>>>>>> 
>>>>>>>>> Their precedence is between that of + and - and that of < and >.
>>>>>>>>> So "x" ! 1+2 evalates to "x3" and "x" ! 1+2 < "x4" is TRUE.
>>>>>>>>> 
>>>>>>>>> (Actually, pqR also has a .. operator that fixes the problems 
>>>>>>>>> with generating sequences with the : operator, and it has 
>>>>>>>>> precedence lower than + and - and higher than ! and !!, but 
>>>>>>>>> that's not relevant if you don't have the .. operator.)
>>>>>>>>> 
>>>>>>>>> Radford Neal
>>>>>>>>> 
>>>>>>>>> ______________________________________________
>>>>>>>>> R-devel at r-project.org mailing list 
>>>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>>>> 
>>>>>>>> 
>>>>>>>>      [[alternative HTML version deleted]]
>>>>>>>> 
>>>>>>>> ______________________________________________
>>>>>>>> R-devel at r-project.org mailing list 
>>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>>> 
>>>>>> 
>>>>>> ______________________________________________
>>>>>> R-devel at r-project.org mailing list
>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>> 
>>>>> 
>>>> 
>>>> 	[[alternative HTML version deleted]]
>>>> 
>>>> ______________________________________________
>>>> R-devel at r-project.org mailing list
>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>> 
>>>> ______________________________________________
>>>> R-devel at r-project.org mailing list
>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>> 
>>> ______________________________________________
>>> R-devel at r-project.org <mailto:R-devel at r-project.org> mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel <https://stat.ethz.ch/mailman/listinfo/r-devel>
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 


From kev|nu@hey @end|ng |rom gm@||@com  Wed Dec  8 00:13:56 2021
From: kev|nu@hey @end|ng |rom gm@||@com (Kevin Ushey)
Date: Tue, 7 Dec 2021 15:13:56 -0800
Subject: [Rd] String interpolation [Was: string concatenation operator
 (revisited)]
In-Reply-To: <98866BE8-AA8B-45DC-85CB-D51AEE625533@R-project.org>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
 <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
 <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
 <010101d7eb09$8c0156d0$a4040470$@verizon.net>
 <7CA551D8-3636-4E03-AF4C-0BDD4F5FB9F4@uzh.ch>
 <921415D6-E68C-41EE-A836-25B30668A00C@R-project.org>
 <F8A25DDA-EB48-46EB-8D4E-04783E7F5731@uzh.ch>
 <98866BE8-AA8B-45DC-85CB-D51AEE625533@R-project.org>
Message-ID: <CAJXgQP1ir2gurPusQDJXfmvJZYBtnKztKkUU5shvTBMq1Nj2ow@mail.gmail.com>

For what it's worth, you can also get 90% of the way there with:

    f <- glue::glue
    f("if you squint, this is a Python f-string")

Having this in an add-on package also makes it much easier to change
in response to user feedback; R packages have more freedom to make
backwards-incompatible changes.

That said, if something like this were to happen in R, my vote would
be an implementation in the parser that transformed f"string" into
something like 'interpolate("string")', so that f"string" would just
become syntactic sugar for already-existing code (and so such code
could remain debuggable, easy to reason about, etc without any changes
to R internals)

Thanks,
Kevin

On Tue, Dec 7, 2021 at 2:06 PM Simon Urbanek
<simon.urbanek at r-project.org> wrote:
>
> I don't think a custom type alone would work, because users would expect to use such string anywhere a regular string can be used, and that's where the problems start - the evaluation would have to happen at a point where it is not expected since we can assume today that CHAR() doesn't evaluate. If it's just construct that needs some function call to turn it into a real string, then that's (from user's perspective) no different than glue() so I don't think the users would see the benefit (admittedly, you could do a lot more with such internal type, but not sure if the complexity is worth it).
>
> Cheers,
> Simon
>
>
>
> > On Dec 8, 2021, at 12:56 AM, Taras Zakharko <taras.zakharko at uzh.ch> wrote:
> >
> > I fully agree! General string interpolation opens a gaping security hole and is accompanied by all kinds of problems and decisions. What I envision instead is something like this:
> >
> >   f?hello {name}?
> >
> > Which gets parsed by R to this:
> >
> >   (STRINTERPSXP (CHARSXP (PROMISE nil)))
> >
> > Basically, a new type of R language construct that still can be processed by packages (for customized interpolation like in cli etc.), with a default eval which is basically paste0(). The benefit here would be that this is eagerly parsed and syntactically checked, and that the promise code could carry a srcref. And of course, that you could pass an interpolated string expression lazily between frames without losing the environment etc? For more advanced applications, a low level string interpolation expression constructor could be provided (that could either parse a general string ? at the user?s risk, or build it directly from expressions).
> >
> > ? Taras
> >
> >


From @v|gro@@ @end|ng |rom ver|zon@net  Wed Dec  8 03:10:12 2021
From: @v|gro@@ @end|ng |rom ver|zon@net (Avi Gross)
Date: Tue, 7 Dec 2021 21:10:12 -0500
Subject: [Rd] string concatenation operator (revisited)
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
 <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
 <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
 <010101d7eb09$8c0156d0$a4040470$@verizon.net>
 <7CA551D8-3636-4E03-AF4C-0BDD4F5FB9F4@uzh.ch> 
Message-ID: <008e01d7ebd8$bbf26fd0$33d74f70$@verizon.net>

Taras and Duncan and others do make a point about things not needing to be built in to the base R distribution if something similar can already be found elsewhere.

To an extent, that is quite true. But what exactly should be in the core of a language that has this kind of extensibility? 

I note how annoying it can be to load a package that then loads all kinds of other packages it depends on and often ones you personally will not know anything about and mostly never use directly. If core R was minimal, this can get worse and there can be serious overhead.

Obviously some code belongs there that directly interacts with the operating system or that implements major parts of the language. But clearly there was more put into S/R than the minimum even from early days based on how the language was expected to be used. And it has grown further over the years. The recent addition of a modified form of a pipe operator, along with a new way to declare a function so it can be added into a pipeline, are examples. Ideally, any feature that becomes used heavily that is already in a package, let alone a package with many such useful features, can be a candidate for inclusion directly or by emulation.

Back to string concatenation, I think it is fair to suggest S began as a statistical language of sorts with a heavy emphasis on numeric data and on vectorized data that led to vectors and data.frames being "built-in" so doing lots more with text was a secondary consideration that functions like paste() not only could easily handle, but could also handle vectorized input. It works pretty well and arguably overloading '+' is not needed. And note, underneath it all, R programs can largely be written using functions rather than operators. You can type:

`+`(5, `*`(2, 3))

and it evaluates to 11 and means 5+(2*3) and 

And paste() is not the only function you can use to do string concatenation. Consider one trivial use of sprintf() which also does much more:

> first <- "Avi"
> last <- "Gross"
> combined <- sprintf("%s%s", first, last)
> print(combined)
[1] "AviGross"

Obviously this also supports including a space between the %s copies and so on.


I note other languages also keep trying to expand to be everything for everybody and can use examples from many but Python is easy to see in many ways and is a bit of a competitor to R for some purposes. Python too has  packages called modules that extend the interpreted language and have had tons of modules added over the years including some to deal with items not included when the language was created. One reason R has done so well is that Python had things like lists but had no vectorized methods and other components like R did so lots of programs must first import modules like numpy and pandas to be able to create Series and Dataframes and manipulate them efficiently. But many modules have now been built on top of these extensions for various kinds of scientific programming and at some point you wonder why it is not built-in to the language to fill a gap they left. Lists are slow and dictionaries have limited use for many things. Tasks like machine learning can use huge amounts of data and do complex calculations repeatedly so Python has had to be extended. Yet, there too, most things have to be imported at runtime.

I am not a fanatic in R about the tidyverse set of packages  and often do some things using the built-in ways or use the tidyverse or mix and match. Both have value for me and some things remain easier than others depending on circumstances. Of course, using the same function name as other packages makes it hard to incorporate. But I don't think it would be hard to create a base R that includes a subset of the tidyverse as part of the base and leave other parts to be brought in only as needed.

The talk about string concatenation, also mentions the use of the glue package that I also sometimes use. The concatenation of strings and other types into a bigger string is often done in many languages and I note I have used five different methods in Python that are built-in as people keep wanting to bring in the way it is already done in some other language they like. I am talking about not so much concatenation but variants on the printf() family to format a string from many components and some look a bit like glue.  Potentially, a package like glue could also qualify as worth including in base R but let me clarify. There is a difference between being in the minimal core of a language and being in a list of packages that are by default included when R is built. Even if you include a package by default, it should not be an error to say library(name) if it is already loaded on your machine. So even after you make something part of the base distribution, people may continue to invoke it as if it was not there, lest the code be run on an older version.

The reality is that there can be significant costs in a tradeoff between ease of use with many choices and in the expense of running a bloated application that takes longer to load and more memory and spends more time searching namespaces and so on. 

Does adding a properly designed "+" cause much bloat? Maybe not. But the guardians of the language get so many requests, that realistically they can only approve a small number for each release and often then have to spend more time fixing bugs after getting complaints about code that does not work the same anymore!


-----Original Message-----
From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Taras Zakharko
Sent: Tuesday, December 7, 2021 4:09 AM
To: r-devel <r-devel at r-project.org>
Subject: Re: [Rd] string concatenation operator (revisited)

Great summary, Avi. 

String concatenation cold be trivially added to R, but it probably should not be. You will notice that modern languages tend not to use ?+? to do string concatenation (they either have a custom operator or a special kind of pattern to do it) due to practical issues such an approach brings (implicit type casting, lack of commutativity, performance etc.). These issues will be felt even more so in R with it?s weak typing, idiosyncratic casting behavior and NAs. 

As other?s have pointed out, any kind of behavior one wants from string concatenation can be implemented by custom operators as needed. This is not something that needs to be in the base R. I would rather like the efforts to be directed on improving string formatting (such as glue-style built-in string interpolation).

? Taras


> On 7 Dec 2021, at 02:27, Avi Gross via R-devel <r-devel at r-project.org> wrote:
> 
> After seeing what others are saying, it is clear that you need to 
> carefully think things out before designing any implementation of a 
> more native concatenation operator whether it is called "+' or 
> anything else. There may not be any ONE right solution but unlike a 
> function version like paste() there is nowhere to place any options that specify what you mean.
> 
> You can obviously expand paste() to accept arguments like 
> replace.NA="" or replace.NA="<NA>" and similar arguments on what to do 
> if you see a NaN, and Inf or -Inf, a NULL or even an NA.character_ and 
> so on. Heck, you might tell to make other substitutions as in 
> substitute=list(100=99, D=F) or any other nonsense you can come up with.
> 
> But you have nowhere to put options when saying:
> 
> c <- a + b
> 
> Sure, you could set various global options before the addition and 
> maybe rest them after, but that is not a way I like to go for 
> something this basic.
> 
> And enough such tinkering makes me wonder if it is easier to ask a 
> user to use a slightly different function like this:
> 
> paste.no.na <- function(...) do.call(paste, Filter(Negate(is.na),
> list(...)))
> 
> The above one-line function removes any NA from the argument list to 
> make a potentially shorter list before calling the real paste() using it.
> 
> Variations can, of course, be made that allow functionality as above. 
> 
> If R was a true object-oriented language in the same sense as others 
> like Python, operator overloading of "+" might be doable in more 
> complex ways but we can only work with what we have. I tend to agree 
> with others that in some places R is so lenient that all kinds of 
> errors can happen because it makes a guess on how to correct it.
> Generally, if you really want to mix numeric and character, many 
> languages require you to transform any arguments to make all of 
> compatible types. The paste() function is clearly stated to coerce all 
> arguments to be of type character for you. Whereas a+b makes no such 
> promises and also is not properly defined even if a and b are both of 
> type character. Sure, we can expand the language but it may still do 
> things some find not to be quite what they wanted as in "2"+"3"
> becoming "23" rather than 5. Right now, I can use
> as.numeric("2")+as.numeric("3") and get the intended result after making very clear to anyone reading the code that I wanted strings converted to floating point before the addition.
> 
> As has been pointed out, the plus operator if used to concatenate does 
> not have a cognate for other operations like -*/ and R has used most 
> other special symbols for other purposes. So, sure, we can use something like ....
> (4 periods) if it is not already being used for something but using + 
> here is a tad confusing. Having said that, the makers of Python did 
> make that choice.
> 
> -----Original Message-----
> From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Gabriel 
> Becker
> Sent: Monday, December 6, 2021 7:21 PM
> To: Bill Dunlap <williamwdunlap at gmail.com>
> Cc: Radford Neal <radford at cs.toronto.edu>; r-devel 
> <r-devel at r-project.org>
> Subject: Re: [Rd] string concatenation operator (revisited)
> 
> As I recall, there was a large discussion related to that which 
> resulted in the recycle0 argument being added (but defaulting to
> FALSE) for paste/paste0.
> 
> I think a lot of these things ultimately mean that if there were to be 
> a string concatenation operator, it probably shouldn't have behavior 
> identical to paste0. Was that what you were getting at as well, Bill?
> 
> ~G
> 
> On Mon, Dec 6, 2021 at 4:11 PM Bill Dunlap <williamwdunlap at gmail.com> wrote:
> 
>> Should paste0(character(0), c("a","b")) give character(0)?
>> There is a fair bit of code that assumes that paste("X",NULL) gives "X"
>> but c(1,2)+NULL gives numeric(0).
>> 
>> -Bill
>> 
>> On Mon, Dec 6, 2021 at 1:32 PM Duncan Murdoch 
>> <murdoch.duncan at gmail.com>
>> wrote:
>> 
>>> On 06/12/2021 4:21 p.m., Avraham Adler wrote:
>>>> Gabe, I agree that missingness is important to factor in. To 
>>>> somewhat
>>> abuse
>>>> the terminology, NA is often used to represent missingness. Perhaps 
>>>> concatenating character something with character something missing
>>> should
>>>> result in the original character?
>>> 
>>> I think that's a bad idea.  If you wanted to represent an empty 
>>> string, you should use "" or NULL, not NA.
>>> 
>>> I'd agree with Gabe, paste0("abc", NA) shouldn't give "abcNA", it 
>>> should give NA.
>>> 
>>> Duncan Murdoch
>>> 
>>>> 
>>>> Avi
>>>> 
>>>> On Mon, Dec 6, 2021 at 3:35 PM Gabriel Becker 
>>>> <gabembecker at gmail.com>
>>> wrote:
>>>> 
>>>>> Hi All,
>>>>> 
>>>>> Seeing this and the other thread (and admittedly not having 
>>>>> clicked
>>> through
>>>>> to the linked r-help thread), I wonder about NAs.
>>>>> 
>>>>> Should NA <concat> "hi there"  not result in NA_character_? This 
>>>>> is not what any of the paste functions do, but in my opinoin, NA +
>>> <non_na_value>
>>>>> seems like it should be NA  (not "NA"), particularly if we are 
>>>>> talking about `+` overloading, but potentially even in the case of 
>>>>> a distinct concatenation operator?
>>>>> 
>>>>> I guess what I'm saying is that in my head missingness propagation
>>> rules
>>>>> should take priority in such an operator (ie NA + <anything> 
>>>>> should *always * be NA).
>>>>> 
>>>>> Is that something others disagree with, or has it just not come up 
>>>>> yet
>>> in
>>>>> (the parts I have read) of this discussion?
>>>>> 
>>>>> Best,
>>>>> ~G
>>>>> 
>>>>> On Mon, Dec 6, 2021 at 10:03 AM Radford Neal 
>>>>> <radford at cs.toronto.edu>
>>>>> wrote:
>>>>> 
>>>>>>>> In pqR (see pqR-project.org), I have implemented ! and !! as 
>>>>>>>> binary string concatenation operators, equivalent to paste0 and 
>>>>>>>> paste, respectively.
>>>>>>>> 
>>>>>>>> For instance,
>>>>>>>> 
>>>>>>>>> "hello" ! "world"
>>>>>>>>      [1] "helloworld"
>>>>>>>>> "hello" !! "world"
>>>>>>>>      [1] "hello world"
>>>>>>>>> "hello" !! 1:4
>>>>>>>>      [1] "hello 1" "hello 2" "hello 3" "hello 4"
>>>>>>> 
>>>>>>> I'm curious about the details:
>>>>>>> 
>>>>>>> Would `1 ! 2` convert both to strings?
>>>>>> 
>>>>>> They're equivalent to paste0 and paste, so 1 ! 2 produces "12", 
>>>>>> just like paste0(1,2) does.  Of course, they wouldn't have to be 
>>>>>> exactly equivalent to paste0 and paste - one could impose 
>>>>>> stricter requirements if that seemed better for error detection.
>>>>>> Off hand, though, I think automatically converting is more in 
>>>>>> keeping with the rest of R.  Explicitly converting with 
>>>>>> as.character
> could be tedious.
>>>>>> 
>>>>>> I suppose disallowing logical arguments might make sense to guard 
>>>>>> against typos where ! was meant to be the unary-not operator, but 
>>>>>> ended up being a binary operator, after some sort of typo.  I 
>>>>>> doubt that this would be a common error, though.
>>>>>> 
>>>>>> (Note that there's no ambiguity when there are no typos, except 
>>>>>> that when negation is involved a space may be needed - so, for 
>>>>>> example, "x" !  !TRUE is "xFALSE", but "x"!!TRUE is "x TRUE".
>>>>>> Existing uses of double negation are still fine - eg, a <- !!TRUE
> still sets a to TRUE.
>>>>>> Parsing of operators is greedy, so "x"!!!TRUE is "x FALSE", not
>>> "xTRUE".)
>>>>>> 
>>>>>>> Where does the binary ! fit in the operator priority?  E.g. how 
>>>>>>> is
>>>>>>> 
>>>>>>>   a ! b > c
>>>>>>> 
>>>>>>> parsed?
>>>>>> 
>>>>>> As (a ! b) > c.
>>>>>> 
>>>>>> Their precedence is between that of + and - and that of < and >.
>>>>>> So "x" ! 1+2 evalates to "x3" and "x" ! 1+2 < "x4" is TRUE.
>>>>>> 
>>>>>> (Actually, pqR also has a .. operator that fixes the problems 
>>>>>> with generating sequences with the : operator, and it has 
>>>>>> precedence lower than + and - and higher than ! and !!, but 
>>>>>> that's not relevant if you don't have the .. operator.)
>>>>>> 
>>>>>>    Radford Neal
>>>>>> 
>>>>>> ______________________________________________
>>>>>> R-devel at r-project.org mailing list 
>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>> 
>>>>> 
>>>>>         [[alternative HTML version deleted]]
>>>>> 
>>>>> ______________________________________________
>>>>> R-devel at r-project.org mailing list 
>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>> 
>>> 
>>> ______________________________________________
>>> R-devel at r-project.org mailing list
>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>> 
>> 
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel

______________________________________________
R-devel at r-project.org mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


From t@r@@@z@kh@rko @end|ng |rom uzh@ch  Wed Dec  8 08:55:13 2021
From: t@r@@@z@kh@rko @end|ng |rom uzh@ch (Taras Zakharko)
Date: Wed, 8 Dec 2021 08:55:13 +0100
Subject: [Rd] String interpolation [Was: string concatenation operator
 (revisited)]
In-Reply-To: <CAJXgQP1ir2gurPusQDJXfmvJZYBtnKztKkUU5shvTBMq1Nj2ow@mail.gmail.com>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
 <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
 <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
 <010101d7eb09$8c0156d0$a4040470$@verizon.net>
 <7CA551D8-3636-4E03-AF4C-0BDD4F5FB9F4@uzh.ch>
 <921415D6-E68C-41EE-A836-25B30668A00C@R-project.org>
 <F8A25DDA-EB48-46EB-8D4E-04783E7F5731@uzh.ch>
 <98866BE8-AA8B-45DC-85CB-D51AEE625533@R-project.org>
 <CAJXgQP1ir2gurPusQDJXfmvJZYBtnKztKkUU5shvTBMq1Nj2ow@mail.gmail.com>
Message-ID: <C451D8F9-52A2-4482-A2CF-BAFC5B588452@uzh.ch>

> I don't think a custom type alone would work, because users would expect to use such string anywhere a regular string can be used, and that's where the problems start - the evaluation would have to happen at a point where it is not expected since we can assume today that CHAR() doesn't evaluate. If it's just construct that needs some function call to turn it into a real string, then that's (from user's perspective) no different than glue() 
> 

Oh, it will be still evaluated as expected. It would just be a new type of language expression, just like byte code or call or a promise. You just need a new case in the switch statement of eval(). The rest is just lazy evaluation as usual, no change of rules is needed. Of course, some rules need to be established on when exactly the evaluation kicks in  (and this can be a bit tricky), but I am sure one can figure out a sane approach ? my intuition would be to evaluate a format string any time one evaluates a promise. In fact, it could probably be treated as a special type of promise itself, with value caching and all. Under which approach the end user will never see the special type, every time you assign a formatted string somewhere, it will get evaluated to a plain old character vector. But if passed as an argument you get the benefits of lazy evaluation. 

What functions could do is suspend the evaluation to check if an argument is a (processed) format string and apply custom formatting to it. Again, not any different from today?s R, where  you can capture the lazy expression and apply transformations to it. The R parser just does some basic preprocessing for you. 

> admittedly, you could do a lot more with such internal type, but not sure if the complexity is worth it

That?s the question :) I am not sure either. It was just a spontaneous idea I thew out there, not a result of careful deliberation. Still, I believe it can be useful to think about things like that, it just might give the right person just the right idea. 


> For what it's worth, you can also get 90% of the way there with:
> 
>    f <- glue::glue
>    f("if you squint, this is a Python f-string?)
> 
> ...
> 
> That said, if something like this were to happen in R, my vote would
> be an implementation in the parser that transformed f"string" into
> something like 'interpolate("string")', so that f"string" would just
> become syntactic sugar for already-existing code

Not really. With this approach expression parsing would still be done at evaluation time, so you don?t get any  of the potential benefits that come from my suggestion (expression parsing at parse time, higher runtime performance, correctly captured expression promises). 

One quick note about parser transformations: lazy evaluation with expression capturing (substitution) is one of unique strength of R, as it allows one to trivially implement powerful DLSs on top of the language (as demonstrated by ?tidy evaluation? implementation in tidyverse).  Parser transformations might make the implementation simpler, but they remove the  information from the parse tree and reduce opportunities. 

? Taras


> On 8 Dec 2021, at 00:13, Kevin Ushey <kevinushey at gmail.com> wrote:
> 
> For what it's worth, you can also get 90% of the way there with:
> 
>    f <- glue::glue
>    f("if you squint, this is a Python f-string")
> 
> Having this in an add-on package also makes it much easier to change
> in response to user feedback; R packages have more freedom to make
> backwards-incompatible changes.
> 
> That said, if something like this were to happen in R, my vote would
> be an implementation in the parser that transformed f"string" into
> something like 'interpolate("string")', so that f"string" would just
> become syntactic sugar for already-existing code (and so such code
> could remain debuggable, easy to reason about, etc without any changes
> to R internals)
> 
> Thanks,
> Kevin
> 
> On Tue, Dec 7, 2021 at 2:06 PM Simon Urbanek
> <simon.urbanek at r-project.org> wrote:
>> 
>> I don't think a custom type alone would work, because users would expect to use such string anywhere a regular string can be used, and that's where the problems start - the evaluation would have to happen at a point where it is not expected since we can assume today that CHAR() doesn't evaluate. If it's just construct that needs some function call to turn it into a real string, then that's (from user's perspective) no different than glue() so I don't think the users would see the benefit (admittedly, you could do a lot more with such internal type, but not sure if the complexity is worth it).
>> 
>> Cheers,
>> Simon
>> 
>> 
>> 
>>> On Dec 8, 2021, at 12:56 AM, Taras Zakharko <taras.zakharko at uzh.ch> wrote:
>>> 
>>> I fully agree! General string interpolation opens a gaping security hole and is accompanied by all kinds of problems and decisions. What I envision instead is something like this:
>>> 
>>>  f?hello {name}?
>>> 
>>> Which gets parsed by R to this:
>>> 
>>>  (STRINTERPSXP (CHARSXP (PROMISE nil)))
>>> 
>>> Basically, a new type of R language construct that still can be processed by packages (for customized interpolation like in cli etc.), with a default eval which is basically paste0(). The benefit here would be that this is eagerly parsed and syntactically checked, and that the promise code could carry a srcref. And of course, that you could pass an interpolated string expression lazily between frames without losing the environment etc? For more advanced applications, a low level string interpolation expression constructor could be provided (that could either parse a general string ? at the user?s risk, or build it directly from expressions).
>>> 
>>> ? Taras
>>> 
>>> 


	[[alternative HTML version deleted]]


From |reder|k @end|ng |rom o|b@net  Wed Dec  8 09:24:47 2021
From: |reder|k @end|ng |rom o|b@net (Frederick Eaton)
Date: Wed, 8 Dec 2021 00:24:47 -0800
Subject: [Rd] 
 meaning of browser(skipCalls=) [and multiple mouse buttons]
In-Reply-To: <20211122171358.7rej26rdwpq5ywrm@localhost>
References: <20211122171358.7rej26rdwpq5ywrm@localhost>
Message-ID: <20211208082447.vd3hpq4gxd37llqy@localhost>

Dear R Core Team,

I'm attaching a proposed patch to hopefully address my confusions regarding the documentation of browser(). I'm not sure if all the material I added is correct, but I made experiments to confirm that the behavior is at least roughly as described.

     patch ./src/library/base/man/browser.Rd < browser.patch

Also, here is a patch to support multiple mouse buttons in getGraphicsEvent(). This must be edited before it can be applied, I decided to keep the old code in an 'if(0)' to help make it clearer that my code is essentially doing the same thing.

     https://github.com/navarum/tweaks/blob/master/r/patches/0001-Add-support-for-multiple-mouse-buttons.patch
     wget -O - https://raw.githubusercontent.com/navarum/tweaks/master/r/patches/0001-Add-support-for-multiple-mouse-buttons.patch | patch -p1

It would be useful to have support in R for more than three mouse buttons because this enables the use of the mouse wheel (buttons 4 and 5), which can provide a more convenient interface when adjusting numbers and graphics and so on. I also have shift+wheel bound to buttons 6 and 7 via xbindkeys and xte, which I use for horizontal scrolling, via a trick from the web somewhere:

     $ cat .xbindkeysrc.scm | grep xte
     (xbindkey '(shift "b:4") "xte 'mouseclick 6'")
     (xbindkey '(shift "b:5") "xte 'mouseclick 7'")

I hope that these contributions can be found acceptable.

Thank you in advance,

Frederick



On Mon, Nov 22, 2021 at 09:13:58AM -0800, Frederick Eaton wrote:
>Dear R Devel,
>
>I have been advised to use "options(error=recover)" to enable
>debugging on errors. But sometimes it would seem more convenient to
>override "stopifnot", for example:
>
>    stopifnot = function(b) { if(!b) { browser(skipCalls=1); } }
>
>However, this doesn't do what I expected. On looking closer I find
>that the "skipCalls" argument seems to be ignored except when printing
>the "Called from: " message; it does not affect the evaluation context
>or the output of 'where':
>
>    > var=2; f=function(){var=1; browser(skipCalls=0)}; f()
>    Called from: f()
>    Browse[1]> var
>    [1] 1
>    Browse[1]> where
>    where 1: f()
>
>    Browse[1]> Q
>    > var=2; f=function(){var=1; browser(skipCalls=1)}; f()
>    Called from: top level     Browse[1]> var
>    [1] 1
>    Browse[1]> where
>    where 1: f()
>
>    Browse[1]> Q
>    > var=2; f=function(){var=1; browser(skipCalls=2)}; f()
>    Called from: top level     Browse[1]> var
>    [1] 1
>    Browse[1]> where
>    where 1: f()
>
>    Browse[1]> Q
>
>So it appears that the "browser()" API does not actually make it
>possible to call this built-in function from within another R function
>and thereby emulate the same behavior as calling browser() directly.
>
>If this is the case, it might be good to have it fixed or documented.
>I am aware of "browser(expr=)", but this requires editing the
>particular call that failed. The documentation for "browser()" led me
>to hope that my use case would be supported, if only because it admits
>that users might want to build other debugging functions with
>browser(): "The 'skipCalls' argument should be used when the
>'browser()' call is nested within another debugging function". An
>example where this 'skipCalls' parameter is used to build a useful
>debugging function would help to clarify its English description in
>the manual.
>
>Also, from the browser() command line I could not find a way to step
>*out* of the current function. This would have been a way to recover
>from skipCalls not working as expected. Am I missing something? For
>example is there some command other than "n", where the below
>interaction could pause before "hi" and "bye"?
>
>    > f=function(){browser(); message("in f"); message("out f")}; f(); message("hi"); message("bye")
>    Called from: f()
>    Browse[1]> n
>    debug at #1: message("in f")
>    Browse[2]> n
>    in f
>    debug at #1: message("out f")
>    Browse[2]> n
>    out f
>    hi
>    bye
>
>If it is not possible for the R debugger to step out of a function, it
>would be good to document that too, maybe after the list of browser
>prompt commands in "?browser". Being confined within a single function
>is not an obvious disability for a debugger to have.
>
>I feel that R is an excellent tool, but sometimes I think that if the
>shortcomings of the system were better documented, then this would
>save users a lot of time in certain cases.
>
>Thank you,
>
>Frederick
>

-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: browser.patch
URL: <https://stat.ethz.ch/pipermail/r-devel/attachments/20211208/056037de/attachment.ksh>

From murdoch@dunc@n @end|ng |rom gm@||@com  Wed Dec  8 12:24:04 2021
From: murdoch@dunc@n @end|ng |rom gm@||@com (Duncan Murdoch)
Date: Wed, 8 Dec 2021 06:24:04 -0500
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <008e01d7ebd8$bbf26fd0$33d74f70$@verizon.net>
References: <mailman.52192.3.1638702001.27673.r-devel@r-project.org>
 <20211206061402.GA3810@mail.cs.toronto.edu>
 <b3509a16-a132-8a4e-322f-ccb708d12ff1@gmail.com>
 <20211206180302.GA6850@mail.cs.toronto.edu>
 <CAD4oTHGLQVLwaLCcZtY3YqTg8PP6Y0Ji5ZNueND=uwSSGtZ5DA@mail.gmail.com>
 <CAL6gwn+B+MP7-s2bgQq+GCAyF2vVdS3KtBR4Zot-pVYzGLQW9g@mail.gmail.com>
 <82ea4836-96dd-b979-e684-018354cb3f33@gmail.com>
 <CAHqSRuRxwGRf9to5uNMXXZiJuB6oa_uF_3UKY_2y80t=CnRiYw@mail.gmail.com>
 <CAD4oTHE=Ap+NnQQeOWbexnQcvHYJ14rQdt9c7NZdp1D1BiEuOQ@mail.gmail.com>
 <010101d7eb09$8c0156d0$a4040470$@verizon.net>
 <7CA551D8-3636-4E03-AF4C-0BDD4F5FB9F4@uzh.ch>
 <008e01d7ebd8$bbf26fd0$33d74f70$@verizon.net>
Message-ID: <5e74a3e3-6a5f-79f8-dbbf-b908d82e5d64@gmail.com>

On 07/12/2021 9:10 p.m., Avi Gross via R-devel wrote:
> Taras and Duncan and others do make a point about things not needing to be built in to the base R distribution if something similar can already be found elsewhere.
> 
> To an extent, that is quite true. But what exactly should be in the core of a language that has this kind of extensibility?
> 
> I note how annoying it can be to load a package that then loads all kinds of other packages it depends on and often ones you personally will not know anything about and mostly never use directly. If core R was minimal, this can get worse and there can be serious overhead.

In that case you shouldn't use that package, you should find or write 
another one that doesn't have all those dependencies.

> Obviously some code belongs there that directly interacts with the operating system or that implements major parts of the language. But clearly there was more put into S/R than the minimum even from early days based on how the language was expected to be used. And it has grown further over the years. The recent addition of a modified form of a pipe operator, along with a new way to declare a function so it can be added into a pipeline, are examples. Ideally, any feature that becomes used heavily that is already in a package, let alone a package with many such useful features, can be a candidate for inclusion directly or by emulation.

The difference between core R and contributed R is mainly who is 
responsible for supporting it.  When you ask for something to move to 
core R, you are asking R Core members to take on added work.  When they 
add something, they are volunteering to take on that responsibility. 
That's a big difference.

Duncan Murdoch

> Back to string concatenation, I think it is fair to suggest S began as a statistical language of sorts with a heavy emphasis on numeric data and on vectorized data that led to vectors and data.frames being "built-in" so doing lots more with text was a secondary consideration that functions like paste() not only could easily handle, but could also handle vectorized input. It works pretty well and arguably overloading '+' is not needed. And note, underneath it all, R programs can largely be written using functions rather than operators. You can type:
> 
> `+`(5, `*`(2, 3))
> 
> and it evaluates to 11 and means 5+(2*3) and
> 
> And paste() is not the only function you can use to do string concatenation. Consider one trivial use of sprintf() which also does much more:
> 
>> first <- "Avi"
>> last <- "Gross"
>> combined <- sprintf("%s%s", first, last)
>> print(combined)
> [1] "AviGross"
> 
> Obviously this also supports including a space between the %s copies and so on.
> 
> 
> I note other languages also keep trying to expand to be everything for everybody and can use examples from many but Python is easy to see in many ways and is a bit of a competitor to R for some purposes. Python too has  packages called modules that extend the interpreted language and have had tons of modules added over the years including some to deal with items not included when the language was created. One reason R has done so well is that Python had things like lists but had no vectorized methods and other components like R did so lots of programs must first import modules like numpy and pandas to be able to create Series and Dataframes and manipulate them efficiently. But many modules have now been built on top of these extensions for various kinds of scientific programming and at some point you wonder why it is not built-in to the language to fill a gap they left. Lists are slow and dictionaries have limited use for many things. Tasks like machine learning can use huge amounts of data and do complex calculations repeatedly so Python has had to be extended. Yet, there too, most things have to be imported at runtime.
> 
> I am not a fanatic in R about the tidyverse set of packages  and often do some things using the built-in ways or use the tidyverse or mix and match. Both have value for me and some things remain easier than others depending on circumstances. Of course, using the same function name as other packages makes it hard to incorporate. But I don't think it would be hard to create a base R that includes a subset of the tidyverse as part of the base and leave other parts to be brought in only as needed.
> 
> The talk about string concatenation, also mentions the use of the glue package that I also sometimes use. The concatenation of strings and other types into a bigger string is often done in many languages and I note I have used five different methods in Python that are built-in as people keep wanting to bring in the way it is already done in some other language they like. I am talking about not so much concatenation but variants on the printf() family to format a string from many components and some look a bit like glue.  Potentially, a package like glue could also qualify as worth including in base R but let me clarify. There is a difference between being in the minimal core of a language and being in a list of packages that are by default included when R is built. Even if you include a package by default, it should not be an error to say library(name) if it is already loaded on your machine. So even after you make something part of the base distribution, people may continue to invoke it as if it was not there, lest the code be run on an older version.
> 
> The reality is that there can be significant costs in a tradeoff between ease of use with many choices and in the expense of running a bloated application that takes longer to load and more memory and spends more time searching namespaces and so on.
> 
> Does adding a properly designed "+" cause much bloat? Maybe not. But the guardians of the language get so many requests, that realistically they can only approve a small number for each release and often then have to spend more time fixing bugs after getting complaints about code that does not work the same anymore!
> 
> 
> -----Original Message-----
> From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Taras Zakharko
> Sent: Tuesday, December 7, 2021 4:09 AM
> To: r-devel <r-devel at r-project.org>
> Subject: Re: [Rd] string concatenation operator (revisited)
> 
> Great summary, Avi.
> 
> String concatenation cold be trivially added to R, but it probably should not be. You will notice that modern languages tend not to use ?+? to do string concatenation (they either have a custom operator or a special kind of pattern to do it) due to practical issues such an approach brings (implicit type casting, lack of commutativity, performance etc.). These issues will be felt even more so in R with it?s weak typing, idiosyncratic casting behavior and NAs.
> 
> As other?s have pointed out, any kind of behavior one wants from string concatenation can be implemented by custom operators as needed. This is not something that needs to be in the base R. I would rather like the efforts to be directed on improving string formatting (such as glue-style built-in string interpolation).
> 
> ? Taras
> 
> 
>> On 7 Dec 2021, at 02:27, Avi Gross via R-devel <r-devel at r-project.org> wrote:
>>
>> After seeing what others are saying, it is clear that you need to
>> carefully think things out before designing any implementation of a
>> more native concatenation operator whether it is called "+' or
>> anything else. There may not be any ONE right solution but unlike a
>> function version like paste() there is nowhere to place any options that specify what you mean.
>>
>> You can obviously expand paste() to accept arguments like
>> replace.NA="" or replace.NA="<NA>" and similar arguments on what to do
>> if you see a NaN, and Inf or -Inf, a NULL or even an NA.character_ and
>> so on. Heck, you might tell to make other substitutions as in
>> substitute=list(100=99, D=F) or any other nonsense you can come up with.
>>
>> But you have nowhere to put options when saying:
>>
>> c <- a + b
>>
>> Sure, you could set various global options before the addition and
>> maybe rest them after, but that is not a way I like to go for
>> something this basic.
>>
>> And enough such tinkering makes me wonder if it is easier to ask a
>> user to use a slightly different function like this:
>>
>> paste.no.na <- function(...) do.call(paste, Filter(Negate(is.na),
>> list(...)))
>>
>> The above one-line function removes any NA from the argument list to
>> make a potentially shorter list before calling the real paste() using it.
>>
>> Variations can, of course, be made that allow functionality as above.
>>
>> If R was a true object-oriented language in the same sense as others
>> like Python, operator overloading of "+" might be doable in more
>> complex ways but we can only work with what we have. I tend to agree
>> with others that in some places R is so lenient that all kinds of
>> errors can happen because it makes a guess on how to correct it.
>> Generally, if you really want to mix numeric and character, many
>> languages require you to transform any arguments to make all of
>> compatible types. The paste() function is clearly stated to coerce all
>> arguments to be of type character for you. Whereas a+b makes no such
>> promises and also is not properly defined even if a and b are both of
>> type character. Sure, we can expand the language but it may still do
>> things some find not to be quite what they wanted as in "2"+"3"
>> becoming "23" rather than 5. Right now, I can use
>> as.numeric("2")+as.numeric("3") and get the intended result after making very clear to anyone reading the code that I wanted strings converted to floating point before the addition.
>>
>> As has been pointed out, the plus operator if used to concatenate does
>> not have a cognate for other operations like -*/ and R has used most
>> other special symbols for other purposes. So, sure, we can use something like ....
>> (4 periods) if it is not already being used for something but using +
>> here is a tad confusing. Having said that, the makers of Python did
>> make that choice.
>>
>> -----Original Message-----
>> From: R-devel <r-devel-bounces at r-project.org> On Behalf Of Gabriel
>> Becker
>> Sent: Monday, December 6, 2021 7:21 PM
>> To: Bill Dunlap <williamwdunlap at gmail.com>
>> Cc: Radford Neal <radford at cs.toronto.edu>; r-devel
>> <r-devel at r-project.org>
>> Subject: Re: [Rd] string concatenation operator (revisited)
>>
>> As I recall, there was a large discussion related to that which
>> resulted in the recycle0 argument being added (but defaulting to
>> FALSE) for paste/paste0.
>>
>> I think a lot of these things ultimately mean that if there were to be
>> a string concatenation operator, it probably shouldn't have behavior
>> identical to paste0. Was that what you were getting at as well, Bill?
>>
>> ~G
>>
>> On Mon, Dec 6, 2021 at 4:11 PM Bill Dunlap <williamwdunlap at gmail.com> wrote:
>>
>>> Should paste0(character(0), c("a","b")) give character(0)?
>>> There is a fair bit of code that assumes that paste("X",NULL) gives "X"
>>> but c(1,2)+NULL gives numeric(0).
>>>
>>> -Bill
>>>
>>> On Mon, Dec 6, 2021 at 1:32 PM Duncan Murdoch
>>> <murdoch.duncan at gmail.com>
>>> wrote:
>>>
>>>> On 06/12/2021 4:21 p.m., Avraham Adler wrote:
>>>>> Gabe, I agree that missingness is important to factor in. To
>>>>> somewhat
>>>> abuse
>>>>> the terminology, NA is often used to represent missingness. Perhaps
>>>>> concatenating character something with character something missing
>>>> should
>>>>> result in the original character?
>>>>
>>>> I think that's a bad idea.  If you wanted to represent an empty
>>>> string, you should use "" or NULL, not NA.
>>>>
>>>> I'd agree with Gabe, paste0("abc", NA) shouldn't give "abcNA", it
>>>> should give NA.
>>>>
>>>> Duncan Murdoch
>>>>
>>>>>
>>>>> Avi
>>>>>
>>>>> On Mon, Dec 6, 2021 at 3:35 PM Gabriel Becker
>>>>> <gabembecker at gmail.com>
>>>> wrote:
>>>>>
>>>>>> Hi All,
>>>>>>
>>>>>> Seeing this and the other thread (and admittedly not having
>>>>>> clicked
>>>> through
>>>>>> to the linked r-help thread), I wonder about NAs.
>>>>>>
>>>>>> Should NA <concat> "hi there"  not result in NA_character_? This
>>>>>> is not what any of the paste functions do, but in my opinoin, NA +
>>>> <non_na_value>
>>>>>> seems like it should be NA  (not "NA"), particularly if we are
>>>>>> talking about `+` overloading, but potentially even in the case of
>>>>>> a distinct concatenation operator?
>>>>>>
>>>>>> I guess what I'm saying is that in my head missingness propagation
>>>> rules
>>>>>> should take priority in such an operator (ie NA + <anything>
>>>>>> should *always * be NA).
>>>>>>
>>>>>> Is that something others disagree with, or has it just not come up
>>>>>> yet
>>>> in
>>>>>> (the parts I have read) of this discussion?
>>>>>>
>>>>>> Best,
>>>>>> ~G
>>>>>>
>>>>>> On Mon, Dec 6, 2021 at 10:03 AM Radford Neal
>>>>>> <radford at cs.toronto.edu>
>>>>>> wrote:
>>>>>>
>>>>>>>>> In pqR (see pqR-project.org), I have implemented ! and !! as
>>>>>>>>> binary string concatenation operators, equivalent to paste0 and
>>>>>>>>> paste, respectively.
>>>>>>>>>
>>>>>>>>> For instance,
>>>>>>>>>
>>>>>>>>>> "hello" ! "world"
>>>>>>>>>       [1] "helloworld"
>>>>>>>>>> "hello" !! "world"
>>>>>>>>>       [1] "hello world"
>>>>>>>>>> "hello" !! 1:4
>>>>>>>>>       [1] "hello 1" "hello 2" "hello 3" "hello 4"
>>>>>>>>
>>>>>>>> I'm curious about the details:
>>>>>>>>
>>>>>>>> Would `1 ! 2` convert both to strings?
>>>>>>>
>>>>>>> They're equivalent to paste0 and paste, so 1 ! 2 produces "12",
>>>>>>> just like paste0(1,2) does.  Of course, they wouldn't have to be
>>>>>>> exactly equivalent to paste0 and paste - one could impose
>>>>>>> stricter requirements if that seemed better for error detection.
>>>>>>> Off hand, though, I think automatically converting is more in
>>>>>>> keeping with the rest of R.  Explicitly converting with
>>>>>>> as.character
>> could be tedious.
>>>>>>>
>>>>>>> I suppose disallowing logical arguments might make sense to guard
>>>>>>> against typos where ! was meant to be the unary-not operator, but
>>>>>>> ended up being a binary operator, after some sort of typo.  I
>>>>>>> doubt that this would be a common error, though.
>>>>>>>
>>>>>>> (Note that there's no ambiguity when there are no typos, except
>>>>>>> that when negation is involved a space may be needed - so, for
>>>>>>> example, "x" !  !TRUE is "xFALSE", but "x"!!TRUE is "x TRUE".
>>>>>>> Existing uses of double negation are still fine - eg, a <- !!TRUE
>> still sets a to TRUE.
>>>>>>> Parsing of operators is greedy, so "x"!!!TRUE is "x FALSE", not
>>>> "xTRUE".)
>>>>>>>
>>>>>>>> Where does the binary ! fit in the operator priority?  E.g. how
>>>>>>>> is
>>>>>>>>
>>>>>>>>    a ! b > c
>>>>>>>>
>>>>>>>> parsed?
>>>>>>>
>>>>>>> As (a ! b) > c.
>>>>>>>
>>>>>>> Their precedence is between that of + and - and that of < and >.
>>>>>>> So "x" ! 1+2 evalates to "x3" and "x" ! 1+2 < "x4" is TRUE.
>>>>>>>
>>>>>>> (Actually, pqR also has a .. operator that fixes the problems
>>>>>>> with generating sequences with the : operator, and it has
>>>>>>> precedence lower than + and - and higher than ! and !!, but
>>>>>>> that's not relevant if you don't have the .. operator.)
>>>>>>>
>>>>>>>     Radford Neal
>>>>>>>
>>>>>>> ______________________________________________
>>>>>>> R-devel at r-project.org mailing list
>>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>>
>>>>>>
>>>>>>          [[alternative HTML version deleted]]
>>>>>>
>>>>>> ______________________________________________
>>>>>> R-devel at r-project.org mailing list
>>>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>>>
>>>>
>>>> ______________________________________________
>>>> R-devel at r-project.org mailing list
>>>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>>>
>>>
>>
>> 	[[alternative HTML version deleted]]
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 


From tom@@@k@||ber@ @end|ng |rom gm@||@com  Wed Dec  8 14:56:36 2021
From: tom@@@k@||ber@ @end|ng |rom gm@||@com (Tomas Kalibera)
Date: Wed, 8 Dec 2021 14:56:36 +0100
Subject: [Rd] R/CRAN switch to UCRT on Windows
Message-ID: <332260b1-0dad-2808-97dd-150aa7687dd3@gmail.com>

Please note an update concerning the support of UTF-8 as native encoding 
on Windows, which may at this point be of interest particularly to 
developers of packages with native code and to R users using R-devel 
(the development version of R) on Windows:

https://developer.r-project.org/Blog/public/2021/12/07/upcoming-changes-in-r-4.2-on-windows/

The key part is that CRAN will switch the incoming checks of R packages 
on Windows to a new toolchain targeting UCRT on Monday, December 13.

It may take up to several days for all systems to synchronize and during 
this time, it may be difficult to build R-devel on Windows from source 
or to install packages.? After the switch, the snapshot R-devel builds 
and binary package builds provided by CRAN will be built using the new 
toolchain for UCRT. These new builds will use UTF-8 as the native 
encoding on recent Windows.

These builds will be incompatible with the previous builds for MSVCRT 
and installed/binary packages will be incompatible as well. The 
recommended/simplest course of action for R-devel users is to uninstall 
the old build of R-devel, RTools, delete the old package libraries, and 
then install the new versions.

Checks of CRAN packages with the new toolchain have been running since 
March with results available on CRAN pages. By now, most packages are 
working, but some packages using native (C, C++, Fortran) code still 
have to be updated. The Winbuilder service and R-hub support the new 
toolchain, there is also support/example for using github actions. The 
builds of R-devel and CRAN (and recommended binary packages) with the 
new toolchain are available regularly since March.

I've created patches for CRAN (and required Bioconductor packages) which 
are installed automatically at package installation time by R. This 
feature will be also in R-devel after the switch and will be used 
temporarily to give package authors more time to fix their packages. Uwe 
Ligges, other CRAN team members and I have also been in touch with some 
package authors, providing advice how to fix their packages, when the 
issues required more explanation. I am prepared to help the remaining 
authors as well if needed.

Please see the blog post and materials linked from there for more 
details and feel free to ask questions.

Thanks
Tomas


From ||gge@ @end|ng |rom @t@t|@t|k@tu-dortmund@de  Wed Dec  8 15:24:21 2021
From: ||gge@ @end|ng |rom @t@t|@t|k@tu-dortmund@de (Uwe Ligges)
Date: Wed, 8 Dec 2021 15:24:21 +0100
Subject: [Rd] R/CRAN switch to UCRT on Windows
In-Reply-To: <332260b1-0dad-2808-97dd-150aa7687dd3@gmail.com>
References: <332260b1-0dad-2808-97dd-150aa7687dd3@gmail.com>
Message-ID: <4f14e5b0-c969-f97c-56a3-129cd05e5e3e@statistik.tu-dortmund.de>

Thank you, Tomas, for your hard work on the new toolchain, its 
documentation, and all your efforts in providing patches for R and for 
several contributed packages.

Best,
Uwe



On 08.12.2021 14:56, Tomas Kalibera wrote:
> Please note an update concerning the support of UTF-8 as native encoding 
> on Windows, which may at this point be of interest particularly to 
> developers of packages with native code and to R users using R-devel 
> (the development version of R) on Windows:
> 
> https://developer.r-project.org/Blog/public/2021/12/07/upcoming-changes-in-r-4.2-on-windows/ 
> 
> 
> The key part is that CRAN will switch the incoming checks of R packages 
> on Windows to a new toolchain targeting UCRT on Monday, December 13.
> 
> It may take up to several days for all systems to synchronize and during 
> this time, it may be difficult to build R-devel on Windows from source 
> or to install packages.? After the switch, the snapshot R-devel builds 
> and binary package builds provided by CRAN will be built using the new 
> toolchain for UCRT. These new builds will use UTF-8 as the native 
> encoding on recent Windows.
> 
> These builds will be incompatible with the previous builds for MSVCRT 
> and installed/binary packages will be incompatible as well. The 
> recommended/simplest course of action for R-devel users is to uninstall 
> the old build of R-devel, RTools, delete the old package libraries, and 
> then install the new versions.
> 
> Checks of CRAN packages with the new toolchain have been running since 
> March with results available on CRAN pages. By now, most packages are 
> working, but some packages using native (C, C++, Fortran) code still 
> have to be updated. The Winbuilder service and R-hub support the new 
> toolchain, there is also support/example for using github actions. The 
> builds of R-devel and CRAN (and recommended binary packages) with the 
> new toolchain are available regularly since March.
> 
> I've created patches for CRAN (and required Bioconductor packages) which 
> are installed automatically at package installation time by R. This 
> feature will be also in R-devel after the switch and will be used 
> temporarily to give package authors more time to fix their packages. Uwe 
> Ligges, other CRAN team members and I have also been in touch with some 
> package authors, providing advice how to fix their packages, when the 
> issues required more explanation. I am prepared to help the remaining 
> authors as well if needed.
> 
> Please see the blog post and materials linked from there for more 
> details and feel free to ask questions.
> 
> Thanks
> Tomas
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From t|m@t@y|or @end|ng |rom h|ddene|eph@nt@@co@uk  Wed Dec  8 15:44:00 2021
From: t|m@t@y|or @end|ng |rom h|ddene|eph@nt@@co@uk (Tim Taylor)
Date: Wed, 8 Dec 2021 14:44:00 +0000
Subject: [Rd] R/CRAN switch to UCRT on Windows
In-Reply-To: <4f14e5b0-c969-f97c-56a3-129cd05e5e3e@statistik.tu-dortmund.de>
References: <332260b1-0dad-2808-97dd-150aa7687dd3@gmail.com>
 <4f14e5b0-c969-f97c-56a3-129cd05e5e3e@statistik.tu-dortmund.de>
Message-ID: <LO2P265MB2605E88A271188B9D5CCFA0BDD6F9@LO2P265MB2605.GBRP265.PROD.OUTLOOK.COM>

Hear, hear! Also thank you Uwe and the rest of the CRAN team for all the work you put in. It is much appreciated!

________________________________________
From: R-devel <r-devel-bounces at r-project.org> on behalf of Uwe Ligges <ligges at statistik.tu-dortmund.de>
Sent: 08 December 2021 14:24
To: Tomas Kalibera; r-devel
Subject: Re: [Rd] R/CRAN switch to UCRT on Windows

Thank you, Tomas, for your hard work on the new toolchain, its
documentation, and all your efforts in providing patches for R and for
several contributed packages.

Best,
Uwe



On 08.12.2021 14:56, Tomas Kalibera wrote:
> Please note an update concerning the support of UTF-8 as native encoding
> on Windows, which may at this point be of interest particularly to
> developers of packages with native code and to R users using R-devel
> (the development version of R) on Windows:
>
> https://developer.r-project.org/Blog/public/2021/12/07/upcoming-changes-in-r-4.2-on-windows/
>
>
> The key part is that CRAN will switch the incoming checks of R packages
> on Windows to a new toolchain targeting UCRT on Monday, December 13.
>
> It may take up to several days for all systems to synchronize and during
> this time, it may be difficult to build R-devel on Windows from source
> or to install packages.  After the switch, the snapshot R-devel builds
> and binary package builds provided by CRAN will be built using the new
> toolchain for UCRT. These new builds will use UTF-8 as the native
> encoding on recent Windows.
>
> These builds will be incompatible with the previous builds for MSVCRT
> and installed/binary packages will be incompatible as well. The
> recommended/simplest course of action for R-devel users is to uninstall
> the old build of R-devel, RTools, delete the old package libraries, and
> then install the new versions.
>
> Checks of CRAN packages with the new toolchain have been running since
> March with results available on CRAN pages. By now, most packages are
> working, but some packages using native (C, C++, Fortran) code still
> have to be updated. The Winbuilder service and R-hub support the new
> toolchain, there is also support/example for using github actions. The
> builds of R-devel and CRAN (and recommended binary packages) with the
> new toolchain are available regularly since March.
>
> I've created patches for CRAN (and required Bioconductor packages) which
> are installed automatically at package installation time by R. This
> feature will be also in R-devel after the switch and will be used
> temporarily to give package authors more time to fix their packages. Uwe
> Ligges, other CRAN team members and I have also been in touch with some
> package authors, providing advice how to fix their packages, when the
> issues required more explanation. I am prepared to help the remaining
> authors as well if needed.
>
> Please see the blog post and materials linked from there for more
> details and feel free to ask questions.
>
> Thanks
> Tomas
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel

______________________________________________
R-devel at r-project.org mailing list
https://stat.ethz.ch/mailman/listinfo/r-devel


From m@tth|@@-gond@n @end|ng |rom gmx@de  Wed Dec  8 19:37:09 2021
From: m@tth|@@-gond@n @end|ng |rom gmx@de (Matthias Gondan)
Date: Wed, 8 Dec 2021 19:37:09 +0100
Subject: [Rd] plogis (and other p* functions), vectorized lower.tail
Message-ID: <1MCKBm-1mmk5c180A-009QA7@mail.gmx.net>

Dear R developers,

I have seen that plogis silently ignores vector elements of lower.tail,

> plogis(q=0.5, location=1, lower.tail=TRUE) 
[1] 0.3775407
> plogis(q=0.5, location=1, lower.tail=FALSE) 
[1] 0.6224593
> plogis(q=c(0.5, 0.5), location=1, lower.tail=c(TRUE, FALSE)) 
[1] 0.3775407 0.3775407

For those familiar with psychological measurement: A use case of the above function is the so-called Rasch model, where the probability that a person with some specific ability (q) makes a correct (lower.tail=TRUE) or wrong response (lower.tail=FALSE) to an item with a specific difficulty (location). A vectorized version of plogis would enable to determine the likelihood of an entire response vector in a single call. My current workaround is an intermediate call to ?Vectorize?.

I am wondering if the logical argument of lower.tail can be vectorized (?). I see that this may be a substantial change in many places (basically, all p and q functions of probability distributions), but in my understanding, it would not break existing code which assumes lower.tail to be a single element. If that?s not
possible/feasible, I suggest to issue a warning if a vector of length > 1 is given in lower.tail. I am aware that the documentation clearly states that lower.tail is a single boolean.

Thank you for your consideration.

With best wishes,

Matthias



	[[alternative HTML version deleted]]


From therne@u @end|ng |rom m@yo@edu  Thu Dec  9 15:30:28 2021
From: therne@u @end|ng |rom m@yo@edu (Therneau, Terry M., Ph.D.)
Date: Thu, 09 Dec 2021 08:30:28 -0600
Subject: [Rd] Question about the UCRT switch
Message-ID: <f03410$h3f44e@ironport10.mayo.edu>

The connected blog has the statement? "Most authors will not have to do anything as the 
number of CRAN packages that will need some attention is below 1%, but authors of packages 
using native (C, C++ or Fortran) code should read the following lines."

My packages do use a lot of C, but I never use Windows.?? My reading of "the following 
lines" is that? I don't have to do anything.?? Is this correct?

Terry T.


-- 
Terry M Therneau, PhD
Department of Quantitative Health Sciences
Mayo Clinic
therneau at mayo.edu

"TERR-ree THUR-noh"


	[[alternative HTML version deleted]]


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Thu Dec  9 16:03:31 2021
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Thu, 9 Dec 2021 16:03:31 +0100
Subject: [Rd] plogis (and other p* functions), vectorized lower.tail
In-Reply-To: <1MCKBm-1mmk5c180A-009QA7@mail.gmx.net>
References: <1MCKBm-1mmk5c180A-009QA7@mail.gmx.net>
Message-ID: <25010.6851.980357.14339@stat.math.ethz.ch>

>>>>> Matthias Gondan 
>>>>>     on Wed, 8 Dec 2021 19:37:09 +0100 writes:

    > Dear R developers,
    > I have seen that plogis silently ignores vector elements of lower.tail,

and also of 'log'.
This is indeed the case for all d*, p*, q* functions.

Yes, this has been on purpose and therefore documented, in the
case of plogis, e.g. in the 'Value' section of ?plogis :

     The length of the result is determined by ?n? for ?rlogis?, and is
     the maximum of the lengths of the numerical arguments for the
     other functions.

 (note: *numerical* arguments: the logical ones are not recycled)

     The numerical arguments other than ?n? are recycled to the length
     of the result.  Only the first elements of the logical arguments
     are used.

 (above, we even explicitly mention the logical arguments ..)


Recycling happens for the first argument (x,p,q) of these
functions and for "parameters" of the distribution, but not for
lower.tail, log.p (or 'log').


    >> plogis(q=0.5, location=1, lower.tail=TRUE) 
    > [1] 0.3775407
    >> plogis(q=0.5, location=1, lower.tail=FALSE) 
    > [1] 0.6224593
    >> plogis(q=c(0.5, 0.5), location=1, lower.tail=c(TRUE, FALSE)) 
    > [1] 0.3775407 0.3775407

    > For those familiar with psychological measurement: A use case of the above function is the so-called Rasch model, where the probability that a person with some specific ability (q) makes a correct (lower.tail=TRUE) or wrong response (lower.tail=FALSE) to an item with a specific difficulty (location). A vectorized version of plogis would enable to determine the likelihood of an entire response vector in a single call. My current workaround is an intermediate call to ?Vectorize?.

    > I am wondering if the logical argument of lower.tail can be vectorized (?). I see that this may be a substantial change in many places (basically, all p and q functions of probability distributions), but in my understanding, it would not break existing code which assumes lower.tail to be a single element. If that?s not
    > possible/feasible, I suggest to issue a warning if a vector of length > 1 is given in lower.tail. I am aware that the documentation clearly states that lower.tail is a single boolean.

aah ok, here you say you know that the current behavior is documented.

    > Thank you for your consideration.


As you mention, changing this would be quite a large endeavor.
I had thought about doing that many years ago, not remembering
details, but seeing that in almost all situations you really
only need one of the two tails  (for Gaussian- or t- based confidence
intervals you also only need one, for symmetry reason).

Allowing the recycling there would make the intermediate C code
(which does the recycling) larger and probably slightly
slower because of conceptually two more for loops which would in
99.9% only have one case ..

I'd have found that ugly to add. ... ...
... but of course, if you can prove that the code bloat would not be large
and not deteriorate speed in a measurable way and if you'd find
someone to produce a comprehensive and tested patch ...

Martin


    > With best wishes,
    > Matthias



    > [[alternative HTML version deleted]]

    > ______________________________________________
    > R-devel at r-project.org mailing list
    > https://stat.ethz.ch/mailman/listinfo/r-devel


From tom@@@k@||ber@ @end|ng |rom gm@||@com  Thu Dec  9 16:12:24 2021
From: tom@@@k@||ber@ @end|ng |rom gm@||@com (Tomas Kalibera)
Date: Thu, 9 Dec 2021 16:12:24 +0100
Subject: [Rd] Question about the UCRT switch
In-Reply-To: <f03410$h3f44e@ironport10.mayo.edu>
References: <f03410$h3f44e@ironport10.mayo.edu>
Message-ID: <80aae714-0ec5-90f9-5c5a-14b929bb1a92@gmail.com>


On 12/9/21 3:30 PM, Therneau, Terry M., Ph.D. via R-devel wrote:
> The connected blog has the statement? "Most authors will not have to do anything as the
> number of CRAN packages that will need some attention is below 1%, but authors of packages
> using native (C, C++ or Fortran) code should read the following lines."
>
> My packages do use a lot of C, but I never use Windows.?? My reading of "the following
> lines" is that? I don't have to do anything.?? Is this correct?

Well but your users might be using Windows, so as long as your package 
is on CRAN and you are maintaining it to support Windows, the blog might 
have useful information for you - for instance how to check whether you 
need to update your packages or not, but see below.

Specifically for your case, CRAN packages bdsmatrix, coxme, deming, 
noweb and survival are passing their checks with the new toolchain, as 
can be seen from the result pages such as

https://cran.r-project.org/web/checks/check_results_survival.html

They do not use any installation-time patches, as can be seen from

https://svn.r-project.org/R-dev-web/trunk/WindowsBuilds/winutf8/ucrt3/r_packages/patches/CRAN/

So, you really don't have to do anything, as most package authors with 
native code who don't use Windows.

Best
Tomas

>
> Terry T.
>
>


From bbo|ker @end|ng |rom gm@||@com  Thu Dec  9 16:55:17 2021
From: bbo|ker @end|ng |rom gm@||@com (Ben Bolker)
Date: Thu, 9 Dec 2021 10:55:17 -0500
Subject: [Rd] plogis (and other p* functions), vectorized lower.tail
In-Reply-To: <25010.6851.980357.14339@stat.math.ethz.ch>
References: <1MCKBm-1mmk5c180A-009QA7@mail.gmx.net>
 <25010.6851.980357.14339@stat.math.ethz.ch>
Message-ID: <0bd8b088-40c6-f62d-a296-9b540c1c1e55@gmail.com>



On 12/9/21 10:03 AM, Martin Maechler wrote:
>>>>>> Matthias Gondan
>>>>>>      on Wed, 8 Dec 2021 19:37:09 +0100 writes:
> 
>      > Dear R developers,
>      > I have seen that plogis silently ignores vector elements of lower.tail,
> 
> and also of 'log'.
> This is indeed the case for all d*, p*, q* functions.
> 
> Yes, this has been on purpose and therefore documented, in the
> case of plogis, e.g. in the 'Value' section of ?plogis :
> 
>       The length of the result is determined by ?n? for ?rlogis?, and is
>       the maximum of the lengths of the numerical arguments for the
>       other functions.
> 
>   (note: *numerical* arguments: the logical ones are not recycled)
> 
>       The numerical arguments other than ?n? are recycled to the length
>       of the result.  Only the first elements of the logical arguments
>       are used.
> 
>   (above, we even explicitly mention the logical arguments ..)
> 
> 
> Recycling happens for the first argument (x,p,q) of these
> functions and for "parameters" of the distribution, but not for
> lower.tail, log.p (or 'log').
> 
> 
>      >> plogis(q=0.5, location=1, lower.tail=TRUE)
>      > [1] 0.3775407
>      >> plogis(q=0.5, location=1, lower.tail=FALSE)
>      > [1] 0.6224593
>      >> plogis(q=c(0.5, 0.5), location=1, lower.tail=c(TRUE, FALSE))
>      > [1] 0.3775407 0.3775407
> 
>      > For those familiar with psychological measurement: A use case of the above function is the so-called Rasch model, where the probability that a person with some specific ability (q) makes a correct (lower.tail=TRUE) or wrong response (lower.tail=FALSE) to an item with a specific difficulty (location). A vectorized version of plogis would enable to determine the likelihood of an entire response vector in a single call. My current workaround is an intermediate call to ?Vectorize?.
> 
>      > I am wondering if the logical argument of lower.tail can be vectorized (?). I see that this may be a substantial change in many places (basically, all p and q functions of probability distributions), but in my understanding, it would not break existing code which assumes lower.tail to be a single element. If that?s not
>      > possible/feasible, I suggest to issue a warning if a vector of length > 1 is given in lower.tail. I am aware that the documentation clearly states that lower.tail is a single boolean.
> 
> aah ok, here you say you know that the current behavior is documented.
> 
>      > Thank you for your consideration.
> 
> 
> As you mention, changing this would be quite a large endeavor.
> I had thought about doing that many years ago, not remembering
> details, but seeing that in almost all situations you really
> only need one of the two tails  (for Gaussian- or t- based confidence
> intervals you also only need one, for symmetry reason).
> 
> Allowing the recycling there would make the intermediate C code
> (which does the recycling) larger and probably slightly
> slower because of conceptually two more for loops which would in
> 99.9% only have one case ..
> 
> I'd have found that ugly to add. ... ...
> ... but of course, if you can prove that the code bloat would not be large
> and not deteriorate speed in a measurable way and if you'd find
> someone to produce a comprehensive and tested patch ...
> 
> Martin
> 
> 
>      > With best wishes,
>      > Matthias
> 
> 
> 
>      > [[alternative HTML version deleted]]
> 
>      > ______________________________________________
>      > R-devel at r-project.org mailing list
>      > https://stat.ethz.ch/mailman/listinfo/r-devel
> 
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel
> 

   I agree with everything said above, but think that adding a warning 
when length(lower.tail) > 1 (rather than silently ignoring) might be 
helpful ...  ??

   As for the vectorization, it seems almost trivial to do at the user 
level when needed (albeit it's probably a little bit inefficient):

pv <- Vectorize(plogis, c("q", "location", "scale", "lower.tail"))
pv(q=c(0.5, 0.5), location=1, lower.tail=c(TRUE, FALSE))
[1] 0.3775407 0.6224593


From @oko| @end|ng |rom |n@@-tou|ou@e@|r  Thu Dec  9 17:13:36 2021
From: @oko| @end|ng |rom |n@@-tou|ou@e@|r (Sokol Serguei)
Date: Thu, 9 Dec 2021 17:13:36 +0100
Subject: [Rd] plogis (and other p* functions), vectorized lower.tail
In-Reply-To: <0bd8b088-40c6-f62d-a296-9b540c1c1e55@gmail.com>
References: <1MCKBm-1mmk5c180A-009QA7@mail.gmx.net>
 <25010.6851.980357.14339@stat.math.ethz.ch>
 <0bd8b088-40c6-f62d-a296-9b540c1c1e55@gmail.com>
Message-ID: <a8c1428c-e7a5-d5c9-a437-efe448aef2ae@insa-toulouse.fr>

On 09/12/2021 16:55, Ben Bolker wrote:
>
>
> On 12/9/21 10:03 AM, Martin Maechler wrote:
>>>>>>> Matthias Gondan
>>>>>>> ???? on Wed, 8 Dec 2021 19:37:09 +0100 writes:
>>
>> ???? > Dear R developers,
>> ???? > I have seen that plogis silently ignores vector elements of 
>> lower.tail,
>>
>> and also of 'log'.
>> This is indeed the case for all d*, p*, q* functions.
>>
>> Yes, this has been on purpose and therefore documented, in the
>> case of plogis, e.g. in the 'Value' section of ?plogis :
>>
>> ????? The length of the result is determined by ?n? for ?rlogis?, and is
>> ????? the maximum of the lengths of the numerical arguments for the
>> ????? other functions.
>>
>> ? (note: *numerical* arguments: the logical ones are not recycled)
>>
>> ????? The numerical arguments other than ?n? are recycled to the length
>> ????? of the result.? Only the first elements of the logical arguments
>> ????? are used.
>>
>> ? (above, we even explicitly mention the logical arguments ..)
>>
>>
>> Recycling happens for the first argument (x,p,q) of these
>> functions and for "parameters" of the distribution, but not for
>> lower.tail, log.p (or 'log').
>>
>>
>> ???? >> plogis(q=0.5, location=1, lower.tail=TRUE)
>> ???? > [1] 0.3775407
>> ???? >> plogis(q=0.5, location=1, lower.tail=FALSE)
>> ???? > [1] 0.6224593
>> ???? >> plogis(q=c(0.5, 0.5), location=1, lower.tail=c(TRUE, FALSE))
>> ???? > [1] 0.3775407 0.3775407
>>
>> ???? > For those familiar with psychological measurement: A use case 
>> of the above function is the so-called Rasch model, where the 
>> probability that a person with some specific ability (q) makes a 
>> correct (lower.tail=TRUE) or wrong response (lower.tail=FALSE) to an 
>> item with a specific difficulty (location). A vectorized version of 
>> plogis would enable to determine the likelihood of an entire response 
>> vector in a single call. My current workaround is an intermediate 
>> call to ?Vectorize?.
>>
>> ???? > I am wondering if the logical argument of lower.tail can be 
>> vectorized (?). I see that this may be a substantial change in many 
>> places (basically, all p and q functions of probability 
>> distributions), but in my understanding, it would not break existing 
>> code which assumes lower.tail to be a single element. If that?s not
>> ???? > possible/feasible, I suggest to issue a warning if a vector of 
>> length > 1 is given in lower.tail. I am aware that the documentation 
>> clearly states that lower.tail is a single boolean.
>>
>> aah ok, here you say you know that the current behavior is documented.
>>
>> ???? > Thank you for your consideration.
>>
>>
>> As you mention, changing this would be quite a large endeavor.
>> I had thought about doing that many years ago, not remembering
>> details, but seeing that in almost all situations you really
>> only need one of the two tails? (for Gaussian- or t- based confidence
>> intervals you also only need one, for symmetry reason).
>>
>> Allowing the recycling there would make the intermediate C code
>> (which does the recycling) larger and probably slightly
>> slower because of conceptually two more for loops which would in
>> 99.9% only have one case ..
>>
>> I'd have found that ugly to add. ... ...
>> ... but of course, if you can prove that the code bloat would not be 
>> large
>> and not deteriorate speed in a measurable way and if you'd find
>> someone to produce a comprehensive and tested patch ...
>>
>> Martin
>>
>>
>> ???? > With best wishes,
>> ???? > Matthias
>>
>>
>>
>> ???? > [[alternative HTML version deleted]]
>>
>> ???? > ______________________________________________
>> ???? > R-devel at r-project.org mailing list
>> ???? > https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel
>>
>
> ? I agree with everything said above, but think that adding a warning 
> when length(lower.tail) > 1 (rather than silently ignoring) might be 
> helpful ...? ??
>
> ? As for the vectorization, it seems almost trivial to do at the user 
> level when needed (albeit it's probably a little bit inefficient):
>
> pv <- Vectorize(plogis, c("q", "location", "scale", "lower.tail"))
> pv(q=c(0.5, 0.5), location=1, lower.tail=c(TRUE, FALSE))
> [1] 0.3775407 0.6224593

.. or directly use mapply()

mapply(plogis, q=c(0.5, 0.5), location=1, lower.tail=c(TRUE, FALSE))
[1] 0.3775407 0.6224593


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Thu Dec  9 17:35:33 2021
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Thu, 9 Dec 2021 17:35:33 +0100
Subject: [Rd] plogis (and other p* functions), vectorized lower.tail
In-Reply-To: <a8c1428c-e7a5-d5c9-a437-efe448aef2ae@insa-toulouse.fr>
References: <1MCKBm-1mmk5c180A-009QA7@mail.gmx.net>
 <25010.6851.980357.14339@stat.math.ethz.ch>
 <0bd8b088-40c6-f62d-a296-9b540c1c1e55@gmail.com>
 <a8c1428c-e7a5-d5c9-a437-efe448aef2ae@insa-toulouse.fr>
Message-ID: <25010.12373.335441.351617@stat.math.ethz.ch>

>>>>> Sokol Serguei on Thu, 9 Dec 2021 17:13:36 +0100 writes:

    > On 09/12/2021 16:55, Ben Bolker wrote:
    >> 
    >> 
    >> On 12/9/21 10:03 AM, Martin Maechler wrote:
    >>>>>>>> Matthias Gondan
    >>>>>>>> ???? on Wed, 8 Dec 2021 19:37:09 +0100 writes:
    >>> 
    >>> ???? > Dear R developers,
    >>> ???? > I have seen that plogis silently ignores vector elements of 
    >>> lower.tail,
    >>> 
    >>> and also of 'log'.
    >>> This is indeed the case for all d*, p*, q* functions.
    >>> 
    >>> Yes, this has been on purpose and therefore documented, in the
    >>> case of plogis, e.g. in the 'Value' section of ?plogis :
    >>> 
    >>> ????? The length of the result is determined by ?n? for ?rlogis?, and is
    >>> ????? the maximum of the lengths of the numerical arguments for the
    >>> ????? other functions.
    >>> 
    >>> ? (note: *numerical* arguments: the logical ones are not recycled)
    >>> 
    >>> ????? The numerical arguments other than ?n? are recycled to the length
    >>> ????? of the result.? Only the first elements of the logical arguments
    >>> ????? are used.
    >>> 
    >>> ? (above, we even explicitly mention the logical arguments ..)
    >>> 
    >>> 
    >>> Recycling happens for the first argument (x,p,q) of these
    >>> functions and for "parameters" of the distribution, but not for
    >>> lower.tail, log.p (or 'log').
    >>> 
    >>> 
    >>> ???? >> plogis(q=0.5, location=1, lower.tail=TRUE)
    >>> ???? > [1] 0.3775407
    >>> ???? >> plogis(q=0.5, location=1, lower.tail=FALSE)
    >>> ???? > [1] 0.6224593
    >>> ???? >> plogis(q=c(0.5, 0.5), location=1, lower.tail=c(TRUE, FALSE))
    >>> ???? > [1] 0.3775407 0.3775407
    >>> 
    >>> ???? > For those familiar with psychological measurement: A use case 
    >>> of the above function is the so-called Rasch model, where the 
    >>> probability that a person with some specific ability (q) makes a 
    >>> correct (lower.tail=TRUE) or wrong response (lower.tail=FALSE) to an 
    >>> item with a specific difficulty (location). A vectorized version of 
    >>> plogis would enable to determine the likelihood of an entire response 
    >>> vector in a single call. My current workaround is an intermediate 
    >>> call to ?Vectorize?.
    >>> 
    >>> ???? > I am wondering if the logical argument of lower.tail can be 
    >>> vectorized (?). I see that this may be a substantial change in many 
    >>> places (basically, all p and q functions of probability 
    >>> distributions), but in my understanding, it would not break existing 
    >>> code which assumes lower.tail to be a single element. If that?s not
    >>> ???? > possible/feasible, I suggest to issue a warning if a vector of 
    >>> length > 1 is given in lower.tail. I am aware that the documentation 
    >>> clearly states that lower.tail is a single boolean.
    >>> 
    >>> aah ok, here you say you know that the current behavior is documented.
    >>> 
    >>> ???? > Thank you for your consideration.
    >>> 
    >>> 
    >>> As you mention, changing this would be quite a large endeavor.
    >>> I had thought about doing that many years ago, not remembering
    >>> details, but seeing that in almost all situations you really
    >>> only need one of the two tails? (for Gaussian- or t- based confidence
    >>> intervals you also only need one, for symmetry reason).
    >>> 
    >>> Allowing the recycling there would make the intermediate C code
    >>> (which does the recycling) larger and probably slightly
    >>> slower because of conceptually two more for loops which would in
    >>> 99.9% only have one case ..
    >>> 
    >>> I'd have found that ugly to add. ... ...
    >>> ... but of course, if you can prove that the code bloat would not be 
    >>> large
    >>> and not deteriorate speed in a measurable way and if you'd find
    >>> someone to produce a comprehensive and tested patch ...
    >>> 
    >>> Martin
    >>> 
    >>> 
    >>> ???? > With best wishes,
    >>> ???? > Matthias
    >>> 
    >>> 
    >>> 
    >>> ???? > [[alternative HTML version deleted]]
    >>> 
    >>> ???? > ______________________________________________
    >>> ???? > R-devel at r-project.org mailing list
    >>> ???? > https://stat.ethz.ch/mailman/listinfo/r-devel
    >>> 
    >>> ______________________________________________
    >>> R-devel at r-project.org mailing list
    >>> https://stat.ethz.ch/mailman/listinfo/r-devel
    >>> 
    >> 
    >> ? I agree with everything said above, but think that adding a warning 
    >> when length(lower.tail) > 1 (rather than silently ignoring) might be 
    >> helpful ...? ??
    >> 
    >> ? As for the vectorization, it seems almost trivial to do at the user 
    >> level when needed (albeit it's probably a little bit inefficient):
    >> 
    >> pv <- Vectorize(plogis, c("q", "location", "scale", "lower.tail"))
    >> pv(q=c(0.5, 0.5), location=1, lower.tail=c(TRUE, FALSE))
    >> [1] 0.3775407 0.6224593

    > .. or directly use mapply()

    > mapply(plogis, q=c(0.5, 0.5), location=1, lower.tail=c(TRUE, FALSE))
    > [1] 0.3775407 0.6224593

Very nice, yes.  Also, there's no need to recycle/vectorize yourself:
 q=0.5  is sufficient:

 > mapply(plogis, q=0.5, location=1, lower.tail=c(TRUE, FALSE))
 [1] 0.3775407 0.6224593


Martin


From m@tth|@@-gond@n @end|ng |rom gmx@de  Thu Dec  9 20:12:32 2021
From: m@tth|@@-gond@n @end|ng |rom gmx@de (Matthias Gondan)
Date: Thu, 9 Dec 2021 20:12:32 +0100
Subject: [Rd] plogis (and other p* functions), vectorized lower.tail
In-Reply-To: <25010.6851.980357.14339@stat.math.ethz.ch>
References: <1MCKBm-1mmk5c180A-009QA7@mail.gmx.net>
 <25010.6851.980357.14339@stat.math.ethz.ch>
Message-ID: <1N63Vi-1mStfH2pse-016PUK@mail.gmx.net>

Ok, I see. It?s a nontrivial change, since the present setup (DEFMATH3_2 & friends) only allows the real-valued function arguments to be vectorized. If this is to be changed, all these macros would need to be rewritten. Case closed.

Best wishes,

Matthias

Von: Martin Maechler
Gesendet: Donnerstag, 9. Dezember 2021 16:03
An: Matthias Gondan
Cc: r-devel at r-project.org
Betreff: Re: [Rd] plogis (and other p* functions), vectorized lower.tail

>>>>> Matthias Gondan 
>>>>>     on Wed, 8 Dec 2021 19:37:09 +0100 writes:

    > Dear R developers,
    > I have seen that plogis silently ignores vector elements of lower.tail,

and also of 'log'.
This is indeed the case for all d*, p*, q* functions.

Yes, this has been on purpose and therefore documented, in the
case of plogis, e.g. in the 'Value' section of ?plogis :

     The length of the result is determined by ?n? for ?rlogis?, and is
     the maximum of the lengths of the numerical arguments for the
     other functions.

 (note: *numerical* arguments: the logical ones are not recycled)

     The numerical arguments other than ?n? are recycled to the length
     of the result.  Only the first elements of the logical arguments
     are used.

 (above, we even explicitly mention the logical arguments ..)


Recycling happens for the first argument (x,p,q) of these
functions and for "parameters" of the distribution, but not for
lower.tail, log.p (or 'log').


    >> plogis(q=0.5, location=1, lower.tail=TRUE) 
    > [1] 0.3775407
    >> plogis(q=0.5, location=1, lower.tail=FALSE) 
    > [1] 0.6224593
    >> plogis(q=c(0.5, 0.5), location=1, lower.tail=c(TRUE, FALSE)) 
    > [1] 0.3775407 0.3775407

    > For those familiar with psychological measurement: A use case of the above function is the so-called Rasch model, where the probability that a person with some specific ability (q) makes a correct (lower.tail=TRUE) or wrong response (lower.tail=FALSE) to an item with a specific difficulty (location). A vectorized version of plogis would enable to determine the likelihood of an entire response vector in a single call. My current workaround is an intermediate call to ?Vectorize?.

    > I am wondering if the logical argument of lower.tail can be vectorized (?). I see that this may be a substantial change in many places (basically, all p and q functions of probability distributions), but in my understanding, it would not break existing code which assumes lower.tail to be a single element. If that?s not
    > possible/feasible, I suggest to issue a warning if a vector of length > 1 is given in lower.tail. I am aware that the documentation clearly states that lower.tail is a single boolean.

aah ok, here you say you know that the current behavior is documented.

    > Thank you for your consideration.


As you mention, changing this would be quite a large endeavor.
I had thought about doing that many years ago, not remembering
details, but seeing that in almost all situations you really
only need one of the two tails  (for Gaussian- or t- based confidence
intervals you also only need one, for symmetry reason).

Allowing the recycling there would make the intermediate C code
(which does the recycling) larger and probably slightly
slower because of conceptually two more for loops which would in
99.9% only have one case ..

I'd have found that ugly to add. ... ...
... but of course, if you can prove that the code bloat would not be large
and not deteriorate speed in a measurable way and if you'd find
someone to produce a comprehensive and tested patch ...

Martin


    > With best wishes,
    > Matthias



    > [[alternative HTML version deleted]]

    > ______________________________________________
    > R-devel at r-project.org mailing list
    > https://stat.ethz.ch/mailman/listinfo/r-devel


	[[alternative HTML version deleted]]


From gr@ntmcd @end|ng |rom uoregon@edu  Fri Dec 10 19:57:12 2021
From: gr@ntmcd @end|ng |rom uoregon@edu (Grant McDermott)
Date: Fri, 10 Dec 2021 18:57:12 +0000
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <MWHPR1001MB2384CD0939331AF4B4DE9C41CF6B9@MWHPR1001MB2384.namprd10.prod.outlook.com>
References: <MWHPR1001MB2384CD0939331AF4B4DE9C41CF6B9@MWHPR1001MB2384.namprd10.prod.outlook.com>
Message-ID: <MWHPR1001MB2384713F140C2375DFF83998CF719@MWHPR1001MB2384.namprd10.prod.outlook.com>

Sorry I haven't had a chance to reply to anyone. I feel like I dropped a grenade in a room and promptly bolted...

Just to say, then, that I really appreciate everyone's comments and suggestions. While I'm tempted to push back on some points, I don't think it's worth on balance, or will add much beyond what's already been said.

It's interesting to see that there appears to be at least some appetite for additional (f)string operators in base R... notwithstanding the valid objections and the difficulties raised in this thread.

Cheers,
Grant

Get Outlook for Android<https://aka.ms/AAb9ysg>
________________________________
From: Grant McDermott
Sent: Saturday, December 4, 2021 12:36:44 PM
To: r-devel at r-project.org <r-devel at r-project.org>
Subject: string concatenation operator (revisited)

Hi all,

I wonder if the R Core team might reconsider an old feature request, as detailed in this 2005 thread: https://stat.ethz.ch/pipermail/r-help/2005-February/thread.html#66698

The TL;DR version is base R support for a `+.character` method. This would essentially provide a shortcut to `paste?0`, in much the same way that `\(x)` now provides a shortcut to `function(x)`.

> a = "hello "; b = "world"
> a + b
> [1] "hello world"

I appreciate some of the original concerns raised against a native "string1 + string2" implementation. The above thread also provides several use-at-your-own-risk workarounds. But sixteen years is a long time in software development and R now stands as something of an exception on this score. Python, Julia, Stata, and SQL (among various others) all support native string concatenation/interpolation using binary/arithmetic operators. It's been a surprising source of frustration for students in some of the classes I teach, particularly those coming from another language.

Many thanks for considering.

PS. I hope I didn't miss any additional discussion of this issue beyond the original 2005 thread. My search efforts didn't turn anything else up, except this popular Stackoverflow question: https://stackoverflow.com/questions/4730551/making-a-string-concatenation-operator-in-r

Grant McDermott
Assistant Professor
Department of Economics
University of Oregon
www.grantmcdermott.com


	[[alternative HTML version deleted]]


From bob @end|ng |rom rud@|@  Sun Dec 12 15:33:06 2021
From: bob @end|ng |rom rud@|@ (Bob Rudis)
Date: Sun, 12 Dec 2021 09:33:06 -0500
Subject: [Rd] string concatenation operator (revisited)
In-Reply-To: <MWHPR1001MB2384713F140C2375DFF83998CF719@MWHPR1001MB2384.namprd10.prod.outlook.com>
References: <MWHPR1001MB2384CD0939331AF4B4DE9C41CF6B9@MWHPR1001MB2384.namprd10.prod.outlook.com>
 <MWHPR1001MB2384713F140C2375DFF83998CF719@MWHPR1001MB2384.namprd10.prod.outlook.com>
Message-ID: <CAA-FpKXkHXb1YYNbwmOr3P8zdiC==DBOR75sv92DVfkvr=NX9g@mail.gmail.com>

FWIW {stringi} has %+% for this functionality (and I occasionally use
it), tho I do enough processing of quite ughly string content that I
pretty much always have {stringi} loaded. That may not be true for
many other folks.

On Fri, Dec 10, 2021 at 2:07 PM Grant McDermott <grantmcd at uoregon.edu> wrote:
>
> Sorry I haven't had a chance to reply to anyone. I feel like I dropped a grenade in a room and promptly bolted...
>
> Just to say, then, that I really appreciate everyone's comments and suggestions. While I'm tempted to push back on some points, I don't think it's worth on balance, or will add much beyond what's already been said.
>
> It's interesting to see that there appears to be at least some appetite for additional (f)string operators in base R... notwithstanding the valid objections and the difficulties raised in this thread.
>
> Cheers,
> Grant
>
> Get Outlook for Android<https://aka.ms/AAb9ysg>
> ________________________________
> From: Grant McDermott
> Sent: Saturday, December 4, 2021 12:36:44 PM
> To: r-devel at r-project.org <r-devel at r-project.org>
> Subject: string concatenation operator (revisited)
>
> Hi all,
>
> I wonder if the R Core team might reconsider an old feature request, as detailed in this 2005 thread: https://stat.ethz.ch/pipermail/r-help/2005-February/thread.html#66698
>
> The TL;DR version is base R support for a `+.character` method. This would essentially provide a shortcut to `paste0`, in much the same way that `\(x)` now provides a shortcut to `function(x)`.
>
> > a = "hello "; b = "world"
> > a + b
> > [1] "hello world"
>
> I appreciate some of the original concerns raised against a native "string1 + string2" implementation. The above thread also provides several use-at-your-own-risk workarounds. But sixteen years is a long time in software development and R now stands as something of an exception on this score. Python, Julia, Stata, and SQL (among various others) all support native string concatenation/interpolation using binary/arithmetic operators. It's been a surprising source of frustration for students in some of the classes I teach, particularly those coming from another language.
>
> Many thanks for considering.
>
> PS. I hope I didn't miss any additional discussion of this issue beyond the original 2005 thread. My search efforts didn't turn anything else up, except this popular Stackoverflow question: https://stackoverflow.com/questions/4730551/making-a-string-concatenation-operator-in-r
>
> Grant McDermott
> Assistant Professor
> Department of Economics
> University of Oregon
> www.grantmcdermott.com
>
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-devel at r-project.org mailing list
> https://stat.ethz.ch/mailman/listinfo/r-devel


From j@jh@|| @end|ng |rom ed@@c@uk  Sun Dec 12 16:42:42 2021
From: j@jh@|| @end|ng |rom ed@@c@uk (Julian Hall)
Date: Sun, 12 Dec 2021 15:42:42 +0000
Subject: [Rd] Improved LP/MIP solver
Message-ID: <398833eb-b071-f2d0-5813-7f49fe48cb42@ed.ac.uk>

Dear All,

I am leading the development of HiGHS, which is now the top performing open source linear optimization software on the industry standard benchmarks. In particular, our MIP solver out-performs SCIP, and is way ahead of the COIN-OR solver Cbc.

HiGHS solves LPs via simplex or interior point, MIPs via branch-and-cut, and QPs via an active set method.

We were wondering what interest there would be in developing an R interface to HiGHS. I'm not an R user, but have done a bit of searching and see references to Rsymphony and an interface to Lpsolve.

Performance-wise Lpsolve is very poor, but I know that it has a community of devoted followers. I've not seen benchmark results for Symphony, but I know that Cbc is the preferred COIN-OR MIP solver when it comes to general performance.  And, as I observed, the performance of HiGHS is way better than Cbc.

Are people in the R community tearing their hair out over the performance of software requiring the solution of LPs or MIPs?

Would a significantly better LP/MIP solver be valuable to the R community?

Thanks,

Julian
--
Dr. J. A. Julian Hall, Reader, School of Mathematics,
University of Edinburgh, James Clerk Maxwell Building,
Peter Guthrie Tait Road, EDINBURGH, EH9 3FD, UK.
Room: 5418 Phone: [+44](131) 650 5075 Email: J.A.J.Hall at ed.ac.uk<mailto:J.A.J.Hall at ed.ac.uk>
Web: https://www.maths.ed.ac.uk/school-of-mathematics/people/a-z?person=47
[HiGHS]<http://www.highs.dev>

My working hours may not be your working hours. Do not feel pressure to reply to this email outside your working hours.
The University of Edinburgh is a charitable body, registered in Scotland, with registration number SC005336. Is e buidheann carthannais a th? ann an Oilthigh Dh?n ?ideann, cl?raichte an Alba, ?ireamh cl?raidh SC005336.

	[[alternative HTML version deleted]]


From @vr@h@m@@d|er @end|ng |rom gm@||@com  Sun Dec 12 17:24:42 2021
From: @vr@h@m@@d|er @end|ng |rom gm@||@com (Avraham Adler)
Date: Sun, 12 Dec 2021 16:24:42 +0000
Subject: [Rd] Improved LP/MIP solver
In-Reply-To: <398833eb-b071-f2d0-5813-7f49fe48cb42@ed.ac.uk>
References: <398833eb-b071-f2d0-5813-7f49fe48cb42@ed.ac.uk>
Message-ID: <CAL6gwn+1eM7jSJFwif7b66cCTe=64r4U7fvxXnQuigfnLOqo3g@mail.gmail.com>

On Sun, Dec 12, 2021 at 3:44 PM Julian Hall <jajhall at ed.ac.uk> wrote:
>
> Dear All,
>
> I am leading the development of HiGHS, which is now the top performing open source linear optimization software on the industry standard benchmarks. In particular, our MIP solver out-performs SCIP, and is way ahead of the COIN-OR solver Cbc.
>
> HiGHS solves LPs via simplex or interior point, MIPs via branch-and-cut, and QPs via an active set method.
>
> We were wondering what interest there would be in developing an R interface to HiGHS. I'm not an R user, but have done a bit of searching and see references to Rsymphony and an interface to Lpsolve.
>
> Performance-wise Lpsolve is very poor, but I know that it has a community of devoted followers. I've not seen benchmark results for Symphony, but I know that Cbc is the preferred COIN-OR MIP solver when it comes to general performance.  And, as I observed, the performance of HiGHS is way better than Cbc.
>
> Are people in the R community tearing their hair out over the performance of software requiring the solution of LPs or MIPs?
>
> Would a significantly better LP/MIP solver be valuable to the R community?
>
> Thanks,
>
> Julian
> --
> Dr. J. A. Julian Hall, Reader, School of Mathematics,
> University of Edinburgh, James Clerk Maxwell Building,
> Peter Guthrie Tait Road, EDINBURGH, EH9 3FD, UK.
> Room: 5418 Phone: [+44](131) 650 5075 Email: J.A.J.Hall at ed.ac.uk<mailto:J.A.J.Hall at ed.ac.uk>
> Web: https://www.maths.ed.ac.uk/school-of-mathematics/people/a-z?person=47
> [HiGHS]<http://www.highs.dev>
>
> My working hours may not be your working hours. Do not feel pressure to reply to this email outside your working hours.
> The University of Edinburgh is a charitable body, registered in Scotland, with registration number SC005336. Is e buidheann carthannais a th? ann an Oilthigh Dh?n ?ideann, cl?raichte an Alba, ?ireamh cl?raidh SC005336.

Hello, Julian.

I cannot speak for the R community, but as someone who needs
optimization on a regular basis, this sounds intriguing. The fact that
HiGHS appears to be FLOSS, and thus usable as-is in the corporate
setting, appeals to those of us who use R in industry. Would you have
any statistics on how the solvers in HiGHS compare with similar ones
currently available in R, specifically the following in NLOPT [1]
(which is called through nloptr): SLSQP (gradient-based) and COBYLA
(gradient-free) both of which support equality and inequality
constraints, and MMA/CCSA (gradient based) which supports inequality
constraints? As for integer or mixed integer programming, I believe
that there is a lot of room for improvement in R. Personally, I've
resorted to using DEOptim with the "fnMap" entry calling a round
function similar to [2]. So speaking for myself, giving richer options
for optimization is a good thing, especially if the installation
procedure can be simplified!

Thank you,

Avi

[1] https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/
[2] https://stackoverflow.com/questions/42197353/how-to-set-integer-constraint-using-fnmap-in-deoptim-r


From @vr@h@m@@d|er @end|ng |rom gm@||@com  Sun Dec 12 17:27:02 2021
From: @vr@h@m@@d|er @end|ng |rom gm@||@com (Avraham Adler)
Date: Sun, 12 Dec 2021 16:27:02 +0000
Subject: [Rd] Improved LP/MIP solver
In-Reply-To: <CAL6gwn+1eM7jSJFwif7b66cCTe=64r4U7fvxXnQuigfnLOqo3g@mail.gmail.com>
References: <398833eb-b071-f2d0-5813-7f49fe48cb42@ed.ac.uk>
 <CAL6gwn+1eM7jSJFwif7b66cCTe=64r4U7fvxXnQuigfnLOqo3g@mail.gmail.com>
Message-ID: <CAL6gwnKQwnFj8UPBqiH4Uu71i5QiVgti+jSuyqG5KjOkmsws7g@mail.gmail.com>

On Sun, Dec 12, 2021 at 4:24 PM Avraham Adler <avraham.adler at gmail.com> wrote:
>
> On Sun, Dec 12, 2021 at 3:44 PM Julian Hall <jajhall at ed.ac.uk> wrote:
> >
> > Dear All,
> >
> > I am leading the development of HiGHS, which is now the top performing open source linear optimization software on the industry standard benchmarks. In particular, our MIP solver out-performs SCIP, and is way ahead of the COIN-OR solver Cbc.
> >
> > HiGHS solves LPs via simplex or interior point, MIPs via branch-and-cut, and QPs via an active set method.
> >
> > We were wondering what interest there would be in developing an R interface to HiGHS. I'm not an R user, but have done a bit of searching and see references to Rsymphony and an interface to Lpsolve.
> >
> > Performance-wise Lpsolve is very poor, but I know that it has a community of devoted followers. I've not seen benchmark results for Symphony, but I know that Cbc is the preferred COIN-OR MIP solver when it comes to general performance.  And, as I observed, the performance of HiGHS is way better than Cbc.
> >
> > Are people in the R community tearing their hair out over the performance of software requiring the solution of LPs or MIPs?
> >
> > Would a significantly better LP/MIP solver be valuable to the R community?
> >
> > Thanks,
> >
> > Julian
> > --
> > Dr. J. A. Julian Hall, Reader, School of Mathematics,
> > University of Edinburgh, James Clerk Maxwell Building,
> > Peter Guthrie Tait Road, EDINBURGH, EH9 3FD, UK.
> > Room: 5418 Phone: [+44](131) 650 5075 Email: J.A.J.Hall at ed.ac.uk<mailto:J.A.J.Hall at ed.ac.uk>
> > Web: https://www.maths.ed.ac.uk/school-of-mathematics/people/a-z?person=47
> > [HiGHS]<http://www.highs.dev>
> >
> > My working hours may not be your working hours. Do not feel pressure to reply to this email outside your working hours.
> > The University of Edinburgh is a charitable body, registered in Scotland, with registration number SC005336. Is e buidheann carthannais a th? ann an Oilthigh Dh?n ?ideann, cl?raichte an Alba, ?ireamh cl?raidh SC005336.
>
> Hello, Julian.
>
> I cannot speak for the R community, but as someone who needs
> optimization on a regular basis, this sounds intriguing. The fact that
> HiGHS appears to be FLOSS, and thus usable as-is in the corporate
> setting, appeals to those of us who use R in industry. Would you have
> any statistics on how the solvers in HiGHS compare with similar ones
> currently available in R, specifically the following in NLOPT [1]
> (which is called through nloptr): SLSQP (gradient-based) and COBYLA
> (gradient-free) both of which support equality and inequality
> constraints, and MMA/CCSA (gradient based) which supports inequality
> constraints? As for integer or mixed integer programming, I believe
> that there is a lot of room for improvement in R. Personally, I've
> resorted to using DEOptim with the "fnMap" entry calling a round
> function similar to [2]. So speaking for myself, giving richer options
> for optimization is a good thing, especially if the installation
> procedure can be simplified!
>
> Thank you,
>
> Avi
>
> [1] https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/
> [2] https://stackoverflow.com/questions/42197353/how-to-set-integer-constraint-using-fnmap-in-deoptim-r

Also, to be good R-citizens, this thread should probably be moved to
R-package-devel [1].

Thanks,

Avi

[1] https://stat.ethz.ch/mailman/listinfo/r-package-devel


From tom@@@k@||ber@ @end|ng |rom gm@||@com  Mon Dec 13 13:02:14 2021
From: tom@@@k@||ber@ @end|ng |rom gm@||@com (Tomas Kalibera)
Date: Mon, 13 Dec 2021 13:02:14 +0100
Subject: [Rd] Feature request: Change default library path on Windows
In-Reply-To: <1973d4dc-b514-2993-5dbc-28668fcaa2ce@gmail.com>
References: <CAJhjiQmEP6Rw_jM8PEz4gD1VXWWW9E0p7Pw31dyk4TQsEPJRdw@mail.gmail.com>
 <CABFfbXvEQGejh069Ni7UZKub7UPA26QfvcH6waPcw+Z1jGSMMA@mail.gmail.com>
 <CAJhjiQmLUqHJW8PFGdqJU1T3cYX7bQQ7-6DRb34UZ_r7vKqBbw@mail.gmail.com>
 <b09f5373-4d0e-64d7-1d5e-91e948e12a28@gmail.com>
 <CAJhjiQnbggTG_7Hicp1PgbujhrJ5FW8mPRAgb7YhhpSPOx5syw@mail.gmail.com>
 <522686cd-645d-4a62-9dcf-5f701f3f9ab1@gmail.com>
 <CAJhjiQnBAucSkeQmONTz1oBDoO4eC=b_0WJVZ=bg89bqw0SYTw@mail.gmail.com>
 <c8e8bbda-35b4-c61f-46df-91708e1a88d8@gmail.com>
 <CAJhjiQk6H_Fb=fxKqRmZiZcX+Cb7vSiiDeJnSaJ1t8Fj_Bmyjw@mail.gmail.com>
 <1973d4dc-b514-2993-5dbc-28668fcaa2ce@gmail.com>
Message-ID: <d49767c9-11dc-5f50-49a8-c400a448afec@gmail.com>

The default was now changed in R-devel to the local application data 
(e.g. C:\Users\username\AppData\Local), which should solve the issues 
with synchronization/backup/etc services and seems to be more in line 
with conventions for the OS. It is a hidden folder, to open in Windows 
explorer one can use e.g. shell.exec() from R.

Best
Tomas

On 7/27/21 1:12 PM, Tomas Kalibera wrote:
> On 7/26/21 1:44 AM, Steve Haroz wrote:
>> Thanks Ben. I just sent a request for a bugzilla login.
>> Jeroen chimed in earlier in support.
>
> Please note this has been reported, discussed and considered already, 
> last time in PR#17842 (though proposing a different replacement for 
> the default).
>
> I think changing the default from user documents to something else 
> would make sense to consider together with some other breaking change 
> for users, not in isolation, if at all. While the change may help 
> users with a quota on the documents directory (e.g. shared on a cloud, 
> backup, etc), it will make it harder to find the library for others, 
> who would not notice the change to the documented behavior, and I 
> assume that would still be a much larger group.
>
> Of course it does not help that it is not clear what the correct 
> location should be now, and certainly there is little hope it won't 
> change again, soon. My understanding is that the choice was originally 
> correct when made, following the Microsoft guidelines.
>
> As discussed here as well, users may choose their own library path 
> (?.libPaths).
>
> The installation location for R itself can be changed e.g. via /DIR 
> option of the installer (see /?). This is useful e.g. when installing 
> R only for the current user (/CURRENTUSER) and it impacts also the 
> location of the library - it is then inside the given tree.
>
> Best
> Tomas
>
>
>
>>
>> Cheers,
>> Steve
>>
>> ______________________________________________
>> R-devel at r-project.org mailing list
>> https://stat.ethz.ch/mailman/listinfo/r-devel


From m@ech|er @end|ng |rom @t@t@m@th@ethz@ch  Mon Dec 13 16:59:15 2021
From: m@ech|er @end|ng |rom @t@t@m@th@ethz@ch (Martin Maechler)
Date: Mon, 13 Dec 2021 16:59:15 +0100
Subject: [Rd] Appropriate mailing list for " Improved LP/MIP solver "
In-Reply-To: <CAL6gwnKQwnFj8UPBqiH4Uu71i5QiVgti+jSuyqG5KjOkmsws7g@mail.gmail.com>
References: <398833eb-b071-f2d0-5813-7f49fe48cb42@ed.ac.uk>
 <CAL6gwn+1eM7jSJFwif7b66cCTe=64r4U7fvxXnQuigfnLOqo3g@mail.gmail.com>
 <CAL6gwnKQwnFj8UPBqiH4Uu71i5QiVgti+jSuyqG5KjOkmsws7g@mail.gmail.com>
Message-ID: <25015.28115.450016.486300@stat.math.ethz.ch>

>>>>> Avraham Adler 
>>>>>     on Sun, 12 Dec 2021 16:27:02 +0000 writes:

 [........................]

Thank you, Julian and Avi,  on the topic of asking and replying
if there's interest on getting improved LP / MIP  (and QP, I think was
mentioned too!) solver interfaces for R.

However, Avi writes

    > Also, to be good R-citizens, this thread should probably be moved to
    > R-package-devel [1].

    > Thanks,
    > Avi

and I'm of an entirely different opinion.

R-package-devel  has been created, aons after R-devel,  to
*help* R package developers to get their packaging problems
solved, notably to get advice in making their packages ready for
CRAN.

Julian's question was really addressing the whole R developer
community asking if some functionality was desirable to be added
to the R-package space.

For me one *the* appropriate topics for this R-devel mailing
list.

Best,
Martin

---
Martin Maechler
ETH Zurich  and  R Core
(and original creator of R-help, R-devel, .. lists)

    > [1] https://stat.ethz.ch/mailman/listinfo/r-package-devel


From @vr@h@m@@d|er @end|ng |rom gm@||@com  Mon Dec 13 17:10:38 2021
From: @vr@h@m@@d|er @end|ng |rom gm@||@com (Avraham Adler)
Date: Mon, 13 Dec 2021 11:10:38 -0500
Subject: [Rd] Appropriate mailing list for " Improved LP/MIP solver "
In-Reply-To: <25015.28115.450016.486300@stat.math.ethz.ch>
References: <398833eb-b071-f2d0-5813-7f49fe48cb42@ed.ac.uk>
 <CAL6gwn+1eM7jSJFwif7b66cCTe=64r4U7fvxXnQuigfnLOqo3g@mail.gmail.com>
 <CAL6gwnKQwnFj8UPBqiH4Uu71i5QiVgti+jSuyqG5KjOkmsws7g@mail.gmail.com>
 <25015.28115.450016.486300@stat.math.ethz.ch>
Message-ID: <CAL6gwn+=WWxv2JmMWpNbyVCej0mufGwtoufycU3MbSO2jeA4vw@mail.gmail.com>

I defer completely and totally to Martin!

Apologies,

Avi

On Mon, Dec 13, 2021 at 10:59 AM Martin Maechler <maechler at stat.math.ethz.ch>
wrote:

> >>>>> Avraham Adler
> >>>>>     on Sun, 12 Dec 2021 16:27:02 +0000 writes:
>
>  [........................]
>
> Thank you, Julian and Avi,  on the topic of asking and replying
> if there's interest on getting improved LP / MIP  (and QP, I think was
> mentioned too!) solver interfaces for R.
>
> However, Avi writes
>
>     > Also, to be good R-citizens, this thread should probably be moved to
>     > R-package-devel [1].
>
>     > Thanks,
>     > Avi
>
> and I'm of an entirely different opinion.
>
> R-package-devel  has been created, aons after R-devel,  to
> *help* R package developers to get their packaging problems
> solved, notably to get advice in making their packages ready for
> CRAN.
>
> Julian's question was really addressing the whole R developer
> community asking if some functionality was desirable to be added
> to the R-package space.
>
> For me one *the* appropriate topics for this R-devel mailing
> list.
>
> Best,
> Martin
>
> ---
> Martin Maechler
> ETH Zurich  and  R Core
> (and original creator of R-help, R-devel, .. lists)
>
>     > [1] https://stat.ethz.ch/mailman/listinfo/r-package-devel
>
>
> --
Sent from Gmail Mobile

	[[alternative HTML version deleted]]


