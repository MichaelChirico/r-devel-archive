From r@turner @end|ng |rom @uck|@nd@@c@nz  Sat May  1 00:38:40 2021
From: r@turner @end|ng |rom @uck|@nd@@c@nz (Rolf Turner)
Date: Sat, 1 May 2021 10:38:40 +1200
Subject: [R] Package "hse" has been REPLACED by package "dbd".
Message-ID: <20210501103840.651431b6@rolf-Latitude-E7470>


A reviewer of a paper that I wrote, of which the "hse" package was
a central consideration, thought that users might find the name "hse"
("hope springs eternal") to be indicative of a lack of seriousness.

Consequently I have changed the name of the package to "dbd"
("discretised beta distribution").  The underlying distribution, on
which the package is focussed, is now called "db" ("discretised beta").

The "hse" package still exists, *only* in order to produce a message
(when the package is loaded) to the effect that the package is
deprecated and that users should install and utilse the dbd package
instead.

The dbd package includes a number of modifications which (it is to be
hoped) make it an improvement over the hse package that it replaces.

I would be grateful to anyone who points out any problems with or
errors in the dbd package.

cheers,

Rolf Turner

-- 
Honorary Research Fellow
Department of Statistics
University of Auckland
Phone: +64-9-373-7599 ext. 88276


From ru|pb@rr@d@@ @end|ng |rom @@po@pt  Sat May  1 00:56:18 2021
From: ru|pb@rr@d@@ @end|ng |rom @@po@pt (Rui Barradas)
Date: Fri, 30 Apr 2021 23:56:18 +0100
Subject: [R] Help understanding loop behaviour
In-Reply-To: <CAGxFJbSkp59-qXn67kHcZvUbYwgf_qk8iYzszVXxtUYKo1U=zw@mail.gmail.com>
References: <679279936.579089.1619710842379@mail2.virginmedia.com>
 <CA+8X3fVm3mhCTP3z=Uzn2GJL21-iawt-c205T6+nJzFEBO=hzQ@mail.gmail.com>
 <b1031b55f1904a408de7aa67b19d9e6f@SRVEXCHCM1302.precheza.cz>
 <2b419e1d-292c-e826-5810-c224d9d9e112@sapo.pt>
 <CAGxFJbSkp59-qXn67kHcZvUbYwgf_qk8iYzszVXxtUYKo1U=zw@mail.gmail.com>
Message-ID: <47666adf-355a-7bab-7b2f-45d09791583a@sapo.pt>

Hello,

Right, thanks. I should be


xx$I <- ave(xx$NUMBER_OF_YEARS, xx$COMPANY_NUMBER, FUN = function(x){
         c(rep(1, length(x) - 1), length(x))  ### ???
     })


Hope this helps,

Rui Barradas

?s 19:46 de 30/04/21, Bert Gunter escreveu:
> There is something wrong here I believe -- see inline below:
> 
> Bert Gunter
> 
> "The trouble with having an open mind is that people keep coming along 
> and sticking things into it."
> -- Opus (aka Berkeley Breathed in his "Bloom County" comic strip )
> 
> 
> On Fri, Apr 30, 2021 at 10:37 AM Rui Barradas <ruipbarradas at sapo.pt 
> <mailto:ruipbarradas at sapo.pt>> wrote:
> 
>     Hello,
> 
>     For column J, ave/seq_along seems to be the simplest. For column I, ave
>     is also a good option, it avoids split/lapply.
> 
> 
>     xx$I <- ave(xx$NUMBER_OF_YEARS, xx$COMPANY_NUMBER, FUN = function(x){
>      ? ?c(rep(1, length(x) - 1), max(length(x)))? ### ???
>     })
> 
> **********
> length() returns a single integer, so max(length(x)) makes no sense
> ************************************
> 
>     xx$J <- ave(xx$NUMBER_OF_YEARS, xx$COMPANY_NUMBER, FUN = seq_along)
> 
> 
>     Hope this helps,
> 
>     ?s 11:49 de 30/04/21, PIKAL Petr escreveu:
>      > Hallo,
>      >
>      > Sorry, my suggestion did not worked in your case correctly as
>     split used
>      > natural factor ordering.
>      >
>      > So using Jim's data, this results in desired output.
>      >
>      > #prepare factor in original ordering
>      > ff <- factor(xx[,1], levels=unique(xx[,1]))
>      > lll <- split(xx$COMPANY_NUMBER, ff)
>      > xx$I <- unlist(lapply(lll, function(x) c(rep(1, length(x)-1),
>      > max(length(x)))),use.names=FALSE)
>      > xx$J <- unlist(lapply(lll, function(x) 1:length(x)), use.names=FALSE)
>      >> xx
>      >? ? ?COMPANY_NUMBER NUMBER_OF_YEARS I J
>      > 1? ? ? ? ? ?70837? ? ? ? ? ? ? ?3 1 1
>      > 2? ? ? ? ? ?70837? ? ? ? ? ? ? ?3 1 2
>      > 3? ? ? ? ? ?70837? ? ? ? ? ? ? ?3 3 3
>      > 4? ? ? ? ?1000403? ? ? ? ? ? ? ?4 1 1
>      > 5? ? ? ? ?1000403? ? ? ? ? ? ? ?4 1 2
>      > 6? ? ? ? ?1000403? ? ? ? ? ? ? ?4 1 3
>      > 7? ? ? ? ?1000403? ? ? ? ? ? ? ?4 4 4
>      > 8? ? ? ? 10029943? ? ? ? ? ? ? ?3 1 1
>      > 9? ? ? ? 10029943? ? ? ? ? ? ? ?3 1 2
>      > 10? ? ? ?10029943? ? ? ? ? ? ? ?3 3 3
>      > 11? ? ? ?10037980? ? ? ? ? ? ? ?4 1 1
>      > 12? ? ? ?10037980? ? ? ? ? ? ? ?4 1 2
>      > 13? ? ? ?10037980? ? ? ? ? ? ? ?4 1 3
>      > 14? ? ? ?10037980? ? ? ? ? ? ? ?4 4 4
>      > 15? ? ? ?10057418? ? ? ? ? ? ? ?3 1 1
>      > 16? ? ? ?10057418? ? ? ? ? ? ? ?3 1 2
>      > 17? ? ? ?10057418? ? ? ? ? ? ? ?3 3 3
>      > 18? ? ? ? 1009550? ? ? ? ? ? ? ?4 1 1
>      > 19? ? ? ? 1009550? ? ? ? ? ? ? ?4 1 2
>      > 20? ? ? ? 1009550? ? ? ? ? ? ? ?4 1 3
>      > 21? ? ? ? 1009550? ? ? ? ? ? ? ?4 4 4
>      >
>      > Cheers.
>      > Petr
>      >
>      >> -----Original Message-----
>      >> From: R-help <r-help-bounces at r-project.org
>     <mailto:r-help-bounces at r-project.org>> On Behalf Of Jim Lemon
>      >> Sent: Friday, April 30, 2021 11:45 AM
>      >> To: e-mail ma015k3113 <ma015k3113 at blueyonder.co.uk
>     <mailto:ma015k3113 at blueyonder.co.uk>>; r-help mailing list
>      >> <r-help at r-project.org <mailto:r-help at r-project.org>>
>      >> Subject: Re: [R] Help understanding loop behaviour
>      >>
>      >> Hi email,
>      >> If you want what you described, try this:
>      >>
>      >> xx<-read.table(text="COMPANY_NUMBER NUMBER_OF_YEARS
>      >> 0070837? 3
>      >> 0070837? 3
>      >> 0070837? 3
>      >> 1000403? 4
>      >> 1000403? 4
>      >> 1000403? 4
>      >> 1000403? 4
>      >> 10029943? 3
>      >> 10029943? 3
>      >> 10029943? 3
>      >> 10037980? 4
>      >> 10037980? 4
>      >> 10037980? 4
>      >> 10037980? 4
>      >> 10057418? 3
>      >> 10057418? 3
>      >> 10057418? 3
>      >> 1009550? 4
>      >> 1009550? 4
>      >> 1009550? 4
>      >> 1009550? 4",
>      >> header=TRUE,stringsAsFactors=FALSE)
>      >> xx$I<-NA
>      >> xx$J<-NA
>      >> row_count<-1
>      >> for(row in 1:nrow(xx)) {
>      >>? ?if(row == nrow(xx) ||
>      >> xx$COMPANY_NUMBER[row]==xx$COMPANY_NUMBER[row+1]) {
>      >>? ? xx$I[row]<-1
>      >>? ? xx$J[row]<-row_count
>      >>? ? row_count<-row_count+1
>      >>? ?} else {
>      >>? ? xx$I[row]<-xx$J[row]<-xx$NUMBER_OF_YEARS[row]
>      >>? ? row_count<-1
>      >>? ?}
>      >> }
>      >> xx
>      >>
>      >> Like Petr, I am assuming that you want company 10057418 treated
>     the same
>      >> as the others. If not, let us know why. I am also adssuming that
>     the first
>      > three
>      >> rows should _not_ have a "#" at the beginning, which means that
>     they will
>      > be
>      >> discarded.
>      >>
>      >> Jim
>      >>
>      >> On Fri, Apr 30, 2021 at 1:41 AM e-mail ma015k3113 via R-help
>     <r-help at r-
>      >> project.org <http://project.org>> wrote:
>      >>>
>      >>> I am trying to understand how loops in operate. I have a simple
>      >>> dataframe xx which is as follows
>      >>>
>      >>> COMPANY_NUMBER? ?NUMBER_OF_YEARS
>      >>>
>      >>> #0070837? ? ? ? ? ? ? ? ? ? ? ? ? ? ?3
>      >>> #0070837? ? ? ? ? ? ? ? ? ? ? ? ? ? ?3
>      >>> #0070837? ? ? ? ? ? ? ? ? ? ? ? ? ? ?3
>      >>> 1000403? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?4
>      >>> 1000403? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?4
>      >>> 1000403? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?4
>      >>> 1000403? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?4
>      >>> 10029943? ? ? ? ? ? ? ? ? ? ? ? ? ? ?3
>      >>> 10029943? ? ? ? ? ? ? ? ? ? ? ? ? ? ?3
>      >>> 10029943? ? ? ? ? ? ? ? ? ? ? ? ? ? ?3
>      >>> 10037980? ? ? ? ? ? ? ? ? ? ? ? ? ? ?4
>      >>> 10037980? ? ? ? ? ? ? ? ? ? ? ? ? ? ?4
>      >>> 10037980? ? ? ? ? ? ? ? ? ? ? ? ? ? ?4
>      >>> 10037980? ? ? ? ? ? ? ? ? ? ? ? ? ? ?4
>      >>> 10057418? ? ? ? ? ? ? ? ? ? ? ? ? ? ?3
>      >>> 10057418? ? ? ? ? ? ? ? ? ? ? ? ? ? ?3
>      >>>
>      >>> 10057418? ? ? ? ? ? ? ? ? ? ? ? ? ? ?3
>      >>> 1009550? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?4
>      >>> 1009550? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?4
>      >>> 1009550? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?4
>      >>> 1009550? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ?4
>      >>> The code I have written is
>      >>>
>      >>> while (i <= nrow(xx1) )
>      >>>
>      >>> {
>      >>>
>      >>> for (j in 1:xx1$NUMBER_OF_YEARS[i])
>      >>> {
>      >>> xx1$I[i] <- i
>      >>> xx1$J[j] <- j
>      >>> xx1$NUMBER_OF_YEARS_j[j] <- xx1$NUMBER_OF_YEARS[j] } i=i +
>      >>> (xx1$NUMBER_OF_YEARS[i] ) } After running the code I want my
>      >> dataframe
>      >>> to look like
>      >>>
>      >>> |COMPANY_NUMBER |NUMBER_OF_YEARS| | I| |J|
>      >>>
>      >>> |#0070837 |3| |1| |1|
>      >>> |#0070837 |3| |1| |2|
>      >>> |#0070837 |3| |3| |3|
>      >>> |1000403 |4| |1| |1|
>      >>> |1000403 |4| |1| |2|
>      >>> |1000403 |4| |1| |3|
>      >>> |1000403 |4| |4| |4|
>      >>> |10029943 |3| |1| |1|
>      >>> |10029943 |3| |1| |2|
>      >>> |10029943 |3| |3| |3|
>      >>> |10037980 |4| |1| |1|
>      >>> |10037980 |4| |1| |2|
>      >>> |10037980 |4| |1| |3|
>      >>> |10037980 |4| |4| |4|
>      >>> |10057418 |3| |1| |1|
>      >>> |10057418 |3| |1| |1|
>      >>> |10057418 |3| |1| |1|
>      >>> |1009550 |4| |1| |1|
>      >>> |1009550 |4| |1| |2|
>      >>> |1009550 |4| |1| |3|
>      >>> |1009550 |4| |4| |4|
>      >>>
>      >>>
>      >>> I get the correct value of I but in the wrong row but the vaule
>     of J
>      >>> is correct in the first iteration and then it goes to 1
>      >>>
>      >>> Any help will be greatly appreciated
>      >>>? ? ? ? ? [[alternative HTML version deleted]]
>      >>>
>      >>> ______________________________________________
>      >>> R-help at r-project.org <mailto:R-help at r-project.org> mailing list
>     -- To UNSUBSCRIBE and more, see
>      >>> https://stat.ethz.ch/mailman/listinfo/r-help
>     <https://stat.ethz.ch/mailman/listinfo/r-help>
>      >>> PLEASE do read the posting guide
>      >>> http://www.R-project.org/posting-guide.html
>     <http://www.R-project.org/posting-guide.html>
>      >>> and provide commented, minimal, self-contained, reproducible code.
>      >>
>      >> ______________________________________________
>      >> R-help at r-project.org <mailto:R-help at r-project.org> mailing list
>     -- To UNSUBSCRIBE and more, see
>      >> https://stat.ethz.ch/mailman/listinfo/r-help
>     <https://stat.ethz.ch/mailman/listinfo/r-help>
>      >> PLEASE do read the posting guide
>     http://www.R-project.org/posting- <http://www.R-project.org/posting->
>      >> guide.html
>      >> and provide commented, minimal, self-contained, reproducible code.
>      >>
>      >> ______________________________________________
>      >> R-help at r-project.org <mailto:R-help at r-project.org> mailing list
>     -- To UNSUBSCRIBE and more, see
>      >> https://stat.ethz.ch/mailman/listinfo/r-help
>     <https://stat.ethz.ch/mailman/listinfo/r-help>
>      >> PLEASE do read the posting guide
>     http://www.R-project.org/posting-guide.html
>     <http://www.R-project.org/posting-guide.html>
>      >> and provide commented, minimal, self-contained, reproducible code.
> 
>     ______________________________________________
>     R-help at r-project.org <mailto:R-help at r-project.org> mailing list --
>     To UNSUBSCRIBE and more, see
>     https://stat.ethz.ch/mailman/listinfo/r-help
>     <https://stat.ethz.ch/mailman/listinfo/r-help>
>     PLEASE do read the posting guide
>     http://www.R-project.org/posting-guide.html
>     <http://www.R-project.org/posting-guide.html>
>     and provide commented, minimal, self-contained, reproducible code.
>


From m@j@@@n@|yt|c@@b|og @end|ng |rom gm@||@com  Sat May  1 20:17:42 2021
From: m@j@@@n@|yt|c@@b|og @end|ng |rom gm@||@com (Maja Analytics)
Date: Sat, 1 May 2021 20:17:42 +0200
Subject: [R] Question about using R sample datasets
Message-ID: <CALbYN6xwv5fd2c2bN2cebMMNeK-2PgnqqE84uChbvpissv4Nog@mail.gmail.com>

Hello!

I would like to make tutorials for non-data scientists in R on Medium and
as LinkedIn articles. Could you tell me if I can use R sample datasets (I
would note the acknowledgements on the end) for that?

Thanks in advance, kind regards,
Maja

	[[alternative HTML version deleted]]


From dw|n@em|u@ @end|ng |rom comc@@t@net  Sun May  2 01:16:52 2021
From: dw|n@em|u@ @end|ng |rom comc@@t@net (David Winsemius)
Date: Sat, 1 May 2021 17:16:52 -0600
Subject: [R] Question about using R sample datasets
In-Reply-To: <CALbYN6xwv5fd2c2bN2cebMMNeK-2PgnqqE84uChbvpissv4Nog@mail.gmail.com>
References: <CALbYN6xwv5fd2c2bN2cebMMNeK-2PgnqqE84uChbvpissv4Nog@mail.gmail.com>
Message-ID: <AFF3AC76-DD69-48B2-A782-D52DEB3E371E@comcast.net>

Any answer you get here will will have all the authority of "some guy on the Internet", but my reading of the licenses is that as long as you give proper credit that you can use any material in teaching or commercial purposes AND derivative works are likewise copy-able on an open source (FOSS) basis. You should read the LinkedIn TOS and make sure that posting there is not subject to some sort of publisher's copyright. That might be a violation fo the licensing for material copied from CRAN sources. Acknowledgment alone might not be an acceptable use. You may need to seek appropriate legal counsel or get opinions from the creators of the licensing language, since there are a variety of license.

David Winsemius, MD, (IANAL)


> On May 1, 2021, at 12:17 PM, Maja Analytics <maja.analytics.blog at gmail.com> wrote:
> 
> Hello!
> 
> I would like to make tutorials for non-data scientists in R on Medium and
> as LinkedIn articles. Could you tell me if I can use R sample datasets (I
> would note the acknowledgements on the end) for that?
> 
> Thanks in advance, kind regards,
> Maja
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.


From mjung4 @end|ng |rom go@o|em|@@@edu  Sun May  2 01:50:04 2021
From: mjung4 @end|ng |rom go@o|em|@@@edu (Myungjin Jung)
Date: Sat, 1 May 2021 18:50:04 -0500
Subject: [R] Question
Message-ID: <CAApF_pgB6p_pXmxh-d+oTthYyMyMVpQ1ib6Y77=6b1jpeyPtMg@mail.gmail.com>

Good evening,

I have a quick question about the "robumeta" package in R software. Below
is my question:

Is it possible to create funnel plots as well as assess (Egger's test) and
adjust (Trim and fill approach) for publication bias in meta-analysis with
RVE methods?

Thank you so much for your help.

Best regards,
Myungjin

*Myungjin Jung*
Doctoral Graduate Assistant
The University of Mississippi
Department of Health, Exercise Science, and Recreation Management
P.O. Box 1848
234 Turner Center
University, MS 38677-1848
*mjung4 at go.olemiss.ed <mjung4 at go.olemiss.edu>u*

	[[alternative HTML version deleted]]


From bgunter@4567 @end|ng |rom gm@||@com  Sun May  2 04:02:54 2021
From: bgunter@4567 @end|ng |rom gm@||@com (Bert Gunter)
Date: Sat, 1 May 2021 19:02:54 -0700
Subject: [R] Question
In-Reply-To: <CAApF_pgB6p_pXmxh-d+oTthYyMyMVpQ1ib6Y77=6b1jpeyPtMg@mail.gmail.com>
References: <CAApF_pgB6p_pXmxh-d+oTthYyMyMVpQ1ib6Y77=6b1jpeyPtMg@mail.gmail.com>
Message-ID: <CAGxFJbTWs=AGr02xomaX66DBEywMfEVWSyu5TVY_ZLmWaNRR9A@mail.gmail.com>

Do note, per the posting guide linked below (which you should read):

"For questions about functions in standard packages distributed with R (see
the FAQ Add-on packages in R
<https://cran.r-project.org/doc/FAQ/R-FAQ.html#Add-on-packages-in-R>), ask
questions on R-help.

If the question relates to a *contributed package* , e.g., one downloaded
from CRAN, try contacting the package maintainer first. You can also use
find("functionname") and packageDescription("packagename") to find this
information. *Only* send such questions to R-help or R-devel if you get no
reply or need further assistance. This applies to both requests for help
and to bug reports."

So do not be surprised if you do not receive a response here. You would
probably have a better chance for success on the SIG devoted to
meta-analysis:
https://stat.ethz.ch/mailman/listinfo/r-sig-meta-analysis  .

Also per the posting guide, post in plain text not html. Not a problem
here, but it can be when one posts code.

Cheers,
Bert Gunter

"The trouble with having an open mind is that people keep coming along and
sticking things into it."
-- Opus (aka Berkeley Breathed in his "Bloom County" comic strip )


On Sat, May 1, 2021 at 5:59 PM Myungjin Jung <mjung4 at go.olemiss.edu> wrote:

> Good evening,
>
> I have a quick question about the "robumeta" package in R software. Below
> is my question:
>
> Is it possible to create funnel plots as well as assess (Egger's test) and
> adjust (Trim and fill approach) for publication bias in meta-analysis with
> RVE methods?
>
> Thank you so much for your help.
>
> Best regards,
> Myungjin
>
> *Myungjin Jung*
> Doctoral Graduate Assistant
> The University of Mississippi
> Department of Health, Exercise Science, and Recreation Management
> P.O. Box 1848
> 234 Turner Center
> University, MS 38677-1848
> *mjung4 at go.olemiss.ed <mjung4 at go.olemiss.edu>u*
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide
> http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
>

	[[alternative HTML version deleted]]


From drj|m|emon @end|ng |rom gm@||@com  Sun May  2 08:10:48 2021
From: drj|m|emon @end|ng |rom gm@||@com (Jim Lemon)
Date: Sun, 2 May 2021 16:10:48 +1000
Subject: [R] Question
In-Reply-To: <CAApF_pgB6p_pXmxh-d+oTthYyMyMVpQ1ib6Y77=6b1jpeyPtMg@mail.gmail.com>
References: <CAApF_pgB6p_pXmxh-d+oTthYyMyMVpQ1ib6Y77=6b1jpeyPtMg@mail.gmail.com>
Message-ID: <CA+8X3fVZeQOFfrpunF=pt_S4mPytExDp70JN_HB=2LQcz+mtNw@mail.gmail.com>

Hi Myungjin,
The funnel plot is no more than the precision of the estimates of
related studies plotted against the estimates. That is, if your
measure of precision is the sample size (SS) and the estimate is named
E,

plot(E,SS)

Look at the metafor package for good funnel plot functions. Egger's
test can be misleading, see:

https://training.cochrane.org/resource/identifying-publication-bias-meta-analyses-continuous-outcomes

for a good introduction.

Jim


produces a very basic funnel plot. Enclosing lines or curves are
usually added, forming the inverted "funnel".

On Sun, May 2, 2021 at 11:00 AM Myungjin Jung <mjung4 at go.olemiss.edu> wrote:
>
> Good evening,
>
> I have a quick question about the "robumeta" package in R software. Below
> is my question:
>
> Is it possible to create funnel plots as well as assess (Egger's test) and
> adjust (Trim and fill approach) for publication bias in meta-analysis with
> RVE methods?
>
> Thank you so much for your help.
>
> Best regards,
> Myungjin
>
> *Myungjin Jung*
> Doctoral Graduate Assistant
> The University of Mississippi
> Department of Health, Exercise Science, and Recreation Management
> P.O. Box 1848
> 234 Turner Center
> University, MS 38677-1848
> *mjung4 at go.olemiss.ed <mjung4 at go.olemiss.edu>u*
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.


From dw|n@em|u@ @end|ng |rom comc@@t@net  Sun May  2 15:04:04 2021
From: dw|n@em|u@ @end|ng |rom comc@@t@net (David Winsemius)
Date: Sun, 2 May 2021 07:04:04 -0600
Subject: [R] Question about using R sample datasets
In-Reply-To: <CALbYN6yfvGvSLqjJPhK0p+pcH8ihEg5CAExyKPysVLWAvq7Uog@mail.gmail.com>
References: <CALbYN6yfvGvSLqjJPhK0p+pcH8ihEg5CAExyKPysVLWAvq7Uog@mail.gmail.com>
Message-ID: <1785B336-C184-4A4A-B1A3-BA7A8709E371@comcast.net>

Again, the terms of the license govern the legalities. I don?t think you would need any further efforts at licensing your commentary. Screenshots or text copies would both be just copies and the appropriate citations would probably be all that were needed. I do not think your commentary or explanatory work would need to be considered FOSS or a copyleft license. There are many instances of commercial, copyrighted books that contain portions of R source code. Several businesses exist that sell accessories or packages that depend on but are not part of core R. Some of them seem to me to be skirting the line of legality but I don?t think there have been any cases brought before judicial authorities. So your plans seems completely safe and well inside accepted and legal boundaries to my understanding. 

David 

Sent from my iPhone

> On May 2, 2021, at 2:39 AM, Maja Analytics <maja.analytics.blog at gmail.com> wrote:
> 
> ?
> Thanks for the advice.
> 
> What about R code? Is that free to share? I would use my own dataset or made up dataset, so I am only now interested what about R code, can I screenshot it and then explain what is on the photo?
> 
> Maja
> 
> ned, 2. svi 2021. u 01:17 David Winsemius <dwinsemius at comcast.net> napisao je:
>> Any answer you get here will will have all the authority of "some guy on the Internet", but my reading of the licenses is that as long as you give proper credit that you can use any material in teaching or commercial purposes AND derivative works are likewise copy-able on an open source (FOSS) basis. You should read the LinkedIn TOS and make sure that posting there is not subject to some sort of publisher's copyright. That might be a violation fo the licensing for material copied from CRAN sources. Acknowledgment alone might not be an acceptable use. You may need to seek appropriate legal counsel or get opinions from the creators of the licensing language, since there are a variety of license.
>> 
>> David Winsemius, MD, (IANAL)
>> 
>> 
>> > On May 1, 2021, at 12:17 PM, Maja Analytics <maja.analytics.blog at gmail.com> wrote:
>> > 
>> > Hello!
>> > 
>> > I would like to make tutorials for non-data scientists in R on Medium and
>> > as LinkedIn articles. Could you tell me if I can use R sample datasets (I
>> > would note the acknowledgements on the end) for that?
>> > 
>> > Thanks in advance, kind regards,
>> > Maja
>> > 
>> >       [[alternative HTML version deleted]]
>> > 
>> > ______________________________________________
>> > R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> > https://stat.ethz.ch/mailman/listinfo/r-help
>> > PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
>> > and provide commented, minimal, self-contained, reproducible code.
>> 

	[[alternative HTML version deleted]]


From b@k|un@| @end|ng |rom y@hoo@com  Sun May  2 20:38:18 2021
From: b@k|un@| @end|ng |rom y@hoo@com (Baki UNAL)
Date: Sun, 2 May 2021 18:38:18 +0000 (UTC)
Subject: [R] Plotting two time series in one graph
References: <1481832980.304712.1619980698034.ref@mail.yahoo.com>
Message-ID: <1481832980.304712.1619980698034@mail.yahoo.com>

Hi

I'm trying to plot two time series in one graph. I tried the following code:


p = ggplot() +?
? geom_line(data = dovrez, aes(x = Date, y = Res), color = "blue") +
? geom_line(data = rqa_df_USD, aes(x = DATE, y = LAM), color = "red") +
? xlab('Dates') +
? ylab('Values')
print(p)

But I got the following error:

Hata: `mapped_discrete` objects can only be created from numeric vectors
Run `rlang::last_error()` to see where the error occurred.

Time indexes of my dataframes (dovrez, rqa_df_USD) are not same. First dataframe (dovrez) has 820 date points. Second dataframe (rqa_df_USD) has 75 date points.

How can I plot these two data in one graph?

Best Regards
Baki ?nal


From ru|pb@rr@d@@ @end|ng |rom @@po@pt  Sun May  2 21:45:12 2021
From: ru|pb@rr@d@@ @end|ng |rom @@po@pt (Rui Barradas)
Date: Sun, 2 May 2021 20:45:12 +0100
Subject: [R] Plotting two time series in one graph
In-Reply-To: <1481832980.304712.1619980698034@mail.yahoo.com>
References: <1481832980.304712.1619980698034.ref@mail.yahoo.com>
 <1481832980.304712.1619980698034@mail.yahoo.com>
Message-ID: <79e78d1d-aafe-8aad-7f6e-fdff31a0d125@sapo.pt>

Hello,

Can you post sample data? For instance, the output of

dput(head(dovrez, 20))
dput(head(rqa_df_USD, 20))


Or maybe you could rbind the data.frames with one column telling which 
of Res or LAM the values come from.


Hope this helps,

Rui Barradas

?s 19:38 de 02/05/21, Baki UNAL via R-help escreveu:
> Hi
> 
> I'm trying to plot two time series in one graph. I tried the following code:
> 
> 
> p = ggplot() +
>  ? geom_line(data = dovrez, aes(x = Date, y = Res), color = "blue") +
>  ? geom_line(data = rqa_df_USD, aes(x = DATE, y = LAM), color = "red") +
>  ? xlab('Dates') +
>  ? ylab('Values')
> print(p)
> 
> But I got the following error:
> 
> Hata: `mapped_discrete` objects can only be created from numeric vectors
> Run `rlang::last_error()` to see where the error occurred.
> 
> Time indexes of my dataframes (dovrez, rqa_df_USD) are not same. First dataframe (dovrez) has 820 date points. Second dataframe (rqa_df_USD) has 75 date points.
> 
> How can I plot these two data in one graph?
> 
> Best Regards
> Baki ?nal
> 
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
>


From m@j@@@n@|yt|c@@b|og @end|ng |rom gm@||@com  Sun May  2 10:38:49 2021
From: m@j@@@n@|yt|c@@b|og @end|ng |rom gm@||@com (Maja Analytics)
Date: Sun, 2 May 2021 10:38:49 +0200
Subject: [R] Question about using R sample datasets
In-Reply-To: <AFF3AC76-DD69-48B2-A782-D52DEB3E371E@comcast.net>
References: <CALbYN6xwv5fd2c2bN2cebMMNeK-2PgnqqE84uChbvpissv4Nog@mail.gmail.com>
 <AFF3AC76-DD69-48B2-A782-D52DEB3E371E@comcast.net>
Message-ID: <CALbYN6yfvGvSLqjJPhK0p+pcH8ihEg5CAExyKPysVLWAvq7Uog@mail.gmail.com>

Thanks for the advice.

What about R code? Is that free to share? I would use my own dataset or
made up dataset, so I am only now interested what about R code, can I
screenshot it and then explain what is on the photo?

Maja

ned, 2. svi 2021. u 01:17 David Winsemius <dwinsemius at comcast.net> napisao
je:

> Any answer you get here will will have all the authority of "some guy on
> the Internet", but my reading of the licenses is that as long as you give
> proper credit that you can use any material in teaching or commercial
> purposes AND derivative works are likewise copy-able on an open source
> (FOSS) basis. You should read the LinkedIn TOS and make sure that posting
> there is not subject to some sort of publisher's copyright. That might be a
> violation fo the licensing for material copied from CRAN sources.
> Acknowledgment alone might not be an acceptable use. You may need to seek
> appropriate legal counsel or get opinions from the creators of the
> licensing language, since there are a variety of license.
>
> David Winsemius, MD, (IANAL)
>
>
> > On May 1, 2021, at 12:17 PM, Maja Analytics <
> maja.analytics.blog at gmail.com> wrote:
> >
> > Hello!
> >
> > I would like to make tutorials for non-data scientists in R on Medium and
> > as LinkedIn articles. Could you tell me if I can use R sample datasets (I
> > would note the acknowledgements on the end) for that?
> >
> > Thanks in advance, kind regards,
> > Maja
> >
> >       [[alternative HTML version deleted]]
> >
> > ______________________________________________
> > R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> > https://stat.ethz.ch/mailman/listinfo/r-help
> > PLEASE do read the posting guide
> http://www.R-project.org/posting-guide.html
> > and provide commented, minimal, self-contained, reproducible code.
>
>

	[[alternative HTML version deleted]]


From @purd|e@@ @end|ng |rom gm@||@com  Mon May  3 02:42:30 2021
From: @purd|e@@ @end|ng |rom gm@||@com (Abbs Spurdle)
Date: Mon, 3 May 2021 12:42:30 +1200
Subject: [R] Package "hse" has been REPLACED by package "dbd".
In-Reply-To: <20210501103840.651431b6@rolf-Latitude-E7470>
References: <20210501103840.651431b6@rolf-Latitude-E7470>
Message-ID: <CAB8pepwF_gCauek2wL+XE2uGD9JT3w3m3F9DKY8m-h4PwOM1zg@mail.gmail.com>

Previously, I disliked some of R's names.
e.g. Action of the Toes.
But then later realized toes are really important.

I don't want to disagree with a 'reviewer'.
But I would say subtle references to literature and philosophy
demonstrate 'depth'.

Was your reviewer a member of the (A)merican (S)tatistical (S)ociety...?
Who came up with that name...?

It's all subjective really...


On Sat, May 1, 2021 at 10:39 AM Rolf Turner <r.turner at auckland.ac.nz> wrote:
>
>
> A reviewer of a paper that I wrote, of which the "hse" package was
> a central consideration, thought that users might find the name "hse"
> ("hope springs eternal") to be indicative of a lack of seriousness.
>
> Consequently I have changed the name of the package to "dbd"
> ("discretised beta distribution").  The underlying distribution, on
> which the package is focussed, is now called "db" ("discretised beta").
>
> The "hse" package still exists, *only* in order to produce a message
> (when the package is loaded) to the effect that the package is
> deprecated and that users should install and utilse the dbd package
> instead.
>
> The dbd package includes a number of modifications which (it is to be
> hoped) make it an improvement over the hse package that it replaces.
>
> I would be grateful to anyone who points out any problems with or
> errors in the dbd package.
>
> cheers,
>
> Rolf Turner
>
> --
> Honorary Research Fellow
> Department of Statistics
> University of Auckland
> Phone: +64-9-373-7599 ext. 88276
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.


From jdnewm|| @end|ng |rom dcn@d@v|@@c@@u@  Mon May  3 03:29:30 2021
From: jdnewm|| @end|ng |rom dcn@d@v|@@c@@u@ (Jeff Newmiller)
Date: Sun, 02 May 2021 18:29:30 -0700
Subject: [R] Question about using R sample datasets
In-Reply-To: <CALbYN6yfvGvSLqjJPhK0p+pcH8ihEg5CAExyKPysVLWAvq7Uog@mail.gmail.com>
References: <CALbYN6xwv5fd2c2bN2cebMMNeK-2PgnqqE84uChbvpissv4Nog@mail.gmail.com>
 <AFF3AC76-DD69-48B2-A782-D52DEB3E371E@comcast.net>
 <CALbYN6yfvGvSLqjJPhK0p+pcH8ihEg5CAExyKPysVLWAvq7Uog@mail.gmail.com>
Message-ID: <F614473D-DF75-43F7-AF63-B82262DF95A1@dcn.davis.ca.us>

You have already been reminded that none of us are lawyers. There is license text associated with every package and base R, and it is not necessarily the same for all parts of R, so there is no way for us to answer your question in its vague form and no way for you to rely our opinions even if you do clarify.

On May 2, 2021 1:38:49 AM PDT, Maja Analytics <maja.analytics.blog at gmail.com> wrote:
>Thanks for the advice.
>
>What about R code? Is that free to share? I would use my own dataset or
>made up dataset, so I am only now interested what about R code, can I
>screenshot it and then explain what is on the photo?
>
>Maja
>
>ned, 2. svi 2021. u 01:17 David Winsemius <dwinsemius at comcast.net>
>napisao
>je:
>
>> Any answer you get here will will have all the authority of "some guy
>on
>> the Internet", but my reading of the licenses is that as long as you
>give
>> proper credit that you can use any material in teaching or commercial
>> purposes AND derivative works are likewise copy-able on an open
>source
>> (FOSS) basis. You should read the LinkedIn TOS and make sure that
>posting
>> there is not subject to some sort of publisher's copyright. That
>might be a
>> violation fo the licensing for material copied from CRAN sources.
>> Acknowledgment alone might not be an acceptable use. You may need to
>seek
>> appropriate legal counsel or get opinions from the creators of the
>> licensing language, since there are a variety of license.
>>
>> David Winsemius, MD, (IANAL)
>>
>>
>> > On May 1, 2021, at 12:17 PM, Maja Analytics <
>> maja.analytics.blog at gmail.com> wrote:
>> >
>> > Hello!
>> >
>> > I would like to make tutorials for non-data scientists in R on
>Medium and
>> > as LinkedIn articles. Could you tell me if I can use R sample
>datasets (I
>> > would note the acknowledgements on the end) for that?
>> >
>> > Thanks in advance, kind regards,
>> > Maja
>> >
>> >       [[alternative HTML version deleted]]
>> >
>> > ______________________________________________
>> > R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> > https://stat.ethz.ch/mailman/listinfo/r-help
>> > PLEASE do read the posting guide
>> http://www.R-project.org/posting-guide.html
>> > and provide commented, minimal, self-contained, reproducible code.
>>
>>
>
>	[[alternative HTML version deleted]]
>
>______________________________________________
>R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>https://stat.ethz.ch/mailman/listinfo/r-help
>PLEASE do read the posting guide
>http://www.R-project.org/posting-guide.html
>and provide commented, minimal, self-contained, reproducible code.

-- 
Sent from my phone. Please excuse my brevity.


From therne@u @end|ng |rom m@yo@edu  Tue May  4 00:34:03 2021
From: therne@u @end|ng |rom m@yo@edu (Therneau, Terry M., Ph.D.)
Date: Mon, 03 May 2021 17:34:03 -0500
Subject: [R] inverse of the methods function
Message-ID: <9b53cf$fsqt82@ironport10.mayo.edu>

Is there a complement to the methods function, that will list all the defined methods for 
a class???? One solution is to look directly at the NAMESPACE file, for the package that 
defines it, and parse out the entries.?? I was looking for something built-in, i.e., easier.


-- 
Terry M Therneau, PhD
Department of Health Science Research
Mayo Clinic
therneau at mayo.edu

"TERR-ree THUR-noh"


	[[alternative HTML version deleted]]


From mtmorg@n@b|oc @end|ng |rom gm@||@com  Tue May  4 00:37:15 2021
From: mtmorg@n@b|oc @end|ng |rom gm@||@com (Martin Morgan)
Date: Mon, 3 May 2021 22:37:15 +0000
Subject: [R] inverse of the methods function
In-Reply-To: <9b53cf$fsqt82@ironport10.mayo.edu>
References: <9b53cf$fsqt82@ironport10.mayo.edu>
Message-ID: <BN8PR04MB6241D9A119003AF109F97B99F95B9@BN8PR04MB6241.namprd04.prod.outlook.com>

> methods(class = "lm")
 [1] add1           alias          anova          case.names     coerce
 [6] confint        cooks.distance deviance       dfbeta         dfbetas
[11] drop1          dummy.coef     effects        extractAIC     family
[16] formula        hatvalues      influence      initialize     kappa
[21] labels         logLik         model.frame    model.matrix   nobs
[26] plot           predict        print          proj           qr
[31] residuals      rstandard      rstudent       show           simulate
[36] slotsFromS3    summary        variable.names vcov
see '?methods' for accessing help and source code

Martin Morgan

?On 5/3/21, 6:34 PM, "R-help on behalf of Therneau, Terry M., Ph.D. via R-help" <r-help-bounces at r-project.org on behalf of r-help at R-project.org> wrote:

    Is there a complement to the methods function, that will list all the defined methods for 
    a class?    One solution is to look directly at the NAMESPACE file, for the package that 
    defines it, and parse out the entries.   I was looking for something built-in, i.e., easier.


    -- 
    Terry M Therneau, PhD
    Department of Health Science Research
    Mayo Clinic
    therneau at mayo.edu

    "TERR-ree THUR-noh"


    	[[alternative HTML version deleted]]

    ______________________________________________
    R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
    https://stat.ethz.ch/mailman/listinfo/r-help
    PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
    and provide commented, minimal, self-contained, reproducible code.

From @purd|e@@ @end|ng |rom gm@||@com  Tue May  4 00:42:31 2021
From: @purd|e@@ @end|ng |rom gm@||@com (Abbs Spurdle)
Date: Tue, 4 May 2021 10:42:31 +1200
Subject: [R] inverse of the methods function
In-Reply-To: <9b53cf$fsqt82@ironport10.mayo.edu>
References: <9b53cf$fsqt82@ironport10.mayo.edu>
Message-ID: <CAB8pepwzztUgBADwm7xPhXvgE9MgHd4nEwqHPTLU6BP9vCU5BA@mail.gmail.com>

methods (,"glm")


On Tue, May 4, 2021 at 10:34 AM Therneau, Terry M., Ph.D. via R-help
<r-help at r-project.org> wrote:
>
> Is there a complement to the methods function, that will list all the defined methods for
> a class?    One solution is to look directly at the NAMESPACE file, for the package that
> defines it, and parse out the entries.   I was looking for something built-in, i.e., easier.
>
>
> --
> Terry M Therneau, PhD
> Department of Health Science Research
> Mayo Clinic
> therneau at mayo.edu
>
> "TERR-ree THUR-noh"
>
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.


From @gne@g2g @end|ng |rom hotm@||@com  Tue May  4 22:23:41 2021
From: @gne@g2g @end|ng |rom hotm@||@com (Agnes g2g)
Date: Tue, 4 May 2021 20:23:41 +0000
Subject: [R] =?utf-8?q?Warning_=E2=80=9CUnknown_or_uninitialised_column?=
 =?utf-8?q?=3A_=60ntree=60=2E=E2=80=9D_when_trying_to_pass_hyperparameters?=
 =?utf-8?q?_to_a_learner_with_package_mlr?=
Message-ID: <AM0PR0602MB34276CC7EA4B614D46C4BF35835A9@AM0PR0602MB3427.eurprd06.prod.outlook.com>

?Dear all,
I posted this question on stats exchange and got the message that it was off-topic.https://stats.stackexchange.com/questions/522745/warning-unknown-or-uninitialised-column-ntree-when-trying-to-pass-hyperpar
They suggested to use this email list instead.
So that's why I am posting it here. I have read the instructions, but if I have overlooked something that said this question does not belong on this mailing list, I apologise.

Thanks in advance for reading this message!

Kind regards,
Agnes Wattel
problem

I want to do a grid search with different hyperparameters that are provided by a self-made grid. But when I am running the code I get a warning: "Unknown or uninitialised column: ntree."

create grid

gs <- list(ntree = c(50,100,150,200,300,500,550),mtry = c(1,2,3,4,5)) %>% cross_df()


select hyperparameters

  for (h in 1:nrow(gs)) {
    ntree_entry <- gs$ntree[h]
    mtry_entry <- gs$mtry[h]
    (...)
    lrn <- makeMultilabelClassifierChainsWrapper(lrn, order = NULL)
    lrn <- setPredictType(lrn,"prob")
    task <- makeMultilabelTask(data = data[train_lines,], target = label_bact)
    mod <- mlr::train(lrn,task)
    }


On the place of (...) I have tried two different ways to get the hyperparameters into the learner:

option 1: pass hyperparameters to the learner

lrn <- makeLearner("classif.randomForest",ntree = ntree_entry,mtry = mtry_entry)


option 2: pass hyperparameters to the learner

lrn <- makeLearner("classif.randomForest")
lrn <- setHyperPars(lrn,par.vals = list(ntree = ntree_entry,mtry = mtry_entry))


check

The console tells me that the hyperparameters are in the learner:

>lrn
Learner classif.randomForest from package randomForest
Type: classif
Name: Random Forest; Short name: rf
Class: classif.randomForest
Properties: twoclass,multiclass,numerics,factors,ordered,prob,class.weights,oobpreds,featimp
Predict-Type: response
Hyperparameters: ntree=50,mtry=1


ntree and mtry are hyperparameters that are known to the makeLearner, because they are both in getParamSet:

> getParamSet("classif.randomForest")

                     Type  len   Def   Constr Req Tunable Trafo
ntree             integer    -   500 1 to Inf   -    TRUE     -
mtry              integer    -     - 1 to Inf   -    TRUE     -
replace           logical    -  TRUE        -   -    TRUE     -
classwt     numericvector <NA>     - 0 to Inf   -    TRUE     -
cutoff      numericvector <NA>     -   0 to 1   -    TRUE     -
strata            untyped    -     -        -   -   FALSE     -
sampsize    integervector <NA>     - 1 to Inf   -    TRUE     -
nodesize          integer    -     1 1 to Inf   -    TRUE     -
maxnodes          integer    -     - 1 to Inf   -    TRUE     -
importance        logical    - FALSE        -   -    TRUE     -
localImp          logical    - FALSE        -   -    TRUE     -
proximity         logical    - FALSE        -   -   FALSE     -
oob.prox          logical    -     -        -   Y   FALSE     -
norm.votes        logical    -  TRUE        -   -   FALSE     -
do.trace          logical    - FALSE        -   -   FALSE     -
keep.forest       logical    -  TRUE        -   -   FALSE     -
keep.inbag        logical    - FALSE        -   -   FALSE     -


Question

Why do I get the message "Unknown or uninitialised column: ntree"? Although it is only a warning, not an error, I am afraid that it will only use the first line of the grid that I created. The sizes of the models seem to confirm that. They all have the same size. I hope that someone can help me with this problem. Thanks in advance!


	[[alternative HTML version deleted]]


From thebudget72 m@iii@g oii gm@ii@com  Wed May  5 20:55:09 2021
From: thebudget72 m@iii@g oii gm@ii@com (thebudget72 m@iii@g oii gm@ii@com)
Date: Wed, 5 May 2021 20:55:09 +0200
Subject: [R] [MatchIt] Naive Estimator for ATT after Full Matching
Message-ID: <32188880-69bf-8aff-f69f-35d6b2713f02@gmail.com>

Dear R-help ML,

I would like to compute a Naive Estimator for the Average Treatment 
Effect (ATT) after a Propensity Score Matching with full matching.

Since it is full matching, the resulting post-matching database contains 
all the observations of the original dataset.

I came up with this code, which does a weighted average of the outcomes, 
using the weights provided by the matching process, but I'm not sure 
this is the correct way to achieve it.

How can I compute the ATT using a Naive Estimator after PSM?

I know I am supposed to do a regression, but I am interested in 
computing a Naive Estimator as a difference between the means across the 
two groups.


```r
library("MatchIt")
data("lalonde")

m.out2 <- matchit(treat ~ age + educ + race + married +
 ????????????????? nodegree + re74 + re75,
 ????????????????? data = lalonde,
 ????????????????? method = "full",
 ????????????????? distance = "glm",
 ????????????????? link = "probit")

m.data2 <- match.data(m.out2)

te <- weighted.mean(m.data2$re78[m.data2$treat],
 ??????????????????? m.data2$weights[m.data2$treat])
nte <- weighted.mean(m.data2$re78[!m.data2$treat],
 ???????????????????? m.data2$weights[!m.data2$treat])
ne2w <- round(te-nte, 2)

print(paste0("The ATT estimated with a NE is: ", ne2w))
```


Thanks in advance and best regards.


From bgunter@4567 @end|ng |rom gm@||@com  Wed May  5 22:07:41 2021
From: bgunter@4567 @end|ng |rom gm@||@com (Bert Gunter)
Date: Wed, 5 May 2021 13:07:41 -0700
Subject: [R] [MatchIt] Naive Estimator for ATT after Full Matching
In-Reply-To: <32188880-69bf-8aff-f69f-35d6b2713f02@gmail.com>
References: <32188880-69bf-8aff-f69f-35d6b2713f02@gmail.com>
Message-ID: <CAGxFJbQwCkXR+PHH=TLSCfAdV53H9+HG0QRcb5awj0HCARZhrg@mail.gmail.com>

Do note, per the posting guide linked below (please read it if you haven't
done so already):

1. *"Questions about statistics:* The R mailing lists are primarily
intended for questions and discussion about the R software. However,
questions about statistical methodology are sometimes posted. If the
question is well-asked and of interest to someone on the list, it *may*
elicit an informative up-to-date answer. "

So do not be surprised if you do not get a response here.
stats.stackexchange.com *may* be a better alternative if you do not.

2. "For questions about functions in standard packages distributed with R
(see the FAQ Add-on packages in R
<https://cran.r-project.org/doc/FAQ/R-FAQ.html#Add-on-packages-in-R>), ask
questions on R-help.
If the question relates to a *contributed package* , e.g., one downloaded
from CRAN, try contacting the package maintainer first."

The matchit package maintainer can be found by: maintainer("matchit") if
you think the above applies.

Cheers,
Bert

Bert Gunter

"The trouble with having an open mind is that people keep coming along and
sticking things into it."
-- Opus (aka Berkeley Breathed in his "Bloom County" comic strip )


On Wed, May 5, 2021 at 11:55 AM <thebudget72 at gmail.com> wrote:

> Dear R-help ML,
>
> I would like to compute a Naive Estimator for the Average Treatment
> Effect (ATT) after a Propensity Score Matching with full matching.
>
> Since it is full matching, the resulting post-matching database contains
> all the observations of the original dataset.
>
> I came up with this code, which does a weighted average of the outcomes,
> using the weights provided by the matching process, but I'm not sure
> this is the correct way to achieve it.
>
> How can I compute the ATT using a Naive Estimator after PSM?
>
> I know I am supposed to do a regression, but I am interested in
> computing a Naive Estimator as a difference between the means across the
> two groups.
>
>
> ```r
> library("MatchIt")
> data("lalonde")
>
> m.out2 <- matchit(treat ~ age + educ + race + married +
>                    nodegree + re74 + re75,
>                    data = lalonde,
>                    method = "full",
>                    distance = "glm",
>                    link = "probit")
>
> m.data2 <- match.data(m.out2)
>
> te <- weighted.mean(m.data2$re78[m.data2$treat],
>                      m.data2$weights[m.data2$treat])
> nte <- weighted.mean(m.data2$re78[!m.data2$treat],
>                       m.data2$weights[!m.data2$treat])
> ne2w <- round(te-nte, 2)
>
> print(paste0("The ATT estimated with a NE is: ", ne2w))
> ```
>
>
> Thanks in advance and best regards.
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide
> http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
>

	[[alternative HTML version deleted]]


From utr|go@ @end|ng |rom um|ch@edu  Wed May  5 19:39:01 2021
From: utr|go@ @end|ng |rom um|ch@edu (Ursula Trigos-Raczkowski)
Date: Wed, 5 May 2021 13:39:01 -0400
Subject: [R] solving integral equations with undefined parameters using
 multiroot
Message-ID: <CANSXP2RHWd7CkRMOCb8n5Nm2ei5LHyzUBhTsTjdsCH+hq6Ac-w@mail.gmail.com>

Hello,
I am trying to solve a system of integral equations using multiroot. I have
tried asking on stack exchange and reddit without any luck.
Multiroot uses the library(RootSolve).

I have two integral equations involving constants S[1] and S[2] (which are
free.) I would like to find what *positive* values of S[1] and S[2] make
the resulting
(Integrals-1) = 0.
(I know that the way I have the parameters set up the equations are very
similar but I am interested in changing the parameters once I have the code
working.)
My attempt at code:

```{r}
a11 <- 1 #alpha_{11}
a12 <- 1 #alpha_{12}
a21 <- 1 #alpha_{21}
a22 <- 1 #alpha_{22}
b1 <- 2  #beta1
b2 <- 2 #beta2
d1 <- 1 #delta1
d2 <- 1 #delta2
g <- 0.5 #gamma


integrand1 <- function(x,S) {b1*g/d1*exp(-g*x)*(1-exp(-d1*
x))*exp(-a11*b1*S[1]/d1*(1-exp(-d1*x))-a12*b2*S[2]/d2*(1-exp(-d2*x)))}
integrand2 <- function(x,S) {b2*g/d2*exp(-g*x)*(1-exp(-d2*
x))*exp(-a22*b2*S[2]/d2*(1-exp(-d2*x))-a21*b1*S[1]/d1*(1-exp(-d1*x)))}

#defining equation we would like to solve
intfun1<- function(S) {integrate(function(x) integrand1(x,
S),lower=0,upper=Inf)[[1]]-1}
intfun2<- function(S) {integrate(function(x) integrand2(x,
S),lower=0,upper=Inf)[[1]]-1}

#putting both equations into one term
model <- function(S) c(F1 = intfun1,F2 = intfun2)

#Solving for roots
(ss <-multiroot(f=model, start=c(0,0)))
```

This gives me the error Error in stode(y, times, func, parms = parms, ...) :
  REAL() can only be applied to a 'numeric', not a 'list'

However this simpler example works fine:

```{r}
#Defining the functions
model <- function(x) c(F1 = x[1]+ 4*x[2] -8,F2 = x[1]-4*x[2])

#Solving for the roots
(ss <- multiroot(f = model, start = c(0,0)))
```

Giving me the required x_1= 4 and x_2 =1.

I was given some code to perform a least squares analysis on the same
system but I neither understand the code, nor believe that it is doing what
I am looking for as different initial values give wildly different S values.

```{r}
a11 <- 1 #alpha_{11}
a12 <- 1 #alpha_{12}
a21 <- 1 #alpha_{21}
a22 <- 1 #alpha_{22}
b1 <- 2  #beta1
b2 <- 2 #beta2
d1 <- 1 #delta1
d2 <- 1 #delta2
g <- 0.5 #gamma


integrand1 <- function(x,S) {b1*g/d1*exp(-g*x)*(1-exp(-d1*
x))*exp(-a11*b1*S[1]/d1*(1-exp(-d1*x))-a12*b2*S[2]/d2*(1-exp(-d2*x)))}
integrand2 <- function(x,S) {b2*g/d2*exp(-g*x)*(1-exp(-d2*
x))*exp(-a22*b2*S[2]/d2*(1-exp(-d2*x))-a21*b1*S[1]/d1*(1-exp(-d1*x)))}

#defining equation we would like to solve
intfun1<- function(S) {integrate(function(x)integrand1(x,
S),lower=0,upper=Inf)[[1]]-1}
intfun2<- function(S) {integrate(function(x)integrand2(x,
S),lower=0,upper=Inf)[[1]]-1}

#putting both equations into one term
model <- function(S) if(any(S<0))NA else intfun1(S)**2+ intfun2(S)**2

#Solving for roots
optim(c(0,0), model)
```

I appreciate any tips/help as I have been struggling with this for some
weeks now.
thank you,
-- 
Ursula
Ph.D. student, University of Michigan
Applied and Interdisciplinary Mathematics
utrigos at umich.edu

	[[alternative HTML version deleted]]


From r@turner @end|ng |rom @uck|@nd@@c@nz  Thu May  6 00:59:57 2021
From: r@turner @end|ng |rom @uck|@nd@@c@nz (Rolf Turner)
Date: Thu, 6 May 2021 10:59:57 +1200
Subject: [R] Package "hse" has been REPLACED by package "dbd".
In-Reply-To: <CAB8pepwF_gCauek2wL+XE2uGD9JT3w3m3F9DKY8m-h4PwOM1zg@mail.gmail.com>
References: <20210501103840.651431b6@rolf-Latitude-E7470>
 <CAB8pepwF_gCauek2wL+XE2uGD9JT3w3m3F9DKY8m-h4PwOM1zg@mail.gmail.com>
Message-ID: <20210506105957.4e66b647@rolf-Latitude-E7470>


On Mon, 3 May 2021 12:42:30 +1200
Abbs Spurdle <spurdle.a at gmail.com> wrote:

> Previously, I disliked some of R's names.
> e.g. Action of the Toes.
> But then later realized toes are really important.
> 
> I don't want to disagree with a 'reviewer'.
> But I would say subtle references to literature and philosophy
> demonstrate 'depth'.

Well, I thought so too. :-)  OTOH I recognise that I have a tendency to
be flippant, and perhaps it is just as well to curb this tendency.

> Was your reviewer a member of the (A)merican (S)tatistical
> (S)ociety...? Who came up with that name...?

Isn't it called the 'American Statistical *Association*"?  (Presumably
just so as to avoid that unfortunate acronym.)

I of course have no idea who the (anonymous) reviewer is.

> It's all subjective really...

Or a matter of taste.  And (as my late older brother was fond of
saying) there is no accounting for taste, or the lack thereof. :-)

cheers,

Rolf

-- 
Honorary Research Fellow
Department of Statistics
University of Auckland
Phone: +64-9-373-7599 ext. 88276


From @purd|e@@ @end|ng |rom gm@||@com  Thu May  6 10:39:00 2021
From: @purd|e@@ @end|ng |rom gm@||@com (Abbs Spurdle)
Date: Thu, 6 May 2021 20:39:00 +1200
Subject: [R] solving integral equations with undefined parameters using
 multiroot
In-Reply-To: <CANSXP2RHWd7CkRMOCb8n5Nm2ei5LHyzUBhTsTjdsCH+hq6Ac-w@mail.gmail.com>
References: <CANSXP2RHWd7CkRMOCb8n5Nm2ei5LHyzUBhTsTjdsCH+hq6Ac-w@mail.gmail.com>
Message-ID: <CAB8pepx-PjtOOP7KT5Z-637+7wnh5-UqgYSvLfimfBh03VWb5Q@mail.gmail.com>

Hi Ursula,

If I'm not mistaken, there's an infinite number of solutions, which
form a straight (or near straight) line.
Refer to the following code, and attached plot.

----begin code---
library (barsurf)
vF1 <- function (u, v)
{   n <- length (u)
    k <- numeric (n)
    for (i in seq_len (n) )
        k [i] <- intfun1 (c (u [i], v [i]) )
    k
}
plotf_cfield (vF1, c (0, 0.2), fb = (-2:2) / 10,
    main="(integral_1 - 1)",
    xlab="S[1]", ylab="S[2]",
    n=40, raster=TRUE, theme="heat", contour.labels=TRUE)
----end code----

I'm not familiar with the RootSolve package.
Nor am I quite sure what you're trying to compute, given the apparent
infinite set of solutions.

So, for now at least, I'll leave comments on the root finding to someone who is.


Abby


On Thu, May 6, 2021 at 8:46 AM Ursula Trigos-Raczkowski
<utrigos at umich.edu> wrote:
>
> Hello,
> I am trying to solve a system of integral equations using multiroot. I have
> tried asking on stack exchange and reddit without any luck.
> Multiroot uses the library(RootSolve).
>
> I have two integral equations involving constants S[1] and S[2] (which are
> free.) I would like to find what *positive* values of S[1] and S[2] make
> the resulting
> (Integrals-1) = 0.
> (I know that the way I have the parameters set up the equations are very
> similar but I am interested in changing the parameters once I have the code
> working.)
> My attempt at code:
>
> ```{r}
> a11 <- 1 #alpha_{11}
> a12 <- 1 #alpha_{12}
> a21 <- 1 #alpha_{21}
> a22 <- 1 #alpha_{22}
> b1 <- 2  #beta1
> b2 <- 2 #beta2
> d1 <- 1 #delta1
> d2 <- 1 #delta2
> g <- 0.5 #gamma
>
>
> integrand1 <- function(x,S) {b1*g/d1*exp(-g*x)*(1-exp(-d1*
> x))*exp(-a11*b1*S[1]/d1*(1-exp(-d1*x))-a12*b2*S[2]/d2*(1-exp(-d2*x)))}
> integrand2 <- function(x,S) {b2*g/d2*exp(-g*x)*(1-exp(-d2*
> x))*exp(-a22*b2*S[2]/d2*(1-exp(-d2*x))-a21*b1*S[1]/d1*(1-exp(-d1*x)))}
>
> #defining equation we would like to solve
> intfun1<- function(S) {integrate(function(x) integrand1(x,
> S),lower=0,upper=Inf)[[1]]-1}
> intfun2<- function(S) {integrate(function(x) integrand2(x,
> S),lower=0,upper=Inf)[[1]]-1}
>
> #putting both equations into one term
> model <- function(S) c(F1 = intfun1,F2 = intfun2)
>
> #Solving for roots
> (ss <-multiroot(f=model, start=c(0,0)))
> ```
>
> This gives me the error Error in stode(y, times, func, parms = parms, ...) :
>   REAL() can only be applied to a 'numeric', not a 'list'
>
> However this simpler example works fine:
>
> ```{r}
> #Defining the functions
> model <- function(x) c(F1 = x[1]+ 4*x[2] -8,F2 = x[1]-4*x[2])
>
> #Solving for the roots
> (ss <- multiroot(f = model, start = c(0,0)))
> ```
>
> Giving me the required x_1= 4 and x_2 =1.
>
> I was given some code to perform a least squares analysis on the same
> system but I neither understand the code, nor believe that it is doing what
> I am looking for as different initial values give wildly different S values.
>
> ```{r}
> a11 <- 1 #alpha_{11}
> a12 <- 1 #alpha_{12}
> a21 <- 1 #alpha_{21}
> a22 <- 1 #alpha_{22}
> b1 <- 2  #beta1
> b2 <- 2 #beta2
> d1 <- 1 #delta1
> d2 <- 1 #delta2
> g <- 0.5 #gamma
>
>
> integrand1 <- function(x,S) {b1*g/d1*exp(-g*x)*(1-exp(-d1*
> x))*exp(-a11*b1*S[1]/d1*(1-exp(-d1*x))-a12*b2*S[2]/d2*(1-exp(-d2*x)))}
> integrand2 <- function(x,S) {b2*g/d2*exp(-g*x)*(1-exp(-d2*
> x))*exp(-a22*b2*S[2]/d2*(1-exp(-d2*x))-a21*b1*S[1]/d1*(1-exp(-d1*x)))}
>
> #defining equation we would like to solve
> intfun1<- function(S) {integrate(function(x)integrand1(x,
> S),lower=0,upper=Inf)[[1]]-1}
> intfun2<- function(S) {integrate(function(x)integrand2(x,
> S),lower=0,upper=Inf)[[1]]-1}
>
> #putting both equations into one term
> model <- function(S) if(any(S<0))NA else intfun1(S)**2+ intfun2(S)**2
>
> #Solving for roots
> optim(c(0,0), model)
> ```
>
> I appreciate any tips/help as I have been struggling with this for some
> weeks now.
> thank you,
> --
> Ursula
> Ph.D. student, University of Michigan
> Applied and Interdisciplinary Mathematics
> utrigos at umich.edu
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.

-------------- next part --------------
A non-text attachment was scrubbed...
Name: solution.png
Type: image/png
Size: 36474 bytes
Desc: not available
URL: <https://stat.ethz.ch/pipermail/r-help/attachments/20210506/561a8bc4/attachment.png>

From @purd|e@@ @end|ng |rom gm@||@com  Thu May  6 11:27:07 2021
From: @purd|e@@ @end|ng |rom gm@||@com (Abbs Spurdle)
Date: Thu, 6 May 2021 21:27:07 +1200
Subject: [R] solving integral equations with undefined parameters using
 multiroot
In-Reply-To: <CAB8pepx-PjtOOP7KT5Z-637+7wnh5-UqgYSvLfimfBh03VWb5Q@mail.gmail.com>
References: <CANSXP2RHWd7CkRMOCb8n5Nm2ei5LHyzUBhTsTjdsCH+hq6Ac-w@mail.gmail.com>
 <CAB8pepx-PjtOOP7KT5Z-637+7wnh5-UqgYSvLfimfBh03VWb5Q@mail.gmail.com>
Message-ID: <CAB8pepwP_H88QVZ7Jn858nfKdzFEvG_iQLh1DRhMmnBtJL+XcA@mail.gmail.com>

Just realized five minutes after posting that I misinterpreted your
question, slightly.
However, after comparing the solution sets for *both* equations, I
can't see any obvious difference between the two.
If there is any difference, presumably that difference is extremely small.


On Thu, May 6, 2021 at 8:39 PM Abbs Spurdle <spurdle.a at gmail.com> wrote:
>
> Hi Ursula,
>
> If I'm not mistaken, there's an infinite number of solutions, which
> form a straight (or near straight) line.
> Refer to the following code, and attached plot.
>
> ----begin code---
> library (barsurf)
> vF1 <- function (u, v)
> {   n <- length (u)
>     k <- numeric (n)
>     for (i in seq_len (n) )
>         k [i] <- intfun1 (c (u [i], v [i]) )
>     k
> }
> plotf_cfield (vF1, c (0, 0.2), fb = (-2:2) / 10,
>     main="(integral_1 - 1)",
>     xlab="S[1]", ylab="S[2]",
>     n=40, raster=TRUE, theme="heat", contour.labels=TRUE)
> ----end code----
>
> I'm not familiar with the RootSolve package.
> Nor am I quite sure what you're trying to compute, given the apparent
> infinite set of solutions.
>
> So, for now at least, I'll leave comments on the root finding to someone who is.
>
>
> Abby
>
>
> On Thu, May 6, 2021 at 8:46 AM Ursula Trigos-Raczkowski
> <utrigos at umich.edu> wrote:
> >
> > Hello,
> > I am trying to solve a system of integral equations using multiroot. I have
> > tried asking on stack exchange and reddit without any luck.
> > Multiroot uses the library(RootSolve).
> >
> > I have two integral equations involving constants S[1] and S[2] (which are
> > free.) I would like to find what *positive* values of S[1] and S[2] make
> > the resulting
> > (Integrals-1) = 0.
> > (I know that the way I have the parameters set up the equations are very
> > similar but I am interested in changing the parameters once I have the code
> > working.)
> > My attempt at code:
> >
> > ```{r}
> > a11 <- 1 #alpha_{11}
> > a12 <- 1 #alpha_{12}
> > a21 <- 1 #alpha_{21}
> > a22 <- 1 #alpha_{22}
> > b1 <- 2  #beta1
> > b2 <- 2 #beta2
> > d1 <- 1 #delta1
> > d2 <- 1 #delta2
> > g <- 0.5 #gamma
> >
> >
> > integrand1 <- function(x,S) {b1*g/d1*exp(-g*x)*(1-exp(-d1*
> > x))*exp(-a11*b1*S[1]/d1*(1-exp(-d1*x))-a12*b2*S[2]/d2*(1-exp(-d2*x)))}
> > integrand2 <- function(x,S) {b2*g/d2*exp(-g*x)*(1-exp(-d2*
> > x))*exp(-a22*b2*S[2]/d2*(1-exp(-d2*x))-a21*b1*S[1]/d1*(1-exp(-d1*x)))}
> >
> > #defining equation we would like to solve
> > intfun1<- function(S) {integrate(function(x) integrand1(x,
> > S),lower=0,upper=Inf)[[1]]-1}
> > intfun2<- function(S) {integrate(function(x) integrand2(x,
> > S),lower=0,upper=Inf)[[1]]-1}
> >
> > #putting both equations into one term
> > model <- function(S) c(F1 = intfun1,F2 = intfun2)
> >
> > #Solving for roots
> > (ss <-multiroot(f=model, start=c(0,0)))
> > ```
> >
> > This gives me the error Error in stode(y, times, func, parms = parms, ...) :
> >   REAL() can only be applied to a 'numeric', not a 'list'
> >
> > However this simpler example works fine:
> >
> > ```{r}
> > #Defining the functions
> > model <- function(x) c(F1 = x[1]+ 4*x[2] -8,F2 = x[1]-4*x[2])
> >
> > #Solving for the roots
> > (ss <- multiroot(f = model, start = c(0,0)))
> > ```
> >
> > Giving me the required x_1= 4 and x_2 =1.
> >
> > I was given some code to perform a least squares analysis on the same
> > system but I neither understand the code, nor believe that it is doing what
> > I am looking for as different initial values give wildly different S values.
> >
> > ```{r}
> > a11 <- 1 #alpha_{11}
> > a12 <- 1 #alpha_{12}
> > a21 <- 1 #alpha_{21}
> > a22 <- 1 #alpha_{22}
> > b1 <- 2  #beta1
> > b2 <- 2 #beta2
> > d1 <- 1 #delta1
> > d2 <- 1 #delta2
> > g <- 0.5 #gamma
> >
> >
> > integrand1 <- function(x,S) {b1*g/d1*exp(-g*x)*(1-exp(-d1*
> > x))*exp(-a11*b1*S[1]/d1*(1-exp(-d1*x))-a12*b2*S[2]/d2*(1-exp(-d2*x)))}
> > integrand2 <- function(x,S) {b2*g/d2*exp(-g*x)*(1-exp(-d2*
> > x))*exp(-a22*b2*S[2]/d2*(1-exp(-d2*x))-a21*b1*S[1]/d1*(1-exp(-d1*x)))}
> >
> > #defining equation we would like to solve
> > intfun1<- function(S) {integrate(function(x)integrand1(x,
> > S),lower=0,upper=Inf)[[1]]-1}
> > intfun2<- function(S) {integrate(function(x)integrand2(x,
> > S),lower=0,upper=Inf)[[1]]-1}
> >
> > #putting both equations into one term
> > model <- function(S) if(any(S<0))NA else intfun1(S)**2+ intfun2(S)**2
> >
> > #Solving for roots
> > optim(c(0,0), model)
> > ```
> >
> > I appreciate any tips/help as I have been struggling with this for some
> > weeks now.
> > thank you,
> > --
> > Ursula
> > Ph.D. student, University of Michigan
> > Applied and Interdisciplinary Mathematics
> > utrigos at umich.edu
> >
> >         [[alternative HTML version deleted]]
> >
> > ______________________________________________
> > R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> > https://stat.ethz.ch/mailman/listinfo/r-help
> > PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> > and provide commented, minimal, self-contained, reproducible code.


From utr|go@ @end|ng |rom um|ch@edu  Thu May  6 12:17:48 2021
From: utr|go@ @end|ng |rom um|ch@edu (Ursula Trigos-Raczkowski)
Date: Thu, 6 May 2021 06:17:48 -0400
Subject: [R] solving integral equations with undefined parameters using
 multiroot
In-Reply-To: <CAB8pepwP_H88QVZ7Jn858nfKdzFEvG_iQLh1DRhMmnBtJL+XcA@mail.gmail.com>
References: <CANSXP2RHWd7CkRMOCb8n5Nm2ei5LHyzUBhTsTjdsCH+hq6Ac-w@mail.gmail.com>
 <CAB8pepx-PjtOOP7KT5Z-637+7wnh5-UqgYSvLfimfBh03VWb5Q@mail.gmail.com>
 <CAB8pepwP_H88QVZ7Jn858nfKdzFEvG_iQLh1DRhMmnBtJL+XcA@mail.gmail.com>
Message-ID: <CANSXP2RQDf-bnEjDU6m4+vu9m3XyDfCPYamRYvqL8NhQEkrD3Q@mail.gmail.com>

Thanks for your reply. Unfortunately the code doesn't work even when I
change the parameters to ensure I have "different" equations.
Using mathematica I do see that my two equations form planes, intersecting
in a line of infinite solutions but it is not very accurate, I was hoping R
would be more accurate and tell me what this line is, or at least a set of
solutions.

On Thu, May 6, 2021 at 5:28 AM Abbs Spurdle <spurdle.a at gmail.com> wrote:

> Just realized five minutes after posting that I misinterpreted your
> question, slightly.
> However, after comparing the solution sets for *both* equations, I
> can't see any obvious difference between the two.
> If there is any difference, presumably that difference is extremely small.
>
>
> On Thu, May 6, 2021 at 8:39 PM Abbs Spurdle <spurdle.a at gmail.com> wrote:
> >
> > Hi Ursula,
> >
> > If I'm not mistaken, there's an infinite number of solutions, which
> > form a straight (or near straight) line.
> > Refer to the following code, and attached plot.
> >
> > ----begin code---
> > library (barsurf)
> > vF1 <- function (u, v)
> > {   n <- length (u)
> >     k <- numeric (n)
> >     for (i in seq_len (n) )
> >         k [i] <- intfun1 (c (u [i], v [i]) )
> >     k
> > }
> > plotf_cfield (vF1, c (0, 0.2), fb = (-2:2) / 10,
> >     main="(integral_1 - 1)",
> >     xlab="S[1]", ylab="S[2]",
> >     n=40, raster=TRUE, theme="heat", contour.labels=TRUE)
> > ----end code----
> >
> > I'm not familiar with the RootSolve package.
> > Nor am I quite sure what you're trying to compute, given the apparent
> > infinite set of solutions.
> >
> > So, for now at least, I'll leave comments on the root finding to someone
> who is.
> >
> >
> > Abby
> >
> >
> > On Thu, May 6, 2021 at 8:46 AM Ursula Trigos-Raczkowski
> > <utrigos at umich.edu> wrote:
> > >
> > > Hello,
> > > I am trying to solve a system of integral equations using multiroot. I
> have
> > > tried asking on stack exchange and reddit without any luck.
> > > Multiroot uses the library(RootSolve).
> > >
> > > I have two integral equations involving constants S[1] and S[2] (which
> are
> > > free.) I would like to find what *positive* values of S[1] and S[2]
> make
> > > the resulting
> > > (Integrals-1) = 0.
> > > (I know that the way I have the parameters set up the equations are
> very
> > > similar but I am interested in changing the parameters once I have the
> code
> > > working.)
> > > My attempt at code:
> > >
> > > ```{r}
> > > a11 <- 1 #alpha_{11}
> > > a12 <- 1 #alpha_{12}
> > > a21 <- 1 #alpha_{21}
> > > a22 <- 1 #alpha_{22}
> > > b1 <- 2  #beta1
> > > b2 <- 2 #beta2
> > > d1 <- 1 #delta1
> > > d2 <- 1 #delta2
> > > g <- 0.5 #gamma
> > >
> > >
> > > integrand1 <- function(x,S) {b1*g/d1*exp(-g*x)*(1-exp(-d1*
> > > x))*exp(-a11*b1*S[1]/d1*(1-exp(-d1*x))-a12*b2*S[2]/d2*(1-exp(-d2*x)))}
> > > integrand2 <- function(x,S) {b2*g/d2*exp(-g*x)*(1-exp(-d2*
> > > x))*exp(-a22*b2*S[2]/d2*(1-exp(-d2*x))-a21*b1*S[1]/d1*(1-exp(-d1*x)))}
> > >
> > > #defining equation we would like to solve
> > > intfun1<- function(S) {integrate(function(x) integrand1(x,
> > > S),lower=0,upper=Inf)[[1]]-1}
> > > intfun2<- function(S) {integrate(function(x) integrand2(x,
> > > S),lower=0,upper=Inf)[[1]]-1}
> > >
> > > #putting both equations into one term
> > > model <- function(S) c(F1 = intfun1,F2 = intfun2)
> > >
> > > #Solving for roots
> > > (ss <-multiroot(f=model, start=c(0,0)))
> > > ```
> > >
> > > This gives me the error Error in stode(y, times, func, parms = parms,
> ...) :
> > >   REAL() can only be applied to a 'numeric', not a 'list'
> > >
> > > However this simpler example works fine:
> > >
> > > ```{r}
> > > #Defining the functions
> > > model <- function(x) c(F1 = x[1]+ 4*x[2] -8,F2 = x[1]-4*x[2])
> > >
> > > #Solving for the roots
> > > (ss <- multiroot(f = model, start = c(0,0)))
> > > ```
> > >
> > > Giving me the required x_1= 4 and x_2 =1.
> > >
> > > I was given some code to perform a least squares analysis on the same
> > > system but I neither understand the code, nor believe that it is doing
> what
> > > I am looking for as different initial values give wildly different S
> values.
> > >
> > > ```{r}
> > > a11 <- 1 #alpha_{11}
> > > a12 <- 1 #alpha_{12}
> > > a21 <- 1 #alpha_{21}
> > > a22 <- 1 #alpha_{22}
> > > b1 <- 2  #beta1
> > > b2 <- 2 #beta2
> > > d1 <- 1 #delta1
> > > d2 <- 1 #delta2
> > > g <- 0.5 #gamma
> > >
> > >
> > > integrand1 <- function(x,S) {b1*g/d1*exp(-g*x)*(1-exp(-d1*
> > > x))*exp(-a11*b1*S[1]/d1*(1-exp(-d1*x))-a12*b2*S[2]/d2*(1-exp(-d2*x)))}
> > > integrand2 <- function(x,S) {b2*g/d2*exp(-g*x)*(1-exp(-d2*
> > > x))*exp(-a22*b2*S[2]/d2*(1-exp(-d2*x))-a21*b1*S[1]/d1*(1-exp(-d1*x)))}
> > >
> > > #defining equation we would like to solve
> > > intfun1<- function(S) {integrate(function(x)integrand1(x,
> > > S),lower=0,upper=Inf)[[1]]-1}
> > > intfun2<- function(S) {integrate(function(x)integrand2(x,
> > > S),lower=0,upper=Inf)[[1]]-1}
> > >
> > > #putting both equations into one term
> > > model <- function(S) if(any(S<0))NA else intfun1(S)**2+ intfun2(S)**2
> > >
> > > #Solving for roots
> > > optim(c(0,0), model)
> > > ```
> > >
> > > I appreciate any tips/help as I have been struggling with this for some
> > > weeks now.
> > > thank you,
> > > --
> > > Ursula
> > > Ph.D. student, University of Michigan
> > > Applied and Interdisciplinary Mathematics
> > > utrigos at umich.edu
> > >
> > >         [[alternative HTML version deleted]]
> > >
> > > ______________________________________________
> > > R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> > > https://stat.ethz.ch/mailman/listinfo/r-help
> > > PLEASE do read the posting guide
> http://www.R-project.org/posting-guide.html
> > > and provide commented, minimal, self-contained, reproducible code.
>


-- 
Ursula Trigos-Raczkowski (she/her/hers)
Ph.D. student, University of Michigan
Applied and Interdisciplinary Mathematics
5828 East Hall
530 Church St.
Ann Arbor, MI 48109-1085
utrigos at umich.edu

	[[alternative HTML version deleted]]


From meyer@j@me@ @end|ng |rom u@@@net  Thu May  6 13:24:18 2021
From: meyer@j@me@ @end|ng |rom u@@@net (james meyer)
Date: Thu, 06 May 2021 07:24:18 -0400
Subject: [R] calculating area of ellipse
Message-ID: <788ZeFLXs9152Set.1620300258@web07.cms.usa.net>

In doing meta-analysis of diagnostic accuracy I produce ellipses of confidence
and prediction intervals in two dimensions.  How can I calculate the area of
the ellipse in ggplot2 or base R?

thank you
James Meyer


From j|ox @end|ng |rom mcm@@ter@c@  Thu May  6 21:06:45 2021
From: j|ox @end|ng |rom mcm@@ter@c@ (John Fox)
Date: Thu, 6 May 2021 15:06:45 -0400
Subject: [R] calculating area of ellipse
In-Reply-To: <14678_1620323470_146Hp9BO009977_788ZeFLXs9152Set.1620300258@web07.cms.usa.net>
References: <14678_1620323470_146Hp9BO009977_788ZeFLXs9152Set.1620300258@web07.cms.usa.net>
Message-ID: <e0ac21ae-5e96-a9ea-21d3-44ce384e10fc@mcmaster.ca>

Dear James,

To mix notation a bit, presumably the (border of the) confidence ellipse 
is of the form (b - beta)'V(b)^-1 (b - beta) = c, where V(b) is the 
covariance matrix of b and c is a constant. Then the area of the ellipse 
is pi*c^2*sqrt(det(V(b))). It shouldn't be hard to translate that into R 
code.

I hope this helps,
  John

John Fox, Professor Emeritus
McMaster University
Hamilton, Ontario, Canada
web: https://socialsciences.mcmaster.ca/jfox/

John Fox, Professor Emeritus
McMaster University
Hamilton, Ontario, Canada
web: https://socialsciences.mcmaster.ca/jfox/

On 2021-05-06 7:24 a.m., james meyer wrote:
> In doing meta-analysis of diagnostic accuracy I produce ellipses of confidence
> and prediction intervals in two dimensions.  How can I calculate the area of
> the ellipse in ggplot2 or base R?
> 
> thank you
> James Meyer
> 
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
>


From re|chm@nj @end|ng |rom @bcg|ob@|@net  Thu May  6 21:36:50 2021
From: re|chm@nj @end|ng |rom @bcg|ob@|@net (Jeff Reichman)
Date: Thu, 6 May 2021 14:36:50 -0500
Subject: [R] Transforming data
References: <001401d742af$29a4dfa0$7cee9ee0$.ref@sbcglobal.net>
Message-ID: <001401d742af$29a4dfa0$7cee9ee0$@sbcglobal.net>

R Help Forum

I am attempting to transform the data frame in Table 1 to the form shown in
Table 2. Any suggestions. I?ve started by removing duplicate rows 

 

Jeff

 

 

Table 1


Taxon

Importer


Guarouba guarouba

AE


Acipenser gueldenstaedtii

AE


Caiman crocodilus fuscus

AE


Caiman crocodilus fuscus

AE


Caiman crocodilus fuscus

AE


Ara ararauna

AG


Ara chloropterus

AG


Python reticulatus

AE


Strombus gigas

AE


Strombus gigas

AE


Strombus gigas

AE


Strombus gigas

AE


Strombus gigas

AE


Varanus niloticus

AE


Varanus niloticus

AE


Caiman crocodilus fuscus

AE

 

 

Table 2


Country 

Guarouba guarouba

Acipenser gueldenstaedtii

Caiman crocodilus fuscus

Python reticulatus

Strombus gigas

Varanus niloticus

Caiman crocodilus fuscus

Ara ararauna

Caiman crocodilus fuscus


AE

1

1

1

1

1

1

1

0

0


AG

0

0

0

0

0

0

0

1

1

 


	[[alternative HTML version deleted]]


From re|chm@nj @end|ng |rom @bcg|ob@|@net  Thu May  6 22:13:16 2021
From: re|chm@nj @end|ng |rom @bcg|ob@|@net (Jeff Reichman)
Date: Thu, 6 May 2021 15:13:16 -0500
Subject: [R] Transforming data
In-Reply-To: <001401d742af$29a4dfa0$7cee9ee0$@sbcglobal.net>
References: <001401d742af$29a4dfa0$7cee9ee0$.ref@sbcglobal.net>
 <001401d742af$29a4dfa0$7cee9ee0$@sbcglobal.net>
Message-ID: <002701d742b4$40243460$c06c9d20$@sbcglobal.net>

R-help

Never mind I figured out a working solution

- remove duplicate
- mutate a new column  == 1
- spread the data from long  to wide
- replace NA with 0's

Not sure it?s the most elegant but gets the gob done


-----Original Message-----
From: R-help <r-help-bounces at r-project.org> On Behalf Of Jeff Reichman
Sent: Thursday, May 6, 2021 2:37 PM
To: R-help at r-project.org
Subject: [R] Transforming data

R Help Forum

I am attempting to transform the data frame in Table 1 to the form shown in Table 2. Any suggestions. I ve started by removing duplicate rows 

 

Jeff

 

 

Table 1


Taxon

Importer


Guarouba guarouba

AE


Acipenser gueldenstaedtii

AE


Caiman crocodilus fuscus

AE


Caiman crocodilus fuscus

AE


Caiman crocodilus fuscus

AE


Ara ararauna

AG


Ara chloropterus

AG


Python reticulatus

AE


Strombus gigas

AE


Strombus gigas

AE


Strombus gigas

AE


Strombus gigas

AE


Strombus gigas

AE


Varanus niloticus

AE


Varanus niloticus

AE


Caiman crocodilus fuscus

AE

 

 

Table 2


Country 

Guarouba guarouba

Acipenser gueldenstaedtii

Caiman crocodilus fuscus

Python reticulatus

Strombus gigas

Varanus niloticus

Caiman crocodilus fuscus

Ara ararauna

Caiman crocodilus fuscus


AE

1

1

1

1

1

1

1

0

0


AG

0

0

0

0

0

0

0

1

1

 


	[[alternative HTML version deleted]]


From jdnewm|| @end|ng |rom dcn@d@v|@@c@@u@  Thu May  6 22:48:55 2021
From: jdnewm|| @end|ng |rom dcn@d@v|@@c@@u@ (Jeff Newmiller)
Date: Thu, 06 May 2021 13:48:55 -0700
Subject: [R] Transforming data
In-Reply-To: <002701d742b4$40243460$c06c9d20$@sbcglobal.net>
References: <001401d742af$29a4dfa0$7cee9ee0$.ref@sbcglobal.net>
 <001401d742af$29a4dfa0$7cee9ee0$@sbcglobal.net>
 <002701d742b4$40243460$c06c9d20$@sbcglobal.net>
Message-ID: <311218FA-DB98-4B7B-84EF-1BD8CF173F59@dcn.davis.ca.us>

Posting HTML email is a good way to reduce your chances of getting a response.

On May 6, 2021 1:13:16 PM PDT, Jeff Reichman <reichmanj at sbcglobal.net> wrote:
>R-help
>
>Never mind I figured out a working solution
>
>- remove duplicate
>- mutate a new column  == 1
>- spread the data from long  to wide
>- replace NA with 0's
>
>Not sure it?s the most elegant but gets the gob done
>
>
>-----Original Message-----
>From: R-help <r-help-bounces at r-project.org> On Behalf Of Jeff Reichman
>Sent: Thursday, May 6, 2021 2:37 PM
>To: R-help at r-project.org
>Subject: [R] Transforming data
>
>R Help Forum
>
>I am attempting to transform the data frame in Table 1 to the form
>shown in Table 2. Any suggestions. I ve started by removing duplicate
>rows 
>
> 
>
>Jeff
>
> 
>
> 
>
>Table 1
>
>
>Taxon
>
>Importer
>
>
>Guarouba guarouba
>
>AE
>
>
>Acipenser gueldenstaedtii
>
>AE
>
>
>Caiman crocodilus fuscus
>
>AE
>
>
>Caiman crocodilus fuscus
>
>AE
>
>
>Caiman crocodilus fuscus
>
>AE
>
>
>Ara ararauna
>
>AG
>
>
>Ara chloropterus
>
>AG
>
>
>Python reticulatus
>
>AE
>
>
>Strombus gigas
>
>AE
>
>
>Strombus gigas
>
>AE
>
>
>Strombus gigas
>
>AE
>
>
>Strombus gigas
>
>AE
>
>
>Strombus gigas
>
>AE
>
>
>Varanus niloticus
>
>AE
>
>
>Varanus niloticus
>
>AE
>
>
>Caiman crocodilus fuscus
>
>AE
>
> 
>
> 
>
>Table 2
>
>
>Country 
>
>Guarouba guarouba
>
>Acipenser gueldenstaedtii
>
>Caiman crocodilus fuscus
>
>Python reticulatus
>
>Strombus gigas
>
>Varanus niloticus
>
>Caiman crocodilus fuscus
>
>Ara ararauna
>
>Caiman crocodilus fuscus
>
>
>AE
>
>1
>
>1
>
>1
>
>1
>
>1
>
>1
>
>1
>
>0
>
>0
>
>
>AG
>
>0
>
>0
>
>0
>
>0
>
>0
>
>0
>
>0
>
>1
>
>1
>
> 
>
>
>	[[alternative HTML version deleted]]
>
>______________________________________________
>R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>https://stat.ethz.ch/mailman/listinfo/r-help
>PLEASE do read the posting guide
>http://www.R-project.org/posting-guide.html
>and provide commented, minimal, self-contained, reproducible code.

-- 
Sent from my phone. Please excuse my brevity.


From c||n|c@|0910 @end|ng |rom gm@||@com  Thu May  6 21:40:56 2021
From: c||n|c@|0910 @end|ng |rom gm@||@com (Ahmad Raza)
Date: Thu, 6 May 2021 23:40:56 +0400
Subject: [R] Analysing data with repeated measure variable
Message-ID: <CANSYM40wKq0c9Vp6PyCAZJrV-bNH4Xve1vHuYq1knC+SQyWS3g@mail.gmail.com>

Dear Experts,
Greetings

I have the following type of repeated measures data (table 1), and events
data in table 2 (single measure). I want to perform the following tasks (in
R or excel sheet please).

   - To filter subjects who had any response at least 3 days.
   - Response should be > 5 in each day.
   - Then table 1 should have another column, date first response recorded.
   - Then both tables should be merged

Table 1 ? Response Data

Sub_No    Response     Date1          5          01-Jan1          5
      02-Jan2          5          01-Jan2          10         02-Jan2
        10         03-Jan2          10         04-Jan2          10
    05-Jan3          10         01-Jan3          10         02-Jan3
      10         03-Jan4          5          01-Jan4          5
  02-Jan4          10         03-Jan4          10         04-Jan4
    10         05-Jan


Table 2 ? Event Data

Sub_No   Response        Date1          No2         Yes          30
Jan3         Yes          29 Jan4          No

Thanks for your help.
Regards,

	[[alternative HTML version deleted]]


From bgunter@4567 @end|ng |rom gm@||@com  Fri May  7 00:07:01 2021
From: bgunter@4567 @end|ng |rom gm@||@com (Bert Gunter)
Date: Thu, 6 May 2021 15:07:01 -0700
Subject: [R] Analysing data with repeated measure variable
In-Reply-To: <CANSYM40wKq0c9Vp6PyCAZJrV-bNH4Xve1vHuYq1knC+SQyWS3g@mail.gmail.com>
References: <CANSYM40wKq0c9Vp6PyCAZJrV-bNH4Xve1vHuYq1knC+SQyWS3g@mail.gmail.com>
Message-ID: <CAGxFJbQ_tzaO7en8xV++SpT8P8_rOEARQ4J29GTfRWEDU8C=VA@mail.gmail.com>

This looks like homework. We don't do homework on this list.

To see what is done here, read and follow the posting guide linked below.
If not homework, I think it is still very much out of  bounds anyway, as
you appear to be asking us to do your work for you.

On Thu, May 6, 2021, 2:32 PM Ahmad Raza <clinical0910 at gmail.com> wrote:

> Dear Experts,
> Greetings
>
> I have the following type of repeated measures data (table 1), and events
> data in table 2 (single measure). I want to perform the following tasks (in
> R or excel sheet please).
>
>    - To filter subjects who had any response at least 3 days.
>    - Response should be > 5 in each day.
>    - Then table 1 should have another column, date first response recorded.
>    - Then both tables should be merged
>
> Table 1 ? Response Data
>
> Sub_No    Response     Date1          5          01-Jan1          5
>       02-Jan2          5          01-Jan2          10         02-Jan2
>         10         03-Jan2          10         04-Jan2          10
>     05-Jan3          10         01-Jan3          10         02-Jan3
>       10         03-Jan4          5          01-Jan4          5
>   02-Jan4          10         03-Jan4          10         04-Jan4
>     10         05-Jan
>
>
> Table 2 ? Event Data
>
> Sub_No   Response        Date1          No2         Yes          30
> Jan3         Yes          29 Jan4          No
>
> Thanks for your help.
> Regards,
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide
> http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
>

	[[alternative HTML version deleted]]


From drj|m|emon @end|ng |rom gm@||@com  Fri May  7 03:29:42 2021
From: drj|m|emon @end|ng |rom gm@||@com (Jim Lemon)
Date: Fri, 7 May 2021 11:29:42 +1000
Subject: [R] calculating area of ellipse
In-Reply-To: <788ZeFLXs9152Set.1620300258@web07.cms.usa.net>
References: <788ZeFLXs9152Set.1620300258@web07.cms.usa.net>
Message-ID: <CA+8X3fWb1vamG21m09SLZnbytOmE3HeVaGTC0CqWdZ+ShFF47A@mail.gmail.com>

Hi James,
If the result contains the major (a) and minor (b) axes of the
ellipse, it's easy:

area<-pi*a*b

try using str() on the result you get.

Jim

On Fri, May 7, 2021 at 3:51 AM james meyer <meyer.james at usa.net> wrote:
>
> In doing meta-analysis of diagnostic accuracy I produce ellipses of confidence
> and prediction intervals in two dimensions.  How can I calculate the area of
> the ellipse in ggplot2 or base R?
>
> thank you
> James Meyer
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.


From @purd|e@@ @end|ng |rom gm@||@com  Fri May  7 03:56:40 2021
From: @purd|e@@ @end|ng |rom gm@||@com (Abbs Spurdle)
Date: Fri, 7 May 2021 13:56:40 +1200
Subject: [R] solving integral equations with undefined parameters using
 multiroot
In-Reply-To: <CANSXP2RQDf-bnEjDU6m4+vu9m3XyDfCPYamRYvqL8NhQEkrD3Q@mail.gmail.com>
References: <CANSXP2RHWd7CkRMOCb8n5Nm2ei5LHyzUBhTsTjdsCH+hq6Ac-w@mail.gmail.com>
 <CAB8pepx-PjtOOP7KT5Z-637+7wnh5-UqgYSvLfimfBh03VWb5Q@mail.gmail.com>
 <CAB8pepwP_H88QVZ7Jn858nfKdzFEvG_iQLh1DRhMmnBtJL+XcA@mail.gmail.com>
 <CANSXP2RQDf-bnEjDU6m4+vu9m3XyDfCPYamRYvqL8NhQEkrD3Q@mail.gmail.com>
Message-ID: <CAB8pepxdSrSY=wOZK_ciqif0bXyCSu_9OFcRnxHj=6Cu0D29kQ@mail.gmail.com>

#using vF1 function
#from my previous posts
u <- seq (0, 0.25,, 200)
cl <- contourLines (u, u, outer (u, u, vF1),, 0)[[1]]
plot (cl$x, cl$y, type="l")


On Thu, May 6, 2021 at 10:18 PM Ursula Trigos-Raczkowski
<utrigos at umich.edu> wrote:
>
> Thanks for your reply. Unfortunately the code doesn't work even when I change the parameters to ensure I have "different" equations.
> Using mathematica I do see that my two equations form planes, intersecting in a line of infinite solutions but it is not very accurate, I was hoping R would be more accurate and tell me what this line is, or at least a set of solutions.
>
> On Thu, May 6, 2021 at 5:28 AM Abbs Spurdle <spurdle.a at gmail.com> wrote:
>>
>> Just realized five minutes after posting that I misinterpreted your
>> question, slightly.
>> However, after comparing the solution sets for *both* equations, I
>> can't see any obvious difference between the two.
>> If there is any difference, presumably that difference is extremely small.
>>
>>
>> On Thu, May 6, 2021 at 8:39 PM Abbs Spurdle <spurdle.a at gmail.com> wrote:
>> >
>> > Hi Ursula,
>> >
>> > If I'm not mistaken, there's an infinite number of solutions, which
>> > form a straight (or near straight) line.
>> > Refer to the following code, and attached plot.
>> >
>> > ----begin code---
>> > library (barsurf)
>> > vF1 <- function (u, v)
>> > {   n <- length (u)
>> >     k <- numeric (n)
>> >     for (i in seq_len (n) )
>> >         k [i] <- intfun1 (c (u [i], v [i]) )
>> >     k
>> > }
>> > plotf_cfield (vF1, c (0, 0.2), fb = (-2:2) / 10,
>> >     main="(integral_1 - 1)",
>> >     xlab="S[1]", ylab="S[2]",
>> >     n=40, raster=TRUE, theme="heat", contour.labels=TRUE)
>> > ----end code----
>> >
>> > I'm not familiar with the RootSolve package.
>> > Nor am I quite sure what you're trying to compute, given the apparent
>> > infinite set of solutions.
>> >
>> > So, for now at least, I'll leave comments on the root finding to someone who is.
>> >
>> >
>> > Abby
>> >
>> >
>> > On Thu, May 6, 2021 at 8:46 AM Ursula Trigos-Raczkowski
>> > <utrigos at umich.edu> wrote:
>> > >
>> > > Hello,
>> > > I am trying to solve a system of integral equations using multiroot. I have
>> > > tried asking on stack exchange and reddit without any luck.
>> > > Multiroot uses the library(RootSolve).
>> > >
>> > > I have two integral equations involving constants S[1] and S[2] (which are
>> > > free.) I would like to find what *positive* values of S[1] and S[2] make
>> > > the resulting
>> > > (Integrals-1) = 0.
>> > > (I know that the way I have the parameters set up the equations are very
>> > > similar but I am interested in changing the parameters once I have the code
>> > > working.)
>> > > My attempt at code:
>> > >
>> > > ```{r}
>> > > a11 <- 1 #alpha_{11}
>> > > a12 <- 1 #alpha_{12}
>> > > a21 <- 1 #alpha_{21}
>> > > a22 <- 1 #alpha_{22}
>> > > b1 <- 2  #beta1
>> > > b2 <- 2 #beta2
>> > > d1 <- 1 #delta1
>> > > d2 <- 1 #delta2
>> > > g <- 0.5 #gamma
>> > >
>> > >
>> > > integrand1 <- function(x,S) {b1*g/d1*exp(-g*x)*(1-exp(-d1*
>> > > x))*exp(-a11*b1*S[1]/d1*(1-exp(-d1*x))-a12*b2*S[2]/d2*(1-exp(-d2*x)))}
>> > > integrand2 <- function(x,S) {b2*g/d2*exp(-g*x)*(1-exp(-d2*
>> > > x))*exp(-a22*b2*S[2]/d2*(1-exp(-d2*x))-a21*b1*S[1]/d1*(1-exp(-d1*x)))}
>> > >
>> > > #defining equation we would like to solve
>> > > intfun1<- function(S) {integrate(function(x) integrand1(x,
>> > > S),lower=0,upper=Inf)[[1]]-1}
>> > > intfun2<- function(S) {integrate(function(x) integrand2(x,
>> > > S),lower=0,upper=Inf)[[1]]-1}
>> > >
>> > > #putting both equations into one term
>> > > model <- function(S) c(F1 = intfun1,F2 = intfun2)
>> > >
>> > > #Solving for roots
>> > > (ss <-multiroot(f=model, start=c(0,0)))
>> > > ```
>> > >
>> > > This gives me the error Error in stode(y, times, func, parms = parms, ...) :
>> > >   REAL() can only be applied to a 'numeric', not a 'list'
>> > >
>> > > However this simpler example works fine:
>> > >
>> > > ```{r}
>> > > #Defining the functions
>> > > model <- function(x) c(F1 = x[1]+ 4*x[2] -8,F2 = x[1]-4*x[2])
>> > >
>> > > #Solving for the roots
>> > > (ss <- multiroot(f = model, start = c(0,0)))
>> > > ```
>> > >
>> > > Giving me the required x_1= 4 and x_2 =1.
>> > >
>> > > I was given some code to perform a least squares analysis on the same
>> > > system but I neither understand the code, nor believe that it is doing what
>> > > I am looking for as different initial values give wildly different S values.
>> > >
>> > > ```{r}
>> > > a11 <- 1 #alpha_{11}
>> > > a12 <- 1 #alpha_{12}
>> > > a21 <- 1 #alpha_{21}
>> > > a22 <- 1 #alpha_{22}
>> > > b1 <- 2  #beta1
>> > > b2 <- 2 #beta2
>> > > d1 <- 1 #delta1
>> > > d2 <- 1 #delta2
>> > > g <- 0.5 #gamma
>> > >
>> > >
>> > > integrand1 <- function(x,S) {b1*g/d1*exp(-g*x)*(1-exp(-d1*
>> > > x))*exp(-a11*b1*S[1]/d1*(1-exp(-d1*x))-a12*b2*S[2]/d2*(1-exp(-d2*x)))}
>> > > integrand2 <- function(x,S) {b2*g/d2*exp(-g*x)*(1-exp(-d2*
>> > > x))*exp(-a22*b2*S[2]/d2*(1-exp(-d2*x))-a21*b1*S[1]/d1*(1-exp(-d1*x)))}
>> > >
>> > > #defining equation we would like to solve
>> > > intfun1<- function(S) {integrate(function(x)integrand1(x,
>> > > S),lower=0,upper=Inf)[[1]]-1}
>> > > intfun2<- function(S) {integrate(function(x)integrand2(x,
>> > > S),lower=0,upper=Inf)[[1]]-1}
>> > >
>> > > #putting both equations into one term
>> > > model <- function(S) if(any(S<0))NA else intfun1(S)**2+ intfun2(S)**2
>> > >
>> > > #Solving for roots
>> > > optim(c(0,0), model)
>> > > ```
>> > >
>> > > I appreciate any tips/help as I have been struggling with this for some
>> > > weeks now.
>> > > thank you,
>> > > --
>> > > Ursula
>> > > Ph.D. student, University of Michigan
>> > > Applied and Interdisciplinary Mathematics
>> > > utrigos at umich.edu
>> > >
>> > >         [[alternative HTML version deleted]]
>> > >
>> > > ______________________________________________
>> > > R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> > > https://stat.ethz.ch/mailman/listinfo/r-help
>> > > PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
>> > > and provide commented, minimal, self-contained, reproducible code.
>
>
>
> --
> Ursula Trigos-Raczkowski (she/her/hers)
> Ph.D. student, University of Michigan
> Applied and Interdisciplinary Mathematics
> 5828 East Hall
> 530 Church St.
> Ann Arbor, MI 48109-1085
> utrigos at umich.edu
>


From @purd|e@@ @end|ng |rom gm@||@com  Fri May  7 04:02:16 2021
From: @purd|e@@ @end|ng |rom gm@||@com (Abbs Spurdle)
Date: Fri, 7 May 2021 14:02:16 +1200
Subject: [R] solving integral equations with undefined parameters using
 multiroot
In-Reply-To: <CAB8pepxdSrSY=wOZK_ciqif0bXyCSu_9OFcRnxHj=6Cu0D29kQ@mail.gmail.com>
References: <CANSXP2RHWd7CkRMOCb8n5Nm2ei5LHyzUBhTsTjdsCH+hq6Ac-w@mail.gmail.com>
 <CAB8pepx-PjtOOP7KT5Z-637+7wnh5-UqgYSvLfimfBh03VWb5Q@mail.gmail.com>
 <CAB8pepwP_H88QVZ7Jn858nfKdzFEvG_iQLh1DRhMmnBtJL+XcA@mail.gmail.com>
 <CANSXP2RQDf-bnEjDU6m4+vu9m3XyDfCPYamRYvqL8NhQEkrD3Q@mail.gmail.com>
 <CAB8pepxdSrSY=wOZK_ciqif0bXyCSu_9OFcRnxHj=6Cu0D29kQ@mail.gmail.com>
Message-ID: <CAB8pepyWLhROb=-YSqACdfRT0N0e+oixWOrYov0of6MKxXuiCA@mail.gmail.com>

lm (cl$y ~ cl$x)$coef
(Intercept)        cl$x
  0.1817509  -1.0000000


On Fri, May 7, 2021 at 1:56 PM Abbs Spurdle <spurdle.a at gmail.com> wrote:
>
> #using vF1 function
> #from my previous posts
> u <- seq (0, 0.25,, 200)
> cl <- contourLines (u, u, outer (u, u, vF1),, 0)[[1]]
> plot (cl$x, cl$y, type="l")
>
>
> On Thu, May 6, 2021 at 10:18 PM Ursula Trigos-Raczkowski
> <utrigos at umich.edu> wrote:
> >
> > Thanks for your reply. Unfortunately the code doesn't work even when I change the parameters to ensure I have "different" equations.
> > Using mathematica I do see that my two equations form planes, intersecting in a line of infinite solutions but it is not very accurate, I was hoping R would be more accurate and tell me what this line is, or at least a set of solutions.
> >
> > On Thu, May 6, 2021 at 5:28 AM Abbs Spurdle <spurdle.a at gmail.com> wrote:
> >>
> >> Just realized five minutes after posting that I misinterpreted your
> >> question, slightly.
> >> However, after comparing the solution sets for *both* equations, I
> >> can't see any obvious difference between the two.
> >> If there is any difference, presumably that difference is extremely small.
> >>
> >>
> >> On Thu, May 6, 2021 at 8:39 PM Abbs Spurdle <spurdle.a at gmail.com> wrote:
> >> >
> >> > Hi Ursula,
> >> >
> >> > If I'm not mistaken, there's an infinite number of solutions, which
> >> > form a straight (or near straight) line.
> >> > Refer to the following code, and attached plot.
> >> >
> >> > ----begin code---
> >> > library (barsurf)
> >> > vF1 <- function (u, v)
> >> > {   n <- length (u)
> >> >     k <- numeric (n)
> >> >     for (i in seq_len (n) )
> >> >         k [i] <- intfun1 (c (u [i], v [i]) )
> >> >     k
> >> > }
> >> > plotf_cfield (vF1, c (0, 0.2), fb = (-2:2) / 10,
> >> >     main="(integral_1 - 1)",
> >> >     xlab="S[1]", ylab="S[2]",
> >> >     n=40, raster=TRUE, theme="heat", contour.labels=TRUE)
> >> > ----end code----
> >> >
> >> > I'm not familiar with the RootSolve package.
> >> > Nor am I quite sure what you're trying to compute, given the apparent
> >> > infinite set of solutions.
> >> >
> >> > So, for now at least, I'll leave comments on the root finding to someone who is.
> >> >
> >> >
> >> > Abby
> >> >
> >> >
> >> > On Thu, May 6, 2021 at 8:46 AM Ursula Trigos-Raczkowski
> >> > <utrigos at umich.edu> wrote:
> >> > >
> >> > > Hello,
> >> > > I am trying to solve a system of integral equations using multiroot. I have
> >> > > tried asking on stack exchange and reddit without any luck.
> >> > > Multiroot uses the library(RootSolve).
> >> > >
> >> > > I have two integral equations involving constants S[1] and S[2] (which are
> >> > > free.) I would like to find what *positive* values of S[1] and S[2] make
> >> > > the resulting
> >> > > (Integrals-1) = 0.
> >> > > (I know that the way I have the parameters set up the equations are very
> >> > > similar but I am interested in changing the parameters once I have the code
> >> > > working.)
> >> > > My attempt at code:
> >> > >
> >> > > ```{r}
> >> > > a11 <- 1 #alpha_{11}
> >> > > a12 <- 1 #alpha_{12}
> >> > > a21 <- 1 #alpha_{21}
> >> > > a22 <- 1 #alpha_{22}
> >> > > b1 <- 2  #beta1
> >> > > b2 <- 2 #beta2
> >> > > d1 <- 1 #delta1
> >> > > d2 <- 1 #delta2
> >> > > g <- 0.5 #gamma
> >> > >
> >> > >
> >> > > integrand1 <- function(x,S) {b1*g/d1*exp(-g*x)*(1-exp(-d1*
> >> > > x))*exp(-a11*b1*S[1]/d1*(1-exp(-d1*x))-a12*b2*S[2]/d2*(1-exp(-d2*x)))}
> >> > > integrand2 <- function(x,S) {b2*g/d2*exp(-g*x)*(1-exp(-d2*
> >> > > x))*exp(-a22*b2*S[2]/d2*(1-exp(-d2*x))-a21*b1*S[1]/d1*(1-exp(-d1*x)))}
> >> > >
> >> > > #defining equation we would like to solve
> >> > > intfun1<- function(S) {integrate(function(x) integrand1(x,
> >> > > S),lower=0,upper=Inf)[[1]]-1}
> >> > > intfun2<- function(S) {integrate(function(x) integrand2(x,
> >> > > S),lower=0,upper=Inf)[[1]]-1}
> >> > >
> >> > > #putting both equations into one term
> >> > > model <- function(S) c(F1 = intfun1,F2 = intfun2)
> >> > >
> >> > > #Solving for roots
> >> > > (ss <-multiroot(f=model, start=c(0,0)))
> >> > > ```
> >> > >
> >> > > This gives me the error Error in stode(y, times, func, parms = parms, ...) :
> >> > >   REAL() can only be applied to a 'numeric', not a 'list'
> >> > >
> >> > > However this simpler example works fine:
> >> > >
> >> > > ```{r}
> >> > > #Defining the functions
> >> > > model <- function(x) c(F1 = x[1]+ 4*x[2] -8,F2 = x[1]-4*x[2])
> >> > >
> >> > > #Solving for the roots
> >> > > (ss <- multiroot(f = model, start = c(0,0)))
> >> > > ```
> >> > >
> >> > > Giving me the required x_1= 4 and x_2 =1.
> >> > >
> >> > > I was given some code to perform a least squares analysis on the same
> >> > > system but I neither understand the code, nor believe that it is doing what
> >> > > I am looking for as different initial values give wildly different S values.
> >> > >
> >> > > ```{r}
> >> > > a11 <- 1 #alpha_{11}
> >> > > a12 <- 1 #alpha_{12}
> >> > > a21 <- 1 #alpha_{21}
> >> > > a22 <- 1 #alpha_{22}
> >> > > b1 <- 2  #beta1
> >> > > b2 <- 2 #beta2
> >> > > d1 <- 1 #delta1
> >> > > d2 <- 1 #delta2
> >> > > g <- 0.5 #gamma
> >> > >
> >> > >
> >> > > integrand1 <- function(x,S) {b1*g/d1*exp(-g*x)*(1-exp(-d1*
> >> > > x))*exp(-a11*b1*S[1]/d1*(1-exp(-d1*x))-a12*b2*S[2]/d2*(1-exp(-d2*x)))}
> >> > > integrand2 <- function(x,S) {b2*g/d2*exp(-g*x)*(1-exp(-d2*
> >> > > x))*exp(-a22*b2*S[2]/d2*(1-exp(-d2*x))-a21*b1*S[1]/d1*(1-exp(-d1*x)))}
> >> > >
> >> > > #defining equation we would like to solve
> >> > > intfun1<- function(S) {integrate(function(x)integrand1(x,
> >> > > S),lower=0,upper=Inf)[[1]]-1}
> >> > > intfun2<- function(S) {integrate(function(x)integrand2(x,
> >> > > S),lower=0,upper=Inf)[[1]]-1}
> >> > >
> >> > > #putting both equations into one term
> >> > > model <- function(S) if(any(S<0))NA else intfun1(S)**2+ intfun2(S)**2
> >> > >
> >> > > #Solving for roots
> >> > > optim(c(0,0), model)
> >> > > ```
> >> > >
> >> > > I appreciate any tips/help as I have been struggling with this for some
> >> > > weeks now.
> >> > > thank you,
> >> > > --
> >> > > Ursula
> >> > > Ph.D. student, University of Michigan
> >> > > Applied and Interdisciplinary Mathematics
> >> > > utrigos at umich.edu
> >> > >
> >> > >         [[alternative HTML version deleted]]
> >> > >
> >> > > ______________________________________________
> >> > > R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> >> > > https://stat.ethz.ch/mailman/listinfo/r-help
> >> > > PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> >> > > and provide commented, minimal, self-contained, reproducible code.
> >
> >
> >
> > --
> > Ursula Trigos-Raczkowski (she/her/hers)
> > Ph.D. student, University of Michigan
> > Applied and Interdisciplinary Mathematics
> > 5828 East Hall
> > 530 Church St.
> > Ann Arbor, MI 48109-1085
> > utrigos at umich.edu
> >


From dw|n@em|u@ @end|ng |rom comc@@t@net  Fri May  7 04:31:50 2021
From: dw|n@em|u@ @end|ng |rom comc@@t@net (David Winsemius)
Date: Thu, 6 May 2021 19:31:50 -0700
Subject: [R] calculating area of ellipse
In-Reply-To: <CA+8X3fWb1vamG21m09SLZnbytOmE3HeVaGTC0CqWdZ+ShFF47A@mail.gmail.com>
References: <788ZeFLXs9152Set.1620300258@web07.cms.usa.net>
 <CA+8X3fWb1vamG21m09SLZnbytOmE3HeVaGTC0CqWdZ+ShFF47A@mail.gmail.com>
Message-ID: <5b857aca-8940-74fd-13d1-5504057851e6@comcast.net>


On 5/6/21 6:29 PM, Jim Lemon wrote:
> Hi James,
> If the result contains the major (a) and minor (b) axes of the
> ellipse, it's easy:
>
> area<-pi*a*b


ITYM semi-major and semi-minor axes.


-- 

David

>
> try using str() on the result you get.
>
> Jim
>
> On Fri, May 7, 2021 at 3:51 AM james meyer <meyer.james at usa.net> wrote:
>> In doing meta-analysis of diagnostic accuracy I produce ellipses of confidence
>> and prediction intervals in two dimensions.  How can I calculate the area of
>> the ellipse in ggplot2 or base R?
>>
>> thank you
>> James Meyer
>>
>> ______________________________________________
>> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> https://stat.ethz.ch/mailman/listinfo/r-help
>> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
>> and provide commented, minimal, self-contained, reproducible code.
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.


From j|ox @end|ng |rom mcm@@ter@c@  Fri May  7 18:15:03 2021
From: j|ox @end|ng |rom mcm@@ter@c@ (John Fox)
Date: Fri, 7 May 2021 12:15:03 -0400
Subject: [R] calculating area of ellipse
In-Reply-To: <32731_1620354746_1472UmbU009599_5b857aca-8940-74fd-13d1-5504057851e6@comcast.net>
References: <788ZeFLXs9152Set.1620300258@web07.cms.usa.net>
 <CA+8X3fWb1vamG21m09SLZnbytOmE3HeVaGTC0CqWdZ+ShFF47A@mail.gmail.com>
 <32731_1620354746_1472UmbU009599_5b857aca-8940-74fd-13d1-5504057851e6@comcast.net>
Message-ID: <91e6a5f5-3216-6f9d-871f-7087ce884376@mcmaster.ca>

Dear David and Jim,

As I explained yesterday, a confidence ellipse is based on a quadratic 
form in the inverse of the covariance matrix of the estimated 
coefficients. When the coefficients are uncorrelated, the axes of the 
ellipse are parallel to the parameter axes, and the radii of the ellipse 
are just a constant times the inverses of the standard deviations of the 
coefficients. The constant is typically the square root of twice a 
corresponding quantile (say, 0.95) of an F distribution with 2 numerator 
df, or a quantile of the chi-square distribution with 2 df.

In the more general case, the confidence ellipse is tilted, and the 
radii correspond to the square roots of the eigenvalues of the 
coefficient covariance matrix, again multiplied by a constant. That 
explains the result I gave yesterday based on the determinant of the 
coefficient covariance matrix, which is the product of its eigenvalues.

These results generalize readily to ellipsoids in higher dimensions, and 
to degenerate cases, such as perfectly correlated coefficients.

For more on the statistics of ellipses, see 
<http://euclid.psych.yorku.ca/datavis/papers/ellipses-STS402.pdf>.

Best,
  John

John Fox, Professor Emeritus
McMaster University
Hamilton, Ontario, Canada
web: https://socialsciences.mcmaster.ca/jfox/

On 2021-05-06 10:31 p.m., David Winsemius wrote:
> 
> On 5/6/21 6:29 PM, Jim Lemon wrote:
>> Hi James,
>> If the result contains the major (a) and minor (b) axes of the
>> ellipse, it's easy:
>>
>> area<-pi*a*b
> 
> 
> ITYM semi-major and semi-minor axes.
> 
>


From drj|m|emon @end|ng |rom gm@||@com  Fri May  7 23:34:04 2021
From: drj|m|emon @end|ng |rom gm@||@com (Jim Lemon)
Date: Sat, 8 May 2021 07:34:04 +1000
Subject: [R] calculating area of ellipse
In-Reply-To: <91e6a5f5-3216-6f9d-871f-7087ce884376@mcmaster.ca>
References: <788ZeFLXs9152Set.1620300258@web07.cms.usa.net>
 <CA+8X3fWb1vamG21m09SLZnbytOmE3HeVaGTC0CqWdZ+ShFF47A@mail.gmail.com>
 <32731_1620354746_1472UmbU009599_5b857aca-8940-74fd-13d1-5504057851e6@comcast.net>
 <91e6a5f5-3216-6f9d-871f-7087ce884376@mcmaster.ca>
Message-ID: <CA+8X3fUBL2s=BcHSjVoGo93ePA5MYX8YFkFhSvK2K=38gkpw6g@mail.gmail.com>

Hi John,
Thanks for that. An education for me and my advice to use "str" to
check for the radii in the return value
 was clearly mistaken.

Jim

On Sat, May 8, 2021 at 2:15 AM John Fox <jfox at mcmaster.ca> wrote:
>
> Dear David and Jim,
>
> As I explained yesterday, a confidence ellipse is based on a quadratic
> form in the inverse of the covariance matrix of the estimated
> coefficients. When the coefficients are uncorrelated, the axes of the
> ellipse are parallel to the parameter axes, and the radii of the ellipse
> are just a constant times the inverses of the standard deviations of the
> coefficients. The constant is typically the square root of twice a
> corresponding quantile (say, 0.95) of an F distribution with 2 numerator
> df, or a quantile of the chi-square distribution with 2 df.
>
> In the more general case, the confidence ellipse is tilted, and the
> radii correspond to the square roots of the eigenvalues of the
> coefficient covariance matrix, again multiplied by a constant. That
> explains the result I gave yesterday based on the determinant of the
> coefficient covariance matrix, which is the product of its eigenvalues.
>
> These results generalize readily to ellipsoids in higher dimensions, and
> to degenerate cases, such as perfectly correlated coefficients.
>
> For more on the statistics of ellipses, see
> <http://euclid.psych.yorku.ca/datavis/papers/ellipses-STS402.pdf>.
>
> Best,
>   John
>
> John Fox, Professor Emeritus
> McMaster University
> Hamilton, Ontario, Canada
> web: https://socialsciences.mcmaster.ca/jfox/
>
> On 2021-05-06 10:31 p.m., David Winsemius wrote:
> >
> > On 5/6/21 6:29 PM, Jim Lemon wrote:
> >> Hi James,
> >> If the result contains the major (a) and minor (b) axes of the
> >> ellipse, it's easy:
> >>
> >> area<-pi*a*b
> >
> >
> > ITYM semi-major and semi-minor axes.
> >
> >


From @tyen @end|ng |rom ntu@edu@tw  Sat May  8 19:00:12 2021
From: @tyen @end|ng |rom ntu@edu@tw (Steven Yen)
Date: Sun, 9 May 2021 01:00:12 +0800
Subject: [R] grep
Message-ID: <b5f941cd-ce01-b60f-583a-2c7524e9e106@ntu.edu.tw>

Below, the first command simply creates a list of 16 names (labels) 
which can be ignore.

In the 2nd and 3rd commands, I am able to identify names containing "black".

In line 4, I am trying to identify names containing "black" or "conserv" 
but obviously it does not work. Can someone help? Thanks.

 > names<-names(tp.nohs$estimate)[c(1:8,58:65)]; names
 ?[1] "x1.one"????? "x1.black"??? "x1.othrrace" "x1.moddkna" 
"x1.conserv"? "x1.nstrprty"
 ?[7] "x1.strrep"?? "x1.sevngprt" "x2.one"????? "x2.black" "x2.othrrace" 
"x2.moddkna"
[13] "x2.conserv"? "x2.nstrprty" "x2.strrep"?? "x2.sevngprt"
 > grep("black",names,value=TRUE)
[1] "x1.black" "x2.black"
 > grep("black",names,value=FALSE)
[1]? 2 10
 > grep(c("black","conserv"),names,value=TRUE)
[1] "x1.black" "x2.black"
Warning message:
In grep(c("black", "conserv"), names, value = TRUE) :
 ? argument 'pattern' has length > 1 and only the first element will be used


From dw|n@em|u@ @end|ng |rom comc@@t@net  Sat May  8 19:05:00 2021
From: dw|n@em|u@ @end|ng |rom comc@@t@net (David Winsemius)
Date: Sat, 8 May 2021 10:05:00 -0700
Subject: [R] grep
In-Reply-To: <b5f941cd-ce01-b60f-583a-2c7524e9e106@ntu.edu.tw>
References: <b5f941cd-ce01-b60f-583a-2c7524e9e106@ntu.edu.tw>
Message-ID: <cb3cb9a3-f133-d95c-855d-c901b6141d61@comcast.net>


On 5/8/21 10:00 AM, Steven Yen wrote:
> Below, the first command simply creates a list of 16 names (labels) 
> which can be ignore.
>
> In the 2nd and 3rd commands, I am able to identify names containing 
> "black".
>
> In line 4, I am trying to identify names containing "black" or 
> "conserv" but obviously it does not work. Can someone help? Thanks.
>
> > names<-names(tp.nohs$estimate)[c(1:8,58:65)]; names
> ?[1] "x1.one"????? "x1.black"??? "x1.othrrace" "x1.moddkna" 
> "x1.conserv"? "x1.nstrprty"
> ?[7] "x1.strrep"?? "x1.sevngprt" "x2.one"????? "x2.black" 
> "x2.othrrace" "x2.moddkna"
> [13] "x2.conserv"? "x2.nstrprty" "x2.strrep"?? "x2.sevngprt"
> > grep("black",names,value=TRUE)
> [1] "x1.black" "x2.black"
> > grep("black",names,value=FALSE)
> [1]? 2 10
> > grep(c("black","conserv"),names,value=TRUE)
> [1] "x1.black" "x2.black"
> Warning message:
> In grep(c("black", "conserv"), names, value = TRUE) :
> ? argument 'pattern' has length > 1 and only the first element will be 
> used


Try using the logical OR operator (vertical bar, AKA "pipe")

grep(c("black|conserv"), names, value=TRUE)

-- 

David.

>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide 
> http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.


From jdnewm|| @end|ng |rom dcn@d@v|@@c@@u@  Sat May  8 19:20:23 2021
From: jdnewm|| @end|ng |rom dcn@d@v|@@c@@u@ (Jeff Newmiller)
Date: Sat, 08 May 2021 10:20:23 -0700
Subject: [R] grep
In-Reply-To: <b5f941cd-ce01-b60f-583a-2c7524e9e106@ntu.edu.tw>
References: <b5f941cd-ce01-b60f-583a-2c7524e9e106@ntu.edu.tw>
Message-ID: <95812983-6A72-4392-A293-43CF974E3FF7@dcn.davis.ca.us>

Regular expression patterns are not vectorized... only the data to be searched are. Use one of the many websites dedicated to tutoring regular expressions to learn how they work. (Using function names like "names" as data names is bad practice.)

nms <- c( "x1.one", "x1.black", "x1.othrrace", "x1.moddkna", "x1.conserv", "x1.nstrprty", "x1.strrep", "x1.sevngprt", "x2.one", "x2.black", "x2.othrrace", "x2.moddkna", "x2.conserv", "x2.nstrprty", "x2.strrep", "x2.sevngprt" )

grep( "black|conserv", nms, value = TRUE )

On May 8, 2021 10:00:12 AM PDT, Steven Yen <styen at ntu.edu.tw> wrote:
>Below, the first command simply creates a list of 16 names (labels) 
>which can be ignore.
>
>In the 2nd and 3rd commands, I am able to identify names containing
>"black".
>
>In line 4, I am trying to identify names containing "black" or
>"conserv" 
>but obviously it does not work. Can someone help? Thanks.
>
> > names<-names(tp.nohs$estimate)[c(1:8,58:65)]; names
> ?[1] "x1.one"????? "x1.black"??? "x1.othrrace" "x1.moddkna" 
>"x1.conserv"? "x1.nstrprty"
>?[7] "x1.strrep"?? "x1.sevngprt" "x2.one"????? "x2.black" "x2.othrrace"
>
>"x2.moddkna"
>[13] "x2.conserv"? "x2.nstrprty" "x2.strrep"?? "x2.sevngprt"
> > grep("black",names,value=TRUE)
>[1] "x1.black" "x2.black"
> > grep("black",names,value=FALSE)
>[1]? 2 10
> > grep(c("black","conserv"),names,value=TRUE)
>[1] "x1.black" "x2.black"
>Warning message:
>In grep(c("black", "conserv"), names, value = TRUE) :
>? argument 'pattern' has length > 1 and only the first element will be
>used
>
>______________________________________________
>R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>https://stat.ethz.ch/mailman/listinfo/r-help
>PLEASE do read the posting guide
>http://www.R-project.org/posting-guide.html
>and provide commented, minimal, self-contained, reproducible code.

-- 
Sent from my phone. Please excuse my brevity.


From ru|pb@rr@d@@ @end|ng |rom @@po@pt  Sat May  8 21:02:32 2021
From: ru|pb@rr@d@@ @end|ng |rom @@po@pt (Rui Barradas)
Date: Sat, 8 May 2021 20:02:32 +0100
Subject: [R] grep
In-Reply-To: <95812983-6A72-4392-A293-43CF974E3FF7@dcn.davis.ca.us>
References: <b5f941cd-ce01-b60f-583a-2c7524e9e106@ntu.edu.tw>
 <95812983-6A72-4392-A293-43CF974E3FF7@dcn.davis.ca.us>
Message-ID: <2e7f26fa-cfc1-d3c8-7575-c03c4a32402d@sapo.pt>

Hello,

The pattern can be assembled with paste(., collapse = "|").
With the same vector of names, nms:


words <- c("black","conserv")
pattern <- paste(words, collapse = "|")
grep(pattern = pattern, nms, value = TRUE)
#[1] "x1.black"   "x1.conserv" "x2.black"   "x2.conserv"


Hope this helps,

Rui Barradas

?s 18:20 de 08/05/21, Jeff Newmiller escreveu:
> Regular expression patterns are not vectorized... only the data to be searched are. Use one of the many websites dedicated to tutoring regular expressions to learn how they work. (Using function names like "names" as data names is bad practice.)
> 
> nms <- c( "x1.one", "x1.black", "x1.othrrace", "x1.moddkna", "x1.conserv", "x1.nstrprty", "x1.strrep", "x1.sevngprt", "x2.one", "x2.black", "x2.othrrace", "x2.moddkna", "x2.conserv", "x2.nstrprty", "x2.strrep", "x2.sevngprt" )
> 
> grep( "black|conserv", nms, value = TRUE )
> 
> On May 8, 2021 10:00:12 AM PDT, Steven Yen <styen at ntu.edu.tw> wrote:
>> Below, the first command simply creates a list of 16 names (labels)
>> which can be ignore.
>>
>> In the 2nd and 3rd commands, I am able to identify names containing
>> "black".
>>
>> In line 4, I am trying to identify names containing "black" or
>> "conserv"
>> but obviously it does not work. Can someone help? Thanks.
>>
>>> names<-names(tp.nohs$estimate)[c(1:8,58:65)]; names
>>  ?[1] "x1.one"????? "x1.black"??? "x1.othrrace" "x1.moddkna"
>> "x1.conserv"? "x1.nstrprty"
>>  ?[7] "x1.strrep"?? "x1.sevngprt" "x2.one"????? "x2.black" "x2.othrrace"
>>
>> "x2.moddkna"
>> [13] "x2.conserv"? "x2.nstrprty" "x2.strrep"?? "x2.sevngprt"
>>> grep("black",names,value=TRUE)
>> [1] "x1.black" "x2.black"
>>> grep("black",names,value=FALSE)
>> [1]? 2 10
>>> grep(c("black","conserv"),names,value=TRUE)
>> [1] "x1.black" "x2.black"
>> Warning message:
>> In grep(c("black", "conserv"), names, value = TRUE) :
>>  ? argument 'pattern' has length > 1 and only the first element will be
>> used
>>
>> ______________________________________________
>> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> https://stat.ethz.ch/mailman/listinfo/r-help
>> PLEASE do read the posting guide
>> http://www.R-project.org/posting-guide.html
>> and provide commented, minimal, self-contained, reproducible code.
>


From hyun@ @end|ng |rom @nu@@c@kr  Sat May  8 12:05:12 2021
From: hyun@ @end|ng |rom @nu@@c@kr (Hyun Soo Park)
Date: Sat, 8 May 2021 19:05:12 +0900
Subject: [R] factor analysis of dynamic structure (FADS) for a huge
 time-series data
Message-ID: <CAPwByMzqdjTcQyf1c8sKkqOaQDSq=koT0NmuxQRXfdjwzMZHRw@mail.gmail.com>

Dear R users,

I want to find the latent factors from a kind of time-series data
describing temporal changes of concentration using a factor analysis
technique called 'factor analysis of dynamic structure (FADS).' I learned
how to form the data for the analysis using a proper package embedding
FADS, such as 'fad' package.

The analysis with 'fad' worked and gave me results, but the problem was
raised when the time-series data is vast.

The time-series data extracted from the 3-dimensional matrix (i.e., 3D
image volume of 50 x 50 x 163) repeatedly acquired at 54-time points is
consisted of 50 x 50 x 163 x 54 = 22,005,000 observations. The desired
number of the latent factor (k) is 4. What I got from fad(MATRIX, k) is
following:

Error in fun(A, k, nu, nv, opts, mattype = "matrix") :
  TridiagEigen: eigen decomposition failed

When I resize the matrix smaller into 5 x 5 x 15, it gives me what I wanted
properly.

I found that some resampling methods such as random sampling, data
stratification, etc., could resolve this kind of problem, but I have no
ideas which one could be appropriate.

Please teach me with any ideas and comments.

Thanks in advance,

Park

-- 
*??????, ?????????*
*????:*
(???) +82-31-787-2936
(????) +82-10-8833-2806
*??:* +82-31-787-4018
*???:* hyuns at snu.ac.kr

*Hyun Soo Park, PhD*
*--*
*Research professor*
Department of Nuclear Medicine
Seoul National University Bundang Hospital, Seongnam, Korea
*Telephone:*
(Office) +82-31-787-2936
(Mobile) +82-10-8833-2806
*Fax:* +82-31-787-4018
*email:* hyuns at snu.ac.kr

	[[alternative HTML version deleted]]


From jdnewm|| @end|ng |rom dcn@d@v|@@c@@u@  Sat May  8 23:00:42 2021
From: jdnewm|| @end|ng |rom dcn@d@v|@@c@@u@ (Jeff Newmiller)
Date: Sat, 08 May 2021 14:00:42 -0700
Subject: [R] factor analysis of dynamic structure (FADS) for a huge
 time-series data
In-Reply-To: <CAPwByMzqdjTcQyf1c8sKkqOaQDSq=koT0NmuxQRXfdjwzMZHRw@mail.gmail.com>
References: <CAPwByMzqdjTcQyf1c8sKkqOaQDSq=koT0NmuxQRXfdjwzMZHRw@mail.gmail.com>
Message-ID: <59BC5CB2-5AC0-4F34-95B7-48107A7FCB36@dcn.davis.ca.us>

This not being a question about R, but rather about statistics, or possibly about a contributed package, means (per the Posting Guide) that you should be asking in a statistics forum like stats.stackexchange.com or corresponding with the author of the package in question. If you are lucky someone here will have something to offer, but it is not very likely.

On May 8, 2021 3:05:12 AM PDT, Hyun Soo Park <hyuns at snu.ac.kr> wrote:
>Dear R users,
>
>I want to find the latent factors from a kind of time-series data
>describing temporal changes of concentration using a factor analysis
>technique called 'factor analysis of dynamic structure (FADS).' I
>learned
>how to form the data for the analysis using a proper package embedding
>FADS, such as 'fad' package.
>
>The analysis with 'fad' worked and gave me results, but the problem was
>raised when the time-series data is vast.
>
>The time-series data extracted from the 3-dimensional matrix (i.e., 3D
>image volume of 50 x 50 x 163) repeatedly acquired at 54-time points is
>consisted of 50 x 50 x 163 x 54 = 22,005,000 observations. The desired
>number of the latent factor (k) is 4. What I got from fad(MATRIX, k) is
>following:
>
>Error in fun(A, k, nu, nv, opts, mattype = "matrix") :
>  TridiagEigen: eigen decomposition failed
>
>When I resize the matrix smaller into 5 x 5 x 15, it gives me what I
>wanted
>properly.
>
>I found that some resampling methods such as random sampling, data
>stratification, etc., could resolve this kind of problem, but I have no
>ideas which one could be appropriate.
>
>Please teach me with any ideas and comments.
>
>Thanks in advance,
>
>Park

-- 
Sent from my phone. Please excuse my brevity.


From @tyen @end|ng |rom ntu@edu@tw  Sun May  9 03:54:43 2021
From: @tyen @end|ng |rom ntu@edu@tw (Steven Yen)
Date: Sun, 9 May 2021 09:54:43 +0800
Subject: [R] grep
In-Reply-To: <2e7f26fa-cfc1-d3c8-7575-c03c4a32402d@sapo.pt>
References: <b5f941cd-ce01-b60f-583a-2c7524e9e106@ntu.edu.tw>
 <95812983-6A72-4392-A293-43CF974E3FF7@dcn.davis.ca.us>
 <2e7f26fa-cfc1-d3c8-7575-c03c4a32402d@sapo.pt>
Message-ID: <26cf6075-2181-3b40-2b8a-5cc7b7631f17@ntu.edu.tw>

Thank to Rui, Jeff, and Bert. They are all very useful.
Somewhat related is the following, in which jindex is a numeric or 
alphanumeric vector in a function that starts with

try<-function(...., jindex=NA)

In the if loop, in the first line I am trying to determine whether the 
vector jindex is NA;
In the second line, I am trying to determine whether elements in vector 
jindex is are all non-numeric.

Not sure how so I tried to judge by the first element of jindex. Any 
better way? Thannks.

 ? if (!is.na(jindex[1])){?????? # like to improve this line
 ??? if(!is.numeric(jindex)[1]){ # like to improve this line
 ????? words? <-jindex
 ????? pattern<-paste(words,collapse="|")
 ????? jindex <-grep(pattern=pattern,x.label,value=FALSE)
 ??? }
 ??? jj<-jindex; x.label<-x.label[jj]
 ? }

On 2021/5/9 ?? 03:02, Rui Barradas wrote:
> Hello,
>
> The pattern can be assembled with paste(., collapse = "|").
> With the same vector of names, nms:
>
>
> words <- c("black","conserv")
> pattern <- paste(words, collapse = "|")
> grep(pattern = pattern, nms, value = TRUE)
> #[1] "x1.black"?? "x1.conserv" "x2.black"?? "x2.conserv"
>
>
> Hope this helps,
>
> Rui Barradas
>
> ?s 18:20 de 08/05/21, Jeff Newmiller escreveu:
>> Regular expression patterns are not vectorized... only the data to be 
>> searched are. Use one of the many websites dedicated to tutoring 
>> regular expressions to learn how they work. (Using function names 
>> like "names" as data names is bad practice.)
>>
>> nms <- c( "x1.one", "x1.black", "x1.othrrace", "x1.moddkna", 
>> "x1.conserv", "x1.nstrprty", "x1.strrep", "x1.sevngprt", "x2.one", 
>> "x2.black", "x2.othrrace", "x2.moddkna", "x2.conserv", "x2.nstrprty", 
>> "x2.strrep", "x2.sevngprt" )
>>
>> grep( "black|conserv", nms, value = TRUE )
>>
>> On May 8, 2021 10:00:12 AM PDT, Steven Yen <styen at ntu.edu.tw> wrote:
>>> Below, the first command simply creates a list of 16 names (labels)
>>> which can be ignore.
>>>
>>> In the 2nd and 3rd commands, I am able to identify names containing
>>> "black".
>>>
>>> In line 4, I am trying to identify names containing "black" or
>>> "conserv"
>>> but obviously it does not work. Can someone help? Thanks.
>>>
>>>> names<-names(tp.nohs$estimate)[c(1:8,58:65)]; names
>>> ??[1] "x1.one"????? "x1.black"??? "x1.othrrace" "x1.moddkna"
>>> "x1.conserv"? "x1.nstrprty"
>>> ??[7] "x1.strrep"?? "x1.sevngprt" "x2.one"????? "x2.black" 
>>> "x2.othrrace"
>>>
>>> "x2.moddkna"
>>> [13] "x2.conserv"? "x2.nstrprty" "x2.strrep"?? "x2.sevngprt"
>>>> grep("black",names,value=TRUE)
>>> [1] "x1.black" "x2.black"
>>>> grep("black",names,value=FALSE)
>>> [1]? 2 10
>>>> grep(c("black","conserv"),names,value=TRUE)
>>> [1] "x1.black" "x2.black"
>>> Warning message:
>>> In grep(c("black", "conserv"), names, value = TRUE) :
>>> ?? argument 'pattern' has length > 1 and only the first element will be
>>> used
>>>
>>> ______________________________________________
>>> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>>> https://stat.ethz.ch/mailman/listinfo/r-help
>>> PLEASE do read the posting guide
>>> http://www.R-project.org/posting-guide.html
>>> and provide commented, minimal, self-contained, reproducible code.
>>


From m@|tr@ @end|ng |rom em@||@com  Sun May  9 04:28:47 2021
From: m@|tr@ @end|ng |rom em@||@com (Ranjan Maitra)
Date: Sun, 9 May 2021 04:28:47 +0200
Subject: [R] factor analysis of dynamic structure (FADS) for a huge
 time-series data
In-Reply-To: <CAPwByMzqdjTcQyf1c8sKkqOaQDSq=koT0NmuxQRXfdjwzMZHRw@mail.gmail.com>
References: <CAPwByMzqdjTcQyf1c8sKkqOaQDSq=koT0NmuxQRXfdjwzMZHRw@mail.gmail.com>
Message-ID: <trinity-b7063bb7-7fc1-446e-9d63-04017802f369-1620527327464@3c-app-mailcom-lxa11>

I am an author of the paper behind the fad package. I suspect that the call is not correct. Actually, fad does not quite account for time series or other structured data and you have to enter it, as in all general EFA packages as a n x p matrix, with n the number of observations and p the number of coordinates.
 
So, if you can provide a reproducible example, I can look into it, or you can also file an issue on the github site.
 
One thing to note that EFA requires all variances in the dispersion matrix to be positive, and it is possible that your images have some background where there is no activity and hence the sd for those pixel/voxels are zero. 

Of course, ideally, your EFA should account for the image structure, but that is a different topic and not part of fad or any similar package.

Ranjan

PS: I monitor this e-mail address only through this list.
 

?
?
?

Sent:?Saturday, May 08, 2021 at 5:05 AM
From:?"Hyun Soo Park" <hyuns at snu.ac.kr>
To:?"r-help at r-project.org" <r-help at r-project.org>
Subject:?[R] factor analysis of dynamic structure (FADS) for a huge time-series data
Dear R users,

I want to find the latent factors from a kind of time-series data
describing temporal changes of concentration using a factor analysis
technique called 'factor analysis of dynamic structure (FADS).' I learned
how to form the data for the analysis using a proper package embedding
FADS, such as 'fad' package.

The analysis with 'fad' worked and gave me results, but the problem was
raised when the time-series data is vast.

The time-series data extracted from the 3-dimensional matrix (i.e., 3D
image volume of 50 x 50 x 163) repeatedly acquired at 54-time points is
consisted of 50 x 50 x 163 x 54 = 22,005,000 observations. The desired
number of the latent factor (k) is 4. What I got from fad(MATRIX, k) is
following:

Error in fun(A, k, nu, nv, opts, mattype = "matrix") :
TridiagEigen: eigen decomposition failed

When I resize the matrix smaller into 5 x 5 x 15, it gives me what I wanted
properly.

I found that some resampling methods such as random sampling, data
stratification, etc., could resolve this kind of problem, but I have no
ideas which one could be appropriate.

Please teach me with any ideas and comments.

Thanks in advance,

Park

--
*??????, ?????????*
*????:*
(???) +82-31-787-2936
(????) +82-10-8833-2806
*??:* +82-31-787-4018
*???:* hyuns at snu.ac.kr

*Hyun Soo Park, PhD*
*--*
*Research professor*
Department of Nuclear Medicine
Seoul National University Bundang Hospital, Seongnam, Korea
*Telephone:*
(Office) +82-31-787-2936
(Mobile) +82-10-8833-2806
*Fax:* +82-31-787-4018
*email:* hyuns at snu.ac.kr

[[alternative HTML version deleted]]

______________________________________________
R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
https://stat.ethz.ch/mailman/listinfo/r-help
PLEASE do read the posting guide http://www.R-project.org/posting-guide.html[http://www.R-project.org/posting-guide.html]
and provide commented, minimal, self-contained, reproducible code.


From ru|pb@rr@d@@ @end|ng |rom @@po@pt  Sun May  9 08:41:17 2021
From: ru|pb@rr@d@@ @end|ng |rom @@po@pt (Rui Barradas)
Date: Sun, 9 May 2021 07:41:17 +0100
Subject: [R] grep
In-Reply-To: <26cf6075-2181-3b40-2b8a-5cc7b7631f17@ntu.edu.tw>
References: <b5f941cd-ce01-b60f-583a-2c7524e9e106@ntu.edu.tw>
 <95812983-6A72-4392-A293-43CF974E3FF7@dcn.davis.ca.us>
 <2e7f26fa-cfc1-d3c8-7575-c03c4a32402d@sapo.pt>
 <26cf6075-2181-3b40-2b8a-5cc7b7631f17@ntu.edu.tw>
Message-ID: <a54e605e-87cb-c15e-9b4f-1035f6b56c87@sapo.pt>

Hello,

Maybe instead of a loop, vectorize with logical indices.


i1 <- is.na(jindex)
i2 <- is.numeric(jindex)
if(any(!i1)){
   if(any(!i2)){
     words <- jindex[!i1 & !i2]
     pattern <- paste(words, collapse = "|")
     jindex <- grep(pattern = pattern, x.label, value = FALSE)
   }
   jj <- jindex[!i1]
   x.label <- x.label[jj]
}


Or even simpler

if(any(!i1 & !i2)){
   words <- jindex[!i1 & !i2]
   pattern <- paste(words, collapse = "|")
   jindex <- grep(pattern = pattern, x.label, value = FALSE)
   jj <- jindex[!i1]
   x.label <- x.label[jj]
}


Hope this helps,

Rui Barradas

?s 02:54 de 09/05/21, Steven Yen escreveu:
> Thank to Rui, Jeff, and Bert. They are all very useful.
> Somewhat related is the following, in which jindex is a numeric or 
> alphanumeric vector in a function that starts with
> 
> try<-function(...., jindex=NA)
> 
> In the if loop, in the first line I am trying to determine whether the 
> vector jindex is NA;
> In the second line, I am trying to determine whether elements in vector 
> jindex is are all non-numeric.
> 
> Not sure how so I tried to judge by the first element of jindex. Any 
> better way? Thannks.
> 
>  ? if (!is.na(jindex[1])){?????? # like to improve this line
>  ??? if(!is.numeric(jindex)[1]){ # like to improve this line
>  ????? words? <-jindex
>  ????? pattern<-paste(words,collapse="|")
>  ????? jindex <-grep(pattern=pattern,x.label,value=FALSE)
>  ??? }
>  ??? jj<-jindex; x.label<-x.label[jj]
>  ? }
> 
> On 2021/5/9 ?? 03:02, Rui Barradas wrote:
>> Hello,
>>
>> The pattern can be assembled with paste(., collapse = "|").
>> With the same vector of names, nms:
>>
>>
>> words <- c("black","conserv")
>> pattern <- paste(words, collapse = "|")
>> grep(pattern = pattern, nms, value = TRUE)
>> #[1] "x1.black"?? "x1.conserv" "x2.black"?? "x2.conserv"
>>
>>
>> Hope this helps,
>>
>> Rui Barradas
>>
>> ?s 18:20 de 08/05/21, Jeff Newmiller escreveu:
>>> Regular expression patterns are not vectorized... only the data to be 
>>> searched are. Use one of the many websites dedicated to tutoring 
>>> regular expressions to learn how they work. (Using function names 
>>> like "names" as data names is bad practice.)
>>>
>>> nms <- c( "x1.one", "x1.black", "x1.othrrace", "x1.moddkna", 
>>> "x1.conserv", "x1.nstrprty", "x1.strrep", "x1.sevngprt", "x2.one", 
>>> "x2.black", "x2.othrrace", "x2.moddkna", "x2.conserv", "x2.nstrprty", 
>>> "x2.strrep", "x2.sevngprt" )
>>>
>>> grep( "black|conserv", nms, value = TRUE )
>>>
>>> On May 8, 2021 10:00:12 AM PDT, Steven Yen <styen at ntu.edu.tw> wrote:
>>>> Below, the first command simply creates a list of 16 names (labels)
>>>> which can be ignore.
>>>>
>>>> In the 2nd and 3rd commands, I am able to identify names containing
>>>> "black".
>>>>
>>>> In line 4, I am trying to identify names containing "black" or
>>>> "conserv"
>>>> but obviously it does not work. Can someone help? Thanks.
>>>>
>>>>> names<-names(tp.nohs$estimate)[c(1:8,58:65)]; names
>>>> ??[1] "x1.one"????? "x1.black"??? "x1.othrrace" "x1.moddkna"
>>>> "x1.conserv"? "x1.nstrprty"
>>>> ??[7] "x1.strrep"?? "x1.sevngprt" "x2.one"????? "x2.black" 
>>>> "x2.othrrace"
>>>>
>>>> "x2.moddkna"
>>>> [13] "x2.conserv"? "x2.nstrprty" "x2.strrep"?? "x2.sevngprt"
>>>>> grep("black",names,value=TRUE)
>>>> [1] "x1.black" "x2.black"
>>>>> grep("black",names,value=FALSE)
>>>> [1]? 2 10
>>>>> grep(c("black","conserv"),names,value=TRUE)
>>>> [1] "x1.black" "x2.black"
>>>> Warning message:
>>>> In grep(c("black", "conserv"), names, value = TRUE) :
>>>> ?? argument 'pattern' has length > 1 and only the first element will be
>>>> used
>>>>
>>>> ______________________________________________
>>>> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>>>> https://stat.ethz.ch/mailman/listinfo/r-help
>>>> PLEASE do read the posting guide
>>>> http://www.R-project.org/posting-guide.html
>>>> and provide commented, minimal, self-contained, reproducible code.
>>>


From hyun@ @end|ng |rom @nu@@c@kr  Sun May  9 03:41:43 2021
From: hyun@ @end|ng |rom @nu@@c@kr (Hyun Soo Park)
Date: Sun, 9 May 2021 10:41:43 +0900
Subject: [R] factor analysis of dynamic structure (FADS) for a huge
 time-series data
In-Reply-To: <59BC5CB2-5AC0-4F34-95B7-48107A7FCB36@dcn.davis.ca.us>
References: <CAPwByMzqdjTcQyf1c8sKkqOaQDSq=koT0NmuxQRXfdjwzMZHRw@mail.gmail.com>
 <59BC5CB2-5AC0-4F34-95B7-48107A7FCB36@dcn.davis.ca.us>
Message-ID: <CAPwByMx5xpPip+88D_MFXJyhAE9snw-XhVjtXPEUZL2Rn2wRMg@mail.gmail.com>

Dear Newmiller,

Thank  you for your reply. I?ve just posted the same question in the
another forum for stats as you suggested.

Meanwhile, I would like to keep the question submitted to learn from R
users, if it is available .

Park

On Sun, May 9, 2021 at 6:01 AM Jeff Newmiller <jdnewmil at dcn.davis.ca.us>
wrote:

> This not being a question about R, but rather about statistics, or
> possibly about a contributed package, means (per the Posting Guide) that
> you should be asking in a statistics forum like stats.stackexchange.com
> or corresponding with the author of the package in question. If you are
> lucky someone here will have something to offer, but it is not very likely.
>
> On May 8, 2021 3:05:12 AM PDT, Hyun Soo Park <hyuns at snu.ac.kr> wrote:
> >Dear R users,
> >
> >I want to find the latent factors from a kind of time-series data
> >describing temporal changes of concentration using a factor analysis
> >technique called 'factor analysis of dynamic structure (FADS).' I
> >learned
> >how to form the data for the analysis using a proper package embedding
> >FADS, such as 'fad' package.
> >
> >The analysis with 'fad' worked and gave me results, but the problem was
> >raised when the time-series data is vast.
> >
> >The time-series data extracted from the 3-dimensional matrix (i.e., 3D
> >image volume of 50 x 50 x 163) repeatedly acquired at 54-time points is
> >consisted of 50 x 50 x 163 x 54 = 22,005,000 observations. The desired
> >number of the latent factor (k) is 4. What I got from fad(MATRIX, k) is
> >following:
> >
> >Error in fun(A, k, nu, nv, opts, mattype = "matrix") :
> >  TridiagEigen: eigen decomposition failed
> >
> >When I resize the matrix smaller into 5 x 5 x 15, it gives me what I
> >wanted
> >properly.
> >
> >I found that some resampling methods such as random sampling, data
> >stratification, etc., could resolve this kind of problem, but I have no
> >ideas which one could be appropriate.
> >
> >Please teach me with any ideas and comments.
> >
> >Thanks in advance,
> >
> >Park
>
> --
> Sent from my phone. Please excuse my brevity.
>
-- 
*??????, ?????????*
*????:*
(???) +82-31-787-2936
(????) +82-10-8833-2806
*??:* +82-31-787-4018
*???:* hyuns at snu.ac.kr

*Hyun Soo Park, PhD*
*--*
*Research professor*
Department of Nuclear Medicine
Seoul National University Bundang Hospital, Seongnam, Korea
*Telephone:*
(Office) +82-31-787-2936
(Mobile) +82-10-8833-2806
*Fax:* +82-31-787-4018
*email:* hyuns at snu.ac.kr

	[[alternative HTML version deleted]]


From v@r|n@@ch@ @end|ng |rom y@hoo@|r  Sun May  9 20:39:32 2021
From: v@r|n@@ch@ @end|ng |rom y@hoo@|r (varin sacha)
Date: Sun, 9 May 2021 18:39:32 +0000 (UTC)
Subject: [R] No error message but don't get the 8 graphs
References: <294893856.3283193.1620585572644.ref@mail.yahoo.com>
Message-ID: <294893856.3283193.1620585572644@mail.yahoo.com>

Dear R-experts,

I am trying to get the 8 graphs like the ones in this paper : 
https://statweb.stanford.edu/~tibs/reshef/comment.pdf 
My R code does not show any error message neither warnings but I d'on't get what I would like to get (I mean the 8 graphs), so I am missing something. What's it ? Many thanks for your precious help.

#################
set.seed(1)
library(energy) 

# Here we define parameters which we use to simulate the data?
# The number of null datasets we use to estimate our rejection reject #regions for an alternative with level 0.05
nsim=50 

# Number of alternative datasets we use to estimate our power
nsim2=50

# The number of different noise levels used
num.noise <- 30????????????????????

# A constant to determine the amount of noise
noise <- 3? 

# Number of data points per simulation
n=100

# Vectors holding the null "correlations" (for pearson, for spearman, for kendall and dcor respectively) for each # of the nsim null datasets at a #given noise level
val.cor=val.cors=val.cork=val.dcor=rep(NA,nsim)

# Vectors holding the alternative "correlations" (for pearson, for #spearman, for kendall and dcor respectively) #for each of the nsim2 alternative datasets at a given noise level
val.cor2=val.cors2=val.cork2=val.dcor2= rep(NA,nsim2)
?

# Arrays holding the estimated power for each of the 4 "correlation" types, for each data type (linear, #parabolic, etc...) with each noise level
power.cor=power.cors=power.cork=power.dcor= array(NA, c(8,num.noise))

## We loop through the noise level and functional form; each time we #estimate a null distribution based on #the marginals of the data, and then #use that null distribution to estimate power 
## We use a uniformly distributed x, because in the original paper the #authors used the same

for(l in 1:num.noise) {??

????? for(typ in 1:8) {

## This next loop simulates data under the null with the correct marginals (x is uniform, and y is a function of a #uniform with gaussian noise)

??? for(ii in 1:nsim) {?????? 
????? x=runif(n)

#lin+noise??????????????????????????????????????????????????????? 
if(typ==1) {??????? 
y=x+ noise *(l/num.noise)* rnorm(n)??????
}

#parabolic+noise
if(typ==2) {??????? 
y=4*(x-.5)^2+? noise * (l/num.noise) * rnorm(n)????? 
}

#cubic+noise
if(typ==3) {??????? 
y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise? * (l/num.noise) *rnorm(n)????? 
}

#sin+noise
if(typ==4) {??????? 
y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)????? 
}

#their sine + noise
if(typ==5) {??????? 
y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)????? 
}

#x^(1/4) + noise
if(typ==6) {??????? 
y=x^(1/4) + noise * (l/num.noise) *rnorm(n)????? 
}

#circle
if(typ==7) {??????? 
y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise *rnorm(n)????? 
}

#step function
if(typ==8) {??????? 
y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)????? 
}??????

# We resimulate x so that we have the null scenario
x <- runif(n)

# Calculate the 4 correlations????? ??????
val.cor[ii]=(cor(x,y))
val.cors[ii]=(cor(x,y,method=c("spearman")))
val.cork[ii]=(cor(x,y,method=c("kendal")))
val.dcor[ii]=dcor(x,y)??? ?????????
}

## Next we calculate our 4 rejection cutoffs???????? 
cut.cor=quantile(val.cor,.95) ??? 
cut.cors=quantile(val.cors,.95)
cut.cork=quantile(val.cork,.95)
cut.dcor=quantile(val.dcor,.95)

## Next we simulate the data again, this time under the alternative

??? for(ii in 1:nsim2) {?????? 
????? x=runif(n)

#lin+noise??????????????????????????????????????????????????????? 
if(typ==1) {??????? 
y=x+ noise *(l/num.noise)* rnorm(n)????? 
}

#parabolic+noise
if(typ==2) {??????? 
y=4*(x-.5)^2+? noise * (l/num.noise) * rnorm(n)????? 
}

#cubic+noise
if(typ==3) {??????? 
y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise? * (l/num.noise) *rnorm(n)????? 
}

#sin+noise
if(typ==4) {??????? 
y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)????? 
}

#their sine + noise
if(typ==5) {??????? 
y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)????? 
}

#x^(1/4) + noise
if(typ==6) {??????? 
y=x^(1/4) + noise * (l/num.noise) *rnorm(n)????? 
}

#circle
if(typ==7) {??????? 
y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise *rnorm(n)????? 
}

#step function
if(typ==8) {??????? 
y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)????? 
}??????

## We again calculate our 4 "correlations"????????????? 
val.cor2[ii]=(cor(x,y))????? 
val.cors2[ii]=(cor(x,y,method=c("spearman")))
val.cork2[ii]=(cor(x,y,method=c("kendal")))
val.dcor2[ii]=dcor(x,y)?????????????? 
}

## Now we estimate the power as the number of alternative statistics #exceeding our estimated cutoffs???????? 
power.cor[typ,l] <- sum(val.cor2 > cut.cor)/nsim2??? 
power.cors[typ,l] <- sum(val.cors2 > cut.cor)/nsim2
power.cork[typ,l] <- sum(val.cork2 > cut.cor)/nsim2
power.dcor[typ,l] <- sum(val.dcor2 > cut.dcor)/nsim2???????
}
}

save.image()?

## The rest of the code is for plotting the image 
pdf("power.pdf")
par(mfrow = c(4,2), cex = 0.45)
plot((1:30)/10, power.cor[1,], ylim = c(0,1), main = "Linear", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
points((1:30)/10, power.cors[1,], pch = 2, col = "green", type = 'b')
points((1:30)/10, power.cork[1,], pch = 3, col = "blue", type = 'b')
points((1:30)/10, power.dcor[1,], pch = 4, col = "red", type = 'b')
legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))

plot((1:30)/10, power.cor[2,], ylim = c(0,1), main = "Quadratic", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
points((1:30)/10, power.cors[2,], pch = 2, col = "green", type = 'b')
points((1:30)/10, power.cork[2,], pch = 3, col = "blue", type = 'b')
points((1:30)/10, power.dcor[2,], pch = 4, col = "red", type = 'b')
legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))

plot((1:30)/10, power.cor[3,], ylim = c(0,1), main = "Cubic", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
points((1:30)/10, power.cors[3,], pch = 2, col = "green", type = 'b')
points((1:30)/10, power.cork[3,], pch = 3, col = "blue", type = 'b')
points((1:30)/10, power.dcor[3,], pch = 4, col = "red", type = 'b')
legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))

plot((1:30)/10, power.cor[5,], ylim = c(0,1), main = "Sine: period 1/8", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
points((1:30)/10, power.cors[5,], pch = 2, col = "green", type = 'b')
points((1:30)/10, power.cork[5,], pch = 3, col = "blue", type = 'b')
points((1:30)/10, power.dcor[5,], pch = 4, col = "red", type = 'b')
legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))

plot((1:30)/10, power.cor[4,], ylim = c(0,1), main = "Sine: period 1/2", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
points((1:30)/10, power.cors[4,], pch = 2, col = "green", type = 'b')
points((1:30)/10, power.cork[4,], pch = 3, col = "blue", type = 'b')
points((1:30)/10, power.dcor[4,], pch = 4, col = "red", type = 'b')
legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))

plot((1:30)/10, power.cor[6,], ylim = c(0,1), main = "X^(1/4)", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
points((1:30)/10, power.cors[6,], pch = 2, col = "green", type = 'b')
points((1:30)/10, power.cork[6,], pch = 3, col = "blue", type = 'b')
points((1:30)/10, power.dcor[6,], pch = 4, col = "red", type = 'b')
legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))

plot((1:30)/10, power.cor[7,], ylim = c(0,1), main = "Circle", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
points((1:30)/10, power.cors[7,], pch = 2, col = "green", type = 'b')
points((1:30)/10, power.cork[7,], pch = 3, col = "blue", type = 'b')
points((1:30)/10, power.dcor[7,], pch = 4, col = "red", type = 'b')
legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))

plot((1:30)/10, power.cor[8,], ylim = c(0,1), main = "Step function", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
points((1:30)/10, power.cors[8,], pch = 2, col = "green", type = 'b')
points((1:30)/10, power.cork[8,], pch = 3, col = "blue", type = 'b')
points((1:30)/10, power.dcor[8,], pch = 4, col = "red", type = 'b')
legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))

#################


From ru|pb@rr@d@@ @end|ng |rom @@po@pt  Sun May  9 22:44:19 2021
From: ru|pb@rr@d@@ @end|ng |rom @@po@pt (Rui Barradas)
Date: Sun, 9 May 2021 21:44:19 +0100
Subject: [R] No error message but don't get the 8 graphs
In-Reply-To: <294893856.3283193.1620585572644@mail.yahoo.com>
References: <294893856.3283193.1620585572644.ref@mail.yahoo.com>
 <294893856.3283193.1620585572644@mail.yahoo.com>
Message-ID: <b9186679-16a2-d6e4-afac-eecebbba7e01@sapo.pt>

Hello,

You are not closing the pdf device.
The only changes I have made to your code are right at the beginning of 
the plotting instructions and at the end of the code.


## The rest of the code is for plotting the image
pdf(file = "power.pdf")
op <- par(mfrow = c(4,2), cex = 0.45)

[...]

par(op)
dev.off()
#################

The comments only line is your last code line.
The result is attached.

Hope this helps,

Rui Barradas

?s 19:39 de 09/05/21, varin sacha via R-help escreveu:
> Dear R-experts,
> 
> I am trying to get the 8 graphs like the ones in this paper :
> https://statweb.stanford.edu/~tibs/reshef/comment.pdf
> My R code does not show any error message neither warnings but I d'on't get what I would like to get (I mean the 8 graphs), so I am missing something. What's it ? Many thanks for your precious help.
> 
> #################
> set.seed(1)
> library(energy)
> 
> # Here we define parameters which we use to simulate the data
> # The number of null datasets we use to estimate our rejection reject #regions for an alternative with level 0.05
> nsim=50
> 
> # Number of alternative datasets we use to estimate our power
> nsim2=50
> 
> # The number of different noise levels used
> num.noise <- 30
> 
> # A constant to determine the amount of noise
> noise <- 3
> 
> # Number of data points per simulation
> n=100
> 
> # Vectors holding the null "correlations" (for pearson, for spearman, for kendall and dcor respectively) for each # of the nsim null datasets at a #given noise level
> val.cor=val.cors=val.cork=val.dcor=rep(NA,nsim)
> 
> # Vectors holding the alternative "correlations" (for pearson, for #spearman, for kendall and dcor respectively) #for each of the nsim2 alternative datasets at a given noise level
> val.cor2=val.cors2=val.cork2=val.dcor2= rep(NA,nsim2)
>   
> 
> # Arrays holding the estimated power for each of the 4 "correlation" types, for each data type (linear, #parabolic, etc...) with each noise level
> power.cor=power.cors=power.cork=power.dcor= array(NA, c(8,num.noise))
> 
> ## We loop through the noise level and functional form; each time we #estimate a null distribution based on #the marginals of the data, and then #use that null distribution to estimate power
> ## We use a uniformly distributed x, because in the original paper the #authors used the same
> 
> for(l in 1:num.noise) {
> 
>  ????? for(typ in 1:8) {
> 
> ## This next loop simulates data under the null with the correct marginals (x is uniform, and y is a function of a #uniform with gaussian noise)
> 
>  ??? for(ii in 1:nsim) {
>  ????? x=runif(n)
> 
> #lin+noise
> if(typ==1) {
> y=x+ noise *(l/num.noise)* rnorm(n)
> }
> 
> #parabolic+noise
> if(typ==2) {
> y=4*(x-.5)^2+? noise * (l/num.noise) * rnorm(n)
> }
> 
> #cubic+noise
> if(typ==3) {
> y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise? * (l/num.noise) *rnorm(n)
> }
> 
> #sin+noise
> if(typ==4) {
> y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
> }
> 
> #their sine + noise
> if(typ==5) {
> y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
> }
> 
> #x^(1/4) + noise
> if(typ==6) {
> y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
> }
> 
> #circle
> if(typ==7) {
> y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise *rnorm(n)
> }
> 
> #step function
> if(typ==8) {
> y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
> }
> 
> # We resimulate x so that we have the null scenario
> x <- runif(n)
> 
> # Calculate the 4 correlations
> val.cor[ii]=(cor(x,y))
> val.cors[ii]=(cor(x,y,method=c("spearman")))
> val.cork[ii]=(cor(x,y,method=c("kendal")))
> val.dcor[ii]=dcor(x,y)
> }
> 
> ## Next we calculate our 4 rejection cutoffs
> cut.cor=quantile(val.cor,.95)
> cut.cors=quantile(val.cors,.95)
> cut.cork=quantile(val.cork,.95)
> cut.dcor=quantile(val.dcor,.95)
> 
> ## Next we simulate the data again, this time under the alternative
> 
>  ??? for(ii in 1:nsim2) {
>  ????? x=runif(n)
> 
> #lin+noise
> if(typ==1) {
> y=x+ noise *(l/num.noise)* rnorm(n)
> }
> 
> #parabolic+noise
> if(typ==2) {
> y=4*(x-.5)^2+? noise * (l/num.noise) * rnorm(n)
> }
> 
> #cubic+noise
> if(typ==3) {
> y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise? * (l/num.noise) *rnorm(n)
> }
> 
> #sin+noise
> if(typ==4) {
> y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
> }
> 
> #their sine + noise
> if(typ==5) {
> y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
> }
> 
> #x^(1/4) + noise
> if(typ==6) {
> y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
> }
> 
> #circle
> if(typ==7) {
> y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise *rnorm(n)
> }
> 
> #step function
> if(typ==8) {
> y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
> }
> 
> ## We again calculate our 4 "correlations"
> val.cor2[ii]=(cor(x,y))
> val.cors2[ii]=(cor(x,y,method=c("spearman")))
> val.cork2[ii]=(cor(x,y,method=c("kendal")))
> val.dcor2[ii]=dcor(x,y)
> }
> 
> ## Now we estimate the power as the number of alternative statistics #exceeding our estimated cutoffs
> power.cor[typ,l] <- sum(val.cor2 > cut.cor)/nsim2
> power.cors[typ,l] <- sum(val.cors2 > cut.cor)/nsim2
> power.cork[typ,l] <- sum(val.cork2 > cut.cor)/nsim2
> power.dcor[typ,l] <- sum(val.dcor2 > cut.dcor)/nsim2
> }
> }
> 
> save.image()
> 
> ## The rest of the code is for plotting the image
> pdf("power.pdf")
> par(mfrow = c(4,2), cex = 0.45)
> plot((1:30)/10, power.cor[1,], ylim = c(0,1), main = "Linear", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[1,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[1,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[1,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
> 
> plot((1:30)/10, power.cor[2,], ylim = c(0,1), main = "Quadratic", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[2,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[2,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[2,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
> 
> plot((1:30)/10, power.cor[3,], ylim = c(0,1), main = "Cubic", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[3,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[3,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[3,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
> 
> plot((1:30)/10, power.cor[5,], ylim = c(0,1), main = "Sine: period 1/8", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[5,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[5,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[5,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
> 
> plot((1:30)/10, power.cor[4,], ylim = c(0,1), main = "Sine: period 1/2", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[4,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[4,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[4,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
> 
> plot((1:30)/10, power.cor[6,], ylim = c(0,1), main = "X^(1/4)", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[6,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[6,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[6,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
> 
> plot((1:30)/10, power.cor[7,], ylim = c(0,1), main = "Circle", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[7,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[7,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[7,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
> 
> plot((1:30)/10, power.cor[8,], ylim = c(0,1), main = "Step function", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[8,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[8,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[8,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
> 
> #################
> 
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
> 

-------------- next part --------------
A non-text attachment was scrubbed...
Name: power.pdf
Type: application/pdf
Size: 44649 bytes
Desc: not available
URL: <https://stat.ethz.ch/pipermail/r-help/attachments/20210509/a24b613f/attachment.pdf>

From v@r|n@@ch@ @end|ng |rom y@hoo@|r  Sun May  9 23:27:29 2021
From: v@r|n@@ch@ @end|ng |rom y@hoo@|r (varin sacha)
Date: Sun, 9 May 2021 21:27:29 +0000 (UTC)
Subject: [R] No error message but don't get the 8 graphs
In-Reply-To: <b9186679-16a2-d6e4-afac-eecebbba7e01@sapo.pt>
References: <294893856.3283193.1620585572644.ref@mail.yahoo.com>
 <294893856.3283193.1620585572644@mail.yahoo.com>
 <b9186679-16a2-d6e4-afac-eecebbba7e01@sapo.pt>
Message-ID: <928869154.3343817.1620595649281@mail.yahoo.com>

Dear Rui,

I thank you for your response but when I run the code with your few modifications, I still don't get the 8 graphs but I get the following answer :

null device
????????? 1

Here below my R code with your modifications. I don't know what I am still missing ? 

##############
set.seed(1)
library(energy)

# Here we define parameters which we use to simulate the data 
# The number of null datasets we use to estimate our rejection reject #regions for an alternative with level 0.05
nsim=50 

# Number of alternative datasets we use to estimate our power
nsim2=50

# The number of different noise levels used
num.noise <- 30????????????????????

# A constant to determine the amount of noise
noise <- 3?

# Number of data points per simulation
n=100

# Vectors holding the null "correlations" (for pearson, for spearman, for kendall and dcor respectively) for each # of the nsim null datasets at a #given noise level
val.cor=val.cors=val.cork=val.dcor=rep(NA,nsim)

# Vectors holding the alternative "correlations" (for pearson, for #spearman, for kendall and dcor respectively) #for each of the nsim2 alternative datasets at a given noise level
val.cor2=val.cors2=val.cork2=val.dcor2= rep(NA,nsim2)

# Arrays holding the estimated power for each of the 4 "correlation" types, for each data type (linear, #parabolic, etc...) with each noise level
power.cor=power.cors=power.cork=power.dcor= array(NA, c(8,num.noise))

## We loop through the noise level and functional form; each time we #estimate a null distribution based on #the marginals of the data, and then #use that null distribution to estimate power
## We use a uniformly distributed x, because in the original paper the #authors used the same

for(l in 1:num.noise) {??

????? for(typ in 1:8) {

## This next loop simulates data under the null with the correct marginals (x is uniform, and y is a function of a #uniform with gaussian noise)

??? for(ii in 1:nsim) {????? 
????? x=runif(n)

#lin+noise?????????????????????????????????????????????????????? 
if(typ==1) {?????? 
y=x+ noise *(l/num.noise)* rnorm(n)????? 
}

#parabolic+noise
if(typ==2) {?????? 
y=4*(x-.5)^2+? noise * (l/num.noise) * rnorm(n)???? 
}

#cubic+noise
if(typ==3) {?????? 
y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise? * (l/num.noise) *rnorm(n)???? 
} 

#sin+noise
if(typ==4) {?????? 
y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)???? 
}

#their sine + noise
if(typ==5) {?????? 
y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)???? 
}

#x^(1/4) + noise
if(typ==6) {?????? 
y=x^(1/4) + noise * (l/num.noise) *rnorm(n)???? 
}

#circle
if(typ==7) {?????? 
y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise *rnorm(n)???? 
}

#step function
if(typ==8) {?????? 
y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)???? 
}??????

?
# We resimulate x so that we have the null scenario
x <- runif(n)

# Calculate the 4 correlations????? ????? 
val.cor[ii]=(cor(x,y))
val.cors[ii]=(cor(x,y,method=c("spearman")))
val.cork[ii]=(cor(x,y,method=c("kendal")))
val.dcor[ii]=dcor(x,y)??? ?????????
}

## Next we calculate our 4 rejection cutoffs??????? 
cut.cor=quantile(val.cor,.95) ?? 
cut.cors=quantile(val.cors,.95)
cut.cork=quantile(val.cork,.95)
cut.dcor=quantile(val.dcor,.95)

## Next we simulate the data again, this time under the alternative

??? for(ii in 1:nsim2) {????? 
????? x=runif(n)

#lin+noise?????????????????????????????????????????????????????? 
if(typ==1) {?????? 
y=x+ noise *(l/num.noise)* rnorm(n)???? 
} 

#parabolic+noise
if(typ==2) {?????? 
y=4*(x-.5)^2+? noise * (l/num.noise) * rnorm(n)???? 
}

#cubic+noise
if(typ==3) {?????? 
y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise? * (l/num.noise) *rnorm(n)???? 
}

#sin+noise
if(typ==4) {?????? 
y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)???? 
}

#their sine + noise
if(typ==5) {?????? 
y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)???? 
}

#x^(1/4) + noise
if(typ==6) {?????? 
y=x^(1/4) + noise * (l/num.noise) *rnorm(n)???? 
}

#circle
if(typ==7) {?????? 
y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise *rnorm(n)???? 
}

#step function
if(typ==8) {?????? 
y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)???? 
}??????

## We again calculate our 4 "correlations"???????????? 
val.cor2[ii]=(cor(x,y))???? 
val.cors2[ii]=(cor(x,y,method=c("spearman")))
val.cork2[ii]=(cor(x,y,method=c("kendal")))
val.dcor2[ii]=dcor(x,y)??????????????
}

## Now we estimate the power as the number of alternative statistics #exceeding our estimated cutoffs??????? 
power.cor[typ,l] <- sum(val.cor2 > cut.cor)/nsim2?? 
power.cors[typ,l] <- sum(val.cors2 > cut.cor)/nsim2
power.cork[typ,l] <- sum(val.cork2 > cut.cor)/nsim2
power.dcor[typ,l] <- sum(val.dcor2 > cut.dcor)/nsim2???????
}
}

save.image()?

## The rest of the code is for plotting the image
pdf(file = "power.pdf")
op <- par(mfrow = c(4,2), cex = 0.45)
plot((1:30)/10, power.cor[1,], ylim = c(0,1), main = "Linear", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
points((1:30)/10, power.cors[1,], pch = 2, col = "green", type = 'b')
points((1:30)/10, power.cork[1,], pch = 3, col = "blue", type = 'b')
points((1:30)/10, power.dcor[1,], pch = 4, col = "red", type = 'b')
legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))

?plot((1:30)/10, power.cor[2,], ylim = c(0,1), main = "Quadratic", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
points((1:30)/10, power.cors[2,], pch = 2, col = "green", type = 'b')
points((1:30)/10, power.cork[2,], pch = 3, col = "blue", type = 'b')
points((1:30)/10, power.dcor[2,], pch = 4, col = "red", type = 'b')
legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))

?plot((1:30)/10, power.cor[3,], ylim = c(0,1), main = "Cubic", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
points((1:30)/10, power.cors[3,], pch = 2, col = "green", type = 'b')
points((1:30)/10, power.cork[3,], pch = 3, col = "blue", type = 'b')
points((1:30)/10, power.dcor[3,], pch = 4, col = "red", type = 'b')
legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))

plot((1:30)/10, power.cor[5,], ylim = c(0,1), main = "Sine: period 1/8", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
points((1:30)/10, power.cors[5,], pch = 2, col = "green", type = 'b')
points((1:30)/10, power.cork[5,], pch = 3, col = "blue", type = 'b')
points((1:30)/10, power.dcor[5,], pch = 4, col = "red", type = 'b')
legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))

plot((1:30)/10, power.cor[4,], ylim = c(0,1), main = "Sine: period 1/2", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
points((1:30)/10, power.cors[4,], pch = 2, col = "green", type = 'b')
points((1:30)/10, power.cork[4,], pch = 3, col = "blue", type = 'b')
points((1:30)/10, power.dcor[4,], pch = 4, col = "red", type = 'b')
legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))

plot((1:30)/10, power.cor[6,], ylim = c(0,1), main = "X^(1/4)", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
points((1:30)/10, power.cors[6,], pch = 2, col = "green", type = 'b')
points((1:30)/10, power.cork[6,], pch = 3, col = "blue", type = 'b')
points((1:30)/10, power.dcor[6,], pch = 4, col = "red", type = 'b')
legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))

plot((1:30)/10, power.cor[7,], ylim = c(0,1), main = "Circle", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
points((1:30)/10, power.cors[7,], pch = 2, col = "green", type = 'b')
points((1:30)/10, power.cork[7,], pch = 3, col = "blue", type = 'b')
points((1:30)/10, power.dcor[7,], pch = 4, col = "red", type = 'b')
legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))

plot((1:30)/10, power.cor[8,], ylim = c(0,1), main = "Step function", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
points((1:30)/10, power.cors[8,], pch = 2, col = "green", type = 'b')
points((1:30)/10, power.cork[8,], pch = 3, col = "blue", type = 'b')
points((1:30)/10, power.dcor[8,], pch = 4, col = "red", type = 'b')
legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
par(op)
dev.off()
#################







Le dimanche 9 mai 2021 ? 22:44:22 UTC+2, Rui Barradas <ruipbarradas at sapo.pt> a ?crit : 





Hello,

You are not closing the pdf device.
The only changes I have made to your code are right at the beginning of 
the plotting instructions and at the end of the code.


## The rest of the code is for plotting the image
pdf(file = "power.pdf")
op <- par(mfrow = c(4,2), cex = 0.45)

[...]

par(op)
dev.off()
#################

The comments only line is your last code line.
The result is attached.

Hope this helps,

Rui Barradas

?s 19:39 de 09/05/21, varin sacha via R-help escreveu:
> Dear R-experts,
> 
> I am trying to get the 8 graphs like the ones in this paper :
> https://statweb.stanford.edu/~tibs/reshef/comment.pdf
> My R code does not show any error message neither warnings but I d'on't get what I would like to get (I mean the 8 graphs), so I am missing something. What's it ? Many thanks for your precious help.
> 
> #################
> set.seed(1)
> library(energy)
> 
> # Here we define parameters which we use to simulate the data
> # The number of null datasets we use to estimate our rejection reject #regions for an alternative with level 0.05
> nsim=50
> 
> # Number of alternative datasets we use to estimate our power
> nsim2=50
> 
> # The number of different noise levels used
> num.noise <- 30
> 
> # A constant to determine the amount of noise
> noise <- 3
> 
> # Number of data points per simulation
> n=100
> 
> # Vectors holding the null "correlations" (for pearson, for spearman, for kendall and dcor respectively) for each # of the nsim null datasets at a #given noise level
> val.cor=val.cors=val.cork=val.dcor=rep(NA,nsim)
> 
> # Vectors holding the alternative "correlations" (for pearson, for #spearman, for kendall and dcor respectively) #for each of the nsim2 alternative datasets at a given noise level
> val.cor2=val.cors2=val.cork2=val.dcor2= rep(NA,nsim2)
>? 
> 
> # Arrays holding the estimated power for each of the 4 "correlation" types, for each data type (linear, #parabolic, etc...) with each noise level
> power.cor=power.cors=power.cork=power.dcor= array(NA, c(8,num.noise))
> 
> ## We loop through the noise level and functional form; each time we #estimate a null distribution based on #the marginals of the data, and then #use that null distribution to estimate power
> ## We use a uniformly distributed x, because in the original paper the #authors used the same
> 
> for(l in 1:num.noise) {
> 
>? ????? for(typ in 1:8) {
> 
> ## This next loop simulates data under the null with the correct marginals (x is uniform, and y is a function of a #uniform with gaussian noise)
> 
>? ??? for(ii in 1:nsim) {
>? ????? x=runif(n)
> 
> #lin+noise
> if(typ==1) {
> y=x+ noise *(l/num.noise)* rnorm(n)
> }
> 
> #parabolic+noise
> if(typ==2) {
> y=4*(x-.5)^2+? noise * (l/num.noise) * rnorm(n)
> }
> 
> #cubic+noise
> if(typ==3) {
> y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise? * (l/num.noise) *rnorm(n)
> }
> 
> #sin+noise
> if(typ==4) {
> y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
> }
> 
> #their sine + noise
> if(typ==5) {
> y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
> }
> 
> #x^(1/4) + noise
> if(typ==6) {
> y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
> }
> 
> #circle
> if(typ==7) {
> y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise *rnorm(n)
> }
> 
> #step function
> if(typ==8) {
> y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
> }
> 
> # We resimulate x so that we have the null scenario
> x <- runif(n)
> 
> # Calculate the 4 correlations
> val.cor[ii]=(cor(x,y))
> val.cors[ii]=(cor(x,y,method=c("spearman")))
> val.cork[ii]=(cor(x,y,method=c("kendal")))
> val.dcor[ii]=dcor(x,y)
> }
> 
> ## Next we calculate our 4 rejection cutoffs
> cut.cor=quantile(val.cor,.95)
> cut.cors=quantile(val.cors,.95)
> cut.cork=quantile(val.cork,.95)
> cut.dcor=quantile(val.dcor,.95)
> 
> ## Next we simulate the data again, this time under the alternative
> 
>? ??? for(ii in 1:nsim2) {
>? ????? x=runif(n)
> 
> #lin+noise
> if(typ==1) {
> y=x+ noise *(l/num.noise)* rnorm(n)
> }
> 
> #parabolic+noise
> if(typ==2) {
> y=4*(x-.5)^2+? noise * (l/num.noise) * rnorm(n)
> }
> 
> #cubic+noise
> if(typ==3) {
> y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise? * (l/num.noise) *rnorm(n)
> }
> 
> #sin+noise
> if(typ==4) {
> y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
> }
> 
> #their sine + noise
> if(typ==5) {
> y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
> }
> 
> #x^(1/4) + noise
> if(typ==6) {
> y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
> }
> 
> #circle
> if(typ==7) {
> y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise *rnorm(n)
> }
> 
> #step function
> if(typ==8) {
> y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
> }
> 
> ## We again calculate our 4 "correlations"
> val.cor2[ii]=(cor(x,y))
> val.cors2[ii]=(cor(x,y,method=c("spearman")))
> val.cork2[ii]=(cor(x,y,method=c("kendal")))
> val.dcor2[ii]=dcor(x,y)
> }
> 
> ## Now we estimate the power as the number of alternative statistics #exceeding our estimated cutoffs
> power.cor[typ,l] <- sum(val.cor2 > cut.cor)/nsim2
> power.cors[typ,l] <- sum(val.cors2 > cut.cor)/nsim2
> power.cork[typ,l] <- sum(val.cork2 > cut.cor)/nsim2
> power.dcor[typ,l] <- sum(val.dcor2 > cut.dcor)/nsim2
> }
> }
> 
> save.image()
> 
> ## The rest of the code is for plotting the image
> pdf("power.pdf")
> par(mfrow = c(4,2), cex = 0.45)
> plot((1:30)/10, power.cor[1,], ylim = c(0,1), main = "Linear", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[1,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[1,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[1,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
> 
> plot((1:30)/10, power.cor[2,], ylim = c(0,1), main = "Quadratic", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[2,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[2,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[2,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
> 
> plot((1:30)/10, power.cor[3,], ylim = c(0,1), main = "Cubic", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[3,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[3,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[3,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
> 
> plot((1:30)/10, power.cor[5,], ylim = c(0,1), main = "Sine: period 1/8", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[5,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[5,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[5,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
> 
> plot((1:30)/10, power.cor[4,], ylim = c(0,1), main = "Sine: period 1/2", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[4,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[4,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[4,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
> 
> plot((1:30)/10, power.cor[6,], ylim = c(0,1), main = "X^(1/4)", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[6,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[6,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[6,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
> 
> plot((1:30)/10, power.cor[7,], ylim = c(0,1), main = "Circle", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[7,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[7,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[7,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
> 
> plot((1:30)/10, power.cor[8,], ylim = c(0,1), main = "Step function", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[8,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[8,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[8,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))

> 
> #################
> 
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.

> 


From c@nty @end|ng |rom m@th@mcm@@ter@c@  Sun May  9 23:48:50 2021
From: c@nty @end|ng |rom m@th@mcm@@ter@c@ (Angelo Canty)
Date: Sun, 9 May 2021 17:48:50 -0400
Subject: [R] No error message but don't get the 8 graphs
In-Reply-To: <928869154.3343817.1620595649281@mail.yahoo.com>
References: <294893856.3283193.1620585572644.ref@mail.yahoo.com>
 <294893856.3283193.1620585572644@mail.yahoo.com>
 <b9186679-16a2-d6e4-afac-eecebbba7e01@sapo.pt>
 <928869154.3343817.1620595649281@mail.yahoo.com>
Message-ID: <5ba132c7-e604-8c5d-d9c1-2c1335b3bff8@math.mcmaster.ca>

Have you looked in the pdf file (power.pdf) to which you instructed R to 
send the plots?


On 2021-05-09 5:27 p.m., varin sacha via R-help wrote:
> Dear Rui,
>
> I thank you for your response but when I run the code with your few modifications, I still don't get the 8 graphs but I get the following answer :
>
> null device
>  ????????? 1
>
> Here below my R code with your modifications. I don't know what I am still missing ?
>
> ##############
> set.seed(1)
> library(energy)
>
> # Here we define parameters which we use to simulate the data
> # The number of null datasets we use to estimate our rejection reject #regions for an alternative with level 0.05
> nsim=50
>
> # Number of alternative datasets we use to estimate our power
> nsim2=50
>
> # The number of different noise levels used
> num.noise <- 30
>
> # A constant to determine the amount of noise
> noise <- 3
>
> # Number of data points per simulation
> n=100
>
> # Vectors holding the null "correlations" (for pearson, for spearman, for kendall and dcor respectively) for each # of the nsim null datasets at a #given noise level
> val.cor=val.cors=val.cork=val.dcor=rep(NA,nsim)
>
> # Vectors holding the alternative "correlations" (for pearson, for #spearman, for kendall and dcor respectively) #for each of the nsim2 alternative datasets at a given noise level
> val.cor2=val.cors2=val.cork2=val.dcor2= rep(NA,nsim2)
>
> # Arrays holding the estimated power for each of the 4 "correlation" types, for each data type (linear, #parabolic, etc...) with each noise level
> power.cor=power.cors=power.cork=power.dcor= array(NA, c(8,num.noise))
>
> ## We loop through the noise level and functional form; each time we #estimate a null distribution based on #the marginals of the data, and then #use that null distribution to estimate power
> ## We use a uniformly distributed x, because in the original paper the #authors used the same
>
> for(l in 1:num.noise) {
>
>  ????? for(typ in 1:8) {
>
> ## This next loop simulates data under the null with the correct marginals (x is uniform, and y is a function of a #uniform with gaussian noise)
>
>  ??? for(ii in 1:nsim) {
>  ????? x=runif(n)
>
> #lin+noise
> if(typ==1) {
> y=x+ noise *(l/num.noise)* rnorm(n)
> }
>
> #parabolic+noise
> if(typ==2) {
> y=4*(x-.5)^2+? noise * (l/num.noise) * rnorm(n)
> }
>
> #cubic+noise
> if(typ==3) {
> y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise? * (l/num.noise) *rnorm(n)
> }
>
> #sin+noise
> if(typ==4) {
> y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
> }
>
> #their sine + noise
> if(typ==5) {
> y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
> }
>
> #x^(1/4) + noise
> if(typ==6) {
> y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
> }
>
> #circle
> if(typ==7) {
> y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise *rnorm(n)
> }
>
> #step function
> if(typ==8) {
> y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
> }
>
>   
> # We resimulate x so that we have the null scenario
> x <- runif(n)
>
> # Calculate the 4 correlations
> val.cor[ii]=(cor(x,y))
> val.cors[ii]=(cor(x,y,method=c("spearman")))
> val.cork[ii]=(cor(x,y,method=c("kendal")))
> val.dcor[ii]=dcor(x,y)
> }
>
> ## Next we calculate our 4 rejection cutoffs
> cut.cor=quantile(val.cor,.95)
> cut.cors=quantile(val.cors,.95)
> cut.cork=quantile(val.cork,.95)
> cut.dcor=quantile(val.dcor,.95)
>
> ## Next we simulate the data again, this time under the alternative
>
>  ??? for(ii in 1:nsim2) {
>  ????? x=runif(n)
>
> #lin+noise
> if(typ==1) {
> y=x+ noise *(l/num.noise)* rnorm(n)
> }
>
> #parabolic+noise
> if(typ==2) {
> y=4*(x-.5)^2+? noise * (l/num.noise) * rnorm(n)
> }
>
> #cubic+noise
> if(typ==3) {
> y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise? * (l/num.noise) *rnorm(n)
> }
>
> #sin+noise
> if(typ==4) {
> y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
> }
>
> #their sine + noise
> if(typ==5) {
> y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
> }
>
> #x^(1/4) + noise
> if(typ==6) {
> y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
> }
>
> #circle
> if(typ==7) {
> y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise *rnorm(n)
> }
>
> #step function
> if(typ==8) {
> y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
> }
>
> ## We again calculate our 4 "correlations"
> val.cor2[ii]=(cor(x,y))
> val.cors2[ii]=(cor(x,y,method=c("spearman")))
> val.cork2[ii]=(cor(x,y,method=c("kendal")))
> val.dcor2[ii]=dcor(x,y)
> }
>
> ## Now we estimate the power as the number of alternative statistics #exceeding our estimated cutoffs
> power.cor[typ,l] <- sum(val.cor2 > cut.cor)/nsim2
> power.cors[typ,l] <- sum(val.cors2 > cut.cor)/nsim2
> power.cork[typ,l] <- sum(val.cork2 > cut.cor)/nsim2
> power.dcor[typ,l] <- sum(val.dcor2 > cut.dcor)/nsim2
> }
> }
>
> save.image()
>
> ## The rest of the code is for plotting the image
> pdf(file = "power.pdf")
> op <- par(mfrow = c(4,2), cex = 0.45)
> plot((1:30)/10, power.cor[1,], ylim = c(0,1), main = "Linear", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[1,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[1,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[1,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
>
>  ?plot((1:30)/10, power.cor[2,], ylim = c(0,1), main = "Quadratic", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[2,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[2,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[2,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
>
>  ?plot((1:30)/10, power.cor[3,], ylim = c(0,1), main = "Cubic", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[3,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[3,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[3,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
>
> plot((1:30)/10, power.cor[5,], ylim = c(0,1), main = "Sine: period 1/8", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[5,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[5,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[5,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
>
> plot((1:30)/10, power.cor[4,], ylim = c(0,1), main = "Sine: period 1/2", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[4,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[4,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[4,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
>
> plot((1:30)/10, power.cor[6,], ylim = c(0,1), main = "X^(1/4)", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[6,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[6,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[6,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
>
> plot((1:30)/10, power.cor[7,], ylim = c(0,1), main = "Circle", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[7,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[7,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[7,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
>
> plot((1:30)/10, power.cor[8,], ylim = c(0,1), main = "Step function", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[8,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[8,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[8,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
> par(op)
> dev.off()
> #################
>
>
>
>
>
>
>
> Le dimanche 9 mai 2021 ? 22:44:22 UTC+2, Rui Barradas <ruipbarradas at sapo.pt> a ?crit :
>
>
>
>
>
> Hello,
>
> You are not closing the pdf device.
> The only changes I have made to your code are right at the beginning of
> the plotting instructions and at the end of the code.
>
>
> ## The rest of the code is for plotting the image
> pdf(file = "power.pdf")
> op <- par(mfrow = c(4,2), cex = 0.45)
>
> [...]
>
> par(op)
> dev.off()
> #################
>
> The comments only line is your last code line.
> The result is attached.
>
> Hope this helps,
>
> Rui Barradas
>
> ?s 19:39 de 09/05/21, varin sacha via R-help escreveu:
>> Dear R-experts,
>>
>> I am trying to get the 8 graphs like the ones in this paper :
>> https://statweb.stanford.edu/~tibs/reshef/comment.pdf
>> My R code does not show any error message neither warnings but I d'on't get what I would like to get (I mean the 8 graphs), so I am missing something. What's it ? Many thanks for your precious help.
>>
>> #################
>> set.seed(1)
>> library(energy)
>>
>> # Here we define parameters which we use to simulate the data
>> # The number of null datasets we use to estimate our rejection reject #regions for an alternative with level 0.05
>> nsim=50
>>
>> # Number of alternative datasets we use to estimate our power
>> nsim2=50
>>
>> # The number of different noise levels used
>> num.noise <- 30
>>
>> # A constant to determine the amount of noise
>> noise <- 3
>>
>> # Number of data points per simulation
>> n=100
>>
>> # Vectors holding the null "correlations" (for pearson, for spearman, for kendall and dcor respectively) for each # of the nsim null datasets at a #given noise level
>> val.cor=val.cors=val.cork=val.dcor=rep(NA,nsim)
>>
>> # Vectors holding the alternative "correlations" (for pearson, for #spearman, for kendall and dcor respectively) #for each of the nsim2 alternative datasets at a given noise level
>> val.cor2=val.cors2=val.cork2=val.dcor2= rep(NA,nsim2)
>>    
>>
>> # Arrays holding the estimated power for each of the 4 "correlation" types, for each data type (linear, #parabolic, etc...) with each noise level
>> power.cor=power.cors=power.cork=power.dcor= array(NA, c(8,num.noise))
>>
>> ## We loop through the noise level and functional form; each time we #estimate a null distribution based on #the marginals of the data, and then #use that null distribution to estimate power
>> ## We use a uniformly distributed x, because in the original paper the #authors used the same
>>
>> for(l in 1:num.noise) {
>>
>>  ? ????? for(typ in 1:8) {
>>
>> ## This next loop simulates data under the null with the correct marginals (x is uniform, and y is a function of a #uniform with gaussian noise)
>>
>>  ? ??? for(ii in 1:nsim) {
>>  ? ????? x=runif(n)
>>
>> #lin+noise
>> if(typ==1) {
>> y=x+ noise *(l/num.noise)* rnorm(n)
>> }
>>
>> #parabolic+noise
>> if(typ==2) {
>> y=4*(x-.5)^2+? noise * (l/num.noise) * rnorm(n)
>> }
>>
>> #cubic+noise
>> if(typ==3) {
>> y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise? * (l/num.noise) *rnorm(n)
>> }
>>
>> #sin+noise
>> if(typ==4) {
>> y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
>> }
>>
>> #their sine + noise
>> if(typ==5) {
>> y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
>> }
>>
>> #x^(1/4) + noise
>> if(typ==6) {
>> y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
>> }
>>
>> #circle
>> if(typ==7) {
>> y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise *rnorm(n)
>> }
>>
>> #step function
>> if(typ==8) {
>> y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
>> }
>>
>> # We resimulate x so that we have the null scenario
>> x <- runif(n)
>>
>> # Calculate the 4 correlations
>> val.cor[ii]=(cor(x,y))
>> val.cors[ii]=(cor(x,y,method=c("spearman")))
>> val.cork[ii]=(cor(x,y,method=c("kendal")))
>> val.dcor[ii]=dcor(x,y)
>> }
>>
>> ## Next we calculate our 4 rejection cutoffs
>> cut.cor=quantile(val.cor,.95)
>> cut.cors=quantile(val.cors,.95)
>> cut.cork=quantile(val.cork,.95)
>> cut.dcor=quantile(val.dcor,.95)
>>
>> ## Next we simulate the data again, this time under the alternative
>>
>>  ? ??? for(ii in 1:nsim2) {
>>  ? ????? x=runif(n)
>>
>> #lin+noise
>> if(typ==1) {
>> y=x+ noise *(l/num.noise)* rnorm(n)
>> }
>>
>> #parabolic+noise
>> if(typ==2) {
>> y=4*(x-.5)^2+? noise * (l/num.noise) * rnorm(n)
>> }
>>
>> #cubic+noise
>> if(typ==3) {
>> y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise? * (l/num.noise) *rnorm(n)
>> }
>>
>> #sin+noise
>> if(typ==4) {
>> y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
>> }
>>
>> #their sine + noise
>> if(typ==5) {
>> y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
>> }
>>
>> #x^(1/4) + noise
>> if(typ==6) {
>> y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
>> }
>>
>> #circle
>> if(typ==7) {
>> y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise *rnorm(n)
>> }
>>
>> #step function
>> if(typ==8) {
>> y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
>> }
>>
>> ## We again calculate our 4 "correlations"
>> val.cor2[ii]=(cor(x,y))
>> val.cors2[ii]=(cor(x,y,method=c("spearman")))
>> val.cork2[ii]=(cor(x,y,method=c("kendal")))
>> val.dcor2[ii]=dcor(x,y)
>> }
>>
>> ## Now we estimate the power as the number of alternative statistics #exceeding our estimated cutoffs
>> power.cor[typ,l] <- sum(val.cor2 > cut.cor)/nsim2
>> power.cors[typ,l] <- sum(val.cors2 > cut.cor)/nsim2
>> power.cork[typ,l] <- sum(val.cork2 > cut.cor)/nsim2
>> power.dcor[typ,l] <- sum(val.dcor2 > cut.dcor)/nsim2
>> }
>> }
>>
>> save.image()
>>
>> ## The rest of the code is for plotting the image
>> pdf("power.pdf")
>> par(mfrow = c(4,2), cex = 0.45)
>> plot((1:30)/10, power.cor[1,], ylim = c(0,1), main = "Linear", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> points((1:30)/10, power.cors[1,], pch = 2, col = "green", type = 'b')
>> points((1:30)/10, power.cork[1,], pch = 3, col = "blue", type = 'b')
>> points((1:30)/10, power.dcor[1,], pch = 4, col = "red", type = 'b')
>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
>>
>> plot((1:30)/10, power.cor[2,], ylim = c(0,1), main = "Quadratic", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> points((1:30)/10, power.cors[2,], pch = 2, col = "green", type = 'b')
>> points((1:30)/10, power.cork[2,], pch = 3, col = "blue", type = 'b')
>> points((1:30)/10, power.dcor[2,], pch = 4, col = "red", type = 'b')
>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
>>
>> plot((1:30)/10, power.cor[3,], ylim = c(0,1), main = "Cubic", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> points((1:30)/10, power.cors[3,], pch = 2, col = "green", type = 'b')
>> points((1:30)/10, power.cork[3,], pch = 3, col = "blue", type = 'b')
>> points((1:30)/10, power.dcor[3,], pch = 4, col = "red", type = 'b')
>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
>>
>> plot((1:30)/10, power.cor[5,], ylim = c(0,1), main = "Sine: period 1/8", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> points((1:30)/10, power.cors[5,], pch = 2, col = "green", type = 'b')
>> points((1:30)/10, power.cork[5,], pch = 3, col = "blue", type = 'b')
>> points((1:30)/10, power.dcor[5,], pch = 4, col = "red", type = 'b')
>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
>>
>> plot((1:30)/10, power.cor[4,], ylim = c(0,1), main = "Sine: period 1/2", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> points((1:30)/10, power.cors[4,], pch = 2, col = "green", type = 'b')
>> points((1:30)/10, power.cork[4,], pch = 3, col = "blue", type = 'b')
>> points((1:30)/10, power.dcor[4,], pch = 4, col = "red", type = 'b')
>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
>>
>> plot((1:30)/10, power.cor[6,], ylim = c(0,1), main = "X^(1/4)", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> points((1:30)/10, power.cors[6,], pch = 2, col = "green", type = 'b')
>> points((1:30)/10, power.cork[6,], pch = 3, col = "blue", type = 'b')
>> points((1:30)/10, power.dcor[6,], pch = 4, col = "red", type = 'b')
>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
>>
>> plot((1:30)/10, power.cor[7,], ylim = c(0,1), main = "Circle", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> points((1:30)/10, power.cors[7,], pch = 2, col = "green", type = 'b')
>> points((1:30)/10, power.cork[7,], pch = 3, col = "blue", type = 'b')
>> points((1:30)/10, power.dcor[7,], pch = 4, col = "red", type = 'b')
>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
>>
>> plot((1:30)/10, power.cor[8,], ylim = c(0,1), main = "Step function", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> points((1:30)/10, power.cors[8,], pch = 2, col = "green", type = 'b')
>> points((1:30)/10, power.cork[8,], pch = 3, col = "blue", type = 'b')
>> points((1:30)/10, power.dcor[8,], pch = 4, col = "red", type = 'b')
>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
>> #################
>>
>> ______________________________________________
>> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> https://stat.ethz.ch/mailman/listinfo/r-help
>> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
>> and provide commented, minimal, self-contained, reproducible code.
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
>

-- 
------------------------------------------------------------------
|   Angelo J. Canty                Email: cantya at mcmaster.ca     |
|   Mathematics and Statistics     Phone: (905) 525-9140 x 27079 |
|   McMaster University            Fax  : (905) 522-0935         |
|   1280 Main St. W.                                             |
|   Hamilton ON L8S 4K1                                          |


From v@r|n@@ch@ @end|ng |rom y@hoo@|r  Sun May  9 23:50:14 2021
From: v@r|n@@ch@ @end|ng |rom y@hoo@|r (varin sacha)
Date: Sun, 9 May 2021 21:50:14 +0000 (UTC)
Subject: [R] No error message but don't get the 8 graphs
In-Reply-To: <b9186679-16a2-d6e4-afac-eecebbba7e01@sapo.pt>
References: <294893856.3283193.1620585572644.ref@mail.yahoo.com>
 <294893856.3283193.1620585572644@mail.yahoo.com>
 <b9186679-16a2-d6e4-afac-eecebbba7e01@sapo.pt>
Message-ID: <1115549345.3369846.1620597015000@mail.yahoo.com>

Rui,

The created pdf.file is off-screen device. Indeed after dev.off() I should view the pdf file on my computer. But I don't find it. Where do I find the pdf.file ?

Regards,



Le dimanche 9 mai 2021 ? 22:44:22 UTC+2, Rui Barradas <ruipbarradas at sapo.pt> a ?crit : 





Hello,

You are not closing the pdf device.
The only changes I have made to your code are right at the beginning of 
the plotting instructions and at the end of the code.


## The rest of the code is for plotting the image
pdf(file = "power.pdf")
op <- par(mfrow = c(4,2), cex = 0.45)

[...]

par(op)
dev.off()
#################

The comments only line is your last code line.
The result is attached.

Hope this helps,

Rui Barradas

?s 19:39 de 09/05/21, varin sacha via R-help escreveu:
> Dear R-experts,
> 
> I am trying to get the 8 graphs like the ones in this paper :
> https://statweb.stanford.edu/~tibs/reshef/comment.pdf
> My R code does not show any error message neither warnings but I d'on't get what I would like to get (I mean the 8 graphs), so I am missing something. What's it ? Many thanks for your precious help.
> 
> #################
> set.seed(1)
> library(energy)
> 
> # Here we define parameters which we use to simulate the data
> # The number of null datasets we use to estimate our rejection reject #regions for an alternative with level 0.05
> nsim=50
> 
> # Number of alternative datasets we use to estimate our power
> nsim2=50
> 
> # The number of different noise levels used
> num.noise <- 30
> 
> # A constant to determine the amount of noise
> noise <- 3
> 
> # Number of data points per simulation
> n=100
> 
> # Vectors holding the null "correlations" (for pearson, for spearman, for kendall and dcor respectively) for each # of the nsim null datasets at a #given noise level
> val.cor=val.cors=val.cork=val.dcor=rep(NA,nsim)
> 
> # Vectors holding the alternative "correlations" (for pearson, for #spearman, for kendall and dcor respectively) #for each of the nsim2 alternative datasets at a given noise level
> val.cor2=val.cors2=val.cork2=val.dcor2= rep(NA,nsim2)
>? 
> 
> # Arrays holding the estimated power for each of the 4 "correlation" types, for each data type (linear, #parabolic, etc...) with each noise level
> power.cor=power.cors=power.cork=power.dcor= array(NA, c(8,num.noise))
> 
> ## We loop through the noise level and functional form; each time we #estimate a null distribution based on #the marginals of the data, and then #use that null distribution to estimate power
> ## We use a uniformly distributed x, because in the original paper the #authors used the same
> 
> for(l in 1:num.noise) {
> 
>? ????? for(typ in 1:8) {
> 
> ## This next loop simulates data under the null with the correct marginals (x is uniform, and y is a function of a #uniform with gaussian noise)
> 
>? ??? for(ii in 1:nsim) {
>? ????? x=runif(n)
> 
> #lin+noise
> if(typ==1) {
> y=x+ noise *(l/num.noise)* rnorm(n)
> }
> 
> #parabolic+noise
> if(typ==2) {
> y=4*(x-.5)^2+? noise * (l/num.noise) * rnorm(n)
> }
> 
> #cubic+noise
> if(typ==3) {
> y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise? * (l/num.noise) *rnorm(n)
> }
> 
> #sin+noise
> if(typ==4) {
> y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
> }
> 
> #their sine + noise
> if(typ==5) {
> y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
> }
> 
> #x^(1/4) + noise
> if(typ==6) {
> y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
> }
> 
> #circle
> if(typ==7) {
> y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise *rnorm(n)
> }
> 
> #step function
> if(typ==8) {
> y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
> }
> 
> # We resimulate x so that we have the null scenario
> x <- runif(n)
> 
> # Calculate the 4 correlations
> val.cor[ii]=(cor(x,y))
> val.cors[ii]=(cor(x,y,method=c("spearman")))
> val.cork[ii]=(cor(x,y,method=c("kendal")))
> val.dcor[ii]=dcor(x,y)
> }
> 
> ## Next we calculate our 4 rejection cutoffs
> cut.cor=quantile(val.cor,.95)
> cut.cors=quantile(val.cors,.95)
> cut.cork=quantile(val.cork,.95)
> cut.dcor=quantile(val.dcor,.95)
> 
> ## Next we simulate the data again, this time under the alternative
> 
>? ??? for(ii in 1:nsim2) {
>? ????? x=runif(n)
> 
> #lin+noise
> if(typ==1) {
> y=x+ noise *(l/num.noise)* rnorm(n)
> }
> 
> #parabolic+noise
> if(typ==2) {
> y=4*(x-.5)^2+? noise * (l/num.noise) * rnorm(n)
> }
> 
> #cubic+noise
> if(typ==3) {
> y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise? * (l/num.noise) *rnorm(n)
> }
> 
> #sin+noise
> if(typ==4) {
> y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
> }
> 
> #their sine + noise
> if(typ==5) {
> y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
> }
> 
> #x^(1/4) + noise
> if(typ==6) {
> y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
> }
> 
> #circle
> if(typ==7) {
> y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise *rnorm(n)
> }
> 
> #step function
> if(typ==8) {
> y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
> }
> 
> ## We again calculate our 4 "correlations"
> val.cor2[ii]=(cor(x,y))
> val.cors2[ii]=(cor(x,y,method=c("spearman")))
> val.cork2[ii]=(cor(x,y,method=c("kendal")))
> val.dcor2[ii]=dcor(x,y)
> }
> 
> ## Now we estimate the power as the number of alternative statistics #exceeding our estimated cutoffs
> power.cor[typ,l] <- sum(val.cor2 > cut.cor)/nsim2
> power.cors[typ,l] <- sum(val.cors2 > cut.cor)/nsim2
> power.cork[typ,l] <- sum(val.cork2 > cut.cor)/nsim2
> power.dcor[typ,l] <- sum(val.dcor2 > cut.dcor)/nsim2
> }
> }
> 
> save.image()
> 
> ## The rest of the code is for plotting the image
> pdf("power.pdf")
> par(mfrow = c(4,2), cex = 0.45)
> plot((1:30)/10, power.cor[1,], ylim = c(0,1), main = "Linear", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[1,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[1,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[1,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
> 
> plot((1:30)/10, power.cor[2,], ylim = c(0,1), main = "Quadratic", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[2,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[2,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[2,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
> 
> plot((1:30)/10, power.cor[3,], ylim = c(0,1), main = "Cubic", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[3,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[3,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[3,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
> 
> plot((1:30)/10, power.cor[5,], ylim = c(0,1), main = "Sine: period 1/8", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[5,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[5,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[5,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
> 
> plot((1:30)/10, power.cor[4,], ylim = c(0,1), main = "Sine: period 1/2", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[4,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[4,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[4,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
> 
> plot((1:30)/10, power.cor[6,], ylim = c(0,1), main = "X^(1/4)", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[6,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[6,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[6,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
> 
> plot((1:30)/10, power.cor[7,], ylim = c(0,1), main = "Circle", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[7,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[7,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[7,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
> 
> plot((1:30)/10, power.cor[8,], ylim = c(0,1), main = "Step function", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[8,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[8,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[8,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
> 
> #################
> 
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
> 


From v@r|n@@ch@ @end|ng |rom y@hoo@|r  Sun May  9 23:54:46 2021
From: v@r|n@@ch@ @end|ng |rom y@hoo@|r (varin sacha)
Date: Sun, 9 May 2021 21:54:46 +0000 (UTC)
Subject: [R] No error message but don't get the 8 graphs
In-Reply-To: <5ba132c7-e604-8c5d-d9c1-2c1335b3bff8@math.mcmaster.ca>
References: <294893856.3283193.1620585572644.ref@mail.yahoo.com>
 <294893856.3283193.1620585572644@mail.yahoo.com>
 <b9186679-16a2-d6e4-afac-eecebbba7e01@sapo.pt>
 <928869154.3343817.1620595649281@mail.yahoo.com>
 <5ba132c7-e604-8c5d-d9c1-2c1335b3bff8@math.mcmaster.ca>
Message-ID: <736209186.3358686.1620597286766@mail.yahoo.com>

Rui, 
Angelo,

I found it :=) 

Many thanks

S.


Le dimanche 9 mai 2021 ? 23:49:41 UTC+2, Angelo Canty <canty at math.mcmaster.ca> a ?crit : 





Have you looked in the pdf file (power.pdf) to which you instructed R to 
send the plots?


On 2021-05-09 5:27 p.m., varin sacha via R-help wrote:
> Dear Rui,
>
> I thank you for your response but when I run the code with your few modifications, I still don't get the 8 graphs but I get the following answer :
>
> null device
>? ????????? 1
>
> Here below my R code with your modifications. I don't know what I am still missing ?
>
> ##############
> set.seed(1)
> library(energy)
>
> # Here we define parameters which we use to simulate the data
> # The number of null datasets we use to estimate our rejection reject #regions for an alternative with level 0.05
> nsim=50
>
> # Number of alternative datasets we use to estimate our power
> nsim2=50
>
> # The number of different noise levels used
> num.noise <- 30
>
> # A constant to determine the amount of noise
> noise <- 3
>
> # Number of data points per simulation
> n=100
>
> # Vectors holding the null "correlations" (for pearson, for spearman, for kendall and dcor respectively) for each # of the nsim null datasets at a #given noise level
> val.cor=val.cors=val.cork=val.dcor=rep(NA,nsim)
>
> # Vectors holding the alternative "correlations" (for pearson, for #spearman, for kendall and dcor respectively) #for each of the nsim2 alternative datasets at a given noise level
> val.cor2=val.cors2=val.cork2=val.dcor2= rep(NA,nsim2)
>
> # Arrays holding the estimated power for each of the 4 "correlation" types, for each data type (linear, #parabolic, etc...) with each noise level
> power.cor=power.cors=power.cork=power.dcor= array(NA, c(8,num.noise))
>
> ## We loop through the noise level and functional form; each time we #estimate a null distribution based on #the marginals of the data, and then #use that null distribution to estimate power
> ## We use a uniformly distributed x, because in the original paper the #authors used the same
>
> for(l in 1:num.noise) {
>
>? ????? for(typ in 1:8) {
>
> ## This next loop simulates data under the null with the correct marginals (x is uniform, and y is a function of a #uniform with gaussian noise)
>
>? ??? for(ii in 1:nsim) {
>? ????? x=runif(n)
>
> #lin+noise
> if(typ==1) {
> y=x+ noise *(l/num.noise)* rnorm(n)
> }
>
> #parabolic+noise
> if(typ==2) {
> y=4*(x-.5)^2+? noise * (l/num.noise) * rnorm(n)
> }
>
> #cubic+noise
> if(typ==3) {
> y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise? * (l/num.noise) *rnorm(n)
> }
>
> #sin+noise
> if(typ==4) {
> y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
> }
>
> #their sine + noise
> if(typ==5) {
> y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
> }
>
> #x^(1/4) + noise
> if(typ==6) {
> y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
> }
>
> #circle
> if(typ==7) {
> y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise *rnorm(n)
> }
>
> #step function
> if(typ==8) {
> y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
> }
>
>? 
> # We resimulate x so that we have the null scenario
> x <- runif(n)
>
> # Calculate the 4 correlations
> val.cor[ii]=(cor(x,y))
> val.cors[ii]=(cor(x,y,method=c("spearman")))
> val.cork[ii]=(cor(x,y,method=c("kendal")))
> val.dcor[ii]=dcor(x,y)
> }
>
> ## Next we calculate our 4 rejection cutoffs
> cut.cor=quantile(val.cor,.95)
> cut.cors=quantile(val.cors,.95)
> cut.cork=quantile(val.cork,.95)
> cut.dcor=quantile(val.dcor,.95)
>
> ## Next we simulate the data again, this time under the alternative
>
>? ??? for(ii in 1:nsim2) {
>? ????? x=runif(n)
>
> #lin+noise
> if(typ==1) {
> y=x+ noise *(l/num.noise)* rnorm(n)
> }
>
> #parabolic+noise
> if(typ==2) {
> y=4*(x-.5)^2+? noise * (l/num.noise) * rnorm(n)
> }
>
> #cubic+noise
> if(typ==3) {
> y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise? * (l/num.noise) *rnorm(n)
> }
>
> #sin+noise
> if(typ==4) {
> y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
> }
>
> #their sine + noise
> if(typ==5) {
> y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
> }
>
> #x^(1/4) + noise
> if(typ==6) {
> y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
> }
>
> #circle
> if(typ==7) {
> y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise *rnorm(n)
> }
>
> #step function
> if(typ==8) {
> y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
> }
>
> ## We again calculate our 4 "correlations"
> val.cor2[ii]=(cor(x,y))
> val.cors2[ii]=(cor(x,y,method=c("spearman")))
> val.cork2[ii]=(cor(x,y,method=c("kendal")))
> val.dcor2[ii]=dcor(x,y)
> }
>
> ## Now we estimate the power as the number of alternative statistics #exceeding our estimated cutoffs
> power.cor[typ,l] <- sum(val.cor2 > cut.cor)/nsim2
> power.cors[typ,l] <- sum(val.cors2 > cut.cor)/nsim2
> power.cork[typ,l] <- sum(val.cork2 > cut.cor)/nsim2
> power.dcor[typ,l] <- sum(val.dcor2 > cut.dcor)/nsim2
> }
> }
>
> save.image()
>
> ## The rest of the code is for plotting the image
> pdf(file = "power.pdf")
> op <- par(mfrow = c(4,2), cex = 0.45)
> plot((1:30)/10, power.cor[1,], ylim = c(0,1), main = "Linear", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[1,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[1,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[1,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
>
>? ?plot((1:30)/10, power.cor[2,], ylim = c(0,1), main = "Quadratic", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[2,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[2,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[2,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
>
>? ?plot((1:30)/10, power.cor[3,], ylim = c(0,1), main = "Cubic", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[3,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[3,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[3,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
>
> plot((1:30)/10, power.cor[5,], ylim = c(0,1), main = "Sine: period 1/8", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[5,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[5,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[5,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
>
> plot((1:30)/10, power.cor[4,], ylim = c(0,1), main = "Sine: period 1/2", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[4,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[4,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[4,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
>
> plot((1:30)/10, power.cor[6,], ylim = c(0,1), main = "X^(1/4)", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[6,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[6,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[6,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
>
> plot((1:30)/10, power.cor[7,], ylim = c(0,1), main = "Circle", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[7,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[7,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[7,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
>
> plot((1:30)/10, power.cor[8,], ylim = c(0,1), main = "Step function", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[8,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[8,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[8,], pch = 4, col = "red", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
> par(op)
> dev.off()
> #################
>
>
>
>
>
>
>
> Le dimanche 9 mai 2021 ? 22:44:22 UTC+2, Rui Barradas <ruipbarradas at sapo.pt> a ?crit :
>
>
>
>
>
> Hello,
>
> You are not closing the pdf device.
> The only changes I have made to your code are right at the beginning of
> the plotting instructions and at the end of the code.
>
>
> ## The rest of the code is for plotting the image
> pdf(file = "power.pdf")
> op <- par(mfrow = c(4,2), cex = 0.45)
>
> [...]
>
> par(op)
> dev.off()
> #################
>
> The comments only line is your last code line.
> The result is attached.
>
> Hope this helps,
>
> Rui Barradas
>
> ?s 19:39 de 09/05/21, varin sacha via R-help escreveu:
>> Dear R-experts,
>>
>> I am trying to get the 8 graphs like the ones in this paper :
>> https://statweb.stanford.edu/~tibs/reshef/comment.pdf
>> My R code does not show any error message neither warnings but I d'on't get what I would like to get (I mean the 8 graphs), so I am missing something. What's it ? Many thanks for your precious help.
>>
>> #################
>> set.seed(1)
>> library(energy)
>>
>> # Here we define parameters which we use to simulate the data
>> # The number of null datasets we use to estimate our rejection reject #regions for an alternative with level 0.05
>> nsim=50
>>
>> # Number of alternative datasets we use to estimate our power
>> nsim2=50
>>
>> # The number of different noise levels used
>> num.noise <- 30
>>
>> # A constant to determine the amount of noise
>> noise <- 3
>>
>> # Number of data points per simulation
>> n=100
>>
>> # Vectors holding the null "correlations" (for pearson, for spearman, for kendall and dcor respectively) for each # of the nsim null datasets at a #given noise level
>> val.cor=val.cors=val.cork=val.dcor=rep(NA,nsim)
>>
>> # Vectors holding the alternative "correlations" (for pearson, for #spearman, for kendall and dcor respectively) #for each of the nsim2 alternative datasets at a given noise level
>> val.cor2=val.cors2=val.cork2=val.dcor2= rep(NA,nsim2)
>>? ? 
>>
>> # Arrays holding the estimated power for each of the 4 "correlation" types, for each data type (linear, #parabolic, etc...) with each noise level
>> power.cor=power.cors=power.cork=power.dcor= array(NA, c(8,num.noise))
>>
>> ## We loop through the noise level and functional form; each time we #estimate a null distribution based on #the marginals of the data, and then #use that null distribution to estimate power
>> ## We use a uniformly distributed x, because in the original paper the #authors used the same
>>
>> for(l in 1:num.noise) {
>>
>>? ? ????? for(typ in 1:8) {
>>
>> ## This next loop simulates data under the null with the correct marginals (x is uniform, and y is a function of a #uniform with gaussian noise)
>>
>>? ? ??? for(ii in 1:nsim) {
>>? ? ????? x=runif(n)
>>
>> #lin+noise
>> if(typ==1) {
>> y=x+ noise *(l/num.noise)* rnorm(n)
>> }
>>
>> #parabolic+noise
>> if(typ==2) {
>> y=4*(x-.5)^2+? noise * (l/num.noise) * rnorm(n)
>> }
>>
>> #cubic+noise
>> if(typ==3) {
>> y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise? * (l/num.noise) *rnorm(n)
>> }
>>
>> #sin+noise
>> if(typ==4) {
>> y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
>> }
>>
>> #their sine + noise
>> if(typ==5) {
>> y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
>> }
>>
>> #x^(1/4) + noise
>> if(typ==6) {
>> y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
>> }
>>
>> #circle
>> if(typ==7) {
>> y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise *rnorm(n)
>> }
>>
>> #step function
>> if(typ==8) {
>> y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
>> }
>>
>> # We resimulate x so that we have the null scenario
>> x <- runif(n)
>>
>> # Calculate the 4 correlations
>> val.cor[ii]=(cor(x,y))
>> val.cors[ii]=(cor(x,y,method=c("spearman")))
>> val.cork[ii]=(cor(x,y,method=c("kendal")))
>> val.dcor[ii]=dcor(x,y)
>> }
>>
>> ## Next we calculate our 4 rejection cutoffs
>> cut.cor=quantile(val.cor,.95)
>> cut.cors=quantile(val.cors,.95)
>> cut.cork=quantile(val.cork,.95)
>> cut.dcor=quantile(val.dcor,.95)
>>
>> ## Next we simulate the data again, this time under the alternative
>>
>>? ? ??? for(ii in 1:nsim2) {
>>? ? ????? x=runif(n)
>>
>> #lin+noise
>> if(typ==1) {
>> y=x+ noise *(l/num.noise)* rnorm(n)
>> }
>>
>> #parabolic+noise
>> if(typ==2) {
>> y=4*(x-.5)^2+? noise * (l/num.noise) * rnorm(n)
>> }
>>
>> #cubic+noise
>> if(typ==3) {
>> y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise? * (l/num.noise) *rnorm(n)
>> }
>>
>> #sin+noise
>> if(typ==4) {
>> y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
>> }
>>
>> #their sine + noise
>> if(typ==5) {
>> y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
>> }
>>
>> #x^(1/4) + noise
>> if(typ==6) {
>> y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
>> }
>>
>> #circle
>> if(typ==7) {
>> y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise *rnorm(n)
>> }
>>
>> #step function
>> if(typ==8) {
>> y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
>> }
>>
>> ## We again calculate our 4 "correlations"
>> val.cor2[ii]=(cor(x,y))
>> val.cors2[ii]=(cor(x,y,method=c("spearman")))
>> val.cork2[ii]=(cor(x,y,method=c("kendal")))
>> val.dcor2[ii]=dcor(x,y)
>> }
>>
>> ## Now we estimate the power as the number of alternative statistics #exceeding our estimated cutoffs
>> power.cor[typ,l] <- sum(val.cor2 > cut.cor)/nsim2
>> power.cors[typ,l] <- sum(val.cors2 > cut.cor)/nsim2
>> power.cork[typ,l] <- sum(val.cork2 > cut.cor)/nsim2
>> power.dcor[typ,l] <- sum(val.dcor2 > cut.dcor)/nsim2
>> }
>> }
>>
>> save.image()
>>
>> ## The rest of the code is for plotting the image
>> pdf("power.pdf")
>> par(mfrow = c(4,2), cex = 0.45)
>> plot((1:30)/10, power.cor[1,], ylim = c(0,1), main = "Linear", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> points((1:30)/10, power.cors[1,], pch = 2, col = "green", type = 'b')
>> points((1:30)/10, power.cork[1,], pch = 3, col = "blue", type = 'b')
>> points((1:30)/10, power.dcor[1,], pch = 4, col = "red", type = 'b')
>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
>>
>> plot((1:30)/10, power.cor[2,], ylim = c(0,1), main = "Quadratic", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> points((1:30)/10, power.cors[2,], pch = 2, col = "green", type = 'b')
>> points((1:30)/10, power.cork[2,], pch = 3, col = "blue", type = 'b')
>> points((1:30)/10, power.dcor[2,], pch = 4, col = "red", type = 'b')
>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
>>
>> plot((1:30)/10, power.cor[3,], ylim = c(0,1), main = "Cubic", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> points((1:30)/10, power.cors[3,], pch = 2, col = "green", type = 'b')
>> points((1:30)/10, power.cork[3,], pch = 3, col = "blue", type = 'b')
>> points((1:30)/10, power.dcor[3,], pch = 4, col = "red", type = 'b')
>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
>>
>> plot((1:30)/10, power.cor[5,], ylim = c(0,1), main = "Sine: period 1/8", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> points((1:30)/10, power.cors[5,], pch = 2, col = "green", type = 'b')
>> points((1:30)/10, power.cork[5,], pch = 3, col = "blue", type = 'b')
>> points((1:30)/10, power.dcor[5,], pch = 4, col = "red", type = 'b')
>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
>>
>> plot((1:30)/10, power.cor[4,], ylim = c(0,1), main = "Sine: period 1/2", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> points((1:30)/10, power.cors[4,], pch = 2, col = "green", type = 'b')
>> points((1:30)/10, power.cork[4,], pch = 3, col = "blue", type = 'b')
>> points((1:30)/10, power.dcor[4,], pch = 4, col = "red", type = 'b')
>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
>>
>> plot((1:30)/10, power.cor[6,], ylim = c(0,1), main = "X^(1/4)", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> points((1:30)/10, power.cors[6,], pch = 2, col = "green", type = 'b')
>> points((1:30)/10, power.cork[6,], pch = 3, col = "blue", type = 'b')
>> points((1:30)/10, power.dcor[6,], pch = 4, col = "red", type = 'b')
>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
>>
>> plot((1:30)/10, power.cor[7,], ylim = c(0,1), main = "Circle", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> points((1:30)/10, power.cors[7,], pch = 2, col = "green", type = 'b')
>> points((1:30)/10, power.cork[7,], pch = 3, col = "blue", type = 'b')
>> points((1:30)/10, power.dcor[7,], pch = 4, col = "red", type = 'b')
>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
>>
>> plot((1:30)/10, power.cor[8,], ylim = c(0,1), main = "Step function", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> points((1:30)/10, power.cors[8,], pch = 2, col = "green", type = 'b')
>> points((1:30)/10, power.cork[8,], pch = 3, col = "blue", type = 'b')
>> points((1:30)/10, power.dcor[8,], pch = 4, col = "red", type = 'b')
>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"), pch = c(1,2,3), col = c("black","green","blue","red"))
>> #################
>>
>> ______________________________________________
>> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> https://stat.ethz.ch/mailman/listinfo/r-help
>> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
>> and provide commented, minimal, self-contained, reproducible code.
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
>

-- 
------------------------------------------------------------------
|? Angelo J. Canty? ? ? ? ? ? ? ? Email: cantya at mcmaster.ca? ? |
|? Mathematics and Statistics? ? Phone: (905) 525-9140 x 27079 |
|? McMaster University? ? ? ? ? ? Fax? : (905) 522-0935? ? ? ? |
|? 1280 Main St. W.? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? |
|? Hamilton ON L8S 4K1? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? |

______________________________________________
R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
https://stat.ethz.ch/mailman/listinfo/r-help
PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
and provide commented, minimal, self-contained, reproducible code.


From bgunter@4567 @end|ng |rom gm@||@com  Mon May 10 02:13:00 2021
From: bgunter@4567 @end|ng |rom gm@||@com (Bert Gunter)
Date: Sun, 9 May 2021 17:13:00 -0700
Subject: [R] No error message but don't get the 8 graphs
In-Reply-To: <1115549345.3369846.1620597015000@mail.yahoo.com>
References: <294893856.3283193.1620585572644.ref@mail.yahoo.com>
 <294893856.3283193.1620585572644@mail.yahoo.com>
 <b9186679-16a2-d6e4-afac-eecebbba7e01@sapo.pt>
 <1115549345.3369846.1620597015000@mail.yahoo.com>
Message-ID: <CAGxFJbTdN4e9RtgFVBsPA1ktbNXo66KpQ6d9=Tv7LveNz3OqxQ@mail.gmail.com>

?getwd

Bert Gunter

"The trouble with having an open mind is that people keep coming along and
sticking things into it."
-- Opus (aka Berkeley Breathed in his "Bloom County" comic strip )


On Sun, May 9, 2021 at 2:59 PM varin sacha via R-help <r-help at r-project.org>
wrote:

> Rui,
>
> The created pdf.file is off-screen device. Indeed after dev.off() I should
> view the pdf file on my computer. But I don't find it. Where do I find the
> pdf.file ?
>
> Regards,
>
>
>
> Le dimanche 9 mai 2021 ? 22:44:22 UTC+2, Rui Barradas <
> ruipbarradas at sapo.pt> a ?crit :
>
>
>
>
>
> Hello,
>
> You are not closing the pdf device.
> The only changes I have made to your code are right at the beginning of
> the plotting instructions and at the end of the code.
>
>
> ## The rest of the code is for plotting the image
> pdf(file = "power.pdf")
> op <- par(mfrow = c(4,2), cex = 0.45)
>
> [...]
>
> par(op)
> dev.off()
> #################
>
> The comments only line is your last code line.
> The result is attached.
>
> Hope this helps,
>
> Rui Barradas
>
> ?s 19:39 de 09/05/21, varin sacha via R-help escreveu:
> > Dear R-experts,
> >
> > I am trying to get the 8 graphs like the ones in this paper :
> > https://statweb.stanford.edu/~tibs/reshef/comment.pdf
> > My R code does not show any error message neither warnings but I d'on't
> get what I would like to get (I mean the 8 graphs), so I am missing
> something. What's it ? Many thanks for your precious help.
> >
> > #################
> > set.seed(1)
> > library(energy)
> >
> > # Here we define parameters which we use to simulate the data
> > # The number of null datasets we use to estimate our rejection reject
> #regions for an alternative with level 0.05
> > nsim=50
> >
> > # Number of alternative datasets we use to estimate our power
> > nsim2=50
> >
> > # The number of different noise levels used
> > num.noise <- 30
> >
> > # A constant to determine the amount of noise
> > noise <- 3
> >
> > # Number of data points per simulation
> > n=100
> >
> > # Vectors holding the null "correlations" (for pearson, for spearman,
> for kendall and dcor respectively) for each # of the nsim null datasets at
> a #given noise level
> > val.cor=val.cors=val.cork=val.dcor=rep(NA,nsim)
> >
> > # Vectors holding the alternative "correlations" (for pearson, for
> #spearman, for kendall and dcor respectively) #for each of the nsim2
> alternative datasets at a given noise level
> > val.cor2=val.cors2=val.cork2=val.dcor2= rep(NA,nsim2)
> >
> >
> > # Arrays holding the estimated power for each of the 4 "correlation"
> types, for each data type (linear, #parabolic, etc...) with each noise level
> > power.cor=power.cors=power.cork=power.dcor= array(NA, c(8,num.noise))
> >
> > ## We loop through the noise level and functional form; each time we
> #estimate a null distribution based on #the marginals of the data, and then
> #use that null distribution to estimate power
> > ## We use a uniformly distributed x, because in the original paper the
> #authors used the same
> >
> > for(l in 1:num.noise) {
> >
> >        for(typ in 1:8) {
> >
> > ## This next loop simulates data under the null with the correct
> marginals (x is uniform, and y is a function of a #uniform with gaussian
> noise)
> >
> >      for(ii in 1:nsim) {
> >        x=runif(n)
> >
> > #lin+noise
> > if(typ==1) {
> > y=x+ noise *(l/num.noise)* rnorm(n)
> > }
> >
> > #parabolic+noise
> > if(typ==2) {
> > y=4*(x-.5)^2+  noise * (l/num.noise) * rnorm(n)
> > }
> >
> > #cubic+noise
> > if(typ==3) {
> > y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise  * (l/num.noise)
> *rnorm(n)
> > }
> >
> > #sin+noise
> > if(typ==4) {
> > y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
> > }
> >
> > #their sine + noise
> > if(typ==5) {
> > y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
> > }
> >
> > #x^(1/4) + noise
> > if(typ==6) {
> > y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
> > }
> >
> > #circle
> > if(typ==7) {
> > y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise
> *rnorm(n)
> > }
> >
> > #step function
> > if(typ==8) {
> > y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
> > }
> >
> > # We resimulate x so that we have the null scenario
> > x <- runif(n)
> >
> > # Calculate the 4 correlations
> > val.cor[ii]=(cor(x,y))
> > val.cors[ii]=(cor(x,y,method=c("spearman")))
> > val.cork[ii]=(cor(x,y,method=c("kendal")))
> > val.dcor[ii]=dcor(x,y)
> > }
> >
> > ## Next we calculate our 4 rejection cutoffs
> > cut.cor=quantile(val.cor,.95)
> > cut.cors=quantile(val.cors,.95)
> > cut.cork=quantile(val.cork,.95)
> > cut.dcor=quantile(val.dcor,.95)
> >
> > ## Next we simulate the data again, this time under the alternative
> >
> >      for(ii in 1:nsim2) {
> >        x=runif(n)
> >
> > #lin+noise
> > if(typ==1) {
> > y=x+ noise *(l/num.noise)* rnorm(n)
> > }
> >
> > #parabolic+noise
> > if(typ==2) {
> > y=4*(x-.5)^2+  noise * (l/num.noise) * rnorm(n)
> > }
> >
> > #cubic+noise
> > if(typ==3) {
> > y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise  * (l/num.noise)
> *rnorm(n)
> > }
> >
> > #sin+noise
> > if(typ==4) {
> > y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
> > }
> >
> > #their sine + noise
> > if(typ==5) {
> > y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
> > }
> >
> > #x^(1/4) + noise
> > if(typ==6) {
> > y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
> > }
> >
> > #circle
> > if(typ==7) {
> > y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise
> *rnorm(n)
> > }
> >
> > #step function
> > if(typ==8) {
> > y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
> > }
> >
> > ## We again calculate our 4 "correlations"
> > val.cor2[ii]=(cor(x,y))
> > val.cors2[ii]=(cor(x,y,method=c("spearman")))
> > val.cork2[ii]=(cor(x,y,method=c("kendal")))
> > val.dcor2[ii]=dcor(x,y)
> > }
> >
> > ## Now we estimate the power as the number of alternative statistics
> #exceeding our estimated cutoffs
> > power.cor[typ,l] <- sum(val.cor2 > cut.cor)/nsim2
> > power.cors[typ,l] <- sum(val.cors2 > cut.cor)/nsim2
> > power.cork[typ,l] <- sum(val.cork2 > cut.cor)/nsim2
> > power.dcor[typ,l] <- sum(val.dcor2 > cut.dcor)/nsim2
> > }
> > }
> >
> > save.image()
> >
> > ## The rest of the code is for plotting the image
> > pdf("power.pdf")
> > par(mfrow = c(4,2), cex = 0.45)
> > plot((1:30)/10, power.cor[1,], ylim = c(0,1), main = "Linear", xlab =
> "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> > points((1:30)/10, power.cors[1,], pch = 2, col = "green", type = 'b')
> > points((1:30)/10, power.cork[1,], pch = 3, col = "blue", type = 'b')
> > points((1:30)/10, power.dcor[1,], pch = 4, col = "red", type = 'b')
> > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
> pch = c(1,2,3), col = c("black","green","blue","red"))
> >
> > plot((1:30)/10, power.cor[2,], ylim = c(0,1), main = "Quadratic", xlab =
> "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> > points((1:30)/10, power.cors[2,], pch = 2, col = "green", type = 'b')
> > points((1:30)/10, power.cork[2,], pch = 3, col = "blue", type = 'b')
> > points((1:30)/10, power.dcor[2,], pch = 4, col = "red", type = 'b')
> > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
> pch = c(1,2,3), col = c("black","green","blue","red"))
> >
> > plot((1:30)/10, power.cor[3,], ylim = c(0,1), main = "Cubic", xlab =
> "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> > points((1:30)/10, power.cors[3,], pch = 2, col = "green", type = 'b')
> > points((1:30)/10, power.cork[3,], pch = 3, col = "blue", type = 'b')
> > points((1:30)/10, power.dcor[3,], pch = 4, col = "red", type = 'b')
> > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
> pch = c(1,2,3), col = c("black","green","blue","red"))
> >
> > plot((1:30)/10, power.cor[5,], ylim = c(0,1), main = "Sine: period 1/8",
> xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> > points((1:30)/10, power.cors[5,], pch = 2, col = "green", type = 'b')
> > points((1:30)/10, power.cork[5,], pch = 3, col = "blue", type = 'b')
> > points((1:30)/10, power.dcor[5,], pch = 4, col = "red", type = 'b')
> > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
> pch = c(1,2,3), col = c("black","green","blue","red"))
> >
> > plot((1:30)/10, power.cor[4,], ylim = c(0,1), main = "Sine: period 1/2",
> xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> > points((1:30)/10, power.cors[4,], pch = 2, col = "green", type = 'b')
> > points((1:30)/10, power.cork[4,], pch = 3, col = "blue", type = 'b')
> > points((1:30)/10, power.dcor[4,], pch = 4, col = "red", type = 'b')
> > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
> pch = c(1,2,3), col = c("black","green","blue","red"))
> >
> > plot((1:30)/10, power.cor[6,], ylim = c(0,1), main = "X^(1/4)", xlab =
> "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> > points((1:30)/10, power.cors[6,], pch = 2, col = "green", type = 'b')
> > points((1:30)/10, power.cork[6,], pch = 3, col = "blue", type = 'b')
> > points((1:30)/10, power.dcor[6,], pch = 4, col = "red", type = 'b')
> > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
> pch = c(1,2,3), col = c("black","green","blue","red"))
> >
> > plot((1:30)/10, power.cor[7,], ylim = c(0,1), main = "Circle", xlab =
> "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> > points((1:30)/10, power.cors[7,], pch = 2, col = "green", type = 'b')
> > points((1:30)/10, power.cork[7,], pch = 3, col = "blue", type = 'b')
> > points((1:30)/10, power.dcor[7,], pch = 4, col = "red", type = 'b')
> > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
> pch = c(1,2,3), col = c("black","green","blue","red"))
> >
> > plot((1:30)/10, power.cor[8,], ylim = c(0,1), main = "Step function",
> xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> > points((1:30)/10, power.cors[8,], pch = 2, col = "green", type = 'b')
> > points((1:30)/10, power.cork[8,], pch = 3, col = "blue", type = 'b')
> > points((1:30)/10, power.dcor[8,], pch = 4, col = "red", type = 'b')
> > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
> pch = c(1,2,3), col = c("black","green","blue","red"))
> >
> > #################
> >
> > ______________________________________________
> > R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> > https://stat.ethz.ch/mailman/listinfo/r-help
> > PLEASE do read the posting guide
> http://www.R-project.org/posting-guide.html
> > and provide commented, minimal, self-contained, reproducible code.
> >
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide
> http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
>

	[[alternative HTML version deleted]]


From petr@p|k@| @end|ng |rom prechez@@cz  Mon May 10 11:16:12 2021
From: petr@p|k@| @end|ng |rom prechez@@cz (PIKAL Petr)
Date: Mon, 10 May 2021 09:16:12 +0000
Subject: [R] Analysing data with repeated measure variable
In-Reply-To: <CANSYM40wKq0c9Vp6PyCAZJrV-bNH4Xve1vHuYq1knC+SQyWS3g@mail.gmail.com>
References: <CANSYM40wKq0c9Vp6PyCAZJrV-bNH4Xve1vHuYq1knC+SQyWS3g@mail.gmail.com>
Message-ID: <067287e10d634933bf25ce89652dca0b@SRVEXCHCM1302.precheza.cz>

Hi

Do not post in HTML, if you do not want your data to be messed.
see 

?ifelse and/or logical operations
maybe ?sort or ?order and ?min
maybe ?merge

Cheers
Petr

> -----Original Message-----
> From: R-help <r-help-bounces at r-project.org> On Behalf Of Ahmad Raza
> Sent: Thursday, May 6, 2021 9:41 PM
> To: r-help at r-project.org
> Subject: [R] Analysing data with repeated measure variable
> 
> Dear Experts,
> Greetings
> 
> I have the following type of repeated measures data (table 1), and events
> data in table 2 (single measure). I want to perform the following tasks (in R
> or excel sheet please).
> 
>    - To filter subjects who had any response at least 3 days.
>    - Response should be > 5 in each day.
>    - Then table 1 should have another column, date first response recorded.
>    - Then both tables should be merged
> 
> Table 1 ? Response Data
> 
> Sub_No    Response     Date1          5          01-Jan1          5
>       02-Jan2          5          01-Jan2          10         02-Jan2
>         10         03-Jan2          10         04-Jan2          10
>     05-Jan3          10         01-Jan3          10         02-Jan3
>       10         03-Jan4          5          01-Jan4          5
>   02-Jan4          10         03-Jan4          10         04-Jan4
>     10         05-Jan
> 
> 
> Table 2 ? Event Data
> 
> Sub_No   Response        Date1          No2         Yes          30
> Jan3         Yes          29 Jan4          No
> 
> Thanks for your help.
> Regards,
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-
> guide.html
> and provide commented, minimal, self-contained, reproducible code.

From w||||@mwdun|@p @end|ng |rom gm@||@com  Mon May 10 17:17:38 2021
From: w||||@mwdun|@p @end|ng |rom gm@||@com (Bill Dunlap)
Date: Mon, 10 May 2021 08:17:38 -0700
Subject: [R] No error message but don't get the 8 graphs
In-Reply-To: <CAGxFJbTdN4e9RtgFVBsPA1ktbNXo66KpQ6d9=Tv7LveNz3OqxQ@mail.gmail.com>
References: <294893856.3283193.1620585572644.ref@mail.yahoo.com>
 <294893856.3283193.1620585572644@mail.yahoo.com>
 <b9186679-16a2-d6e4-afac-eecebbba7e01@sapo.pt>
 <1115549345.3369846.1620597015000@mail.yahoo.com>
 <CAGxFJbTdN4e9RtgFVBsPA1ktbNXo66KpQ6d9=Tv7LveNz3OqxQ@mail.gmail.com>
Message-ID: <CAHqSRuR52W2to6UYMe_Mmv500AZx9CwMz7s7+oR4kcsVocN=ww@mail.gmail.com>

Also, normalizePath("power.pdf").

On Sun, May 9, 2021 at 5:13 PM Bert Gunter <bgunter.4567 at gmail.com> wrote:

> ?getwd
>
> Bert Gunter
>
> "The trouble with having an open mind is that people keep coming along and
> sticking things into it."
> -- Opus (aka Berkeley Breathed in his "Bloom County" comic strip )
>
>
> On Sun, May 9, 2021 at 2:59 PM varin sacha via R-help <
> r-help at r-project.org>
> wrote:
>
> > Rui,
> >
> > The created pdf.file is off-screen device. Indeed after dev.off() I
> should
> > view the pdf file on my computer. But I don't find it. Where do I find
> the
> > pdf.file ?
> >
> > Regards,
> >
> >
> >
> > Le dimanche 9 mai 2021 ? 22:44:22 UTC+2, Rui Barradas <
> > ruipbarradas at sapo.pt> a ?crit :
> >
> >
> >
> >
> >
> > Hello,
> >
> > You are not closing the pdf device.
> > The only changes I have made to your code are right at the beginning of
> > the plotting instructions and at the end of the code.
> >
> >
> > ## The rest of the code is for plotting the image
> > pdf(file = "power.pdf")
> > op <- par(mfrow = c(4,2), cex = 0.45)
> >
> > [...]
> >
> > par(op)
> > dev.off()
> > #################
> >
> > The comments only line is your last code line.
> > The result is attached.
> >
> > Hope this helps,
> >
> > Rui Barradas
> >
> > ?s 19:39 de 09/05/21, varin sacha via R-help escreveu:
> > > Dear R-experts,
> > >
> > > I am trying to get the 8 graphs like the ones in this paper :
> > > https://statweb.stanford.edu/~tibs/reshef/comment.pdf
> > > My R code does not show any error message neither warnings but I d'on't
> > get what I would like to get (I mean the 8 graphs), so I am missing
> > something. What's it ? Many thanks for your precious help.
> > >
> > > #################
> > > set.seed(1)
> > > library(energy)
> > >
> > > # Here we define parameters which we use to simulate the data
> > > # The number of null datasets we use to estimate our rejection reject
> > #regions for an alternative with level 0.05
> > > nsim=50
> > >
> > > # Number of alternative datasets we use to estimate our power
> > > nsim2=50
> > >
> > > # The number of different noise levels used
> > > num.noise <- 30
> > >
> > > # A constant to determine the amount of noise
> > > noise <- 3
> > >
> > > # Number of data points per simulation
> > > n=100
> > >
> > > # Vectors holding the null "correlations" (for pearson, for spearman,
> > for kendall and dcor respectively) for each # of the nsim null datasets
> at
> > a #given noise level
> > > val.cor=val.cors=val.cork=val.dcor=rep(NA,nsim)
> > >
> > > # Vectors holding the alternative "correlations" (for pearson, for
> > #spearman, for kendall and dcor respectively) #for each of the nsim2
> > alternative datasets at a given noise level
> > > val.cor2=val.cors2=val.cork2=val.dcor2= rep(NA,nsim2)
> > >
> > >
> > > # Arrays holding the estimated power for each of the 4 "correlation"
> > types, for each data type (linear, #parabolic, etc...) with each noise
> level
> > > power.cor=power.cors=power.cork=power.dcor= array(NA, c(8,num.noise))
> > >
> > > ## We loop through the noise level and functional form; each time we
> > #estimate a null distribution based on #the marginals of the data, and
> then
> > #use that null distribution to estimate power
> > > ## We use a uniformly distributed x, because in the original paper the
> > #authors used the same
> > >
> > > for(l in 1:num.noise) {
> > >
> > >        for(typ in 1:8) {
> > >
> > > ## This next loop simulates data under the null with the correct
> > marginals (x is uniform, and y is a function of a #uniform with gaussian
> > noise)
> > >
> > >      for(ii in 1:nsim) {
> > >        x=runif(n)
> > >
> > > #lin+noise
> > > if(typ==1) {
> > > y=x+ noise *(l/num.noise)* rnorm(n)
> > > }
> > >
> > > #parabolic+noise
> > > if(typ==2) {
> > > y=4*(x-.5)^2+  noise * (l/num.noise) * rnorm(n)
> > > }
> > >
> > > #cubic+noise
> > > if(typ==3) {
> > > y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise  * (l/num.noise)
> > *rnorm(n)
> > > }
> > >
> > > #sin+noise
> > > if(typ==4) {
> > > y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
> > > }
> > >
> > > #their sine + noise
> > > if(typ==5) {
> > > y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
> > > }
> > >
> > > #x^(1/4) + noise
> > > if(typ==6) {
> > > y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
> > > }
> > >
> > > #circle
> > > if(typ==7) {
> > > y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise
> > *rnorm(n)
> > > }
> > >
> > > #step function
> > > if(typ==8) {
> > > y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
> > > }
> > >
> > > # We resimulate x so that we have the null scenario
> > > x <- runif(n)
> > >
> > > # Calculate the 4 correlations
> > > val.cor[ii]=(cor(x,y))
> > > val.cors[ii]=(cor(x,y,method=c("spearman")))
> > > val.cork[ii]=(cor(x,y,method=c("kendal")))
> > > val.dcor[ii]=dcor(x,y)
> > > }
> > >
> > > ## Next we calculate our 4 rejection cutoffs
> > > cut.cor=quantile(val.cor,.95)
> > > cut.cors=quantile(val.cors,.95)
> > > cut.cork=quantile(val.cork,.95)
> > > cut.dcor=quantile(val.dcor,.95)
> > >
> > > ## Next we simulate the data again, this time under the alternative
> > >
> > >      for(ii in 1:nsim2) {
> > >        x=runif(n)
> > >
> > > #lin+noise
> > > if(typ==1) {
> > > y=x+ noise *(l/num.noise)* rnorm(n)
> > > }
> > >
> > > #parabolic+noise
> > > if(typ==2) {
> > > y=4*(x-.5)^2+  noise * (l/num.noise) * rnorm(n)
> > > }
> > >
> > > #cubic+noise
> > > if(typ==3) {
> > > y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise  * (l/num.noise)
> > *rnorm(n)
> > > }
> > >
> > > #sin+noise
> > > if(typ==4) {
> > > y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
> > > }
> > >
> > > #their sine + noise
> > > if(typ==5) {
> > > y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
> > > }
> > >
> > > #x^(1/4) + noise
> > > if(typ==6) {
> > > y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
> > > }
> > >
> > > #circle
> > > if(typ==7) {
> > > y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise
> > *rnorm(n)
> > > }
> > >
> > > #step function
> > > if(typ==8) {
> > > y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
> > > }
> > >
> > > ## We again calculate our 4 "correlations"
> > > val.cor2[ii]=(cor(x,y))
> > > val.cors2[ii]=(cor(x,y,method=c("spearman")))
> > > val.cork2[ii]=(cor(x,y,method=c("kendal")))
> > > val.dcor2[ii]=dcor(x,y)
> > > }
> > >
> > > ## Now we estimate the power as the number of alternative statistics
> > #exceeding our estimated cutoffs
> > > power.cor[typ,l] <- sum(val.cor2 > cut.cor)/nsim2
> > > power.cors[typ,l] <- sum(val.cors2 > cut.cor)/nsim2
> > > power.cork[typ,l] <- sum(val.cork2 > cut.cor)/nsim2
> > > power.dcor[typ,l] <- sum(val.dcor2 > cut.dcor)/nsim2
> > > }
> > > }
> > >
> > > save.image()
> > >
> > > ## The rest of the code is for plotting the image
> > > pdf("power.pdf")
> > > par(mfrow = c(4,2), cex = 0.45)
> > > plot((1:30)/10, power.cor[1,], ylim = c(0,1), main = "Linear", xlab =
> > "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> > > points((1:30)/10, power.cors[1,], pch = 2, col = "green", type = 'b')
> > > points((1:30)/10, power.cork[1,], pch = 3, col = "blue", type = 'b')
> > > points((1:30)/10, power.dcor[1,], pch = 4, col = "red", type = 'b')
> > > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
> > pch = c(1,2,3), col = c("black","green","blue","red"))
> > >
> > > plot((1:30)/10, power.cor[2,], ylim = c(0,1), main = "Quadratic", xlab
> =
> > "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> > > points((1:30)/10, power.cors[2,], pch = 2, col = "green", type = 'b')
> > > points((1:30)/10, power.cork[2,], pch = 3, col = "blue", type = 'b')
> > > points((1:30)/10, power.dcor[2,], pch = 4, col = "red", type = 'b')
> > > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
> > pch = c(1,2,3), col = c("black","green","blue","red"))
> > >
> > > plot((1:30)/10, power.cor[3,], ylim = c(0,1), main = "Cubic", xlab =
> > "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> > > points((1:30)/10, power.cors[3,], pch = 2, col = "green", type = 'b')
> > > points((1:30)/10, power.cork[3,], pch = 3, col = "blue", type = 'b')
> > > points((1:30)/10, power.dcor[3,], pch = 4, col = "red", type = 'b')
> > > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
> > pch = c(1,2,3), col = c("black","green","blue","red"))
> > >
> > > plot((1:30)/10, power.cor[5,], ylim = c(0,1), main = "Sine: period
> 1/8",
> > xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> > > points((1:30)/10, power.cors[5,], pch = 2, col = "green", type = 'b')
> > > points((1:30)/10, power.cork[5,], pch = 3, col = "blue", type = 'b')
> > > points((1:30)/10, power.dcor[5,], pch = 4, col = "red", type = 'b')
> > > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
> > pch = c(1,2,3), col = c("black","green","blue","red"))
> > >
> > > plot((1:30)/10, power.cor[4,], ylim = c(0,1), main = "Sine: period
> 1/2",
> > xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> > > points((1:30)/10, power.cors[4,], pch = 2, col = "green", type = 'b')
> > > points((1:30)/10, power.cork[4,], pch = 3, col = "blue", type = 'b')
> > > points((1:30)/10, power.dcor[4,], pch = 4, col = "red", type = 'b')
> > > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
> > pch = c(1,2,3), col = c("black","green","blue","red"))
> > >
> > > plot((1:30)/10, power.cor[6,], ylim = c(0,1), main = "X^(1/4)", xlab =
> > "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> > > points((1:30)/10, power.cors[6,], pch = 2, col = "green", type = 'b')
> > > points((1:30)/10, power.cork[6,], pch = 3, col = "blue", type = 'b')
> > > points((1:30)/10, power.dcor[6,], pch = 4, col = "red", type = 'b')
> > > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
> > pch = c(1,2,3), col = c("black","green","blue","red"))
> > >
> > > plot((1:30)/10, power.cor[7,], ylim = c(0,1), main = "Circle", xlab =
> > "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> > > points((1:30)/10, power.cors[7,], pch = 2, col = "green", type = 'b')
> > > points((1:30)/10, power.cork[7,], pch = 3, col = "blue", type = 'b')
> > > points((1:30)/10, power.dcor[7,], pch = 4, col = "red", type = 'b')
> > > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
> > pch = c(1,2,3), col = c("black","green","blue","red"))
> > >
> > > plot((1:30)/10, power.cor[8,], ylim = c(0,1), main = "Step function",
> > xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> > > points((1:30)/10, power.cors[8,], pch = 2, col = "green", type = 'b')
> > > points((1:30)/10, power.cork[8,], pch = 3, col = "blue", type = 'b')
> > > points((1:30)/10, power.dcor[8,], pch = 4, col = "red", type = 'b')
> > > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
> > pch = c(1,2,3), col = c("black","green","blue","red"))
> > >
> > > #################
> > >
> > > ______________________________________________
> > > R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> > > https://stat.ethz.ch/mailman/listinfo/r-help
> > > PLEASE do read the posting guide
> > http://www.R-project.org/posting-guide.html
> > > and provide commented, minimal, self-contained, reproducible code.
> > >
> >
> > ______________________________________________
> > R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> > https://stat.ethz.ch/mailman/listinfo/r-help
> > PLEASE do read the posting guide
> > http://www.R-project.org/posting-guide.html
> > and provide commented, minimal, self-contained, reproducible code.
> >
>
>         [[alternative HTML version deleted]]
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide
> http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
>

	[[alternative HTML version deleted]]


From ch@|@b|@e|@he @end|ng |rom y@hoo@de  Tue May 11 13:11:46 2021
From: ch@|@b|@e|@he @end|ng |rom y@hoo@de (Elahe chalabi)
Date: Tue, 11 May 2021 11:11:46 +0000 (UTC)
Subject: [R] Group by and duplicate a value/dplyr
References: <1222077831.4309120.1620731506656.ref@mail.yahoo.com>
Message-ID: <1222077831.4309120.1620731506656@mail.yahoo.com>

Hi all,

I have the following data frame?


dput(df)
? ??structure(list(Department = c("A", "A", "A", "A", "A", "A", "A",?
"A", "B", "B", "B", "B", "B", "B", "B", "B"), Class = c(1L, 1L,?
1L, 1L, 2L, 2L, 2L, 2L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L), Value = c(0L,?
100L, 800L, 800L, 0L, 300L, 1200L, 1200L, 0L, 0L, 400L, 400L,?
200L, 800L, 1200L, 1200L)), class = "data.frame", row.names = c(NA,?
-16L))


I would like to group by "Department" and "Class" and repeat the minimum value of "Valule" excluding zeros or get the second minimum value. The desired output is:


? ??dput(df)
? ??structure(list(Department = c("A", "A", "A", "A", "A", "A", "A",?
"A", "B", "B", "B", "B", "B", "B", "B", "B"), Class = c(1L, 1L,?
1L, 1L, 2L, 2L, 2L, 2L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L), Value = c(0L,?
100L, 800L, 800L, 0L, 300L, 1200L, 1200L, 0L, 0L, 400L, 400L,?
200L, 800L, 1200L, 1200L), MinValue = c(100L, 100L, 100L, 100L,?
300L, 300L, 300L, 300L, 400L, 400L, 400L, 400L, 200L, 200L, 200L,?
200L)), class = "data.frame", row.names = c(NA, -16L))

? ?
how should I change the following dplyr to give me the desired output??


? ?df <-?
? df %>%
? group_by(Department,Class) %>%
? mutate(MinValue=min(Value) )


Thanks for any help.
Elahe


From gerr|t@e|chner @end|ng |rom m@th@un|-g|e@@en@de  Tue May 11 13:26:10 2021
From: gerr|t@e|chner @end|ng |rom m@th@un|-g|e@@en@de (Gerrit Eichner)
Date: Tue, 11 May 2021 13:26:10 +0200
Subject: [R] Group by and duplicate a value/dplyr
In-Reply-To: <1222077831.4309120.1620731506656@mail.yahoo.com>
References: <1222077831.4309120.1620731506656.ref@mail.yahoo.com>
 <1222077831.4309120.1620731506656@mail.yahoo.com>
Message-ID: <fe15327d-599e-965c-3bcb-eb86a0b21c5b@math.uni-giessen.de>

Homework?

Try maybe

mutate(MinValue = min(Value[Value != 0]) )

or

mutate(MinValue = sort(unique(Value))[2])

  Hth  --  Gerrit

---------------------------------------------------------------------
Dr. Gerrit Eichner                   Mathematical Institute, Room 212
gerrit.eichner at math.uni-giessen.de   Justus-Liebig-University Giessen
Tel: +49-(0)641-99-32104          Arndtstr. 2, 35392 Giessen, Germany
http://www.uni-giessen.de/eichner
---------------------------------------------------------------------

Am 11.05.2021 um 13:11 schrieb Elahe chalabi via R-help:
> Hi all,
> 
> I have the following data frame
> 
> 
> dput(df)
>  ? ??structure(list(Department = c("A", "A", "A", "A", "A", "A", "A",
> "A", "B", "B", "B", "B", "B", "B", "B", "B"), Class = c(1L, 1L,
> 1L, 1L, 2L, 2L, 2L, 2L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L), Value = c(0L,
> 100L, 800L, 800L, 0L, 300L, 1200L, 1200L, 0L, 0L, 400L, 400L,
> 200L, 800L, 1200L, 1200L)), class = "data.frame", row.names = c(NA,
> -16L))
> 
> 
> I would like to group by "Department" and "Class" and repeat the minimum value of "Valule" excluding zeros or get the second minimum value. The desired output is:
> 
> 
>  ? ??dput(df)
>  ? ??structure(list(Department = c("A", "A", "A", "A", "A", "A", "A",
> "A", "B", "B", "B", "B", "B", "B", "B", "B"), Class = c(1L, 1L,
> 1L, 1L, 2L, 2L, 2L, 2L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L), Value = c(0L,
> 100L, 800L, 800L, 0L, 300L, 1200L, 1200L, 0L, 0L, 400L, 400L,
> 200L, 800L, 1200L, 1200L), MinValue = c(100L, 100L, 100L, 100L,
> 300L, 300L, 300L, 300L, 400L, 400L, 400L, 400L, 200L, 200L, 200L,
> 200L)), class = "data.frame", row.names = c(NA, -16L))
> 
>     
> how should I change the following dplyr to give me the desired output?
> 
> 
>  ? ?df <-
>  ? df %>%
>  ? group_by(Department,Class) %>%
>  ? mutate(MinValue=min(Value) )
> 
> 
> Thanks for any help.
> Elahe
> 
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
>


From petr@p|k@| @end|ng |rom prechez@@cz  Tue May 11 13:27:42 2021
From: petr@p|k@| @end|ng |rom prechez@@cz (PIKAL Petr)
Date: Tue, 11 May 2021 11:27:42 +0000
Subject: [R] FW:  Group by and duplicate a value/dplyr
In-Reply-To: <d2435deb59f54329bc09bfd6c5da7295@SRVEXCHCM1302.precheza.cz>
References: <1222077831.4309120.1620731506656.ref@mail.yahoo.com>
 <1222077831.4309120.1620731506656@mail.yahoo.com>
 <d2435deb59f54329bc09bfd6c5da7295@SRVEXCHCM1302.precheza.cz>
Message-ID: <b7b75f61bf2f4245b252cc244091524a@SRVEXCHCM1302.precheza.cz>

I forgot to cc to rhelp.

Petr

Hi
Dunno how to do it by dplyr
I would use ave

df$MinValue <- ave(df$Value, paste(df$Class, df$Department), FUN =
function(x)
min(x[x>0]))

Cheers
Petr



> > -----Original Message-----
> > From: R-help <r-help-bounces at r-project.org> On Behalf Of Elahe chalabi
> via
> > R-help
> > Sent: Tuesday, May 11, 2021 1:12 PM
> > To: R-help Mailing List <r-help at r-project.org>
> > Subject: [R] Group by and duplicate a value/dplyr
> >
> > Hi all,
> >
> > I have the following data frame
> >
> >
> > dput(df)
> >     structure(list(Department = c("A", "A", "A", "A", "A", "A", "A", "A",
> > "B", "B",
> > "B", "B", "B", "B", "B", "B"), Class = c(1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L, 
> > 1L,
> > 1L, 1L, 1L,
> > 2L, 2L, 2L, 2L), Value = c(0L, 100L, 800L, 800L, 0L, 300L, 1200L, 1200L, 
> > 0L,
> > 0L,
> > 400L, 400L, 200L, 800L, 1200L, 1200L)), class = "data.frame", row.names =
> > c(NA,
> > -16L))
> >
> >
> > I would like to group by "Department" and "Class" and repeat the minimum
> > value of "Valule" excluding zeros or get the second minimum value. The
> > desired output is:
> >
> >
> >     dput(df)
> >     structure(list(Department = c("A", "A", "A", "A", "A", "A", "A", "A",
> > "B", "B",
> > "B", "B", "B", "B", "B", "B"), Class = c(1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L, 
> > 1L,
> > 1L, 1L, 1L,
> > 2L, 2L, 2L, 2L), Value = c(0L, 100L, 800L, 800L, 0L, 300L, 1200L, 1200L, 
> > 0L,
> > 0L,
> > 400L, 400L, 200L, 800L, 1200L, 1200L), MinValue = c(100L, 100L, 100L, 
> > 100L,
> > 300L, 300L, 300L, 300L, 400L, 400L, 400L, 400L, 200L, 200L, 200L, 200L)),
> > class =
> > "data.frame", row.names = c(NA, -16L))
> >
> >
> > how should I change the following dplyr to give me the desired output?
> >
> >
> >    df <-
> >   df %>%
> >   group_by(Department,Class) %>%
> >   mutate(MinValue=min(Value) )
> >
> >
> > Thanks for any help.
> > Elahe
> >
> > ______________________________________________
> > R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> > https://stat.ethz.ch/mailman/listinfo/r-help
> > PLEASE do read the posting guide http://www.R-project.org/posting-
> > guide.html
> > and provide commented, minimal, self-contained, reproducible code.

From ru|pb@rr@d@@ @end|ng |rom @@po@pt  Tue May 11 13:39:20 2021
From: ru|pb@rr@d@@ @end|ng |rom @@po@pt (Rui Barradas)
Date: Tue, 11 May 2021 12:39:20 +0100
Subject: [R] Group by and duplicate a value/dplyr
In-Reply-To: <1222077831.4309120.1620731506656@mail.yahoo.com>
References: <1222077831.4309120.1620731506656.ref@mail.yahoo.com>
 <1222077831.4309120.1620731506656@mail.yahoo.com>
Message-ID: <628d0bcc-8918-dd2d-b453-3679d91da5b0@sapo.pt>

Hello,

This can be done by getting the min of Value[Value != 0].
In the code that follows I have named the expected output df2 and 
assigned the result to df3 and df4.


library(dplyr)

df3 <- df %>%
   group_by(Department,Class) %>%
   mutate(flag = Value != 0,
     MinValue = min(Value[flag]) ) %>%
   select(-flag)

identical(df2$MinValue, df3$MinValue)
#[1] TRUE


Or, simpler:


df4 <- df %>%
   group_by(Department,Class) %>%
   mutate(MinValue = min(Value[Value != 0]) )

identical(df2$MinValue, df4$MinValue)
#[1] TRUE


Hope this helps,

Rui Barradas



?s 12:11 de 11/05/21, Elahe chalabi via R-help escreveu:
> Hi all,
> 
> I have the following data frame
> 
> 
> dput(df)
>  ? ??structure(list(Department = c("A", "A", "A", "A", "A", "A", "A",
> "A", "B", "B", "B", "B", "B", "B", "B", "B"), Class = c(1L, 1L,
> 1L, 1L, 2L, 2L, 2L, 2L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L), Value = c(0L,
> 100L, 800L, 800L, 0L, 300L, 1200L, 1200L, 0L, 0L, 400L, 400L,
> 200L, 800L, 1200L, 1200L)), class = "data.frame", row.names = c(NA,
> -16L))
> 
> 
> I would like to group by "Department" and "Class" and repeat the minimum value of "Valule" excluding zeros or get the second minimum value. The desired output is:
> 
> 
>  ? ??dput(df)
>  ? ??structure(list(Department = c("A", "A", "A", "A", "A", "A", "A",
> "A", "B", "B", "B", "B", "B", "B", "B", "B"), Class = c(1L, 1L,
> 1L, 1L, 2L, 2L, 2L, 2L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L), Value = c(0L,
> 100L, 800L, 800L, 0L, 300L, 1200L, 1200L, 0L, 0L, 400L, 400L,
> 200L, 800L, 1200L, 1200L), MinValue = c(100L, 100L, 100L, 100L,
> 300L, 300L, 300L, 300L, 400L, 400L, 400L, 400L, 200L, 200L, 200L,
> 200L)), class = "data.frame", row.names = c(NA, -16L))
> 
>     
> how should I change the following dplyr to give me the desired output?
> 
> 
>  ? ?df <-
>  ? df %>%
>  ? group_by(Department,Class) %>%
>  ? mutate(MinValue=min(Value) )
> 
> 
> Thanks for any help.
> Elahe
> 
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
>


From ch@|@b|@e|@he @end|ng |rom y@hoo@de  Tue May 11 13:40:57 2021
From: ch@|@b|@e|@he @end|ng |rom y@hoo@de (Elahe chalabi)
Date: Tue, 11 May 2021 11:40:57 +0000 (UTC)
Subject: [R] Group by and duplicate a value/dplyr
In-Reply-To: <fe15327d-599e-965c-3bcb-eb86a0b21c5b@math.uni-giessen.de>
References: <1222077831.4309120.1620731506656.ref@mail.yahoo.com>
 <1222077831.4309120.1620731506656@mail.yahoo.com>
 <fe15327d-599e-965c-3bcb-eb86a0b21c5b@math.uni-giessen.de>
Message-ID: <903693759.4419750.1620733257904@mail.yahoo.com>

Hello Gerit

mutate(MinValue = min(Value[Value != 0]) )? or? mutate(MinValue = sort(unique(Value))[2]) only mutates one value which is 100, it doesnt mutate minimum?Value != 0 per group by element








On Tuesday, May 11, 2021, 01:26:49 PM GMT+2, Gerrit Eichner <gerrit.eichner at math.uni-giessen.de> wrote: 





Homework?

Try maybe

mutate(MinValue = min(Value[Value != 0]) )

or

mutate(MinValue = sort(unique(Value))[2])

? Hth? --? Gerrit

---------------------------------------------------------------------
Dr. Gerrit Eichner? ? ? ? ? ? ? ? ? Mathematical Institute, Room 212
gerrit.eichner at math.uni-giessen.de? Justus-Liebig-University Giessen
Tel: +49-(0)641-99-32104? ? ? ? ? Arndtstr. 2, 35392 Giessen, Germany
http://www.uni-giessen.de/eichner
---------------------------------------------------------------------

Am 11.05.2021 um 13:11 schrieb Elahe chalabi via R-help:
> Hi all,
> 
> I have the following data frame
> 
> 
> dput(df)
>? ? ??structure(list(Department = c("A", "A", "A", "A", "A", "A", "A",
> "A", "B", "B", "B", "B", "B", "B", "B", "B"), Class = c(1L, 1L,
> 1L, 1L, 2L, 2L, 2L, 2L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L), Value = c(0L,
> 100L, 800L, 800L, 0L, 300L, 1200L, 1200L, 0L, 0L, 400L, 400L,
> 200L, 800L, 1200L, 1200L)), class = "data.frame", row.names = c(NA,
> -16L))
> 
> 
> I would like to group by "Department" and "Class" and repeat the minimum value of "Valule" excluding zeros or get the second minimum value. The desired output is:
> 
> 
>? ? ??dput(df)
>? ? ??structure(list(Department = c("A", "A", "A", "A", "A", "A", "A",
> "A", "B", "B", "B", "B", "B", "B", "B", "B"), Class = c(1L, 1L,
> 1L, 1L, 2L, 2L, 2L, 2L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L), Value = c(0L,
> 100L, 800L, 800L, 0L, 300L, 1200L, 1200L, 0L, 0L, 400L, 400L,
> 200L, 800L, 1200L, 1200L), MinValue = c(100L, 100L, 100L, 100L,
> 300L, 300L, 300L, 300L, 400L, 400L, 400L, 400L, 200L, 200L, 200L,
> 200L)), class = "data.frame", row.names = c(NA, -16L))
> 
>? ? 
> how should I change the following dplyr to give me the desired output?
> 
> 
>? ? ?df <-
>? ? df %>%
>? ? group_by(Department,Class) %>%
>? ? mutate(MinValue=min(Value) )
> 
> 
> Thanks for any help.
> Elahe

> 
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
>

______________________________________________
R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
https://stat.ethz.ch/mailman/listinfo/r-help
PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
and provide commented, minimal, self-contained, reproducible code.


From ch@|@b|@e|@he @end|ng |rom y@hoo@de  Tue May 11 14:07:11 2021
From: ch@|@b|@e|@he @end|ng |rom y@hoo@de (Elahe chalabi)
Date: Tue, 11 May 2021 12:07:11 +0000 (UTC)
Subject: [R] FW:  Group by and duplicate a value/dplyr
In-Reply-To: <b7b75f61bf2f4245b252cc244091524a@SRVEXCHCM1302.precheza.cz>
References: <1222077831.4309120.1620731506656.ref@mail.yahoo.com>
 <1222077831.4309120.1620731506656@mail.yahoo.com>
 <d2435deb59f54329bc09bfd6c5da7295@SRVEXCHCM1302.precheza.cz>
 <b7b75f61bf2f4245b252cc244091524a@SRVEXCHCM1302.precheza.cz>
Message-ID: <1365945208.4420132.1620734831580@mail.yahoo.com>

Hi Petr,

Thanks for your help! it works perfectly fine.?






On Tuesday, May 11, 2021, 01:36:50 PM GMT+2, PIKAL Petr <petr.pikal at precheza.cz> wrote: 





I forgot to cc to rhelp.

Petr


Hi
Dunno how to do it by dplyr
I would use ave

df$MinValue <- ave(df$Value, paste(df$Class, df$Department), FUN =
function(x)
min(x[x>0]))

Cheers
Petr



> > -----Original Message-----
> > From: R-help <r-help-bounces at r-project.org> On Behalf Of Elahe chalabi
> via
> > R-help
> > Sent: Tuesday, May 11, 2021 1:12 PM
> > To: R-help Mailing List <r-help at r-project.org>
> > Subject: [R] Group by and duplicate a value/dplyr
> >
> > Hi all,
> >
> > I have the following data frame
> >
> >
> > dput(df)
> >? ? structure(list(Department = c("A", "A", "A", "A", "A", "A", "A", "A",
> > "B", "B",
> > "B", "B", "B", "B", "B", "B"), Class = c(1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L, 
> > 1L,
> > 1L, 1L, 1L,
> > 2L, 2L, 2L, 2L), Value = c(0L, 100L, 800L, 800L, 0L, 300L, 1200L, 1200L, 
> > 0L,
> > 0L,
> > 400L, 400L, 200L, 800L, 1200L, 1200L)), class = "data.frame", row.names =
> > c(NA,
> > -16L))
> >
> >
> > I would like to group by "Department" and "Class" and repeat the minimum
> > value of "Valule" excluding zeros or get the second minimum value. The
> > desired output is:
> >
> >
> >? ? dput(df)
> >? ? structure(list(Department = c("A", "A", "A", "A", "A", "A", "A", "A",
> > "B", "B",
> > "B", "B", "B", "B", "B", "B"), Class = c(1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L, 
> > 1L,
> > 1L, 1L, 1L,
> > 2L, 2L, 2L, 2L), Value = c(0L, 100L, 800L, 800L, 0L, 300L, 1200L, 1200L, 
> > 0L,
> > 0L,
> > 400L, 400L, 200L, 800L, 1200L, 1200L), MinValue = c(100L, 100L, 100L, 
> > 100L,
> > 300L, 300L, 300L, 300L, 400L, 400L, 400L, 400L, 200L, 200L, 200L, 200L)),
> > class =
> > "data.frame", row.names = c(NA, -16L))
> >
> >
> > how should I change the following dplyr to give me the desired output?
> >
> >
> >? ? df <-
> >? df %>%
> >? group_by(Department,Class) %>%
> >? mutate(MinValue=min(Value) )
> >
> >
> > Thanks for any help.
> > Elahe
> >
> > ______________________________________________
> > R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> > https://stat.ethz.ch/mailman/listinfo/r-help
> > PLEASE do read the posting guide http://www.R-project.org/posting-
> > guide.html
> > and provide commented, minimal, self-contained, reproducible code.
______________________________________________
R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
https://stat.ethz.ch/mailman/listinfo/r-help
PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
and provide commented, minimal, self-contained, reproducible code.


From gerr|t@e|chner @end|ng |rom m@th@un|-g|e@@en@de  Tue May 11 15:10:45 2021
From: gerr|t@e|chner @end|ng |rom m@th@un|-g|e@@en@de (Gerrit Eichner)
Date: Tue, 11 May 2021 15:10:45 +0200
Subject: [R] Group by and duplicate a value/dplyr
In-Reply-To: <903693759.4419750.1620733257904@mail.yahoo.com>
References: <1222077831.4309120.1620731506656.ref@mail.yahoo.com>
 <1222077831.4309120.1620731506656@mail.yahoo.com>
 <fe15327d-599e-965c-3bcb-eb86a0b21c5b@math.uni-giessen.de>
 <903693759.4419750.1620733257904@mail.yahoo.com>
Message-ID: <dec6b8b9-4374-b4a3-5aac-defc1031a071@math.uni-giessen.de>

Hello, Elahe,

you were, of course, supposed to insert my suggested
code-snippet into you code and test it therein ...

  Regards  --  Gerrit

---------------------------------------------------------------------
Dr. Gerrit Eichner                   Mathematical Institute, Room 212
gerrit.eichner at math.uni-giessen.de   Justus-Liebig-University Giessen
Tel: +49-(0)641-99-32104          Arndtstr. 2, 35392 Giessen, Germany
http://www.uni-giessen.de/eichner
---------------------------------------------------------------------

Am 11.05.2021 um 13:40 schrieb Elahe chalabi:
> Hello Gerit
> 
> mutate(MinValue = min(Value[Value != 0]) )? or? mutate(MinValue = sort(unique(Value))[2]) only mutates one value which is 100, it doesnt mutate minimum?Value != 0 per group by element
> 
> 
> 
> 
> 
> 
> 
> 
> On Tuesday, May 11, 2021, 01:26:49 PM GMT+2, Gerrit Eichner <gerrit.eichner at math.uni-giessen.de> wrote:
> 
> 
> 
> 
> 
> Homework?
> 
> Try maybe
> 
> mutate(MinValue = min(Value[Value != 0]) )
> 
> or
> 
> mutate(MinValue = sort(unique(Value))[2])
> 
>  ? Hth? --? Gerrit
> 
> ---------------------------------------------------------------------
> Dr. Gerrit Eichner? ? ? ? ? ? ? ? ? Mathematical Institute, Room 212
> gerrit.eichner at math.uni-giessen.de? Justus-Liebig-University Giessen
> Tel: +49-(0)641-99-32104? ? ? ? ? Arndtstr. 2, 35392 Giessen, Germany
> http://www.uni-giessen.de/eichner
> ---------------------------------------------------------------------
> 
> Am 11.05.2021 um 13:11 schrieb Elahe chalabi via R-help:
>> Hi all,
>>
>> I have the following data frame
>>
>>
>> dput(df)
>>  ? ? ??structure(list(Department = c("A", "A", "A", "A", "A", "A", "A",
>> "A", "B", "B", "B", "B", "B", "B", "B", "B"), Class = c(1L, 1L,
>> 1L, 1L, 2L, 2L, 2L, 2L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L), Value = c(0L,
>> 100L, 800L, 800L, 0L, 300L, 1200L, 1200L, 0L, 0L, 400L, 400L,
>> 200L, 800L, 1200L, 1200L)), class = "data.frame", row.names = c(NA,
>> -16L))
>>
>>
>> I would like to group by "Department" and "Class" and repeat the minimum value of "Valule" excluding zeros or get the second minimum value. The desired output is:
>>
>>
>>  ? ? ??dput(df)
>>  ? ? ??structure(list(Department = c("A", "A", "A", "A", "A", "A", "A",
>> "A", "B", "B", "B", "B", "B", "B", "B", "B"), Class = c(1L, 1L,
>> 1L, 1L, 2L, 2L, 2L, 2L, 1L, 1L, 1L, 1L, 2L, 2L, 2L, 2L), Value = c(0L,
>> 100L, 800L, 800L, 0L, 300L, 1200L, 1200L, 0L, 0L, 400L, 400L,
>> 200L, 800L, 1200L, 1200L), MinValue = c(100L, 100L, 100L, 100L,
>> 300L, 300L, 300L, 300L, 400L, 400L, 400L, 400L, 200L, 200L, 200L,
>> 200L)), class = "data.frame", row.names = c(NA, -16L))
>>
>>      
>> how should I change the following dplyr to give me the desired output?
>>
>>
>>  ? ? ?df <-
>>  ? ? df %>%
>>  ? ? group_by(Department,Class) %>%
>>  ? ? mutate(MinValue=min(Value) )
>>
>>
>> Thanks for any help.
>> Elahe
> 
>>
>> ______________________________________________
>> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> https://stat.ethz.ch/mailman/listinfo/r-help
>> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
>> and provide commented, minimal, self-contained, reproducible code.
>>
> 
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
>


From S@E|||@on @end|ng |rom LGCGroup@com  Tue May 11 16:20:28 2021
From: S@E|||@on @end|ng |rom LGCGroup@com (Stephen Ellison)
Date: Tue, 11 May 2021 14:20:28 +0000
Subject: [R] calculating area of ellipse
Message-ID: <12cb19b5dcf447b78504324790b5a359@GBDCVPEXC04.corp.lgc-group.com>

> In doing meta-analysis of diagnostic accuracy I produce ellipses of confidence
> and prediction intervals in two dimensions.  How can I calculate the area of
> the ellipse in ggplot2 or base R?

There are established formulae for ellipse area, but I am curious: in a 2-d ellipse with different quantities (eg coefficients for salary and age) represented by the different dimensions, what does 'area' mean?

S


*******************************************************************
This email and any attachments are confidential. Any use...{{dropped:8}}


From j|ox @end|ng |rom mcm@@ter@c@  Tue May 11 16:30:22 2021
From: j|ox @end|ng |rom mcm@@ter@c@ (John Fox)
Date: Tue, 11 May 2021 10:30:22 -0400
Subject: [R] calculating area of ellipse
In-Reply-To: <27354_1620742859_14BEJAU3016065_12cb19b5dcf447b78504324790b5a359@GBDCVPEXC04.corp.lgc-group.com>
References: <27354_1620742859_14BEJAU3016065_12cb19b5dcf447b78504324790b5a359@GBDCVPEXC04.corp.lgc-group.com>
Message-ID: <afc58281-7c2f-0d12-4936-2305e776dfc4@mcmaster.ca>

Dear Stephen,

On 2021-05-11 10:20 a.m., Stephen Ellison wrote:
 >> In doing meta-analysis of diagnostic accuracy I produce ellipses of 
confidence
 >> and prediction intervals in two dimensions.  How can I calculate the 
area of
 >> the ellipse in ggplot2 or base R?
 >
 > There are established formulae for ellipse area, but I am curious: in 
a 2-d ellipse with different quantities (eg coefficients for salary and 
age) represented by the different dimensions, what does 'area' mean?

I answered James's question narrowly, but the point you raise is correct 
-- the area isn't directly interpretable unless the coefficients are 
measured in the same units.

It still may be possible to compare areas of ellipsoids for, say, 
different regressions with the same predictors, as ratios, however, 
since these ratios would be unaffected by rescaling the coefficients. 
The generalization of this idea to ellipsoids of any dimension is the 
basis for the generalized variance-inflation factors computed by the 
vif() function in the car package.

Best,
  John

John Fox, Professor Emeritus
McMaster University
Hamilton, Ontario, Canada
web: https://socialsciences.mcmaster.ca/jfox/

 >
 > S
 >
 >
 > *******************************************************************
 > This email and any attachments are confidential. Any use...{{dropped:8}}
 >
 > ______________________________________________
 > R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
 > https://stat.ethz.ch/mailman/listinfo/r-help
 > PLEASE do read the posting guide 
http://www.R-project.org/posting-guide.html
 > and provide commented, minimal, self-contained, reproducible code.
 >


From jdnewm|| @end|ng |rom dcn@d@v|@@c@@u@  Tue May 11 16:48:16 2021
From: jdnewm|| @end|ng |rom dcn@d@v|@@c@@u@ (Jeff Newmiller)
Date: Tue, 11 May 2021 07:48:16 -0700
Subject: [R] calculating area of ellipse
In-Reply-To: <afc58281-7c2f-0d12-4936-2305e776dfc4@mcmaster.ca>
References: <27354_1620742859_14BEJAU3016065_12cb19b5dcf447b78504324790b5a359@GBDCVPEXC04.corp.lgc-group.com>
 <afc58281-7c2f-0d12-4936-2305e776dfc4@mcmaster.ca>
Message-ID: <A0F333A3-9581-489D-8012-B9609CFC3159@dcn.davis.ca.us>

The area is a product, not a ratio. There are certainly examples out there of meaningful products of different units, such as distance * force (work) or power " time (work).

If you choose to form a ratio with the area as numerator, you could conceivably obtain the numerator with force snd distance and then meaningfully form a ratio with time (power). So this asserted requirement as to homogeneous units seems inaccurate. But without context I don't know if any of this will aid in interpretation of variance for the OP.

On May 11, 2021 7:30:22 AM PDT, John Fox <jfox at mcmaster.ca> wrote:
>Dear Stephen,
>
>On 2021-05-11 10:20 a.m., Stephen Ellison wrote:
>>> In doing meta-analysis of diagnostic accuracy I produce ellipses of 
>confidence
>>> and prediction intervals in two dimensions.  How can I calculate the
>
>area of
> >> the ellipse in ggplot2 or base R?
> >
>> There are established formulae for ellipse area, but I am curious: in
>
>a 2-d ellipse with different quantities (eg coefficients for salary and
>
>age) represented by the different dimensions, what does 'area' mean?
>
>I answered James's question narrowly, but the point you raise is
>correct 
>-- the area isn't directly interpretable unless the coefficients are 
>measured in the same units.
>
>It still may be possible to compare areas of ellipsoids for, say, 
>different regressions with the same predictors, as ratios, however, 
>since these ratios would be unaffected by rescaling the coefficients. 
>The generalization of this idea to ellipsoids of any dimension is the 
>basis for the generalized variance-inflation factors computed by the 
>vif() function in the car package.
>
>Best,
>  John
>
>John Fox, Professor Emeritus
>McMaster University
>Hamilton, Ontario, Canada
>web: https://socialsciences.mcmaster.ca/jfox/
>
> >
> > S
> >
> >
> > *******************************************************************
>> This email and any attachments are confidential. Any
>use...{{dropped:8}}
> >
> > ______________________________________________
> > R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> > https://stat.ethz.ch/mailman/listinfo/r-help
> > PLEASE do read the posting guide 
>http://www.R-project.org/posting-guide.html
> > and provide commented, minimal, self-contained, reproducible code.
> >
>
>______________________________________________
>R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>https://stat.ethz.ch/mailman/listinfo/r-help
>PLEASE do read the posting guide
>http://www.R-project.org/posting-guide.html
>and provide commented, minimal, self-contained, reproducible code.

-- 
Sent from my phone. Please excuse my brevity.


From ||@t@ @end|ng |rom dewey@myzen@co@uk  Tue May 11 19:06:03 2021
From: ||@t@ @end|ng |rom dewey@myzen@co@uk (Michael Dewey)
Date: Tue, 11 May 2021 18:06:03 +0100
Subject: [R] calculating area of ellipse
In-Reply-To: <12cb19b5dcf447b78504324790b5a359@GBDCVPEXC04.corp.lgc-group.com>
References: <12cb19b5dcf447b78504324790b5a359@GBDCVPEXC04.corp.lgc-group.com>
Message-ID: <5e9ec32c-9ce0-74b3-0f1e-3f422ee11b2c@dewey.myzen.co.uk>

Dear Stephen

In that application the axes would be sensitivity and specificity (or 
their inverses) or some transformation of them like logits so the units 
would be the same. Whether the area has any scientific meaning I am not 
sure.

Michael

On 11/05/2021 15:20, Stephen Ellison wrote:
>> In doing meta-analysis of diagnostic accuracy I produce ellipses of confidence
>> and prediction intervals in two dimensions.  How can I calculate the area of
>> the ellipse in ggplot2 or base R?
> 
> There are established formulae for ellipse area, but I am curious: in a 2-d ellipse with different quantities (eg coefficients for salary and age) represented by the different dimensions, what does 'area' mean?
> 
> S
> 
> 
> *******************************************************************
> This email and any attachments are confidential. Any u...{{dropped:13}}


From j|ox @end|ng |rom mcm@@ter@c@  Tue May 11 19:21:04 2021
From: j|ox @end|ng |rom mcm@@ter@c@ (John Fox)
Date: Tue, 11 May 2021 13:21:04 -0400
Subject: [R] calculating area of ellipse
In-Reply-To: <29148_1620744532_14BEl3Vk006355_A0F333A3-9581-489D-8012-B9609CFC3159@dcn.davis.ca.us>
References: <27354_1620742859_14BEJAU3016065_12cb19b5dcf447b78504324790b5a359@GBDCVPEXC04.corp.lgc-group.com>
 <afc58281-7c2f-0d12-4936-2305e776dfc4@mcmaster.ca>
 <29148_1620744532_14BEl3Vk006355_A0F333A3-9581-489D-8012-B9609CFC3159@dcn.davis.ca.us>
Message-ID: <05da711f-8b93-b064-54dd-9614edfb33c4@mcmaster.ca>

Dear Jeff,

I don't think that it would be sensible to claim that it *never* makes 
sense to multiply quantities measured in different units, but rather 
that this would rarely make sense for regression coefficients. James 
might have a justification for finding the area, but it is still, I 
think, reasonable to point out that doing so may be problematic.

With respect to ratios of areas: I apologize if my examples were 
cryptic. Imagine, for example, that the same regression model is fit to 
two groups and joint-confidence ellipse for two coefficients computed 
for each. The ratio of the two areas would reflect the relative 
precision of the estimates in the two groups, which is unaffected by the 
units of measurement of the coefficients. This is also the idea behind 
generalized variance inflation, where the comparison is to a "utopian" 
situation in which the parameters are uncorrelated. For details, see 
help("vif", package="car") and in particular Fox, J. and Monette, G. 
(1992) Generalized collinearity diagnostics. JASA, 87, 178?183.

Best,
  John


On 2021-05-11 10:48 a.m., Jeff Newmiller wrote:
> The area is a product, not a ratio. There are certainly examples out there of meaningful products of different units, such as distance * force (work) or power " time (work).
> 
> If you choose to form a ratio with the area as numerator, you could conceivably obtain the numerator with force snd distance and then meaningfully form a ratio with time (power). So this asserted requirement as to homogeneous units seems inaccurate. But without context I don't know if any of this will aid in interpretation of variance for the OP.
> 
> On May 11, 2021 7:30:22 AM PDT, John Fox <jfox at mcmaster.ca> wrote:
>> Dear Stephen,
>>
>> On 2021-05-11 10:20 a.m., Stephen Ellison wrote:
>>>> In doing meta-analysis of diagnostic accuracy I produce ellipses of
>> confidence
>>>> and prediction intervals in two dimensions.  How can I calculate the
>>
>> area of
>>>> the ellipse in ggplot2 or base R?
>>>
>>> There are established formulae for ellipse area, but I am curious: in
>>
>> a 2-d ellipse with different quantities (eg coefficients for salary and
>>
>> age) represented by the different dimensions, what does 'area' mean?
>>
>> I answered James's question narrowly, but the point you raise is
>> correct
>> -- the area isn't directly interpretable unless the coefficients are
>> measured in the same units.
>>
>> It still may be possible to compare areas of ellipsoids for, say,
>> different regressions with the same predictors, as ratios, however,
>> since these ratios would be unaffected by rescaling the coefficients.
>> The generalization of this idea to ellipsoids of any dimension is the
>> basis for the generalized variance-inflation factors computed by the
>> vif() function in the car package.
>>
>> Best,
>>   John
>>
>> John Fox, Professor Emeritus
>> McMaster University
>> Hamilton, Ontario, Canada
>> web: https://socialsciences.mcmaster.ca/jfox/
>>
>>>
>>> S
>>>
>>>
>>> *******************************************************************
>>> This email and any attachments are confidential. Any
>> use...{{dropped:8}}
>>>
>>> ______________________________________________
>>> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>>> https://stat.ethz.ch/mailman/listinfo/r-help
>>> PLEASE do read the posting guide
>> http://www.R-project.org/posting-guide.html
>>> and provide commented, minimal, self-contained, reproducible code.
>>>
>>
>> ______________________________________________
>> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> https://stat.ethz.ch/mailman/listinfo/r-help
>> PLEASE do read the posting guide
>> http://www.R-project.org/posting-guide.html
>> and provide commented, minimal, self-contained, reproducible code.
>


From v@r|n@@ch@ @end|ng |rom y@hoo@|r  Tue May 11 19:59:51 2021
From: v@r|n@@ch@ @end|ng |rom y@hoo@|r (varin sacha)
Date: Tue, 11 May 2021 17:59:51 +0000 (UTC)
Subject: [R] No error message but don't get the 8 graphs
In-Reply-To: <CAHqSRuR52W2to6UYMe_Mmv500AZx9CwMz7s7+oR4kcsVocN=ww@mail.gmail.com>
References: <294893856.3283193.1620585572644.ref@mail.yahoo.com>
 <294893856.3283193.1620585572644@mail.yahoo.com>
 <b9186679-16a2-d6e4-afac-eecebbba7e01@sapo.pt>
 <1115549345.3369846.1620597015000@mail.yahoo.com>
 <CAGxFJbTdN4e9RtgFVBsPA1ktbNXo66KpQ6d9=Tv7LveNz3OqxQ@mail.gmail.com>
 <CAHqSRuR52W2to6UYMe_Mmv500AZx9CwMz7s7+oR4kcsVocN=ww@mail.gmail.com>
Message-ID: <1754150943.4687777.1620755991674@mail.yahoo.com>

Dear all,

Many thanks for your responses.

Best
S.







Le lundi 10 mai 2021 ? 17:18:59 UTC+2, Bill Dunlap <williamwdunlap at gmail.com> a ?crit : 





Also, normalizePath("power.pdf").

On Sun, May 9, 2021 at 5:13 PM Bert Gunter <bgunter.4567 at gmail.com> wrote:
> ?getwd
> 
> Bert Gunter
> 
> "The trouble with having an open mind is that people keep coming along and
> sticking things into it."
> -- Opus (aka Berkeley Breathed in his "Bloom County" comic strip )
> 
> 
> On Sun, May 9, 2021 at 2:59 PM varin sacha via R-help <r-help at r-project.org>
> wrote:
> 
>> Rui,
>>
>> The created pdf.file is off-screen device. Indeed after dev.off() I should
>> view the pdf file on my computer. But I don't find it. Where do I find the
>> pdf.file ?
>>
>> Regards,
>>
>>
>>
>> Le dimanche 9 mai 2021 ? 22:44:22 UTC+2, Rui Barradas <
>> ruipbarradas at sapo.pt> a ?crit :
>>
>>
>>
>>
>>
>> Hello,
>>
>> You are not closing the pdf device.
>> The only changes I have made to your code are right at the beginning of
>> the plotting instructions and at the end of the code.
>>
>>
>> ## The rest of the code is for plotting the image
>> pdf(file = "power.pdf")
>> op <- par(mfrow = c(4,2), cex = 0.45)
>>
>> [...]
>>
>> par(op)
>> dev.off()
>> #################
>>
>> The comments only line is your last code line.
>> The result is attached.
>>
>> Hope this helps,
>>
>> Rui Barradas
>>
>> ?s 19:39 de 09/05/21, varin sacha via R-help escreveu:
>> > Dear R-experts,
>> >
>> > I am trying to get the 8 graphs like the ones in this paper :
>> > https://statweb.stanford.edu/~tibs/reshef/comment.pdf
>> > My R code does not show any error message neither warnings but I d'on't
>> get what I would like to get (I mean the 8 graphs), so I am missing
>> something. What's it ? Many thanks for your precious help.
>> >
>> > #################
>> > set.seed(1)
>> > library(energy)
>> >
>> > # Here we define parameters which we use to simulate the data
>> > # The number of null datasets we use to estimate our rejection reject
>> #regions for an alternative with level 0.05
>> > nsim=50
>> >
>> > # Number of alternative datasets we use to estimate our power
>> > nsim2=50
>> >
>> > # The number of different noise levels used
>> > num.noise <- 30
>> >
>> > # A constant to determine the amount of noise
>> > noise <- 3
>> >
>> > # Number of data points per simulation
>> > n=100
>> >
>> > # Vectors holding the null "correlations" (for pearson, for spearman,
>> for kendall and dcor respectively) for each # of the nsim null datasets at
>> a #given noise level
>> > val.cor=val.cors=val.cork=val.dcor=rep(NA,nsim)
>> >
>> > # Vectors holding the alternative "correlations" (for pearson, for
>> #spearman, for kendall and dcor respectively) #for each of the nsim2
>> alternative datasets at a given noise level
>> > val.cor2=val.cors2=val.cork2=val.dcor2= rep(NA,nsim2)
>> >
>> >
>> > # Arrays holding the estimated power for each of the 4 "correlation"
>> types, for each data type (linear, #parabolic, etc...) with each noise level
>> > power.cor=power.cors=power.cork=power.dcor= array(NA, c(8,num.noise))
>> >
>> > ## We loop through the noise level and functional form; each time we
>> #estimate a null distribution based on #the marginals of the data, and then
>> #use that null distribution to estimate power
>> > ## We use a uniformly distributed x, because in the original paper the
>> #authors used the same
>> >
>> > for(l in 1:num.noise) {
>> >
>> >? ? ? ? for(typ in 1:8) {
>> >
>> > ## This next loop simulates data under the null with the correct
>> marginals (x is uniform, and y is a function of a #uniform with gaussian
>> noise)
>> >
>> >? ? ? for(ii in 1:nsim) {
>> >? ? ? ? x=runif(n)
>> >
>> > #lin+noise
>> > if(typ==1) {
>> > y=x+ noise *(l/num.noise)* rnorm(n)
>> > }
>> >
>> > #parabolic+noise
>> > if(typ==2) {
>> > y=4*(x-.5)^2+? noise * (l/num.noise) * rnorm(n)
>> > }
>> >
>> > #cubic+noise
>> > if(typ==3) {
>> > y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise? * (l/num.noise)
>> *rnorm(n)
>> > }
>> >
>> > #sin+noise
>> > if(typ==4) {
>> > y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
>> > }
>> >
>> > #their sine + noise
>> > if(typ==5) {
>> > y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
>> > }
>> >
>> > #x^(1/4) + noise
>> > if(typ==6) {
>> > y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
>> > }
>> >
>> > #circle
>> > if(typ==7) {
>> > y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise
>> *rnorm(n)
>> > }
>> >
>> > #step function
>> > if(typ==8) {
>> > y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
>> > }
>> >
>> > # We resimulate x so that we have the null scenario
>> > x <- runif(n)
>> >
>> > # Calculate the 4 correlations
>> > val.cor[ii]=(cor(x,y))
>> > val.cors[ii]=(cor(x,y,method=c("spearman")))
>> > val.cork[ii]=(cor(x,y,method=c("kendal")))
>> > val.dcor[ii]=dcor(x,y)
>> > }
>> >
>> > ## Next we calculate our 4 rejection cutoffs
>> > cut.cor=quantile(val.cor,.95)
>> > cut.cors=quantile(val.cors,.95)
>> > cut.cork=quantile(val.cork,.95)
>> > cut.dcor=quantile(val.dcor,.95)
>> >
>> > ## Next we simulate the data again, this time under the alternative
>> >
>> >? ? ? for(ii in 1:nsim2) {
>> >? ? ? ? x=runif(n)
>> >
>> > #lin+noise
>> > if(typ==1) {
>> > y=x+ noise *(l/num.noise)* rnorm(n)
>> > }
>> >
>> > #parabolic+noise
>> > if(typ==2) {
>> > y=4*(x-.5)^2+? noise * (l/num.noise) * rnorm(n)
>> > }
>> >
>> > #cubic+noise
>> > if(typ==3) {
>> > y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise? * (l/num.noise)
>> *rnorm(n)
>> > }
>> >
>> > #sin+noise
>> > if(typ==4) {
>> > y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
>> > }
>> >
>> > #their sine + noise
>> > if(typ==5) {
>> > y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
>> > }
>> >
>> > #x^(1/4) + noise
>> > if(typ==6) {
>> > y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
>> > }
>> >
>> > #circle
>> > if(typ==7) {
>> > y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise
>> *rnorm(n)
>> > }
>> >
>> > #step function
>> > if(typ==8) {
>> > y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
>> > }
>> >
>> > ## We again calculate our 4 "correlations"
>> > val.cor2[ii]=(cor(x,y))
>> > val.cors2[ii]=(cor(x,y,method=c("spearman")))
>> > val.cork2[ii]=(cor(x,y,method=c("kendal")))
>> > val.dcor2[ii]=dcor(x,y)
>> > }
>> >
>> > ## Now we estimate the power as the number of alternative statistics
>> #exceeding our estimated cutoffs
>> > power.cor[typ,l] <- sum(val.cor2 > cut.cor)/nsim2
>> > power.cors[typ,l] <- sum(val.cors2 > cut.cor)/nsim2
>> > power.cork[typ,l] <- sum(val.cork2 > cut.cor)/nsim2
>> > power.dcor[typ,l] <- sum(val.dcor2 > cut.dcor)/nsim2
>> > }
>> > }
>> >
>> > save.image()
>> >
>> > ## The rest of the code is for plotting the image
>> > pdf("power.pdf")
>> > par(mfrow = c(4,2), cex = 0.45)
>> > plot((1:30)/10, power.cor[1,], ylim = c(0,1), main = "Linear", xlab =
>> "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> > points((1:30)/10, power.cors[1,], pch = 2, col = "green", type = 'b')
>> > points((1:30)/10, power.cork[1,], pch = 3, col = "blue", type = 'b')
>> > points((1:30)/10, power.dcor[1,], pch = 4, col = "red", type = 'b')
>> > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
>> pch = c(1,2,3), col = c("black","green","blue","red"))
>> >
>> > plot((1:30)/10, power.cor[2,], ylim = c(0,1), main = "Quadratic", xlab =
>> "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> > points((1:30)/10, power.cors[2,], pch = 2, col = "green", type = 'b')
>> > points((1:30)/10, power.cork[2,], pch = 3, col = "blue", type = 'b')
>> > points((1:30)/10, power.dcor[2,], pch = 4, col = "red", type = 'b')
>> > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
>> pch = c(1,2,3), col = c("black","green","blue","red"))
>> >
>> > plot((1:30)/10, power.cor[3,], ylim = c(0,1), main = "Cubic", xlab =
>> "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> > points((1:30)/10, power.cors[3,], pch = 2, col = "green", type = 'b')
>> > points((1:30)/10, power.cork[3,], pch = 3, col = "blue", type = 'b')
>> > points((1:30)/10, power.dcor[3,], pch = 4, col = "red", type = 'b')
>> > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
>> pch = c(1,2,3), col = c("black","green","blue","red"))
>> >
>> > plot((1:30)/10, power.cor[5,], ylim = c(0,1), main = "Sine: period 1/8",
>> xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> > points((1:30)/10, power.cors[5,], pch = 2, col = "green", type = 'b')
>> > points((1:30)/10, power.cork[5,], pch = 3, col = "blue", type = 'b')
>> > points((1:30)/10, power.dcor[5,], pch = 4, col = "red", type = 'b')
>> > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
>> pch = c(1,2,3), col = c("black","green","blue","red"))
>> >
>> > plot((1:30)/10, power.cor[4,], ylim = c(0,1), main = "Sine: period 1/2",
>> xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> > points((1:30)/10, power.cors[4,], pch = 2, col = "green", type = 'b')
>> > points((1:30)/10, power.cork[4,], pch = 3, col = "blue", type = 'b')
>> > points((1:30)/10, power.dcor[4,], pch = 4, col = "red", type = 'b')
>> > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
>> pch = c(1,2,3), col = c("black","green","blue","red"))
>> >
>> > plot((1:30)/10, power.cor[6,], ylim = c(0,1), main = "X^(1/4)", xlab =
>> "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> > points((1:30)/10, power.cors[6,], pch = 2, col = "green", type = 'b')
>> > points((1:30)/10, power.cork[6,], pch = 3, col = "blue", type = 'b')
>> > points((1:30)/10, power.dcor[6,], pch = 4, col = "red", type = 'b')
>> > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
>> pch = c(1,2,3), col = c("black","green","blue","red"))
>> >
>> > plot((1:30)/10, power.cor[7,], ylim = c(0,1), main = "Circle", xlab =
>> "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> > points((1:30)/10, power.cors[7,], pch = 2, col = "green", type = 'b')
>> > points((1:30)/10, power.cork[7,], pch = 3, col = "blue", type = 'b')
>> > points((1:30)/10, power.dcor[7,], pch = 4, col = "red", type = 'b')
>> > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
>> pch = c(1,2,3), col = c("black","green","blue","red"))
>> >
>> > plot((1:30)/10, power.cor[8,], ylim = c(0,1), main = "Step function",
>> xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> > points((1:30)/10, power.cors[8,], pch = 2, col = "green", type = 'b')
>> > points((1:30)/10, power.cork[8,], pch = 3, col = "blue", type = 'b')
>> > points((1:30)/10, power.dcor[8,], pch = 4, col = "red", type = 'b')
>> > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
>> pch = c(1,2,3), col = c("black","green","blue","red"))
>> >
>> > #################
>> >
>> > ______________________________________________
>> > R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> > https://stat.ethz.ch/mailman/listinfo/r-help
>> > PLEASE do read the posting guide
>> http://www.R-project.org/posting-guide.html
>> > and provide commented, minimal, self-contained, reproducible code.
>> >
>>
>> ______________________________________________
>> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> https://stat.ethz.ch/mailman/listinfo/r-help
>> PLEASE do read the posting guide
>> http://www.R-project.org/posting-guide.html
>> and provide commented, minimal, self-contained, reproducible code.
>>
> 
> ? ? ? ? [[alternative HTML version deleted]]
> 
> 
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
> 


From v@r|n@@ch@ @end|ng |rom y@hoo@|r  Wed May 12 10:33:27 2021
From: v@r|n@@ch@ @end|ng |rom y@hoo@|r (varin sacha)
Date: Wed, 12 May 2021 08:33:27 +0000 (UTC)
Subject: [R] empty plots !
In-Reply-To: <1754150943.4687777.1620755991674@mail.yahoo.com>
References: <294893856.3283193.1620585572644.ref@mail.yahoo.com>
 <294893856.3283193.1620585572644@mail.yahoo.com>
 <b9186679-16a2-d6e4-afac-eecebbba7e01@sapo.pt>
 <1115549345.3369846.1620597015000@mail.yahoo.com>
 <CAGxFJbTdN4e9RtgFVBsPA1ktbNXo66KpQ6d9=Tv7LveNz3OqxQ@mail.gmail.com>
 <CAHqSRuR52W2to6UYMe_Mmv500AZx9CwMz7s7+oR4kcsVocN=ww@mail.gmail.com>
 <1754150943.4687777.1620755991674@mail.yahoo.com>
Message-ID: <1662076064.4942636.1620808407847@mail.yahoo.com>

Dear Experts,

My R code was perfectly working since I decide to add a 5th correlation coefficient : hoeffdings' D.
fter a google search, I guess I need somewhere in my R code "unlist" but I don't know where !
Here below my R code with 1 error message. At the end I get my 8 plots but they are empty !
Many thanks for your precious help !

################# 
set.seed(1)
library(energy)
library(independence)
library(TauStar)

# Here we define parameters which we use to simulate the data 
# The number of null datasets we use to estimate our rejection reject #regions for an alternative with level 0.05
nsim=50

# Number of alternative datasets we use to estimate our power
nsim2=50

# The number of different noise levels used
num.noise <- 30????????????????????

# A constant to determine the amount of noise
noise <- 3?

# Number of data points per simulation

n=100

# Vectors holding the null "correlations" (for pearson, for spearman, for #kendall, for hoeffding and dcor respectively) for each of the nsim null datasets at a #given noise level
val.cor=val.cors=val.cork=val.dcor=val.hoe=rep(NA,nsim)

# Vectors holding the alternative "correlations" (for pearson, for #spearman, for kendall, for hoeffding and dcor respectively) for each of #the nsim2 #alternative datasets at a given noise level
val.cor2=val.cors2=val.cork2=val.dcor2=val.hoe2= rep(NA,nsim2)
?
# Arrays holding the estimated power for each of the 4 "correlation" types, #for each data type (linear, parabolic, etc...) with each noise level
power.cor=power.cors=power.cork=power.dcor=power.hoe= array(NA, c(8,num.noise))

## We loop through the noise level and functional form; each time we #estimate a null distribution based on the marginals of the data, and then #use that null distribution to estimate power 
## We use a uniformly distributed x, because in the original paper the #authors used the same

for(l in 1:num.noise){??

????? for(typ in 1:8){

## This next loop simulates data under the null with the correct marginals #(x is uniform, and y is a function of a uniform with gaussian noise)
?
??? for(ii in 1:nsim){?????? 
????? x=runif(n)

#lin+noise?????????? ??????????????????????????????????????????????
if(typ==1){????????
y=x+ noise *(l/num.noise)* rnorm(n)??????
}
?
#parabolic+noise
if(typ==2){????????
y=4*(x-.5)^2+? noise * (l/num.noise) * rnorm(n)??????
}

#cubic+noise
if(typ==3){????????
y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise? * (l/num.noise) *rnorm(n)??????
}

#sin+noise
if(typ==4){????????
y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)??????
}

#their sine + noise
if(typ==5){????????
y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)??????
}

#x^(1/4) + noise
if(typ==6){????????
y=x^(1/4) + noise * (l/num.noise) *rnorm(n)??????
}

#circle
if(typ==7){????????
y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise *rnorm(n)??????
}

#step function
if(typ==8){???? ????
y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)??????
}??????

# We resimulate x so that we have the null scenario
x <- runif(n)

# Calculate the 5 correlations????? ??????
val.cor[ii]=(cor(x,y))
val.cors[ii]=(cor(x,y,method=c("spearman")))
val.cork[ii]=(cor(x,y,method=c("kendal")))
val.dcor[ii]=dcor(x,y)??? ?????????
val.hoe[ii]=(hoeffding.D.test(x,y,na.rm=TRUE,collisions=TRUE))??? ?????????
}

## Next we calculate our 5 rejection cutoffs?????????
cut.cor=quantile(val.cor,.95)????
cut.cors=quantile(val.cors,.95)
cut.cork=quantile(val.cork,.95)
cut.dcor=quantile(val.dcor,.95)
cut.hoe=quantile(val.hoe,.95)

## Next we simulate the data again, this time under the alternative

??? for(ii in 1:nsim2){?????? 
????? x=runif(n)

#lin+noise?????????????????????? ??????????????????????????????????
if(typ==1){????????
y=x+ noise *(l/num.noise)* rnorm(n)??????
}

#parabolic+noise
if(typ==2){????????
y=4*(x-.5)^2+? noise * (l/num.noise) * rnorm(n)??????
}

#cubic+noise
if(typ==3){????????
y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise? * (l/num.noise) *rnorm(n)??????
}

#sin+noise
if(typ==4){????????
y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)??????
}

#their sine + noise
if(typ==5){????????
y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)??????
}

#x^(1/4) + noise
if(typ==6){????????
y=x^(1/4) + noise * (l/num.noise) *rnorm(n)??????
}

#circle
if(typ==7){????????
y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise *rnorm(n)??????
}

#step function
if(typ==8){????????
y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)??????
}??????

## We again calculate our 5 correlations?????????????
val.cor2[ii]=(cor(x,y))??????
val.cors2[ii]=(cor(x,y,method=c("spearman")))
val.cork2[ii]=(cor(x,y,method=c("kendal")))
val.dcor2[ii]=dcor(x,y)?
val.hoe2[ii]=(hoeffding.D.test(x,y,na.rm=TRUE,collisions=TRUE))??? ??????????????????????
}

## Now we estimate the power as the number of alternative statistics #exceeding our estimated cutoffs?????????
power.cor[typ,l] <- sum(val.cor2 > cut.cor)/nsim2????
power.cors[typ,l] <- sum(val.cors2 > cut.cor)/nsim2
power.cork[typ,l] <- sum(val.cork2 > cut.cor)/nsim2
power.dcor[typ,l] <- sum(val.dcor2 > cut.dcor)/nsim2
power.hoe[typ,l] <- sum(val.hoe2 > cut.hoe)/nsim2??????
}
}

## The rest of the code is for plotting the image?
par(mfrow = c(4,2), cex = 0.45)
plot((1:30)/10, power.cor[1,], ylim = c(0,1), main = "Linear", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
points((1:30)/10, power.cors[1,], pch = 2, col = "green", type = 'b')
points((1:30)/10, power.cork[1,], pch = 3, col = "blue", type = 'b')
points((1:30)/10, power.dcor[1,], pch = 4, col = "red", type = 'b')
points((1:30)/10, power.hoe[1,], pch = 5, col = "purple", type = 'b')
legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor","hoe" ), pch = c(1,2,3,4,5), col = c("black","green","blue","red",?"purple"))

plot((1:30)/10, power.cor[2,], ylim = c(0,1), main = "Quadratic", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
points((1:30)/10, power.cors[2,], pch = 2, col = "green", type = 'b')
points((1:30)/10, power.cork[2,], pch = 3, col = "blue", type = 'b')
points((1:30)/10, power.dcor[2,], pch = 4, col = "red", type = 'b')
points((1:30)/10, power.hoe[2,], pch = 5, col = "purple", type = 'b')
legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor","hoe" ), pch = c(1,2,3,4,5), col = c("black","green","blue","red",?"purple"))

plot((1:30)/10, power.cor[3,], ylim = c(0,1), main = "Cubic", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
points((1:30)/10, power.cors[3,], pch = 2, col = "green", type = 'b')
points((1:30)/10, power.cork[3,], pch = 3, col = "blue", type = 'b')
points((1:30)/10, power.dcor[3,], pch = 4, col = "red", type = 'b')
points((1:30)/10, power.hoe[3,], pch = 5, col = "purple", type = 'b')
legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor","hoe" ), pch = c(1,2,3,4,5), col = c("black","green","blue","red",?"purple")) 

plot((1:30)/10, power.cor[5,], ylim = c(0,1), main = "Sine: period 1/8", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
points((1:30)/10, power.cors[5,], pch = 2, col = "green", type = 'b')
points((1:30)/10, power.cork[5,], pch = 3, col = "blue", type = 'b')
points((1:30)/10, power.dcor[5,], pch = 4, col = "red", type = 'b')
points((1:30)/10, power.hoe[5,], pch = 5, col = "purple", type = 'b')
legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor","hoe" ), pch = c(1,2,3,4,5), col = c("black","green","blue","red",?"purple")) 

plot((1:30)/10, power.cor[4,], ylim = c(0,1), main = "Sine: period 1/2", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
points((1:30)/10, power.cors[4,], pch = 2, col = "green", type = 'b')
points((1:30)/10, power.cork[4,], pch = 3, col = "blue", type = 'b')
points((1:30)/10, power.dcor[4,], pch = 4, col = "red", type = 'b')
points((1:30)/10, power.hoe[4,], pch = 5, col = "purple", type = 'b')
legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor","hoe" ), pch = c(1,2,3,4,5), col = c("black","green","blue","red",?"purple")) 

plot((1:30)/10, power.cor[6,], ylim = c(0,1), main = "X^(1/4)", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
points((1:30)/10, power.cors[6,], pch = 2, col = "green", type = 'b')
points((1:30)/10, power.cork[6,], pch = 3, col = "blue", type = 'b')
points((1:30)/10, power.dcor[6,], pch = 4, col = "red", type = 'b')
points((1:30)/10, power.hoe[6,], pch = 5, col = "purple", type = 'b')
legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor","hoe" ), pch = c(1,2,3,4,5), col = c("black","green","blue","red",?"purple"))
?
plot((1:30)/10, power.cor[7,], ylim = c(0,1), main = "Circle", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
points((1:30)/10, power.cors[7,], pch = 2, col = "green", type = 'b')
points((1:30)/10, power.cork[7,], pch = 3, col = "blue", type = 'b')
points((1:30)/10, power.dcor[7,], pch = 4, col = "red", type = 'b')
points((1:30)/10, power.hoe[7,], pch = 5, col = "purple", type = 'b')
legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor","hoe" ), pch = c(1,2,3,4,5), col = c("black","green","blue","red",?"purple")) 

plot((1:30)/10, power.cor[8,], ylim = c(0,1), main = "Step function", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
points((1:30)/10, power.cors[8,], pch = 2, col = "green", type = 'b')
points((1:30)/10, power.cork[8,], pch = 3, col = "blue", type = 'b')
points((1:30)/10, power.dcor[8,], pch = 4, col = "red", type = 'b')
points((1:30)/10, power.hoe[8,], pch = 5, col = "purple", type = 'b')
legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor","hoe" ), pch = c(1,2,3,4,5), col = c("black","green","blue","red",?"purple"))
#################

?







Le mardi 11 mai 2021 ? 20:00:49 UTC+2, varin sacha via R-help <r-help at r-project.org> a ?crit : 





Dear all,

Many thanks for your responses.

Best
S.







Le lundi 10 mai 2021 ? 17:18:59 UTC+2, Bill Dunlap <williamwdunlap at gmail.com> a ?crit : 





Also, normalizePath("power.pdf").

On Sun, May 9, 2021 at 5:13 PM Bert Gunter <bgunter.4567 at gmail.com> wrote:
> ?getwd
> 
> Bert Gunter
> 
> "The trouble with having an open mind is that people keep coming along and
> sticking things into it."
> -- Opus (aka Berkeley Breathed in his "Bloom County" comic strip )
> 
> 
> On Sun, May 9, 2021 at 2:59 PM varin sacha via R-help <r-help at r-project.org>
> wrote:
> 
>> Rui,
>>
>> The created pdf.file is off-screen device. Indeed after dev.off() I should
>> view the pdf file on my computer. But I don't find it. Where do I find the
>> pdf.file ?
>>
>> Regards,
>>
>>
>>
>> Le dimanche 9 mai 2021 ? 22:44:22 UTC+2, Rui Barradas <
>> ruipbarradas at sapo.pt> a ?crit :
>>
>>
>>
>>
>>
>> Hello,
>>
>> You are not closing the pdf device.
>> The only changes I have made to your code are right at the beginning of
>> the plotting instructions and at the end of the code.
>>
>>
>> ## The rest of the code is for plotting the image
>> pdf(file = "power.pdf")
>> op <- par(mfrow = c(4,2), cex = 0.45)
>>
>> [...]
>>
>> par(op)
>> dev.off()
>> #################
>>
>> The comments only line is your last code line.
>> The result is attached.
>>
>> Hope this helps,
>>
>> Rui Barradas
>>
>> ?s 19:39 de 09/05/21, varin sacha via R-help escreveu:
>> > Dear R-experts,
>> >
>> > I am trying to get the 8 graphs like the ones in this paper :
>> > https://statweb.stanford.edu/~tibs/reshef/comment.pdf
>> > My R code does not show any error message neither warnings but I d'on't
>> get what I would like to get (I mean the 8 graphs), so I am missing
>> something. What's it ? Many thanks for your precious help.
>> >
>> > #################
>> > set.seed(1)
>> > library(energy)
>> >
>> > # Here we define parameters which we use to simulate the data
>> > # The number of null datasets we use to estimate our rejection reject
>> #regions for an alternative with level 0.05
>> > nsim=50
>> >
>> > # Number of alternative datasets we use to estimate our power
>> > nsim2=50
>> >
>> > # The number of different noise levels used
>> > num.noise <- 30
>> >
>> > # A constant to determine the amount of noise
>> > noise <- 3
>> >
>> > # Number of data points per simulation
>> > n=100
>> >
>> > # Vectors holding the null "correlations" (for pearson, for spearman,
>> for kendall and dcor respectively) for each # of the nsim null datasets at
>> a #given noise level
>> > val.cor=val.cors=val.cork=val.dcor=rep(NA,nsim)
>> >
>> > # Vectors holding the alternative "correlations" (for pearson, for
>> #spearman, for kendall and dcor respectively) #for each of the nsim2
>> alternative datasets at a given noise level
>> > val.cor2=val.cors2=val.cork2=val.dcor2= rep(NA,nsim2)
>> >
>> >
>> > # Arrays holding the estimated power for each of the 4 "correlation"
>> types, for each data type (linear, #parabolic, etc...) with each noise level
>> > power.cor=power.cors=power.cork=power.dcor= array(NA, c(8,num.noise))
>> >
>> > ## We loop through the noise level and functional form; each time we
>> #estimate a null distribution based on #the marginals of the data, and then
>> #use that null distribution to estimate power
>> > ## We use a uniformly distributed x, because in the original paper the
>> #authors used the same
>> >
>> > for(l in 1:num.noise) {
>> >
>> >? ? ? ? for(typ in 1:8) {
>> >
>> > ## This next loop simulates data under the null with the correct
>> marginals (x is uniform, and y is a function of a #uniform with gaussian
>> noise)
>> >
>> >? ? ? for(ii in 1:nsim) {
>> >? ? ? ? x=runif(n)
>> >
>> > #lin+noise
>> > if(typ==1) {
>> > y=x+ noise *(l/num.noise)* rnorm(n)
>> > }
>> >
>> > #parabolic+noise
>> > if(typ==2) {
>> > y=4*(x-.5)^2+? noise * (l/num.noise) * rnorm(n)
>> > }
>> >
>> > #cubic+noise
>> > if(typ==3) {
>> > y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise? * (l/num.noise)
>> *rnorm(n)
>> > }
>> >
>> > #sin+noise
>> > if(typ==4) {
>> > y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
>> > }
>> >
>> > #their sine + noise
>> > if(typ==5) {
>> > y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
>> > }
>> >
>> > #x^(1/4) + noise
>> > if(typ==6) {
>> > y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
>> > }
>> >
>> > #circle
>> > if(typ==7) {
>> > y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise
>> *rnorm(n)
>> > }
>> >
>> > #step function
>> > if(typ==8) {
>> > y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
>> > }
>> >
>> > # We resimulate x so that we have the null scenario
>> > x <- runif(n)
>> >
>> > # Calculate the 4 correlations
>> > val.cor[ii]=(cor(x,y))
>> > val.cors[ii]=(cor(x,y,method=c("spearman")))
>> > val.cork[ii]=(cor(x,y,method=c("kendal")))
>> > val.dcor[ii]=dcor(x,y)
>> > }
>> >
>> > ## Next we calculate our 4 rejection cutoffs
>> > cut.cor=quantile(val.cor,.95)
>> > cut.cors=quantile(val.cors,.95)
>> > cut.cork=quantile(val.cork,.95)
>> > cut.dcor=quantile(val.dcor,.95)
>> >
>> > ## Next we simulate the data again, this time under the alternative
>> >
>> >? ? ? for(ii in 1:nsim2) {
>> >? ? ? ? x=runif(n)
>> >
>> > #lin+noise
>> > if(typ==1) {
>> > y=x+ noise *(l/num.noise)* rnorm(n)
>> > }
>> >
>> > #parabolic+noise
>> > if(typ==2) {
>> > y=4*(x-.5)^2+? noise * (l/num.noise) * rnorm(n)
>> > }
>> >
>> > #cubic+noise
>> > if(typ==3) {
>> > y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise? * (l/num.noise)
>> *rnorm(n)
>> > }
>> >
>> > #sin+noise
>> > if(typ==4) {
>> > y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
>> > }
>> >
>> > #their sine + noise
>> > if(typ==5) {
>> > y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
>> > }
>> >
>> > #x^(1/4) + noise
>> > if(typ==6) {
>> > y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
>> > }
>> >
>> > #circle
>> > if(typ==7) {
>> > y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise
>> *rnorm(n)
>> > }
>> >
>> > #step function
>> > if(typ==8) {
>> > y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
>> > }
>> >
>> > ## We again calculate our 4 "correlations"
>> > val.cor2[ii]=(cor(x,y))
>> > val.cors2[ii]=(cor(x,y,method=c("spearman")))
>> > val.cork2[ii]=(cor(x,y,method=c("kendal")))
>> > val.dcor2[ii]=dcor(x,y)
>> > }
>> >
>> > ## Now we estimate the power as the number of alternative statistics
>> #exceeding our estimated cutoffs
>> > power.cor[typ,l] <- sum(val.cor2 > cut.cor)/nsim2
>> > power.cors[typ,l] <- sum(val.cors2 > cut.cor)/nsim2
>> > power.cork[typ,l] <- sum(val.cork2 > cut.cor)/nsim2
>> > power.dcor[typ,l] <- sum(val.dcor2 > cut.dcor)/nsim2
>> > }
>> > }
>> >
>> > save.image()
>> >
>> > ## The rest of the code is for plotting the image
>> > pdf("power.pdf")
>> > par(mfrow = c(4,2), cex = 0.45)
>> > plot((1:30)/10, power.cor[1,], ylim = c(0,1), main = "Linear", xlab =
>> "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> > points((1:30)/10, power.cors[1,], pch = 2, col = "green", type = 'b')
>> > points((1:30)/10, power.cork[1,], pch = 3, col = "blue", type = 'b')
>> > points((1:30)/10, power.dcor[1,], pch = 4, col = "red", type = 'b')
>> > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
>> pch = c(1,2,3), col = c("black","green","blue","red"))
>> >
>> > plot((1:30)/10, power.cor[2,], ylim = c(0,1), main = "Quadratic", xlab =
>> "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> > points((1:30)/10, power.cors[2,], pch = 2, col = "green", type = 'b')
>> > points((1:30)/10, power.cork[2,], pch = 3, col = "blue", type = 'b')
>> > points((1:30)/10, power.dcor[2,], pch = 4, col = "red", type = 'b')
>> > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
>> pch = c(1,2,3), col = c("black","green","blue","red"))
>> >
>> > plot((1:30)/10, power.cor[3,], ylim = c(0,1), main = "Cubic", xlab =
>> "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> > points((1:30)/10, power.cors[3,], pch = 2, col = "green", type = 'b')
>> > points((1:30)/10, power.cork[3,], pch = 3, col = "blue", type = 'b')
>> > points((1:30)/10, power.dcor[3,], pch = 4, col = "red", type = 'b')
>> > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
>> pch = c(1,2,3), col = c("black","green","blue","red"))
>> >
>> > plot((1:30)/10, power.cor[5,], ylim = c(0,1), main = "Sine: period 1/8",
>> xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> > points((1:30)/10, power.cors[5,], pch = 2, col = "green", type = 'b')
>> > points((1:30)/10, power.cork[5,], pch = 3, col = "blue", type = 'b')
>> > points((1:30)/10, power.dcor[5,], pch = 4, col = "red", type = 'b')
>> > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
>> pch = c(1,2,3), col = c("black","green","blue","red"))
>> >
>> > plot((1:30)/10, power.cor[4,], ylim = c(0,1), main = "Sine: period 1/2",
>> xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> > points((1:30)/10, power.cors[4,], pch = 2, col = "green", type = 'b')
>> > points((1:30)/10, power.cork[4,], pch = 3, col = "blue", type = 'b')
>> > points((1:30)/10, power.dcor[4,], pch = 4, col = "red", type = 'b')
>> > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
>> pch = c(1,2,3), col = c("black","green","blue","red"))
>> >
>> > plot((1:30)/10, power.cor[6,], ylim = c(0,1), main = "X^(1/4)", xlab =
>> "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> > points((1:30)/10, power.cors[6,], pch = 2, col = "green", type = 'b')
>> > points((1:30)/10, power.cork[6,], pch = 3, col = "blue", type = 'b')
>> > points((1:30)/10, power.dcor[6,], pch = 4, col = "red", type = 'b')
>> > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
>> pch = c(1,2,3), col = c("black","green","blue","red"))
>> >
>> > plot((1:30)/10, power.cor[7,], ylim = c(0,1), main = "Circle", xlab =
>> "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> > points((1:30)/10, power.cors[7,], pch = 2, col = "green", type = 'b')
>> > points((1:30)/10, power.cork[7,], pch = 3, col = "blue", type = 'b')
>> > points((1:30)/10, power.dcor[7,], pch = 4, col = "red", type = 'b')
>> > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
>> pch = c(1,2,3), col = c("black","green","blue","red"))
>> >
>> > plot((1:30)/10, power.cor[8,], ylim = c(0,1), main = "Step function",
>> xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> > points((1:30)/10, power.cors[8,], pch = 2, col = "green", type = 'b')
>> > points((1:30)/10, power.cork[8,], pch = 3, col = "blue", type = 'b')
>> > points((1:30)/10, power.dcor[8,], pch = 4, col = "red", type = 'b')
>> > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
>> pch = c(1,2,3), col = c("black","green","blue","red"))
>> >
>> > #################
>> >
>> > ______________________________________________
>> > R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> > https://stat.ethz.ch/mailman/listinfo/r-help
>> > PLEASE do read the posting guide
>> http://www.R-project.org/posting-guide.html
>> > and provide commented, minimal, self-contained, reproducible code.
>> >
>>
>> ______________________________________________
>> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> https://stat.ethz.ch/mailman/listinfo/r-help
>> PLEASE do read the posting guide
>> http://www.R-project.org/posting-guide.html
>> and provide commented, minimal, self-contained, reproducible code.
>>
> 
> ? ? ? ? [[alternative HTML version deleted]]

> 
> 
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
> 

______________________________________________
R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
https://stat.ethz.ch/mailman/listinfo/r-help
PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
and provide commented, minimal, self-contained, reproducible code.


From drj|m|emon @end|ng |rom gm@||@com  Wed May 12 13:03:32 2021
From: drj|m|emon @end|ng |rom gm@||@com (Jim Lemon)
Date: Wed, 12 May 2021 21:03:32 +1000
Subject: [R] empty plots !
In-Reply-To: <1662076064.4942636.1620808407847@mail.yahoo.com>
References: <294893856.3283193.1620585572644.ref@mail.yahoo.com>
 <294893856.3283193.1620585572644@mail.yahoo.com>
 <b9186679-16a2-d6e4-afac-eecebbba7e01@sapo.pt>
 <1115549345.3369846.1620597015000@mail.yahoo.com>
 <CAGxFJbTdN4e9RtgFVBsPA1ktbNXo66KpQ6d9=Tv7LveNz3OqxQ@mail.gmail.com>
 <CAHqSRuR52W2to6UYMe_Mmv500AZx9CwMz7s7+oR4kcsVocN=ww@mail.gmail.com>
 <1754150943.4687777.1620755991674@mail.yahoo.com>
 <1662076064.4942636.1620808407847@mail.yahoo.com>
Message-ID: <CA+8X3fXq-AXPAnKJAkJfWEH=z5AxLCnBX1fogUsHLKUqO9OOXA@mail.gmail.com>

Hi varin,
Were you expecting image files? I don't see any plot device e.g. pdf()
in your code.

Jim

On Wed, May 12, 2021 at 6:34 PM varin sacha via R-help
<r-help at r-project.org> wrote:
>
> Dear Experts,
>
> My R code was perfectly working since I decide to add a 5th correlation coefficient : hoeffdings' D.
> fter a google search, I guess I need somewhere in my R code "unlist" but I don't know where !
> Here below my R code with 1 error message. At the end I get my 8 plots but they are empty !
> Many thanks for your precious help !
>
> #################
> set.seed(1)
> library(energy)
> library(independence)
> library(TauStar)
>
> # Here we define parameters which we use to simulate the data
> # The number of null datasets we use to estimate our rejection reject #regions for an alternative with level 0.05
> nsim=50
>
> # Number of alternative datasets we use to estimate our power
> nsim2=50
>
> # The number of different noise levels used
> num.noise <- 30
>
> # A constant to determine the amount of noise
> noise <- 3
>
> # Number of data points per simulation
>
> n=100
>
> # Vectors holding the null "correlations" (for pearson, for spearman, for #kendall, for hoeffding and dcor respectively) for each of the nsim null datasets at a #given noise level
> val.cor=val.cors=val.cork=val.dcor=val.hoe=rep(NA,nsim)
>
> # Vectors holding the alternative "correlations" (for pearson, for #spearman, for kendall, for hoeffding and dcor respectively) for each of #the nsim2 #alternative datasets at a given noise level
> val.cor2=val.cors2=val.cork2=val.dcor2=val.hoe2= rep(NA,nsim2)
>
> # Arrays holding the estimated power for each of the 4 "correlation" types, #for each data type (linear, parabolic, etc...) with each noise level
> power.cor=power.cors=power.cork=power.dcor=power.hoe= array(NA, c(8,num.noise))
>
> ## We loop through the noise level and functional form; each time we #estimate a null distribution based on the marginals of the data, and then #use that null distribution to estimate power
> ## We use a uniformly distributed x, because in the original paper the #authors used the same
>
> for(l in 1:num.noise){
>
>       for(typ in 1:8){
>
> ## This next loop simulates data under the null with the correct marginals #(x is uniform, and y is a function of a uniform with gaussian noise)
>
>     for(ii in 1:nsim){
>       x=runif(n)
>
> #lin+noise
> if(typ==1){
> y=x+ noise *(l/num.noise)* rnorm(n)
> }
>
> #parabolic+noise
> if(typ==2){
> y=4*(x-.5)^2+  noise * (l/num.noise) * rnorm(n)
> }
>
> #cubic+noise
> if(typ==3){
> y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise  * (l/num.noise) *rnorm(n)
> }
>
> #sin+noise
> if(typ==4){
> y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
> }
>
> #their sine + noise
> if(typ==5){
> y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
> }
>
> #x^(1/4) + noise
> if(typ==6){
> y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
> }
>
> #circle
> if(typ==7){
> y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise *rnorm(n)
> }
>
> #step function
> if(typ==8){
> y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
> }
>
> # We resimulate x so that we have the null scenario
> x <- runif(n)
>
> # Calculate the 5 correlations
> val.cor[ii]=(cor(x,y))
> val.cors[ii]=(cor(x,y,method=c("spearman")))
> val.cork[ii]=(cor(x,y,method=c("kendal")))
> val.dcor[ii]=dcor(x,y)
> val.hoe[ii]=(hoeffding.D.test(x,y,na.rm=TRUE,collisions=TRUE))
> }
>
> ## Next we calculate our 5 rejection cutoffs
> cut.cor=quantile(val.cor,.95)
> cut.cors=quantile(val.cors,.95)
> cut.cork=quantile(val.cork,.95)
> cut.dcor=quantile(val.dcor,.95)
> cut.hoe=quantile(val.hoe,.95)
>
> ## Next we simulate the data again, this time under the alternative
>
>     for(ii in 1:nsim2){
>       x=runif(n)
>
> #lin+noise
> if(typ==1){
> y=x+ noise *(l/num.noise)* rnorm(n)
> }
>
> #parabolic+noise
> if(typ==2){
> y=4*(x-.5)^2+  noise * (l/num.noise) * rnorm(n)
> }
>
> #cubic+noise
> if(typ==3){
> y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise  * (l/num.noise) *rnorm(n)
> }
>
> #sin+noise
> if(typ==4){
> y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
> }
>
> #their sine + noise
> if(typ==5){
> y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
> }
>
> #x^(1/4) + noise
> if(typ==6){
> y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
> }
>
> #circle
> if(typ==7){
> y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise *rnorm(n)
> }
>
> #step function
> if(typ==8){
> y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
> }
>
> ## We again calculate our 5 correlations
> val.cor2[ii]=(cor(x,y))
> val.cors2[ii]=(cor(x,y,method=c("spearman")))
> val.cork2[ii]=(cor(x,y,method=c("kendal")))
> val.dcor2[ii]=dcor(x,y)
> val.hoe2[ii]=(hoeffding.D.test(x,y,na.rm=TRUE,collisions=TRUE))
> }
>
> ## Now we estimate the power as the number of alternative statistics #exceeding our estimated cutoffs
> power.cor[typ,l] <- sum(val.cor2 > cut.cor)/nsim2
> power.cors[typ,l] <- sum(val.cors2 > cut.cor)/nsim2
> power.cork[typ,l] <- sum(val.cork2 > cut.cor)/nsim2
> power.dcor[typ,l] <- sum(val.dcor2 > cut.dcor)/nsim2
> power.hoe[typ,l] <- sum(val.hoe2 > cut.hoe)/nsim2
> }
> }
>
> ## The rest of the code is for plotting the image
> par(mfrow = c(4,2), cex = 0.45)
> plot((1:30)/10, power.cor[1,], ylim = c(0,1), main = "Linear", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[1,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[1,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[1,], pch = 4, col = "red", type = 'b')
> points((1:30)/10, power.hoe[1,], pch = 5, col = "purple", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor","hoe" ), pch = c(1,2,3,4,5), col = c("black","green","blue","red", "purple"))
>
> plot((1:30)/10, power.cor[2,], ylim = c(0,1), main = "Quadratic", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[2,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[2,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[2,], pch = 4, col = "red", type = 'b')
> points((1:30)/10, power.hoe[2,], pch = 5, col = "purple", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor","hoe" ), pch = c(1,2,3,4,5), col = c("black","green","blue","red", "purple"))
>
> plot((1:30)/10, power.cor[3,], ylim = c(0,1), main = "Cubic", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[3,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[3,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[3,], pch = 4, col = "red", type = 'b')
> points((1:30)/10, power.hoe[3,], pch = 5, col = "purple", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor","hoe" ), pch = c(1,2,3,4,5), col = c("black","green","blue","red", "purple"))
>
> plot((1:30)/10, power.cor[5,], ylim = c(0,1), main = "Sine: period 1/8", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[5,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[5,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[5,], pch = 4, col = "red", type = 'b')
> points((1:30)/10, power.hoe[5,], pch = 5, col = "purple", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor","hoe" ), pch = c(1,2,3,4,5), col = c("black","green","blue","red", "purple"))
>
> plot((1:30)/10, power.cor[4,], ylim = c(0,1), main = "Sine: period 1/2", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[4,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[4,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[4,], pch = 4, col = "red", type = 'b')
> points((1:30)/10, power.hoe[4,], pch = 5, col = "purple", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor","hoe" ), pch = c(1,2,3,4,5), col = c("black","green","blue","red", "purple"))
>
> plot((1:30)/10, power.cor[6,], ylim = c(0,1), main = "X^(1/4)", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[6,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[6,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[6,], pch = 4, col = "red", type = 'b')
> points((1:30)/10, power.hoe[6,], pch = 5, col = "purple", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor","hoe" ), pch = c(1,2,3,4,5), col = c("black","green","blue","red", "purple"))
>
> plot((1:30)/10, power.cor[7,], ylim = c(0,1), main = "Circle", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[7,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[7,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[7,], pch = 4, col = "red", type = 'b')
> points((1:30)/10, power.hoe[7,], pch = 5, col = "purple", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor","hoe" ), pch = c(1,2,3,4,5), col = c("black","green","blue","red", "purple"))
>
> plot((1:30)/10, power.cor[8,], ylim = c(0,1), main = "Step function", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[8,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[8,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[8,], pch = 4, col = "red", type = 'b')
> points((1:30)/10, power.hoe[8,], pch = 5, col = "purple", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor","hoe" ), pch = c(1,2,3,4,5), col = c("black","green","blue","red", "purple"))
> #################
>
>
>
>
>
>
>
>
>
> Le mardi 11 mai 2021 ? 20:00:49 UTC+2, varin sacha via R-help <r-help at r-project.org> a ?crit :
>
>
>
>
>
> Dear all,
>
> Many thanks for your responses.
>
> Best
> S.
>
>
>
>
>
>
>
> Le lundi 10 mai 2021 ? 17:18:59 UTC+2, Bill Dunlap <williamwdunlap at gmail.com> a ?crit :
>
>
>
>
>
> Also, normalizePath("power.pdf").
>
> On Sun, May 9, 2021 at 5:13 PM Bert Gunter <bgunter.4567 at gmail.com> wrote:
> > ?getwd
> >
> > Bert Gunter
> >
> > "The trouble with having an open mind is that people keep coming along and
> > sticking things into it."
> > -- Opus (aka Berkeley Breathed in his "Bloom County" comic strip )
> >
> >
> > On Sun, May 9, 2021 at 2:59 PM varin sacha via R-help <r-help at r-project.org>
> > wrote:
> >
> >> Rui,
> >>
> >> The created pdf.file is off-screen device. Indeed after dev.off() I should
> >> view the pdf file on my computer. But I don't find it. Where do I find the
> >> pdf.file ?
> >>
> >> Regards,
> >>
> >>
> >>
> >> Le dimanche 9 mai 2021 ? 22:44:22 UTC+2, Rui Barradas <
> >> ruipbarradas at sapo.pt> a ?crit :
> >>
> >>
> >>
> >>
> >>
> >> Hello,
> >>
> >> You are not closing the pdf device.
> >> The only changes I have made to your code are right at the beginning of
> >> the plotting instructions and at the end of the code.
> >>
> >>
> >> ## The rest of the code is for plotting the image
> >> pdf(file = "power.pdf")
> >> op <- par(mfrow = c(4,2), cex = 0.45)
> >>
> >> [...]
> >>
> >> par(op)
> >> dev.off()
> >> #################
> >>
> >> The comments only line is your last code line.
> >> The result is attached.
> >>
> >> Hope this helps,
> >>
> >> Rui Barradas
> >>
> >> ?s 19:39 de 09/05/21, varin sacha via R-help escreveu:
> >> > Dear R-experts,
> >> >
> >> > I am trying to get the 8 graphs like the ones in this paper :
> >> > https://statweb.stanford.edu/~tibs/reshef/comment.pdf
> >> > My R code does not show any error message neither warnings but I d'on't
> >> get what I would like to get (I mean the 8 graphs), so I am missing
> >> something. What's it ? Many thanks for your precious help.
> >> >
> >> > #################
> >> > set.seed(1)
> >> > library(energy)
> >> >
> >> > # Here we define parameters which we use to simulate the data
> >> > # The number of null datasets we use to estimate our rejection reject
> >> #regions for an alternative with level 0.05
> >> > nsim=50
> >> >
> >> > # Number of alternative datasets we use to estimate our power
> >> > nsim2=50
> >> >
> >> > # The number of different noise levels used
> >> > num.noise <- 30
> >> >
> >> > # A constant to determine the amount of noise
> >> > noise <- 3
> >> >
> >> > # Number of data points per simulation
> >> > n=100
> >> >
> >> > # Vectors holding the null "correlations" (for pearson, for spearman,
> >> for kendall and dcor respectively) for each # of the nsim null datasets at
> >> a #given noise level
> >> > val.cor=val.cors=val.cork=val.dcor=rep(NA,nsim)
> >> >
> >> > # Vectors holding the alternative "correlations" (for pearson, for
> >> #spearman, for kendall and dcor respectively) #for each of the nsim2
> >> alternative datasets at a given noise level
> >> > val.cor2=val.cors2=val.cork2=val.dcor2= rep(NA,nsim2)
> >> >
> >> >
> >> > # Arrays holding the estimated power for each of the 4 "correlation"
> >> types, for each data type (linear, #parabolic, etc...) with each noise level
> >> > power.cor=power.cors=power.cork=power.dcor= array(NA, c(8,num.noise))
> >> >
> >> > ## We loop through the noise level and functional form; each time we
> >> #estimate a null distribution based on #the marginals of the data, and then
> >> #use that null distribution to estimate power
> >> > ## We use a uniformly distributed x, because in the original paper the
> >> #authors used the same
> >> >
> >> > for(l in 1:num.noise) {
> >> >
> >> >        for(typ in 1:8) {
> >> >
> >> > ## This next loop simulates data under the null with the correct
> >> marginals (x is uniform, and y is a function of a #uniform with gaussian
> >> noise)
> >> >
> >> >      for(ii in 1:nsim) {
> >> >        x=runif(n)
> >> >
> >> > #lin+noise
> >> > if(typ==1) {
> >> > y=x+ noise *(l/num.noise)* rnorm(n)
> >> > }
> >> >
> >> > #parabolic+noise
> >> > if(typ==2) {
> >> > y=4*(x-.5)^2+  noise * (l/num.noise) * rnorm(n)
> >> > }
> >> >
> >> > #cubic+noise
> >> > if(typ==3) {
> >> > y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise  * (l/num.noise)
> >> *rnorm(n)
> >> > }
> >> >
> >> > #sin+noise
> >> > if(typ==4) {
> >> > y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
> >> > }
> >> >
> >> > #their sine + noise
> >> > if(typ==5) {
> >> > y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
> >> > }
> >> >
> >> > #x^(1/4) + noise
> >> > if(typ==6) {
> >> > y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
> >> > }
> >> >
> >> > #circle
> >> > if(typ==7) {
> >> > y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise
> >> *rnorm(n)
> >> > }
> >> >
> >> > #step function
> >> > if(typ==8) {
> >> > y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
> >> > }
> >> >
> >> > # We resimulate x so that we have the null scenario
> >> > x <- runif(n)
> >> >
> >> > # Calculate the 4 correlations
> >> > val.cor[ii]=(cor(x,y))
> >> > val.cors[ii]=(cor(x,y,method=c("spearman")))
> >> > val.cork[ii]=(cor(x,y,method=c("kendal")))
> >> > val.dcor[ii]=dcor(x,y)
> >> > }
> >> >
> >> > ## Next we calculate our 4 rejection cutoffs
> >> > cut.cor=quantile(val.cor,.95)
> >> > cut.cors=quantile(val.cors,.95)
> >> > cut.cork=quantile(val.cork,.95)
> >> > cut.dcor=quantile(val.dcor,.95)
> >> >
> >> > ## Next we simulate the data again, this time under the alternative
> >> >
> >> >      for(ii in 1:nsim2) {
> >> >        x=runif(n)
> >> >
> >> > #lin+noise
> >> > if(typ==1) {
> >> > y=x+ noise *(l/num.noise)* rnorm(n)
> >> > }
> >> >
> >> > #parabolic+noise
> >> > if(typ==2) {
> >> > y=4*(x-.5)^2+  noise * (l/num.noise) * rnorm(n)
> >> > }
> >> >
> >> > #cubic+noise
> >> > if(typ==3) {
> >> > y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise  * (l/num.noise)
> >> *rnorm(n)
> >> > }
> >> >
> >> > #sin+noise
> >> > if(typ==4) {
> >> > y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
> >> > }
> >> >
> >> > #their sine + noise
> >> > if(typ==5) {
> >> > y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
> >> > }
> >> >
> >> > #x^(1/4) + noise
> >> > if(typ==6) {
> >> > y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
> >> > }
> >> >
> >> > #circle
> >> > if(typ==7) {
> >> > y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise
> >> *rnorm(n)
> >> > }
> >> >
> >> > #step function
> >> > if(typ==8) {
> >> > y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
> >> > }
> >> >
> >> > ## We again calculate our 4 "correlations"
> >> > val.cor2[ii]=(cor(x,y))
> >> > val.cors2[ii]=(cor(x,y,method=c("spearman")))
> >> > val.cork2[ii]=(cor(x,y,method=c("kendal")))
> >> > val.dcor2[ii]=dcor(x,y)
> >> > }
> >> >
> >> > ## Now we estimate the power as the number of alternative statistics
> >> #exceeding our estimated cutoffs
> >> > power.cor[typ,l] <- sum(val.cor2 > cut.cor)/nsim2
> >> > power.cors[typ,l] <- sum(val.cors2 > cut.cor)/nsim2
> >> > power.cork[typ,l] <- sum(val.cork2 > cut.cor)/nsim2
> >> > power.dcor[typ,l] <- sum(val.dcor2 > cut.dcor)/nsim2
> >> > }
> >> > }
> >> >
> >> > save.image()
> >> >
> >> > ## The rest of the code is for plotting the image
> >> > pdf("power.pdf")
> >> > par(mfrow = c(4,2), cex = 0.45)
> >> > plot((1:30)/10, power.cor[1,], ylim = c(0,1), main = "Linear", xlab =
> >> "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> >> > points((1:30)/10, power.cors[1,], pch = 2, col = "green", type = 'b')
> >> > points((1:30)/10, power.cork[1,], pch = 3, col = "blue", type = 'b')
> >> > points((1:30)/10, power.dcor[1,], pch = 4, col = "red", type = 'b')
> >> > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
> >> pch = c(1,2,3), col = c("black","green","blue","red"))
> >> >
> >> > plot((1:30)/10, power.cor[2,], ylim = c(0,1), main = "Quadratic", xlab =
> >> "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> >> > points((1:30)/10, power.cors[2,], pch = 2, col = "green", type = 'b')
> >> > points((1:30)/10, power.cork[2,], pch = 3, col = "blue", type = 'b')
> >> > points((1:30)/10, power.dcor[2,], pch = 4, col = "red", type = 'b')
> >> > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
> >> pch = c(1,2,3), col = c("black","green","blue","red"))
> >> >
> >> > plot((1:30)/10, power.cor[3,], ylim = c(0,1), main = "Cubic", xlab =
> >> "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> >> > points((1:30)/10, power.cors[3,], pch = 2, col = "green", type = 'b')
> >> > points((1:30)/10, power.cork[3,], pch = 3, col = "blue", type = 'b')
> >> > points((1:30)/10, power.dcor[3,], pch = 4, col = "red", type = 'b')
> >> > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
> >> pch = c(1,2,3), col = c("black","green","blue","red"))
> >> >
> >> > plot((1:30)/10, power.cor[5,], ylim = c(0,1), main = "Sine: period 1/8",
> >> xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> >> > points((1:30)/10, power.cors[5,], pch = 2, col = "green", type = 'b')
> >> > points((1:30)/10, power.cork[5,], pch = 3, col = "blue", type = 'b')
> >> > points((1:30)/10, power.dcor[5,], pch = 4, col = "red", type = 'b')
> >> > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
> >> pch = c(1,2,3), col = c("black","green","blue","red"))
> >> >
> >> > plot((1:30)/10, power.cor[4,], ylim = c(0,1), main = "Sine: period 1/2",
> >> xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> >> > points((1:30)/10, power.cors[4,], pch = 2, col = "green", type = 'b')
> >> > points((1:30)/10, power.cork[4,], pch = 3, col = "blue", type = 'b')
> >> > points((1:30)/10, power.dcor[4,], pch = 4, col = "red", type = 'b')
> >> > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
> >> pch = c(1,2,3), col = c("black","green","blue","red"))
> >> >
> >> > plot((1:30)/10, power.cor[6,], ylim = c(0,1), main = "X^(1/4)", xlab =
> >> "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> >> > points((1:30)/10, power.cors[6,], pch = 2, col = "green", type = 'b')
> >> > points((1:30)/10, power.cork[6,], pch = 3, col = "blue", type = 'b')
> >> > points((1:30)/10, power.dcor[6,], pch = 4, col = "red", type = 'b')
> >> > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
> >> pch = c(1,2,3), col = c("black","green","blue","red"))
> >> >
> >> > plot((1:30)/10, power.cor[7,], ylim = c(0,1), main = "Circle", xlab =
> >> "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> >> > points((1:30)/10, power.cors[7,], pch = 2, col = "green", type = 'b')
> >> > points((1:30)/10, power.cork[7,], pch = 3, col = "blue", type = 'b')
> >> > points((1:30)/10, power.dcor[7,], pch = 4, col = "red", type = 'b')
> >> > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
> >> pch = c(1,2,3), col = c("black","green","blue","red"))
> >> >
> >> > plot((1:30)/10, power.cor[8,], ylim = c(0,1), main = "Step function",
> >> xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> >> > points((1:30)/10, power.cors[8,], pch = 2, col = "green", type = 'b')
> >> > points((1:30)/10, power.cork[8,], pch = 3, col = "blue", type = 'b')
> >> > points((1:30)/10, power.dcor[8,], pch = 4, col = "red", type = 'b')
> >> > legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
> >> pch = c(1,2,3), col = c("black","green","blue","red"))
> >> >
> >> > #################
> >> >
> >> > ______________________________________________
> >> > R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> >> > https://stat.ethz.ch/mailman/listinfo/r-help
> >> > PLEASE do read the posting guide
> >> http://www.R-project.org/posting-guide.html
> >> > and provide commented, minimal, self-contained, reproducible code.
> >> >
> >>
> >> ______________________________________________
> >> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> >> https://stat.ethz.ch/mailman/listinfo/r-help
> >> PLEASE do read the posting guide
> >> http://www.R-project.org/posting-guide.html
> >> and provide commented, minimal, self-contained, reproducible code.
> >>
> >
> >         [[alternative HTML version deleted]]
>
> >
> >
> > ______________________________________________
> > R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> > https://stat.ethz.ch/mailman/listinfo/r-help
> > PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> > and provide commented, minimal, self-contained, reproducible code.
> >
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.


From j@zh@o @end|ng |rom ye@h@net  Wed May 12 13:49:28 2021
From: j@zh@o @end|ng |rom ye@h@net (Jinsong Zhao)
Date: Wed, 12 May 2021 19:49:28 +0800
Subject: [R] question about the difference of AIC()
Message-ID: <3bea56e6-703d-ec31-012f-37195d7d89ad@yeah.net>

Hi there,

I learned that AIC = 2 * npar - 2 * log(logLik(model)), where k is the 
number of estimated parameters in the model.

For examle:
 > set.seed(123)
 > y <- rnorm(15)
 > fm <- lm(y ~ 1)
In this example, npar should be 1, so, AIC is:
 > 2*1 - 2 * logLik(fm)
'log Lik.' 38.49275 (df=2)

However, AIC() give:
 > AIC(fm)
[1] 40.49275

I also try another AIC extract function:
 > extractAIC(fm)
[1]  1.000000 -4.075406

Since extractAIC() does not include the constant: n + n * log(2 * pi), so:
 > extractAIC(fm)[2] + 15 + 15 * log(2 * pi)
[1] 38.49275

It equals to the AIC calculated by 2*1 - 2 * logLik(fm), but different 
with the return of AIC().

It seems that AIC use 2 * (npar + 1) instead of 2 * npar.

In the help page of logLik, it said:
  '"df"' (*d*egrees of *f*reedom), giving the number of (estimated) 
parameters in the model.

The "df" is used by AIC() as npar, however, "df" is not number of 
estimated parameters in the model, df - 1 is. Am I correct?

Best wishes,
Jinsong


From ru|pb@rr@d@@ @end|ng |rom @@po@pt  Wed May 12 14:03:47 2021
From: ru|pb@rr@d@@ @end|ng |rom @@po@pt (Rui Barradas)
Date: Wed, 12 May 2021 13:03:47 +0100
Subject: [R] empty plots !
In-Reply-To: <1662076064.4942636.1620808407847@mail.yahoo.com>
References: <294893856.3283193.1620585572644.ref@mail.yahoo.com>
 <294893856.3283193.1620585572644@mail.yahoo.com>
 <b9186679-16a2-d6e4-afac-eecebbba7e01@sapo.pt>
 <1115549345.3369846.1620597015000@mail.yahoo.com>
 <CAGxFJbTdN4e9RtgFVBsPA1ktbNXo66KpQ6d9=Tv7LveNz3OqxQ@mail.gmail.com>
 <CAHqSRuR52W2to6UYMe_Mmv500AZx9CwMz7s7+oR4kcsVocN=ww@mail.gmail.com>
 <1754150943.4687777.1620755991674@mail.yahoo.com>
 <1662076064.4942636.1620808407847@mail.yahoo.com>
Message-ID: <f40a07a0-8610-5366-0ae3-74b40bbea1fa@sapo.pt>

Hello,

All power.* are filled with NA, please revise the code that produces 
those matrices, there's nothing wrong with the plotting code.

Also, suggested in an answer to your previous e-mail *with* code that 
you should save

old_par <- par(mfrow = c(4,2), cex = 0.45)
[...]
par(old_par)  # at the end, put the graphics device pars back.


Hope this helps,

Rui Barradas

?s 09:33 de 12/05/21, varin sacha via R-help escreveu:
> Dear Experts,
> 
> My R code was perfectly working since I decide to add a 5th correlation coefficient : hoeffdings' D.
> fter a google search, I guess I need somewhere in my R code "unlist" but I don't know where !
> Here below my R code with 1 error message. At the end I get my 8 plots but they are empty !
> Many thanks for your precious help !
> 
> #################
> set.seed(1)
> library(energy)
> library(independence)
> library(TauStar)
> 
> # Here we define parameters which we use to simulate the data
> # The number of null datasets we use to estimate our rejection reject #regions for an alternative with level 0.05
> nsim=50
> 
> # Number of alternative datasets we use to estimate our power
> nsim2=50
> 
> # The number of different noise levels used
> num.noise <- 30
> 
> # A constant to determine the amount of noise
> noise <- 3
> 
> # Number of data points per simulation
> 
> n=100
> 
> # Vectors holding the null "correlations" (for pearson, for spearman, for #kendall, for hoeffding and dcor respectively) for each of the nsim null datasets at a #given noise level
> val.cor=val.cors=val.cork=val.dcor=val.hoe=rep(NA,nsim)
> 
> # Vectors holding the alternative "correlations" (for pearson, for #spearman, for kendall, for hoeffding and dcor respectively) for each of #the nsim2 #alternative datasets at a given noise level
> val.cor2=val.cors2=val.cork2=val.dcor2=val.hoe2= rep(NA,nsim2)
>   
> # Arrays holding the estimated power for each of the 4 "correlation" types, #for each data type (linear, parabolic, etc...) with each noise level
> power.cor=power.cors=power.cork=power.dcor=power.hoe= array(NA, c(8,num.noise))
> 
> ## We loop through the noise level and functional form; each time we #estimate a null distribution based on the marginals of the data, and then #use that null distribution to estimate power
> ## We use a uniformly distributed x, because in the original paper the #authors used the same
> 
> for(l in 1:num.noise){
> 
>  ????? for(typ in 1:8){
> 
> ## This next loop simulates data under the null with the correct marginals #(x is uniform, and y is a function of a uniform with gaussian noise)
>   
>  ??? for(ii in 1:nsim){
>  ????? x=runif(n)
> 
> #lin+noise
> if(typ==1){
> y=x+ noise *(l/num.noise)* rnorm(n)
> }
>   
> #parabolic+noise
> if(typ==2){
> y=4*(x-.5)^2+? noise * (l/num.noise) * rnorm(n)
> }
> 
> #cubic+noise
> if(typ==3){
> y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise? * (l/num.noise) *rnorm(n)
> }
> 
> #sin+noise
> if(typ==4){
> y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
> }
> 
> #their sine + noise
> if(typ==5){
> y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
> }
> 
> #x^(1/4) + noise
> if(typ==6){
> y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
> }
> 
> #circle
> if(typ==7){
> y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise *rnorm(n)
> }
> 
> #step function
> if(typ==8){
> y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
> }
> 
> # We resimulate x so that we have the null scenario
> x <- runif(n)
> 
> # Calculate the 5 correlations
> val.cor[ii]=(cor(x,y))
> val.cors[ii]=(cor(x,y,method=c("spearman")))
> val.cork[ii]=(cor(x,y,method=c("kendal")))
> val.dcor[ii]=dcor(x,y)
> val.hoe[ii]=(hoeffding.D.test(x,y,na.rm=TRUE,collisions=TRUE))
> }
> 
> ## Next we calculate our 5 rejection cutoffs
> cut.cor=quantile(val.cor,.95)
> cut.cors=quantile(val.cors,.95)
> cut.cork=quantile(val.cork,.95)
> cut.dcor=quantile(val.dcor,.95)
> cut.hoe=quantile(val.hoe,.95)
> 
> ## Next we simulate the data again, this time under the alternative
> 
>  ??? for(ii in 1:nsim2){
>  ????? x=runif(n)
> 
> #lin+noise
> if(typ==1){
> y=x+ noise *(l/num.noise)* rnorm(n)
> }
> 
> #parabolic+noise
> if(typ==2){
> y=4*(x-.5)^2+? noise * (l/num.noise) * rnorm(n)
> }
> 
> #cubic+noise
> if(typ==3){
> y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise? * (l/num.noise) *rnorm(n)
> }
> 
> #sin+noise
> if(typ==4){
> y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
> }
> 
> #their sine + noise
> if(typ==5){
> y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
> }
> 
> #x^(1/4) + noise
> if(typ==6){
> y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
> }
> 
> #circle
> if(typ==7){
> y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise *rnorm(n)
> }
> 
> #step function
> if(typ==8){
> y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
> }
> 
> ## We again calculate our 5 correlations
> val.cor2[ii]=(cor(x,y))
> val.cors2[ii]=(cor(x,y,method=c("spearman")))
> val.cork2[ii]=(cor(x,y,method=c("kendal")))
> val.dcor2[ii]=dcor(x,y)
> val.hoe2[ii]=(hoeffding.D.test(x,y,na.rm=TRUE,collisions=TRUE))
> }
> 
> ## Now we estimate the power as the number of alternative statistics #exceeding our estimated cutoffs
> power.cor[typ,l] <- sum(val.cor2 > cut.cor)/nsim2
> power.cors[typ,l] <- sum(val.cors2 > cut.cor)/nsim2
> power.cork[typ,l] <- sum(val.cork2 > cut.cor)/nsim2
> power.dcor[typ,l] <- sum(val.dcor2 > cut.dcor)/nsim2
> power.hoe[typ,l] <- sum(val.hoe2 > cut.hoe)/nsim2
> }
> }
> 
> ## The rest of the code is for plotting the image
> par(mfrow = c(4,2), cex = 0.45)
> plot((1:30)/10, power.cor[1,], ylim = c(0,1), main = "Linear", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[1,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[1,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[1,], pch = 4, col = "red", type = 'b')
> points((1:30)/10, power.hoe[1,], pch = 5, col = "purple", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor","hoe" ), pch = c(1,2,3,4,5), col = c("black","green","blue","red",?"purple"))
> 
> plot((1:30)/10, power.cor[2,], ylim = c(0,1), main = "Quadratic", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[2,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[2,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[2,], pch = 4, col = "red", type = 'b')
> points((1:30)/10, power.hoe[2,], pch = 5, col = "purple", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor","hoe" ), pch = c(1,2,3,4,5), col = c("black","green","blue","red",?"purple"))
> 
> plot((1:30)/10, power.cor[3,], ylim = c(0,1), main = "Cubic", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[3,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[3,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[3,], pch = 4, col = "red", type = 'b')
> points((1:30)/10, power.hoe[3,], pch = 5, col = "purple", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor","hoe" ), pch = c(1,2,3,4,5), col = c("black","green","blue","red",?"purple"))
> 
> plot((1:30)/10, power.cor[5,], ylim = c(0,1), main = "Sine: period 1/8", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[5,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[5,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[5,], pch = 4, col = "red", type = 'b')
> points((1:30)/10, power.hoe[5,], pch = 5, col = "purple", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor","hoe" ), pch = c(1,2,3,4,5), col = c("black","green","blue","red",?"purple"))
> 
> plot((1:30)/10, power.cor[4,], ylim = c(0,1), main = "Sine: period 1/2", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[4,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[4,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[4,], pch = 4, col = "red", type = 'b')
> points((1:30)/10, power.hoe[4,], pch = 5, col = "purple", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor","hoe" ), pch = c(1,2,3,4,5), col = c("black","green","blue","red",?"purple"))
> 
> plot((1:30)/10, power.cor[6,], ylim = c(0,1), main = "X^(1/4)", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[6,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[6,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[6,], pch = 4, col = "red", type = 'b')
> points((1:30)/10, power.hoe[6,], pch = 5, col = "purple", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor","hoe" ), pch = c(1,2,3,4,5), col = c("black","green","blue","red",?"purple"))
>   
> plot((1:30)/10, power.cor[7,], ylim = c(0,1), main = "Circle", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[7,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[7,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[7,], pch = 4, col = "red", type = 'b')
> points((1:30)/10, power.hoe[7,], pch = 5, col = "purple", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor","hoe" ), pch = c(1,2,3,4,5), col = c("black","green","blue","red",?"purple"))
> 
> plot((1:30)/10, power.cor[8,], ylim = c(0,1), main = "Step function", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
> points((1:30)/10, power.cors[8,], pch = 2, col = "green", type = 'b')
> points((1:30)/10, power.cork[8,], pch = 3, col = "blue", type = 'b')
> points((1:30)/10, power.dcor[8,], pch = 4, col = "red", type = 'b')
> points((1:30)/10, power.hoe[8,], pch = 5, col = "purple", type = 'b')
> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor","hoe" ), pch = c(1,2,3,4,5), col = c("black","green","blue","red",?"purple"))
> #################
> 
>   
> 
> 
> 
> 
> 
> 
> 
> Le mardi 11 mai 2021 ? 20:00:49 UTC+2, varin sacha via R-help <r-help at r-project.org> a ?crit :
> 
> 
> 
> 
> 
> Dear all,
> 
> Many thanks for your responses.
> 
> Best
> S.
> 
> 
> 
> 
> 
> 
> 
> Le lundi 10 mai 2021 ? 17:18:59 UTC+2, Bill Dunlap <williamwdunlap at gmail.com> a ?crit :
> 
> 
> 
> 
> 
> Also, normalizePath("power.pdf").
> 
> On Sun, May 9, 2021 at 5:13 PM Bert Gunter <bgunter.4567 at gmail.com> wrote:
>> ?getwd
>>
>> Bert Gunter
>>
>> "The trouble with having an open mind is that people keep coming along and
>> sticking things into it."
>> -- Opus (aka Berkeley Breathed in his "Bloom County" comic strip )
>>
>>
>> On Sun, May 9, 2021 at 2:59 PM varin sacha via R-help <r-help at r-project.org>
>> wrote:
>>
>>> Rui,
>>>
>>> The created pdf.file is off-screen device. Indeed after dev.off() I should
>>> view the pdf file on my computer. But I don't find it. Where do I find the
>>> pdf.file ?
>>>
>>> Regards,
>>>
>>>
>>>
>>> Le dimanche 9 mai 2021 ? 22:44:22 UTC+2, Rui Barradas <
>>> ruipbarradas at sapo.pt> a ?crit :
>>>
>>>
>>>
>>>
>>>
>>> Hello,
>>>
>>> You are not closing the pdf device.
>>> The only changes I have made to your code are right at the beginning of
>>> the plotting instructions and at the end of the code.
>>>
>>>
>>> ## The rest of the code is for plotting the image
>>> pdf(file = "power.pdf")
>>> op <- par(mfrow = c(4,2), cex = 0.45)
>>>
>>> [...]
>>>
>>> par(op)
>>> dev.off()
>>> #################
>>>
>>> The comments only line is your last code line.
>>> The result is attached.
>>>
>>> Hope this helps,
>>>
>>> Rui Barradas
>>>
>>> ?s 19:39 de 09/05/21, varin sacha via R-help escreveu:
>>>> Dear R-experts,
>>>>
>>>> I am trying to get the 8 graphs like the ones in this paper :
>>>> https://statweb.stanford.edu/~tibs/reshef/comment.pdf
>>>> My R code does not show any error message neither warnings but I d'on't
>>> get what I would like to get (I mean the 8 graphs), so I am missing
>>> something. What's it ? Many thanks for your precious help.
>>>>
>>>> #################
>>>> set.seed(1)
>>>> library(energy)
>>>>
>>>> # Here we define parameters which we use to simulate the data
>>>> # The number of null datasets we use to estimate our rejection reject
>>> #regions for an alternative with level 0.05
>>>> nsim=50
>>>>
>>>> # Number of alternative datasets we use to estimate our power
>>>> nsim2=50
>>>>
>>>> # The number of different noise levels used
>>>> num.noise <- 30
>>>>
>>>> # A constant to determine the amount of noise
>>>> noise <- 3
>>>>
>>>> # Number of data points per simulation
>>>> n=100
>>>>
>>>> # Vectors holding the null "correlations" (for pearson, for spearman,
>>> for kendall and dcor respectively) for each # of the nsim null datasets at
>>> a #given noise level
>>>> val.cor=val.cors=val.cork=val.dcor=rep(NA,nsim)
>>>>
>>>> # Vectors holding the alternative "correlations" (for pearson, for
>>> #spearman, for kendall and dcor respectively) #for each of the nsim2
>>> alternative datasets at a given noise level
>>>> val.cor2=val.cors2=val.cork2=val.dcor2= rep(NA,nsim2)
>>>>
>>>>
>>>> # Arrays holding the estimated power for each of the 4 "correlation"
>>> types, for each data type (linear, #parabolic, etc...) with each noise level
>>>> power.cor=power.cors=power.cork=power.dcor= array(NA, c(8,num.noise))
>>>>
>>>> ## We loop through the noise level and functional form; each time we
>>> #estimate a null distribution based on #the marginals of the data, and then
>>> #use that null distribution to estimate power
>>>> ## We use a uniformly distributed x, because in the original paper the
>>> #authors used the same
>>>>
>>>> for(l in 1:num.noise) {
>>>>
>>>>  ? ? ? ? for(typ in 1:8) {
>>>>
>>>> ## This next loop simulates data under the null with the correct
>>> marginals (x is uniform, and y is a function of a #uniform with gaussian
>>> noise)
>>>>
>>>>  ? ? ? for(ii in 1:nsim) {
>>>>  ? ? ? ? x=runif(n)
>>>>
>>>> #lin+noise
>>>> if(typ==1) {
>>>> y=x+ noise *(l/num.noise)* rnorm(n)
>>>> }
>>>>
>>>> #parabolic+noise
>>>> if(typ==2) {
>>>> y=4*(x-.5)^2+? noise * (l/num.noise) * rnorm(n)
>>>> }
>>>>
>>>> #cubic+noise
>>>> if(typ==3) {
>>>> y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise? * (l/num.noise)
>>> *rnorm(n)
>>>> }
>>>>
>>>> #sin+noise
>>>> if(typ==4) {
>>>> y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
>>>> }
>>>>
>>>> #their sine + noise
>>>> if(typ==5) {
>>>> y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
>>>> }
>>>>
>>>> #x^(1/4) + noise
>>>> if(typ==6) {
>>>> y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
>>>> }
>>>>
>>>> #circle
>>>> if(typ==7) {
>>>> y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise
>>> *rnorm(n)
>>>> }
>>>>
>>>> #step function
>>>> if(typ==8) {
>>>> y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
>>>> }
>>>>
>>>> # We resimulate x so that we have the null scenario
>>>> x <- runif(n)
>>>>
>>>> # Calculate the 4 correlations
>>>> val.cor[ii]=(cor(x,y))
>>>> val.cors[ii]=(cor(x,y,method=c("spearman")))
>>>> val.cork[ii]=(cor(x,y,method=c("kendal")))
>>>> val.dcor[ii]=dcor(x,y)
>>>> }
>>>>
>>>> ## Next we calculate our 4 rejection cutoffs
>>>> cut.cor=quantile(val.cor,.95)
>>>> cut.cors=quantile(val.cors,.95)
>>>> cut.cork=quantile(val.cork,.95)
>>>> cut.dcor=quantile(val.dcor,.95)
>>>>
>>>> ## Next we simulate the data again, this time under the alternative
>>>>
>>>>  ? ? ? for(ii in 1:nsim2) {
>>>>  ? ? ? ? x=runif(n)
>>>>
>>>> #lin+noise
>>>> if(typ==1) {
>>>> y=x+ noise *(l/num.noise)* rnorm(n)
>>>> }
>>>>
>>>> #parabolic+noise
>>>> if(typ==2) {
>>>> y=4*(x-.5)^2+? noise * (l/num.noise) * rnorm(n)
>>>> }
>>>>
>>>> #cubic+noise
>>>> if(typ==3) {
>>>> y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise? * (l/num.noise)
>>> *rnorm(n)
>>>> }
>>>>
>>>> #sin+noise
>>>> if(typ==4) {
>>>> y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
>>>> }
>>>>
>>>> #their sine + noise
>>>> if(typ==5) {
>>>> y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
>>>> }
>>>>
>>>> #x^(1/4) + noise
>>>> if(typ==6) {
>>>> y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
>>>> }
>>>>
>>>> #circle
>>>> if(typ==7) {
>>>> y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise
>>> *rnorm(n)
>>>> }
>>>>
>>>> #step function
>>>> if(typ==8) {
>>>> y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
>>>> }
>>>>
>>>> ## We again calculate our 4 "correlations"
>>>> val.cor2[ii]=(cor(x,y))
>>>> val.cors2[ii]=(cor(x,y,method=c("spearman")))
>>>> val.cork2[ii]=(cor(x,y,method=c("kendal")))
>>>> val.dcor2[ii]=dcor(x,y)
>>>> }
>>>>
>>>> ## Now we estimate the power as the number of alternative statistics
>>> #exceeding our estimated cutoffs
>>>> power.cor[typ,l] <- sum(val.cor2 > cut.cor)/nsim2
>>>> power.cors[typ,l] <- sum(val.cors2 > cut.cor)/nsim2
>>>> power.cork[typ,l] <- sum(val.cork2 > cut.cor)/nsim2
>>>> power.dcor[typ,l] <- sum(val.dcor2 > cut.dcor)/nsim2
>>>> }
>>>> }
>>>>
>>>> save.image()
>>>>
>>>> ## The rest of the code is for plotting the image
>>>> pdf("power.pdf")
>>>> par(mfrow = c(4,2), cex = 0.45)
>>>> plot((1:30)/10, power.cor[1,], ylim = c(0,1), main = "Linear", xlab =
>>> "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>>>> points((1:30)/10, power.cors[1,], pch = 2, col = "green", type = 'b')
>>>> points((1:30)/10, power.cork[1,], pch = 3, col = "blue", type = 'b')
>>>> points((1:30)/10, power.dcor[1,], pch = 4, col = "red", type = 'b')
>>>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
>>> pch = c(1,2,3), col = c("black","green","blue","red"))
>>>>
>>>> plot((1:30)/10, power.cor[2,], ylim = c(0,1), main = "Quadratic", xlab =
>>> "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>>>> points((1:30)/10, power.cors[2,], pch = 2, col = "green", type = 'b')
>>>> points((1:30)/10, power.cork[2,], pch = 3, col = "blue", type = 'b')
>>>> points((1:30)/10, power.dcor[2,], pch = 4, col = "red", type = 'b')
>>>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
>>> pch = c(1,2,3), col = c("black","green","blue","red"))
>>>>
>>>> plot((1:30)/10, power.cor[3,], ylim = c(0,1), main = "Cubic", xlab =
>>> "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>>>> points((1:30)/10, power.cors[3,], pch = 2, col = "green", type = 'b')
>>>> points((1:30)/10, power.cork[3,], pch = 3, col = "blue", type = 'b')
>>>> points((1:30)/10, power.dcor[3,], pch = 4, col = "red", type = 'b')
>>>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
>>> pch = c(1,2,3), col = c("black","green","blue","red"))
>>>>
>>>> plot((1:30)/10, power.cor[5,], ylim = c(0,1), main = "Sine: period 1/8",
>>> xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>>>> points((1:30)/10, power.cors[5,], pch = 2, col = "green", type = 'b')
>>>> points((1:30)/10, power.cork[5,], pch = 3, col = "blue", type = 'b')
>>>> points((1:30)/10, power.dcor[5,], pch = 4, col = "red", type = 'b')
>>>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
>>> pch = c(1,2,3), col = c("black","green","blue","red"))
>>>>
>>>> plot((1:30)/10, power.cor[4,], ylim = c(0,1), main = "Sine: period 1/2",
>>> xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>>>> points((1:30)/10, power.cors[4,], pch = 2, col = "green", type = 'b')
>>>> points((1:30)/10, power.cork[4,], pch = 3, col = "blue", type = 'b')
>>>> points((1:30)/10, power.dcor[4,], pch = 4, col = "red", type = 'b')
>>>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
>>> pch = c(1,2,3), col = c("black","green","blue","red"))
>>>>
>>>> plot((1:30)/10, power.cor[6,], ylim = c(0,1), main = "X^(1/4)", xlab =
>>> "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>>>> points((1:30)/10, power.cors[6,], pch = 2, col = "green", type = 'b')
>>>> points((1:30)/10, power.cork[6,], pch = 3, col = "blue", type = 'b')
>>>> points((1:30)/10, power.dcor[6,], pch = 4, col = "red", type = 'b')
>>>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
>>> pch = c(1,2,3), col = c("black","green","blue","red"))
>>>>
>>>> plot((1:30)/10, power.cor[7,], ylim = c(0,1), main = "Circle", xlab =
>>> "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>>>> points((1:30)/10, power.cors[7,], pch = 2, col = "green", type = 'b')
>>>> points((1:30)/10, power.cork[7,], pch = 3, col = "blue", type = 'b')
>>>> points((1:30)/10, power.dcor[7,], pch = 4, col = "red", type = 'b')
>>>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
>>> pch = c(1,2,3), col = c("black","green","blue","red"))
>>>>
>>>> plot((1:30)/10, power.cor[8,], ylim = c(0,1), main = "Step function",
>>> xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>>>> points((1:30)/10, power.cors[8,], pch = 2, col = "green", type = 'b')
>>>> points((1:30)/10, power.cork[8,], pch = 3, col = "blue", type = 'b')
>>>> points((1:30)/10, power.dcor[8,], pch = 4, col = "red", type = 'b')
>>>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
>>> pch = c(1,2,3), col = c("black","green","blue","red"))
>>>>
>>>> #################
>>>>
>>>> ______________________________________________
>>>> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>>>> https://stat.ethz.ch/mailman/listinfo/r-help
>>>> PLEASE do read the posting guide
>>> http://www.R-project.org/posting-guide.html
>>>> and provide commented, minimal, self-contained, reproducible code.
>>>>
>>>
>>> ______________________________________________
>>> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>>> https://stat.ethz.ch/mailman/listinfo/r-help
>>> PLEASE do read the posting guide
>>> http://www.R-project.org/posting-guide.html
>>> and provide commented, minimal, self-contained, reproducible code.
>>>
>>
>>  ? ? ? ? [[alternative HTML version deleted]]
> 
>>
>>
>> ______________________________________________
>> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> https://stat.ethz.ch/mailman/listinfo/r-help
>> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
>> and provide commented, minimal, self-contained, reproducible code.
>>
> 
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
> 
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
>


From j@zh@o @end|ng |rom ye@h@net  Wed May 12 14:07:33 2021
From: j@zh@o @end|ng |rom ye@h@net (Jinsong Zhao)
Date: Wed, 12 May 2021 20:07:33 +0800
Subject: [R] question about the difference of AIC()
In-Reply-To: <3bea56e6-703d-ec31-012f-37195d7d89ad@yeah.net>
References: <3bea56e6-703d-ec31-012f-37195d7d89ad@yeah.net>
Message-ID: <59de55ba-cee1-5632-6397-d8d9c5c5c73a@yeah.net>

On 2021/5/12 19:49, Jinsong Zhao wrote:
> Hi there,
> 
> I learned that AIC = 2 * npar - 2 * log(logLik(model)), where k is the 
> number of estimated parameters in the model.

k should be npar in the above sentence. Sorry for the mistake.

> 
> For examle:
>  > set.seed(123)
>  > y <- rnorm(15)
>  > fm <- lm(y ~ 1)
> In this example, npar should be 1, so, AIC is:
>  > 2*1 - 2 * logLik(fm)
> 'log Lik.' 38.49275 (df=2)
> 
> However, AIC() give:
>  > AIC(fm)
> [1] 40.49275
> 
> I also try another AIC extract function:
>  > extractAIC(fm)
> [1]? 1.000000 -4.075406
> 
> Since extractAIC() does not include the constant: n + n * log(2 * pi), so:
>  > extractAIC(fm)[2] + 15 + 15 * log(2 * pi)
> [1] 38.49275
> 
> It equals to the AIC calculated by 2*1 - 2 * logLik(fm), but different 
> with the return of AIC().
> 
> It seems that AIC use 2 * (npar + 1) instead of 2 * npar.
> 
> In the help page of logLik, it said:
>  ?'"df"' (*d*egrees of *f*reedom), giving the number of (estimated) 
> parameters in the model.
> 
> The "df" is used by AIC() as npar, however, "df" is not number of 
> estimated parameters in the model, df - 1 is. Am I correct?
> 
> Best wishes,
> Jinsong


From @orenh @end|ng |rom m@th@@@u@dk  Wed May 12 14:10:31 2021
From: @orenh @end|ng |rom m@th@@@u@dk (=?utf-8?B?U8O4cmVuIEjDuGpzZ2FhcmQ=?=)
Date: Wed, 12 May 2021 12:10:31 +0000
Subject: [R] question about the difference of AIC()
In-Reply-To: <3bea56e6-703d-ec31-012f-37195d7d89ad@yeah.net>
References: <3bea56e6-703d-ec31-012f-37195d7d89ad@yeah.net>
Message-ID: <7feec70a45bbf6cc3747bf63e9cb2efd9a688cb2.camel@math.aau.dk>

In the first model, I believe you estimate two parameters: the mean and
the variance:
> fm <- lm(y ~ 1)
> 2*2 - 2 * logLik(fm)
'log Lik.' 40.49275 (df=2)
>
AIC(fm)
[1] 40.49275


A zero mean model:

fm0 <- lm(y ~ -1)
> 2*1 - 2 * logLik(fm0)
'log Lik.' 39.00611 (df=1)
> AIC(fm0)
[1] 39.00611

Regards
S?ren


On Wed, 2021-05-12 at 19:49 +0800, Jinsong Zhao wrote:
> Hi there,
> 
> I learned that AIC = 2 * npar - 2 * log(logLik(model)), where k is
> the 
> number of estimated parameters in the model.
> 
> For examle:
>  > set.seed(123)
>  > y <- rnorm(15)
>  > fm <- lm(y ~ 1)
> In this example, npar should be 1, so, AIC is:
>  > 2*1 - 2 * logLik(fm)
> 'log Lik.' 38.49275 (df=2)
> 
> However, AIC() give:
>  > AIC(fm)
> [1] 40.49275
> 
> I also try another AIC extract function:
>  > extractAIC(fm)
> [1]  1.000000 -4.075406
> 
> Since extractAIC() does not include the constant: n + n * log(2 *
> pi), so:
>  > extractAIC(fm)[2] + 15 + 15 * log(2 * pi)
> [1] 38.49275
> 
> It equals to the AIC calculated by 2*1 - 2 * logLik(fm), but
> different 
> with the return of AIC().
> 
> It seems that AIC use 2 * (npar + 1) instead of 2 * npar.
> 
> In the help page of logLik, it said:
>   '"df"' (*d*egrees of *f*reedom), giving the number of (estimated) 
> parameters in the model.
> 
> The "df" is used by AIC() as npar, however, "df" is not number of 
> estimated parameters in the model, df - 1 is. Am I correct?
> 
> Best wishes,
> Jinsong
> 
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide 
> http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.

From v@r|n@@ch@ @end|ng |rom y@hoo@|r  Wed May 12 14:33:37 2021
From: v@r|n@@ch@ @end|ng |rom y@hoo@|r (varin sacha)
Date: Wed, 12 May 2021 14:33:37 +0200
Subject: [R] empty plots !
In-Reply-To: <CA+8X3fXq-AXPAnKJAkJfWEH=z5AxLCnBX1fogUsHLKUqO9OOXA@mail.gmail.com>
References: <CA+8X3fXq-AXPAnKJAkJfWEH=z5AxLCnBX1fogUsHLKUqO9OOXA@mail.gmail.com>
Message-ID: <F5BBF32B-4BE7-442E-A6A2-3DE6BC6CFB20@yahoo.fr>

Hi Jim,

No, I just want my R code to run correctly. I don?t want a pdf.file or other off-screen files.
There is 1 error message and I guess it is due to that error message I don?t get the 8 plots.

Envoy? de mon iPhone

> Le 12 mai 2021 ? 13:03, Jim Lemon <drjimlemon at gmail.com> a ?crit :
> 
> ?Hi varin,
> Were you expecting image files? I don't see any plot device e.g. pdf()
> in your code.
> 
> Jim
> 
>> On Wed, May 12, 2021 at 6:34 PM varin sacha via R-help
>> <r-help at r-project.org> wrote:
>> 
>> Dear Experts,
>> 
>> My R code was perfectly working since I decide to add a 5th correlation coefficient : hoeffdings' D.
>> fter a google search, I guess I need somewhere in my R code "unlist" but I don't know where !
>> Here below my R code with 1 error message. At the end I get my 8 plots but they are empty !
>> Many thanks for your precious help !
>> 
>> #################
>> set.seed(1)
>> library(energy)
>> library(independence)
>> library(TauStar)
>> 
>> # Here we define parameters which we use to simulate the data
>> # The number of null datasets we use to estimate our rejection reject #regions for an alternative with level 0.05
>> nsim=50
>> 
>> # Number of alternative datasets we use to estimate our power
>> nsim2=50
>> 
>> # The number of different noise levels used
>> num.noise <- 30
>> 
>> # A constant to determine the amount of noise
>> noise <- 3
>> 
>> # Number of data points per simulation
>> 
>> n=100
>> 
>> # Vectors holding the null "correlations" (for pearson, for spearman, for #kendall, for hoeffding and dcor respectively) for each of the nsim null datasets at a #given noise level
>> val.cor=val.cors=val.cork=val.dcor=val.hoe=rep(NA,nsim)
>> 
>> # Vectors holding the alternative "correlations" (for pearson, for #spearman, for kendall, for hoeffding and dcor respectively) for each of #the nsim2 #alternative datasets at a given noise level
>> val.cor2=val.cors2=val.cork2=val.dcor2=val.hoe2= rep(NA,nsim2)
>> 
>> # Arrays holding the estimated power for each of the 4 "correlation" types, #for each data type (linear, parabolic, etc...) with each noise level
>> power.cor=power.cors=power.cork=power.dcor=power.hoe= array(NA, c(8,num.noise))
>> 
>> ## We loop through the noise level and functional form; each time we #estimate a null distribution based on the marginals of the data, and then #use that null distribution to estimate power
>> ## We use a uniformly distributed x, because in the original paper the #authors used the same
>> 
>> for(l in 1:num.noise){
>> 
>>      for(typ in 1:8){
>> 
>> ## This next loop simulates data under the null with the correct marginals #(x is uniform, and y is a function of a uniform with gaussian noise)
>> 
>>    for(ii in 1:nsim){
>>      x=runif(n)
>> 
>> #lin+noise
>> if(typ==1){
>> y=x+ noise *(l/num.noise)* rnorm(n)
>> }
>> 
>> #parabolic+noise
>> if(typ==2){
>> y=4*(x-.5)^2+  noise * (l/num.noise) * rnorm(n)
>> }
>> 
>> #cubic+noise
>> if(typ==3){
>> y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise  * (l/num.noise) *rnorm(n)
>> }
>> 
>> #sin+noise
>> if(typ==4){
>> y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
>> }
>> 
>> #their sine + noise
>> if(typ==5){
>> y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
>> }
>> 
>> #x^(1/4) + noise
>> if(typ==6){
>> y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
>> }
>> 
>> #circle
>> if(typ==7){
>> y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise *rnorm(n)
>> }
>> 
>> #step function
>> if(typ==8){
>> y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
>> }
>> 
>> # We resimulate x so that we have the null scenario
>> x <- runif(n)
>> 
>> # Calculate the 5 correlations
>> val.cor[ii]=(cor(x,y))
>> val.cors[ii]=(cor(x,y,method=c("spearman")))
>> val.cork[ii]=(cor(x,y,method=c("kendal")))
>> val.dcor[ii]=dcor(x,y)
>> val.hoe[ii]=(hoeffding.D.test(x,y,na.rm=TRUE,collisions=TRUE))
>> }
>> 
>> ## Next we calculate our 5 rejection cutoffs
>> cut.cor=quantile(val.cor,.95)
>> cut.cors=quantile(val.cors,.95)
>> cut.cork=quantile(val.cork,.95)
>> cut.dcor=quantile(val.dcor,.95)
>> cut.hoe=quantile(val.hoe,.95)
>> 
>> ## Next we simulate the data again, this time under the alternative
>> 
>>    for(ii in 1:nsim2){
>>      x=runif(n)
>> 
>> #lin+noise
>> if(typ==1){
>> y=x+ noise *(l/num.noise)* rnorm(n)
>> }
>> 
>> #parabolic+noise
>> if(typ==2){
>> y=4*(x-.5)^2+  noise * (l/num.noise) * rnorm(n)
>> }
>> 
>> #cubic+noise
>> if(typ==3){
>> y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise  * (l/num.noise) *rnorm(n)
>> }
>> 
>> #sin+noise
>> if(typ==4){
>> y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
>> }
>> 
>> #their sine + noise
>> if(typ==5){
>> y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
>> }
>> 
>> #x^(1/4) + noise
>> if(typ==6){
>> y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
>> }
>> 
>> #circle
>> if(typ==7){
>> y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise *rnorm(n)
>> }
>> 
>> #step function
>> if(typ==8){
>> y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
>> }
>> 
>> ## We again calculate our 5 correlations
>> val.cor2[ii]=(cor(x,y))
>> val.cors2[ii]=(cor(x,y,method=c("spearman")))
>> val.cork2[ii]=(cor(x,y,method=c("kendal")))
>> val.dcor2[ii]=dcor(x,y)
>> val.hoe2[ii]=(hoeffding.D.test(x,y,na.rm=TRUE,collisions=TRUE))
>> }
>> 
>> ## Now we estimate the power as the number of alternative statistics #exceeding our estimated cutoffs
>> power.cor[typ,l] <- sum(val.cor2 > cut.cor)/nsim2
>> power.cors[typ,l] <- sum(val.cors2 > cut.cor)/nsim2
>> power.cork[typ,l] <- sum(val.cork2 > cut.cor)/nsim2
>> power.dcor[typ,l] <- sum(val.dcor2 > cut.dcor)/nsim2
>> power.hoe[typ,l] <- sum(val.hoe2 > cut.hoe)/nsim2
>> }
>> }
>> 
>> ## The rest of the code is for plotting the image
>> par(mfrow = c(4,2), cex = 0.45)
>> plot((1:30)/10, power.cor[1,], ylim = c(0,1), main = "Linear", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> points((1:30)/10, power.cors[1,], pch = 2, col = "green", type = 'b')
>> points((1:30)/10, power.cork[1,], pch = 3, col = "blue", type = 'b')
>> points((1:30)/10, power.dcor[1,], pch = 4, col = "red", type = 'b')
>> points((1:30)/10, power.hoe[1,], pch = 5, col = "purple", type = 'b')
>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor","hoe" ), pch = c(1,2,3,4,5), col = c("black","green","blue","red", "purple"))
>> 
>> plot((1:30)/10, power.cor[2,], ylim = c(0,1), main = "Quadratic", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> points((1:30)/10, power.cors[2,], pch = 2, col = "green", type = 'b')
>> points((1:30)/10, power.cork[2,], pch = 3, col = "blue", type = 'b')
>> points((1:30)/10, power.dcor[2,], pch = 4, col = "red", type = 'b')
>> points((1:30)/10, power.hoe[2,], pch = 5, col = "purple", type = 'b')
>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor","hoe" ), pch = c(1,2,3,4,5), col = c("black","green","blue","red", "purple"))
>> 
>> plot((1:30)/10, power.cor[3,], ylim = c(0,1), main = "Cubic", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> points((1:30)/10, power.cors[3,], pch = 2, col = "green", type = 'b')
>> points((1:30)/10, power.cork[3,], pch = 3, col = "blue", type = 'b')
>> points((1:30)/10, power.dcor[3,], pch = 4, col = "red", type = 'b')
>> points((1:30)/10, power.hoe[3,], pch = 5, col = "purple", type = 'b')
>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor","hoe" ), pch = c(1,2,3,4,5), col = c("black","green","blue","red", "purple"))
>> 
>> plot((1:30)/10, power.cor[5,], ylim = c(0,1), main = "Sine: period 1/8", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> points((1:30)/10, power.cors[5,], pch = 2, col = "green", type = 'b')
>> points((1:30)/10, power.cork[5,], pch = 3, col = "blue", type = 'b')
>> points((1:30)/10, power.dcor[5,], pch = 4, col = "red", type = 'b')
>> points((1:30)/10, power.hoe[5,], pch = 5, col = "purple", type = 'b')
>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor","hoe" ), pch = c(1,2,3,4,5), col = c("black","green","blue","red", "purple"))
>> 
>> plot((1:30)/10, power.cor[4,], ylim = c(0,1), main = "Sine: period 1/2", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> points((1:30)/10, power.cors[4,], pch = 2, col = "green", type = 'b')
>> points((1:30)/10, power.cork[4,], pch = 3, col = "blue", type = 'b')
>> points((1:30)/10, power.dcor[4,], pch = 4, col = "red", type = 'b')
>> points((1:30)/10, power.hoe[4,], pch = 5, col = "purple", type = 'b')
>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor","hoe" ), pch = c(1,2,3,4,5), col = c("black","green","blue","red", "purple"))
>> 
>> plot((1:30)/10, power.cor[6,], ylim = c(0,1), main = "X^(1/4)", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> points((1:30)/10, power.cors[6,], pch = 2, col = "green", type = 'b')
>> points((1:30)/10, power.cork[6,], pch = 3, col = "blue", type = 'b')
>> points((1:30)/10, power.dcor[6,], pch = 4, col = "red", type = 'b')
>> points((1:30)/10, power.hoe[6,], pch = 5, col = "purple", type = 'b')
>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor","hoe" ), pch = c(1,2,3,4,5), col = c("black","green","blue","red", "purple"))
>> 
>> plot((1:30)/10, power.cor[7,], ylim = c(0,1), main = "Circle", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> points((1:30)/10, power.cors[7,], pch = 2, col = "green", type = 'b')
>> points((1:30)/10, power.cork[7,], pch = 3, col = "blue", type = 'b')
>> points((1:30)/10, power.dcor[7,], pch = 4, col = "red", type = 'b')
>> points((1:30)/10, power.hoe[7,], pch = 5, col = "purple", type = 'b')
>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor","hoe" ), pch = c(1,2,3,4,5), col = c("black","green","blue","red", "purple"))
>> 
>> plot((1:30)/10, power.cor[8,], ylim = c(0,1), main = "Step function", xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>> points((1:30)/10, power.cors[8,], pch = 2, col = "green", type = 'b')
>> points((1:30)/10, power.cork[8,], pch = 3, col = "blue", type = 'b')
>> points((1:30)/10, power.dcor[8,], pch = 4, col = "red", type = 'b')
>> points((1:30)/10, power.hoe[8,], pch = 5, col = "purple", type = 'b')
>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor","hoe" ), pch = c(1,2,3,4,5), col = c("black","green","blue","red", "purple"))
>> #################
>> 
>> 
>> 
>> 
>> 
>> 
>> 
>> 
>> 
>> Le mardi 11 mai 2021 ? 20:00:49 UTC+2, varin sacha via R-help <r-help at r-project.org> a ?crit :
>> 
>> 
>> 
>> 
>> 
>> Dear all,
>> 
>> Many thanks for your responses.
>> 
>> Best
>> S.
>> 
>> 
>> 
>> 
>> 
>> 
>> 
>> Le lundi 10 mai 2021 ? 17:18:59 UTC+2, Bill Dunlap <williamwdunlap at gmail.com> a ?crit :
>> 
>> 
>> 
>> 
>> 
>> Also, normalizePath("power.pdf").
>> 
>>> On Sun, May 9, 2021 at 5:13 PM Bert Gunter <bgunter.4567 at gmail.com> wrote:
>>> ?getwd
>>> 
>>> Bert Gunter
>>> 
>>> "The trouble with having an open mind is that people keep coming along and
>>> sticking things into it."
>>> -- Opus (aka Berkeley Breathed in his "Bloom County" comic strip )
>>> 
>>> 
>>> On Sun, May 9, 2021 at 2:59 PM varin sacha via R-help <r-help at r-project.org>
>>> wrote:
>>> 
>>>> Rui,
>>>> 
>>>> The created pdf.file is off-screen device. Indeed after dev.off() I should
>>>> view the pdf file on my computer. But I don't find it. Where do I find the
>>>> pdf.file ?
>>>> 
>>>> Regards,
>>>> 
>>>> 
>>>> 
>>>> Le dimanche 9 mai 2021 ? 22:44:22 UTC+2, Rui Barradas <
>>>> ruipbarradas at sapo.pt> a ?crit :
>>>> 
>>>> 
>>>> 
>>>> 
>>>> 
>>>> Hello,
>>>> 
>>>> You are not closing the pdf device.
>>>> The only changes I have made to your code are right at the beginning of
>>>> the plotting instructions and at the end of the code.
>>>> 
>>>> 
>>>> ## The rest of the code is for plotting the image
>>>> pdf(file = "power.pdf")
>>>> op <- par(mfrow = c(4,2), cex = 0.45)
>>>> 
>>>> [...]
>>>> 
>>>> par(op)
>>>> dev.off()
>>>> #################
>>>> 
>>>> The comments only line is your last code line.
>>>> The result is attached.
>>>> 
>>>> Hope this helps,
>>>> 
>>>> Rui Barradas
>>>> 
>>>> ?s 19:39 de 09/05/21, varin sacha via R-help escreveu:
>>>>> Dear R-experts,
>>>>> 
>>>>> I am trying to get the 8 graphs like the ones in this paper :
>>>>> https://statweb.stanford.edu/~tibs/reshef/comment.pdf
>>>>> My R code does not show any error message neither warnings but I d'on't
>>>> get what I would like to get (I mean the 8 graphs), so I am missing
>>>> something. What's it ? Many thanks for your precious help.
>>>>> 
>>>>> #################
>>>>> set.seed(1)
>>>>> library(energy)
>>>>> 
>>>>> # Here we define parameters which we use to simulate the data
>>>>> # The number of null datasets we use to estimate our rejection reject
>>>> #regions for an alternative with level 0.05
>>>>> nsim=50
>>>>> 
>>>>> # Number of alternative datasets we use to estimate our power
>>>>> nsim2=50
>>>>> 
>>>>> # The number of different noise levels used
>>>>> num.noise <- 30
>>>>> 
>>>>> # A constant to determine the amount of noise
>>>>> noise <- 3
>>>>> 
>>>>> # Number of data points per simulation
>>>>> n=100
>>>>> 
>>>>> # Vectors holding the null "correlations" (for pearson, for spearman,
>>>> for kendall and dcor respectively) for each # of the nsim null datasets at
>>>> a #given noise level
>>>>> val.cor=val.cors=val.cork=val.dcor=rep(NA,nsim)
>>>>> 
>>>>> # Vectors holding the alternative "correlations" (for pearson, for
>>>> #spearman, for kendall and dcor respectively) #for each of the nsim2
>>>> alternative datasets at a given noise level
>>>>> val.cor2=val.cors2=val.cork2=val.dcor2= rep(NA,nsim2)
>>>>> 
>>>>> 
>>>>> # Arrays holding the estimated power for each of the 4 "correlation"
>>>> types, for each data type (linear, #parabolic, etc...) with each noise level
>>>>> power.cor=power.cors=power.cork=power.dcor= array(NA, c(8,num.noise))
>>>>> 
>>>>> ## We loop through the noise level and functional form; each time we
>>>> #estimate a null distribution based on #the marginals of the data, and then
>>>> #use that null distribution to estimate power
>>>>> ## We use a uniformly distributed x, because in the original paper the
>>>> #authors used the same
>>>>> 
>>>>> for(l in 1:num.noise) {
>>>>> 
>>>>>       for(typ in 1:8) {
>>>>> 
>>>>> ## This next loop simulates data under the null with the correct
>>>> marginals (x is uniform, and y is a function of a #uniform with gaussian
>>>> noise)
>>>>> 
>>>>>     for(ii in 1:nsim) {
>>>>>       x=runif(n)
>>>>> 
>>>>> #lin+noise
>>>>> if(typ==1) {
>>>>> y=x+ noise *(l/num.noise)* rnorm(n)
>>>>> }
>>>>> 
>>>>> #parabolic+noise
>>>>> if(typ==2) {
>>>>> y=4*(x-.5)^2+  noise * (l/num.noise) * rnorm(n)
>>>>> }
>>>>> 
>>>>> #cubic+noise
>>>>> if(typ==3) {
>>>>> y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise  * (l/num.noise)
>>>> *rnorm(n)
>>>>> }
>>>>> 
>>>>> #sin+noise
>>>>> if(typ==4) {
>>>>> y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
>>>>> }
>>>>> 
>>>>> #their sine + noise
>>>>> if(typ==5) {
>>>>> y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
>>>>> }
>>>>> 
>>>>> #x^(1/4) + noise
>>>>> if(typ==6) {
>>>>> y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
>>>>> }
>>>>> 
>>>>> #circle
>>>>> if(typ==7) {
>>>>> y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise
>>>> *rnorm(n)
>>>>> }
>>>>> 
>>>>> #step function
>>>>> if(typ==8) {
>>>>> y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
>>>>> }
>>>>> 
>>>>> # We resimulate x so that we have the null scenario
>>>>> x <- runif(n)
>>>>> 
>>>>> # Calculate the 4 correlations
>>>>> val.cor[ii]=(cor(x,y))
>>>>> val.cors[ii]=(cor(x,y,method=c("spearman")))
>>>>> val.cork[ii]=(cor(x,y,method=c("kendal")))
>>>>> val.dcor[ii]=dcor(x,y)
>>>>> }
>>>>> 
>>>>> ## Next we calculate our 4 rejection cutoffs
>>>>> cut.cor=quantile(val.cor,.95)
>>>>> cut.cors=quantile(val.cors,.95)
>>>>> cut.cork=quantile(val.cork,.95)
>>>>> cut.dcor=quantile(val.dcor,.95)
>>>>> 
>>>>> ## Next we simulate the data again, this time under the alternative
>>>>> 
>>>>>     for(ii in 1:nsim2) {
>>>>>       x=runif(n)
>>>>> 
>>>>> #lin+noise
>>>>> if(typ==1) {
>>>>> y=x+ noise *(l/num.noise)* rnorm(n)
>>>>> }
>>>>> 
>>>>> #parabolic+noise
>>>>> if(typ==2) {
>>>>> y=4*(x-.5)^2+  noise * (l/num.noise) * rnorm(n)
>>>>> }
>>>>> 
>>>>> #cubic+noise
>>>>> if(typ==3) {
>>>>> y=128*(x-1/3)^3-48*(x-1/3)^3-12*(x-1/3)+10* noise  * (l/num.noise)
>>>> *rnorm(n)
>>>>> }
>>>>> 
>>>>> #sin+noise
>>>>> if(typ==4) {
>>>>> y=sin(4*pi*x) + 2*noise * (l/num.noise) *rnorm(n)
>>>>> }
>>>>> 
>>>>> #their sine + noise
>>>>> if(typ==5) {
>>>>> y=sin(16*pi*x) + noise * (l/num.noise) *rnorm(n)
>>>>> }
>>>>> 
>>>>> #x^(1/4) + noise
>>>>> if(typ==6) {
>>>>> y=x^(1/4) + noise * (l/num.noise) *rnorm(n)
>>>>> }
>>>>> 
>>>>> #circle
>>>>> if(typ==7) {
>>>>> y=(2*rbinom(n,1,0.5)-1) * (sqrt(1 - (2*x - 1)^2)) + noise/4*l/num.noise
>>>> *rnorm(n)
>>>>> }
>>>>> 
>>>>> #step function
>>>>> if(typ==8) {
>>>>> y = (x > 0.5) + noise*5*l/num.noise *rnorm(n)
>>>>> }
>>>>> 
>>>>> ## We again calculate our 4 "correlations"
>>>>> val.cor2[ii]=(cor(x,y))
>>>>> val.cors2[ii]=(cor(x,y,method=c("spearman")))
>>>>> val.cork2[ii]=(cor(x,y,method=c("kendal")))
>>>>> val.dcor2[ii]=dcor(x,y)
>>>>> }
>>>>> 
>>>>> ## Now we estimate the power as the number of alternative statistics
>>>> #exceeding our estimated cutoffs
>>>>> power.cor[typ,l] <- sum(val.cor2 > cut.cor)/nsim2
>>>>> power.cors[typ,l] <- sum(val.cors2 > cut.cor)/nsim2
>>>>> power.cork[typ,l] <- sum(val.cork2 > cut.cor)/nsim2
>>>>> power.dcor[typ,l] <- sum(val.dcor2 > cut.dcor)/nsim2
>>>>> }
>>>>> }
>>>>> 
>>>>> save.image()
>>>>> 
>>>>> ## The rest of the code is for plotting the image
>>>>> pdf("power.pdf")
>>>>> par(mfrow = c(4,2), cex = 0.45)
>>>>> plot((1:30)/10, power.cor[1,], ylim = c(0,1), main = "Linear", xlab =
>>>> "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>>>>> points((1:30)/10, power.cors[1,], pch = 2, col = "green", type = 'b')
>>>>> points((1:30)/10, power.cork[1,], pch = 3, col = "blue", type = 'b')
>>>>> points((1:30)/10, power.dcor[1,], pch = 4, col = "red", type = 'b')
>>>>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
>>>> pch = c(1,2,3), col = c("black","green","blue","red"))
>>>>> 
>>>>> plot((1:30)/10, power.cor[2,], ylim = c(0,1), main = "Quadratic", xlab =
>>>> "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>>>>> points((1:30)/10, power.cors[2,], pch = 2, col = "green", type = 'b')
>>>>> points((1:30)/10, power.cork[2,], pch = 3, col = "blue", type = 'b')
>>>>> points((1:30)/10, power.dcor[2,], pch = 4, col = "red", type = 'b')
>>>>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
>>>> pch = c(1,2,3), col = c("black","green","blue","red"))
>>>>> 
>>>>> plot((1:30)/10, power.cor[3,], ylim = c(0,1), main = "Cubic", xlab =
>>>> "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>>>>> points((1:30)/10, power.cors[3,], pch = 2, col = "green", type = 'b')
>>>>> points((1:30)/10, power.cork[3,], pch = 3, col = "blue", type = 'b')
>>>>> points((1:30)/10, power.dcor[3,], pch = 4, col = "red", type = 'b')
>>>>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
>>>> pch = c(1,2,3), col = c("black","green","blue","red"))
>>>>> 
>>>>> plot((1:30)/10, power.cor[5,], ylim = c(0,1), main = "Sine: period 1/8",
>>>> xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>>>>> points((1:30)/10, power.cors[5,], pch = 2, col = "green", type = 'b')
>>>>> points((1:30)/10, power.cork[5,], pch = 3, col = "blue", type = 'b')
>>>>> points((1:30)/10, power.dcor[5,], pch = 4, col = "red", type = 'b')
>>>>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
>>>> pch = c(1,2,3), col = c("black","green","blue","red"))
>>>>> 
>>>>> plot((1:30)/10, power.cor[4,], ylim = c(0,1), main = "Sine: period 1/2",
>>>> xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>>>>> points((1:30)/10, power.cors[4,], pch = 2, col = "green", type = 'b')
>>>>> points((1:30)/10, power.cork[4,], pch = 3, col = "blue", type = 'b')
>>>>> points((1:30)/10, power.dcor[4,], pch = 4, col = "red", type = 'b')
>>>>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
>>>> pch = c(1,2,3), col = c("black","green","blue","red"))
>>>>> 
>>>>> plot((1:30)/10, power.cor[6,], ylim = c(0,1), main = "X^(1/4)", xlab =
>>>> "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>>>>> points((1:30)/10, power.cors[6,], pch = 2, col = "green", type = 'b')
>>>>> points((1:30)/10, power.cork[6,], pch = 3, col = "blue", type = 'b')
>>>>> points((1:30)/10, power.dcor[6,], pch = 4, col = "red", type = 'b')
>>>>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
>>>> pch = c(1,2,3), col = c("black","green","blue","red"))
>>>>> 
>>>>> plot((1:30)/10, power.cor[7,], ylim = c(0,1), main = "Circle", xlab =
>>>> "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>>>>> points((1:30)/10, power.cors[7,], pch = 2, col = "green", type = 'b')
>>>>> points((1:30)/10, power.cork[7,], pch = 3, col = "blue", type = 'b')
>>>>> points((1:30)/10, power.dcor[7,], pch = 4, col = "red", type = 'b')
>>>>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
>>>> pch = c(1,2,3), col = c("black","green","blue","red"))
>>>>> 
>>>>> plot((1:30)/10, power.cor[8,], ylim = c(0,1), main = "Step function",
>>>> xlab = "Noise Level", ylab = "Power", pch = 1, col = "black", type = 'b')
>>>>> points((1:30)/10, power.cors[8,], pch = 2, col = "green", type = 'b')
>>>>> points((1:30)/10, power.cork[8,], pch = 3, col = "blue", type = 'b')
>>>>> points((1:30)/10, power.dcor[8,], pch = 4, col = "red", type = 'b')
>>>>> legend("topright",c("cor pearson","cor spearman", "cor kendal","dcor"),
>>>> pch = c(1,2,3), col = c("black","green","blue","red"))
>>>>> 
>>>>> #################
>>>>> 
>>>>> ______________________________________________
>>>>> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>>>>> https://stat.ethz.ch/mailman/listinfo/r-help
>>>>> PLEASE do read the posting guide
>>>> http://www.R-project.org/posting-guide.html
>>>>> and provide commented, minimal, self-contained, reproducible code.
>>>>> 
>>>> 
>>>> ______________________________________________
>>>> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>>>> https://stat.ethz.ch/mailman/listinfo/r-help
>>>> PLEASE do read the posting guide
>>>> http://www.R-project.org/posting-guide.html
>>>> and provide commented, minimal, self-contained, reproducible code.
>>>> 
>>> 
>>>        [[alternative HTML version deleted]]
>> 
>>> 
>>> 
>>> ______________________________________________
>>> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>>> https://stat.ethz.ch/mailman/listinfo/r-help
>>> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
>>> and provide commented, minimal, self-contained, reproducible code.
>>> 
>> 
>> ______________________________________________
>> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> https://stat.ethz.ch/mailman/listinfo/r-help
>> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
>> and provide commented, minimal, self-contained, reproducible code.
>> 
>> ______________________________________________
>> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> https://stat.ethz.ch/mailman/listinfo/r-help
>> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
>> and provide commented, minimal, self-contained, reproducible code.


From @tyen @end|ng |rom ntu@edu@tw  Thu May 13 04:48:43 2021
From: @tyen @end|ng |rom ntu@edu@tw (Steven Yen)
Date: Thu, 13 May 2021 10:48:43 +0800
Subject: [R] Variable labels
Message-ID: <2acfbbbc-cf71-90a7-079f-874d63470d25@ntu.edu.tw>

I insert variable with the expss function as shown below. No error 
message. My question is, how to save the variable labels in the data 
frame so that I can click to read the labels. Thank you.

mydata<-read_excel("data/Excel/hseinv.xlsx",na=".")
library(expss)
mydata=apply_labels(mydata,
 ??????????????????? year?? ="1947-1988",
 ??????????????????? inv??? ="real housing inv, millions $",
 ??????????????????? pop??? ="population, 1000s",
 ??????????????????? price? ="housing price index; 1982 = 1",
 ??????????????????? linv?? ="log(inv)",
 ??????????????????? lpop?? ="log(pop)",
 ??????????????????? lprice? ="log(price)",
 ??????????????????? t?????? ="time trend: t=1,...,42",
 ??????????????????? invpc?? ="per capita inv: inv/pop",
 ??????????????????? linvpc? ="log(invpc)",
 ??????????????????? lprice_1="lprice[_n-1]",
 ??????????????????? linvpc_1="linvpc[_n-1]",
 ??????????????????? gprice? ="lprice - lprice_1",
 ??????????????????? ginvpc? ="linvpc - linvpc_1")


From d@rgo@ch @end|ng |rom gm@||@com  Thu May 13 08:56:52 2021
From: d@rgo@ch @end|ng |rom gm@||@com (Fredrik Karlsson)
Date: Thu, 13 May 2021 08:56:52 +0200
Subject: [R] Variable labels
In-Reply-To: <2acfbbbc-cf71-90a7-079f-874d63470d25@ntu.edu.tw>
References: <2acfbbbc-cf71-90a7-079f-874d63470d25@ntu.edu.tw>
Message-ID: <CANO=ohJ9UMLqBNPequ-njsnn+3wYvOv=Q7h-qOPqf0cmWh8Tpw@mail.gmail.com>

Hi,

I am sorry but I don't understand your question, Generally, "clicking" is
not something you can assume to be implemented for anything in R.
However, if you read the manual for the package

 https://gdemin.github.io/expss/

you get an example at the bottom where an illustration of how the package
can be used to create Excel tables which would then be easy to interact
with through clicking.
Is that what you wanted?

Fredrik

On Thu, May 13, 2021 at 4:49 AM Steven Yen <styen at ntu.edu.tw> wrote:

> I insert variable with the expss function as shown below. No error
> message. My question is, how to save the variable labels in the data
> frame so that I can click to read the labels. Thank you.
>
> mydata<-read_excel("data/Excel/hseinv.xlsx",na=".")
> library(expss)
> mydata=apply_labels(mydata,
>                      year   ="1947-1988",
>                      inv    ="real housing inv, millions $",
>                      pop    ="population, 1000s",
>                      price  ="housing price index; 1982 = 1",
>                      linv   ="log(inv)",
>                      lpop   ="log(pop)",
>                      lprice  ="log(price)",
>                      t       ="time trend: t=1,...,42",
>                      invpc   ="per capita inv: inv/pop",
>                      linvpc  ="log(invpc)",
>                      lprice_1="lprice[_n-1]",
>                      linvpc_1="linvpc[_n-1]",
>                      gprice  ="lprice - lprice_1",
>                      ginvpc  ="linvpc - linvpc_1")
>
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide
> http://www.R-project.org/posting-guide.html
> and provide commented, minimal, self-contained, reproducible code.
>


-- 
"Life is like a trumpet - if you don't put anything into it, you don't get
anything out of it."

	[[alternative HTML version deleted]]


From @tyen @end|ng |rom ntu@edu@tw  Thu May 13 10:07:02 2021
From: @tyen @end|ng |rom ntu@edu@tw (Steven Yen)
Date: Thu, 13 May 2021 16:07:02 +0800
Subject: [R] Variable labels
In-Reply-To: <CANO=ohJ9UMLqBNPequ-njsnn+3wYvOv=Q7h-qOPqf0cmWh8Tpw@mail.gmail.com>
References: <CANO=ohJ9UMLqBNPequ-njsnn+3wYvOv=Q7h-qOPqf0cmWh8Tpw@mail.gmail.com>
Message-ID: <6445C370-0081-4F80-9D9C-A0F1511BA397@ntu.edu.tw>

Thanks. What I need ?appears? simple. The .RData file is provided by a third party (likely converted from a different data format such as SAS in which variable labels (not value labels) are common). When I load the binary file, in the ?environment? I see, as expected, a data frame showing how many observations for how many variables. In addition, there is also an item (in the environment) (say ?desc?) containing a list of variable labels (definitions).  I simply like to know how to get ?desc? in the environment?-it is a convenient way to show definitions of all variables when you send a binary data file to a third party. Thank you.

> On May 13, 2021, at 2:57 PM, Fredrik Karlsson <dargosch at gmail.com> wrote:
> 
> ?
> Hi,
> 
> I am sorry but I don't understand your question, Generally, "clicking" is not something you can assume to be implemented for anything in R.
> However, if you read the manual for the package 
> 
>  https://gdemin.github.io/expss/
> 
> you get an example at the bottom where an illustration of how the package can be used to create Excel tables which would then be easy to interact with through clicking.
> Is that what you wanted?
> 
> Fredrik
> 
>> On Thu, May 13, 2021 at 4:49 AM Steven Yen <styen at ntu.edu.tw> wrote:
>> I insert variable with the expss function as shown below. No error 
>> message. My question is, how to save the variable labels in the data 
>> frame so that I can click to read the labels. Thank you.
>> 
>> mydata<-read_excel("data/Excel/hseinv.xlsx",na=".")
>> library(expss)
>> mydata=apply_labels(mydata,
>>                      year   ="1947-1988",
>>                      inv    ="real housing inv, millions $",
>>                      pop    ="population, 1000s",
>>                      price  ="housing price index; 1982 = 1",
>>                      linv   ="log(inv)",
>>                      lpop   ="log(pop)",
>>                      lprice  ="log(price)",
>>                      t       ="time trend: t=1,...,42",
>>                      invpc   ="per capita inv: inv/pop",
>>                      linvpc  ="log(invpc)",
>>                      lprice_1="lprice[_n-1]",
>>                      linvpc_1="linvpc[_n-1]",
>>                      gprice  ="lprice - lprice_1",
>>                      ginvpc  ="linvpc - linvpc_1")
>> 
>> ______________________________________________
>> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
>> https://stat.ethz.ch/mailman/listinfo/r-help
>> PLEASE do read the posting guide http://www.R-project.org/posting-guide.html
>> and provide commented, minimal, self-contained, reproducible code.
> 
> 
> -- 
> "Life is like a trumpet - if you don't put anything into it, you don't get anything out of it."

	[[alternative HTML version deleted]]


From petr@p|k@| @end|ng |rom prechez@@cz  Thu May 13 12:31:49 2021
From: petr@p|k@| @end|ng |rom prechez@@cz (PIKAL Petr)
Date: Thu, 13 May 2021 10:31:49 +0000
Subject: [R] Variable labels
In-Reply-To: <6445C370-0081-4F80-9D9C-A0F1511BA397@ntu.edu.tw>
References: <CANO=ohJ9UMLqBNPequ-njsnn+3wYvOv=Q7h-qOPqf0cmWh8Tpw@mail.gmail.com>
 <6445C370-0081-4F80-9D9C-A0F1511BA397@ntu.edu.tw>
Message-ID: <88a95efb70564eec83ce0a479dd9f0d1@SRVEXCHCM1302.precheza.cz>

Hi.

Maybe you could use attributes.

dput(vec.m)
structure(list(Group.1 = c(2003, 2021, 2003, 2021, 2003, 2021, 
2003, 2021, 2003, 2021, 2003, 2021, 2003, 2021, 2003, 2021, 2003, 
2021), variable = structure(c(1L, 1L, 2L, 2L, 3L, 3L, 4L, 4L, 
5L, 5L, 6L, 6L, 7L, 7L, 8L, 8L, 9L, 9L), .Label = c("s6", "s5", 
"s4", "s3", "s2", "s1.5", "s.7", "s.5", "pod"), class = "factor"), 
    value = c(3.29, 0.525, 5.01, 1.385, 16.38, 7.67, 5.535, 3.28, 
    25.49, 24.41, 10.285, 12.79, 8.905, 12.92, 1.68, 3.67, 2.595, 
    5.06)), row.names = c(NA, -18L), class = "data.frame")

> attr(vec.m, "some.kind.of.value") <- c("some specialvector", "another special vector", "just ordinary vector")

You can access them by attributes or attr.

 attributes(vec.m)
$row.names
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18

$names
[1] "Group.1"  "variable" "value"   

$class
[1] "data.frame"

$some.kind.of.value
[1] "some specialvector"     "another special vector" "just ordinary vector"  

> attr(vec.m, "some")
[1] "some specialvector"     "another special vector" "just ordinary vector"  
>

Cheers
Petr

> -----Original Message-----
> From: R-help <r-help-bounces at r-project.org> On Behalf Of Steven Yen
> Sent: Thursday, May 13, 2021 10:07 AM
> To: Fredrik Karlsson <dargosch at gmail.com>
> Cc: R-help Mailing List <r-help at r-project.org>
> Subject: Re: [R] Variable labels
> 
> Thanks. What I need ?appears? simple. The .RData file is provided by a third
> party (likely converted from a different data format such as SAS in which
> variable labels (not value labels) are common). When I load the binary file, in
> the ?environment? I see, as expected, a data frame showing how many
> observations for how many variables. In addition, there is also an item (in the
> environment) (say ?desc?) containing a list of variable labels (definitions).  I
> simply like to know how to get ?desc? in the environment?-it is a convenient
> way to show definitions of all variables when you send a binary data file to a
> third party. Thank you.
> 
> > On May 13, 2021, at 2:57 PM, Fredrik Karlsson <dargosch at gmail.com>
> wrote:
> >
> > 
> > Hi,
> >
> > I am sorry but I don't understand your question, Generally, "clicking" is not
> something you can assume to be implemented for anything in R.
> > However, if you read the manual for the package
> >
> >  https://gdemin.github.io/expss/
> >
> > you get an example at the bottom where an illustration of how the package
> can be used to create Excel tables which would then be easy to interact with
> through clicking.
> > Is that what you wanted?
> >
> > Fredrik
> >
> >> On Thu, May 13, 2021 at 4:49 AM Steven Yen <styen at ntu.edu.tw> wrote:
> >> I insert variable with the expss function as shown below. No error
> >> message. My question is, how to save the variable labels in the data
> >> frame so that I can click to read the labels. Thank you.
> >>
> >> mydata<-read_excel("data/Excel/hseinv.xlsx",na=".")
> >> library(expss)
> >> mydata=apply_labels(mydata,
> >>                      year   ="1947-1988",
> >>                      inv    ="real housing inv, millions $",
> >>                      pop    ="population, 1000s",
> >>                      price  ="housing price index; 1982 = 1",
> >>                      linv   ="log(inv)",
> >>                      lpop   ="log(pop)",
> >>                      lprice  ="log(price)",
> >>                      t       ="time trend: t=1,...,42",
> >>                      invpc   ="per capita inv: inv/pop",
> >>                      linvpc  ="log(invpc)",
> >>                      lprice_1="lprice[_n-1]",
> >>                      linvpc_1="linvpc[_n-1]",
> >>                      gprice  ="lprice - lprice_1",
> >>                      ginvpc  ="linvpc - linvpc_1")
> >>
> >> ______________________________________________
> >> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> >> https://stat.ethz.ch/mailman/listinfo/r-help
> >> PLEASE do read the posting guide
> >> http://www.R-project.org/posting-guide.html
> >> and provide commented, minimal, self-contained, reproducible code.
> >
> >
> > --
> > "Life is like a trumpet - if you don't put anything into it, you don't get
> anything out of it."
> 
> 	[[alternative HTML version deleted]]
> 
> ______________________________________________
> R-help at r-project.org mailing list -- To UNSUBSCRIBE and more, see
> https://stat.ethz.ch/mailman/listinfo/r-help
> PLEASE do read the posting guide http://www.R-project.org/posting-
> guide.html
> and provide commented, minimal, self-contained, reproducible code.

From hr@pchr|@ten@en @end|ng |rom gm@||@com  Wed May 12 14:14:47 2021
From: hr@pchr|@ten@en @end|ng |rom gm@||@com (Peer Christensen)
Date: Wed, 12 May 2021 14:14:47 +0200
Subject: [R] [R-pkgs] modelimpact
Message-ID: <CAKoOfS3DaQ8dgDRjXY=khi0F_yf_HkhGDMqz9UrLiZYmCQRxEA@mail.gmail.com>

Dear R users,

I am happy to announce that modelimpact is now on CRAN.

modelimpact contains functions to assess the expected business value
of using a churn prediction model in e.g. a marketing campaign.

Examples are shown in the GitHub readme: https://github.com/
<https://github.com/PeerChristensen/modelimpact>PeerChristensen/modelimpact

Best regards

Peer Christensen

	[[alternative HTML version deleted]]

_______________________________________________
R-packages mailing list
R-packages at r-project.org
https://stat.ethz.ch/mailman/listinfo/r-packages


